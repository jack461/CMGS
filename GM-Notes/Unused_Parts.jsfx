/********
 *
 *     Now unused parts of source code from the Game Player. But who knows ?
 *
 ********/


/*


//====== Script- temporary version ======
Script_Size = 4096;
Script_Array = make_array(Script_Size);
Script_CPtr = Script_Array;
Script_CPtr[0] = End;





//====== Script Reader ======
function TstScriptReader()
local (fH, ck, val, sptr)
(
    err_fscr = sptr = 0;
    fH = GM_file_open(#Script_Name);
    (ck = (fH >= 0 && file_text(fH))) ? (
        while (ck && (err_fscr == 0)) (
            file_var(fH, val);
            !(ck = file_avail(fH)) ? val = End;
            Script_Array[sptr] = val; sptr+= 1;
        );
    );
    Script_Array[sptr] = End;
    Script_CPtr = Script_Array;
    AAAAA_sptr = sptr;
    AAAAA_scr0 = Script_Array[0];
    AAAAA_scr1 = Script_Array[1];
    AAAAA_scr2 = Script_Array[2];
    AAAAA_scr3 = Script_Array[3];
    AAAAA_scr4 = Script_Array[4];
    AAAAA_PSetGrp = PSetGrp;
    AAAAA_PSetCLoop = PSetCLoop;
    AAAAA_PSetPLRatio = PSetPLRatio;
    AAAAA_PSetLoopDur = PSetLoopDur;
);


function TstScriptEval()
local (kod, par, par2, inc, flg)
(
    flg = 1;
    while (flg && ((kod = Script_CPtr[0]) != End) && (kod != PSStop))  (
        par = Script_CPtr[1]; inc = 2;
        (kod == PSetGrp) ? (
            GvPlayGrp = par;
        ) :
        (kod == PSetAutoMd) ? (
            //GvAutoMd = par;
            parSet(p_GvAutoMd, par);
        ) :
        (kod == PSetCGens) ? (
            parSet(p_maxGenerators, par);
        ) :
        (kod == PSetCPlay) ? (
            parSet(p_maxPlayers, par);
        ) :
        (kod == PSetCLoop) ? (
            parSet(p_maxLoopers, par);
        ) :
        (kod == PSetPLRatio) ? (
            parSet(p_ratioReadLoop, par);
        ) :
        (kod == PSetHPDsty) ? (
            parSet(p_HP_Density, par);
        ) :
        (kod == PSetGenRand) ? (
            SchedAddTask(9, 0, 0, 0, 0);
            inc = 1;
        ) :
        (kod == PSetPlayVol) ? (
            parSet(p_PlGain, par);
        ) :
        (kod == PSetLoopVol) ? (
            parSet(p_LpGain, par);
        ) :
        (kod == PSetRateCtl) ? (
            parSet(p_RateCtl, par);
        ) :
        (kod == PSetPlayDur) ? (
            parSet(p_playDur, par);
        ) :
        (kod == PSetLoopDur) ? (
            parSet(p_loopDur, par);
        ) :
        (kod == PSWait) ? (
            // exit from execution, reschedule
            flg = 0;
            Schedule(SchedRelative, par, 16, 0, 0, 0, 0);
        ) :
        (kod == PSchedule) ? (
            // schedule a new task
            par2 = Script_CPtr[2];
            Schedule(SchedRelative, par, par2, 0, 0, 0, 0);
            inc = 3;
        ) :
        (kod == PSetTSTX0) ? (
            // create
            xent = SchedAddTask(Script_CPtr[1], 0, 0, 0, 0);
            //AAAAAAAA_00_kod = kod;
            //AAAAAAAA_01_xent = xent;
            //AAAAAAAA_02_uent = SchedActivPts[0] ;
            inc = 2;
        ) :
        (kod == PSetTSTX1) ? (
            // create
            xent = SchedAddTask(Script_CPtr[1], Script_CPtr[2], 0, 0, 0);
            inc = 3;
        ) :
        (kod == PSetTSTX2) ? (
            // create
            xent = SchedAddTask(Script_CPtr[1], Script_CPtr[2], Script_CPtr[3], 0, 0);
            inc = 4;
        ) :
        (kod == PSStop) ? (
            flg = 0; // exit from execution
            inc = 0; // keep script on "stop"
        );
        Script_CPtr += inc;
    );
);


/*
    (code == 14)? (
        Script_CPtr = Script_Array; SchedRemove(SchedDlydPts, 16); TstScriptEval();
    ) :
    (code == 15)? (
        TstScriptReader();
    ) :
    (code == 16)? (
        TstScriptEval();
    );
*/



/*

// This one is not used
function Simple_Action(code, p1, p2, p3, p4, p5)
(
    Simple_temp[0] = 5;
    Simple_temp[1] = code;
    Simple_temp[2] = p1;
    Simple_temp[3] = p2;
    Simple_temp[4] = p3;
    Simple_temp[5] = p4;
    Simple_temp[6] = p5;
    Simple_Action(Simple_temp);
);






function getexpldstr()
local (ux, vz)
(
    #sct = "";
    gmem[expldstr+explavail] = 0;
    ux = 0; vz = gmem[expldstr];
    while (vz != 0) (
        str_setchar(#sct, -0.25, vz, 'uc');
        ux +=1; vz = gmem[expldstr+ux];
    );
    #sct;
);

function setexpldstr(str)
local (ux, lg)
(
    lg = min(explavail,strlen(str));
    ux = 0;
    loop (lg,
        gmem[expldstr+ux] = str_getchar(str, ux, 'uc');
        ux += 1;
    );
    gmem[expldstr+ux] = 0;
);





//#################### INFO BLOCKS MANAGEMENT ##############
// Allocate a new info block
// This is an unique allocation ! no free !
// n.b. = usable size will be size - infoBiFirst
function infoB_New(size) local(uB, a, i)
(
    uB = gmem[iBDummy]; // dummy bloc / default
    // uB = -1;
    ((size >= 8) && (size <= infoBMaxSize)) ? (
        a = gmem[iBFirst];
        ((a >= infoBStarts) && ((a + size) <= infoBMaxSize)) ? (
            uB = a;
            gmem[iBFirst] += size;
            i = 0; loop(size, gmem[uB+i] = 0; i+=1;);
            gmem[uB] = size;
        );
    );
    uB;
);



// Clear an infoBlock
function infoB_clear(uB, size) local(i)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        (size == -1) ? size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            i = 0; loop(size, gmem[uB+i] = 0; i+=1;);
            gmem[uB] = size;
        );
    );
);



// Sort content of a block
// blocks are small, we use a very simple bubble sort in O(n2)
function infoB_sort_unchecked(uB) local (size, k, l, v)
(
    size = gmem[uB];
    k = infoBiFirst;
    while (k < size-1) (
        l = k+1;
        while (l < size) (
            (gmem[uB+k] > gmem[uB+l]) ? (
                v = gmem[uB+k]; gmem[uB+k] = gmem[uB+l]; gmem[uB+l] = v;
            );
            l += 1;
        );
        k += 1;
    );
);


// Sort a block
// and check validity first
function infoB_sort(uB) local (size, k, l, v)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst;
            while (k < size-1) (
                l = k+1;
                while (l < size) (
                    (gmem[uB+k] > gmem[uB+l]) ? (
                        v = gmem[uB+k]; gmem[uB+k] = gmem[uB+l]; gmem[uB+l] = v;
                    );
                    l += 1;
                );
                k += 1;
            );
        );
    );
);



// add an entry to a block
//
function infoB_add(uB, v) local (size, k, index)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst; index = 0;
            while ((k < size) && (index == 0)) (
                ((0|v) == (0|gmem[uB+k])) ? (index = k; gmem[uB+k] = v);
                k += 1;
            );
            (index == 0) ? (
                gmem[uB+infoBiFirst] = v;
                infoB_sort_unchecked(uB);
            );
        );
    );
);



// delete an entry from a bloc
//
function infoB_del(uB, v) local (size, k, index)
(
    infoRemoved = 0;
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst; index = 0;
            while ((k < size) && (index == 0)) (
                (v == gmem[uB+k]) ? index = k;
                k += 1;
            );
            (index != 0) ? (
                gmem[uB+index] = 0;
                infoRemoved = v;
                infoB_sort_unchecked(uB);
            );
        );
    );
    index; // as a return code...
);



// get "next" non null value from a block
//
function infoB_next(uB) local (size, i, v, c)
(
    v = 0;
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            c = 0; i = gmem[uB+infoBent];
            while ((v == 0) && (c < size)) (
                i = (i + 1) % size; (i < infoBiFirst) ? i = infoBiFirst;
                v = gmem[uB + i];
                c += 1;
            );
            gmem[uB+infoBent] = i; // last accessed entry
        );
    );
    v; // return v
);



            /*
            (match("*.txt", #InSens_Name)) ? (
                SensorsDefReader();
            ) :
            */

/*
function SensorsDefReader()
local (fH, ck, getN, zzmmd, val, tout, kct, cnt, pt, zpt,
      state, i, s1, s2, s3, s4, s5)
(
    state = 0; // automaton state
    err_sdfr = 0;
    MIDISeqPtr = 0;
    SensorsDef = 1;
    memset(MIDISeqncs, 0, MIDISeqSiz);
    getN = 1;
    zzmmd = 0; // MIDI mode
    fH = GM_file_open(#InSens_Name);
    (ck = (fH >= 0 && file_text(fH))) ? (
        while (ck && (err_sdfr == 0)) (
            (getN != 0) ? (
                // we need to read a new number from the file
                file_var(fH, val); getN = 0;
                !(ck = file_avail(fH)) ? val = End;
            );
            // Test various cases
            // Etat 0
            (state == 0) ? (
                (val == End) ? (
                    getN = 1;
                ) :
                (val == MMode) ? (
                    state = 1; getN = 1;
                ) :
                (val == DefSeq) ? (
                    // Expect a command, reinit fields
                    s1 = s2 = s3 = s4 = s5 = 0;
                    tout = kct = cnt = 0;
                    state = 2; getN = 1;
                ) :
                (val == Enter) ? (
                    // Expect a seq. of commands, reinit fields
                    s2 = s3 = s4 = s5 = 0; s1 = EnterSens;
                    tout = kct = 0; cnt = 1;
                    state = 5; getN = 1;
                ) :
                (val == Exit) ? (
                    // Expect a seq. of commands, reinit fields
                    s2 = s3 = s4 = s5 = 0; s1 = 98;
                    tout = kct = 0; cnt = 1;
                    state = 5; getN = 1;
                ) :
                ( // else
                    err_sdfr = 0866;  // a keyword is expected here
                );
            ) :

            // Etat 1
            (state == 1) ? (
                ((val != (0|val)) || (val < 0) || (val > 7)) ? (
                    err_sdfr = 0867; // out of bounds value
                ) : (
                    zzmmd = val; getN = 1;
                );
                state = 0; // return to state 0
            ) :

            // Etat 2
            (state == 2) ? (
                // expect a sensor number
                (val == SDur) ? (
                    state = 3; getN = 1;
                ) :
                (val == DoKmd) ? (
                    state = 5; getN = 1;
                ) :
                ((val != (0|val)) || (val < 1) || (val > 16)) ? (
                    err_sdfr = 0870; // out of bounds value
                ) : (
                    s5 = s4; s4 = s3; s3 = s2; s2 = s1; s1 = val;
                    cnt += 1; getN = 1;
                );
                (cnt > 5) ? (
                    err_sdfr = 0872; // out of bounds value
                );
            ) :

            // Etat 3
            (state == 3) ? (
                // expect a time-out
                ((val < 1) || (val > 600)) ? (
                    err_sdfr = 0869; // out of bounds value
                ) : (
                    tout = val; getN = 1;
                    state = 4;
                );
            ) :

            // Etat 4
            (state == 4) ? (
                // expect the Keyworld "DoKmd"
                (val == DoKmd) ? (
                    state = 5; getN = 1;
                ) : (
                    err_sdfr = 0876; // expect "DoKmd"
                );
            ) :

            // Etat 5
            (state == 5) ? (
                // Expect a set of commands - End when a new keyword is found
                (val > Mu) ? (
                    // Build the command
                    ((kct < 1) || (kct > kmdlsize) || (cnt < 1) || (cnt > 5)) ? (
                        err_sdfr = 0877; // error count
                    ) : (
                        pt =  MIDISeqncs + MIDISeqPtr;
                        zpt = pt;
                        pt[0] = totsize = cnt + kct + 5; // Total entry size
                        pt[1] = zzmmd;  // MIDI mode # [0 to... N]
                        (tout == 0) ? tout = cnt * MIDISensDefTout;
                        pt[2] = tout; // Time out for input events sequence
                        // Insert sensor list
                        pt[3] = cnt; // number of sensors/event input
                        pt = pt + 4; // new pt
                        (cnt >= 1) ? (pt[0] = s1; pt += 1;);  // enter next sensor
                        (cnt >= 2) ? (pt[0] = s2; pt += 1;);
                        (cnt >= 3) ? (pt[0] = s3; pt += 1;);
                        (cnt >= 4) ? (pt[0] = s4; pt += 1;);
                        (cnt >= 5) ? (pt[0] = s5; pt += 1;);
                        // Insert command list
                        pt[0] = kct; pt += 1; // size of command list
                        i = 0; loop (kct,
                            pt[0] = kmdlist[i]; pt += 1; i += 1;
                        );
                        MIDISeqPtr += totsize;
                        MIDISeqPtr > MIDISeqSiz - 32 ? err_sdfr = 888; // capacity
                        state = 0;

                        sprintf(#s, "Sensor %g %g %g %g %g %g %g %g  %g %g %g %g", zpt[0], zpt[1], zpt[2], zpt[3], zpt[4],
                                 zpt[5], zpt[6], zpt[7], zpt[8], zpt[9], zpt[10], zpt[11]);
                        mSL_log(SysLogBox, #s);

                    );
                ) :
                ((val < -1000) || (val > 9000000)) ? (
                    err_sdfr = 868; // out of bounds value
                ) : (
                    kmdlist[kct] = val;
                    kct = min(kmdlsize, 1+kct); getN = 1;
                );
            );
        );
    );
    fH >= 0 ? file_close(fH);

    (err_sdfr == 0) ? (
        sprintf(#s, "Sensors load: %s", #InSens_Name);
    ) : (
        sprintf(#s, "Sensors err: %d %s", err_sdfr, #InSens_Name);
    );
    mSL_log(SysLogBox, #s);
);

*/




/*
            ui_split_top(h2);
                opaquestate = control_textinput_focus(opaquestate);
                opaquestate = control_textinput(#text, opaquestate);
                (FlagsTbVals[Flgs_Sys] & 1) ? (
                    (last_text < lastTime) ? (
                        mSL_log(SysLogBox, #text);
                        last_text = lastTime + 20;
                    );
                );
            ui_pop();
*/








            /*
            (match("*.txt", #BanksDefs)) ? (
                BankDefReader();
            ) :
            */



/*
function BankDefReader()
local(state, getN, val, fH, ck, bn, cl, acnt, ix, ixpt, iy, iypt, pct, pos, v)
(
    state = 0; // automaton state
    err_fbnk = 0; // no error
    BanksDefsVersion = 0; // undefined yet
    getN = 1;
    val = 0;
    AStcnt = 0;
    BKMxGrpn = 0;
    BKMxBnkn = 0;
    defBankEntryInit();
    BKDEcnt = 1; // keep entry 0 as workarea
    memset(curBank, Undef, BKEsize);
    fH = GM_file_open(#BanksDefs);
    (ck = (fH >= 0 && file_text(fH))) ? (
        while (ck && (err_fbnk == 0)) (
            (getN != 0) ? (
                // we need to read a new number from the file
                file_var(fH, val); getN = 0; AStcnt += 1;
                !(ck = file_avail(fH)) ? val = End;
                AAAcurval=val;
            );
            // Test des différents cas
            (state == 0) ? (
                ((val & WJ) == KBk) ? (
                    pos = val & 0xff;
                    acnt = (val >> 12) & 0xff;
                    state = 1;
                ) :
                (val == End) ? (
                    ((cl = curBank[idx_Clps]) != Undef) ? (
                         ((cl >= 0) && (cl <= 9999)) ? (
                             // build a new entry
                             curBank[idx_PBFlgs] = curBank[idx_PNumb] = 0;
                             curBank[idx_Grp] == Undef ? curBank[idx_Grp] = 1;
                             v = curBank[idx_Grp];
                             ((v < 0) || (v >= GRPtSiz)) ? err_fbnk = 0344; // invalid group number
                             v > BKMxGrpn ? BKMxGrpn = v;
                             curBank[idx_Bnk] == Undef ? curBank[idx_Bnk] = 1;
                             bn = curBank[idx_Bnk]; // bank number
                             ((bn < 0) || (bn >= 65536)) ? err_fbnk = 0345; // invalid bank number
                             bn > BKMxBnkn ? BKMxBnkn = bn;
                             curBank[idx_Clps+1] == Undef ? curBank[idx_Clps+1] = curBank[idx_Clps];
                             cl = curBank[idx_Clps+1];
                             ((cl < 0) || (cl > 9999)) ? err_fbnk = 0346; // invalid clip number
                             (cl < curBank[idx_Clps]) ? ( // xchange both values
                                curBank[idx_Clps+1] = curBank[idx_Clps]; curBank[idx_Clps] = cl;
                             );
                             curBank[idx_PlM] == Undef ? curBank[idx_PlM] = bn;
                             v = curBank[idx_PlM];
                             ((v < 0) || (v >= PMEcnt)) ? err_fbnk = 0348; // invalid play mode
                             curBank[idx_SpM] == Undef ? curBank[idx_SpM] = bn;
                             v = curBank[idx_SpM];
                             ((v < 0) || (v >= SMEcnt)) ? err_fbnk = 0349; // invalid space mode
                             curBank[idx_prVol] == Undef ? curBank[idx_prVol] = 0;
                             v = curBank[idx_prVol];
                             ((v < -120) || (v > 24)) ? err_fbnk = 0350; // invalid min vol
                             curBank[idx_prVol+1] == Undef ? curBank[idx_prVol+1] = curBank[idx_prVol];
                             v = curBank[idx_prVol+1];
                             ((v < -120) || (v > 24)) ? err_fbnk = 0351; // invalid max vol
                             curBank[idx_PWeight] == Undef ? curBank[idx_PWeight] = 1;
                             v = curBank[idx_PWeight];
                             ((v < 0.01) || (v > 32767)) ? err_fbnk = 0352; // invalid partial weight
                            curBank[idx_PClass] == Undef ? curBank[idx_PClass] = 0;
                             curBank[idx_PBFlgs] == Undef ? curBank[idx_PBFlgs] = 0;
                             v = curBank[idx_PBFlgs];
                             ((v < 0) || (v >= 65536)) ? err_fbnk = 0353; // invalid Flags type
                             // keep entry
                             (BKDEcnt < BKEcnt) ? (
                                 memcpy(BKTab + BKDEcnt*BKEsize, curBank, BKEsize); BKDEcnt += 1;
                                 memset(curBank+2, Undef, BKEsize-2);
                             ) : (
                                 err_fbnk = 0354;  // partial table full
                             );
                        ) : (
                            err_fbnk = 0342; // incorrect clip number
                        );
                    );
                    getN = 1;
                ) :
                (val == FIdent) ? (
                    state = 2 ;
                    AAAstate = 2;
                ) :
                (
                    err_fbnk = 0356; // unexpected entry
                    AAAunexpected = val;
                );
                getN = 1;
            ) :

            (state == 1) ? (
                (val < Mu) ? (
                     (acnt > 0) ? (
                         curBank[pos] = val; acnt -= 1; pos += 1; getN = 1;
                     ) : (
                         err_fbnk = 0357; // too many parameters
                     );
                ) :
                (
                     state = 0;
                );
            ) :

            (state == 2) ? (
                ((val < Mu) && (val > 0) && (val == (0|val))) ? (
                    AAAstatBDV = BanksDefsVersion = val;
                    state = 0; getN = 1;
                ) : (
                    err_fbnk = 0343;  // invalid version
                    AAAunexpected = val;
                );
            );
        );
    ) : (
        // signal an error
        err_fbnk = 0330; // can't open file
    );
    fH >= 0 ? file_close(fH);
    ABEPos = AStcnt;


    (err_fbnk == 0) ? (
        // Part 2 : sort partials & banks
        BKCurrGrp = BKCurrBnk = -2;
        ix = 1;
        while (ix < BKDEcnt-1) (
            ixpt = BKTab + ix*BKEsize;
            iy = ix + 1;
            while (iy < BKDEcnt) (
                iypt = BKTab + iy*BKEsize;
                // should we exchange ?
                ((ixpt[idx_Grp] > iypt[idx_Grp]) ||
                    ((ixpt[idx_Grp] == iypt[idx_Grp]) && (ixpt[idx_Bnk] > iypt[idx_Bnk]))) ? (
                        memcpy(curBank, ixpt, BKEsize);
                        memcpy(ixpt, iypt, BKEsize);
                        memcpy(iypt, curBank, BKEsize);
                );
                iy += 1;
            );
            ix += 1;
        );
        // Part 3 : subpartials numbering, groups referencing
        memset(GRPtTab, -1, GRPtSiz);  // A partial number, or -1
        ix = 1; pct = 0; BKTab[idx_PNumb] = 0;
        ixpt = BKTab + BKEsize; ixpt[idx_PNumb] = 0;
        GRPtTab[ixpt[idx_Grp]] = 1;
        while (ix < BKDEcnt-1) (
            ixpt = BKTab + ix*BKEsize;
            iypt = ixpt + BKEsize;
            (GRPtTab[iypt[idx_Grp]] == -1) ?  GRPtTab[iypt[idx_Grp]] = ix + 1;
            ((ixpt[idx_Grp] == iypt[idx_Grp]) && (ixpt[idx_Bnk] == iypt[idx_Bnk])) ? pct += 1 : pct = 0;
            iypt[idx_PNumb] = pct;
            ix += 1;
        );
    );
    // ADump(BKTab+72);

    (err_fbnk == 0) ? (
        sprintf(#s, "Banks load: %s", #BanksDefs);
    ) : (
        sprintf(#s, "Banks err: %d %s", err_fbnk, #BanksDefs);
    );
    mSL_log(SysLogBox, #s);

    // Create the summary of the bank
    BKTdefineSummary();
);
*/







/*
     Create the string array - use as :
        str_arr_siz = 4007 + 4; // i.e. a prime + 4 for overhead
//        mSL_make_strings_array(make_array(str_arr_siz), str_arr_siz);

// function mSL_make_strings_array(mem, size)
(
    mSL_Str_Siz = size = 0|size;
    ((mSL_new_StrPtrs != 0)) ? (
        mSL_errX = 1011;
    ) :
    ((size < 512)) ? (
        mSL_errX = 1012;
    ) :
    (
        mem[0] = mSL_KODE_strings; // as "String Work area"
        mem[1] = mem[size-2] = mSL_StrsSize = size - 4;
        mem[size - 1] = mem[0] ~ mSL_CC_Chksum;
        mSL_new_StrPtrs = mem + 2;
        memset(mSL_new_StrPtrs, 0, mSL_StrsSize); // set it empty for now
        mSL_PtrPtc = 0; // allocating pointer in strings available
        mSL_PtrTPtc = 0; // allocating pointer in temporary strings available
    );
    (mSL_current_StrPtrs == 0) ?
        mSL_current_StrPtrs = mSL_new_StrPtrs;
    mSL_new_StrPtrs;
);

*/



/*
    Enter the string address in the hash table

// function mSL_provideString(sref)
local (ent, cnt, z, do_it)
(
    // Is the string already in the table ?
    ent = (sref * 47) % mSL_StrsSize;
    do_it = 1; cnt = 0;
    while (do_it) (
        z = mSL_current_StrPtrs[ent];
        (z == 0) ? (
            // put it in
            mSL_current_StrPtrs[ent] = sref;
            do_it = 0;
        ) :
        ((z == sref) || (z == -sref)) ? (
            // aready there
            do_it = 0;
        ) : (
            ent = (ent + 17) % mSL_StrsSize;
            cnt += 1;
            cnt > mSL_StrsSize ? do_it = 0;
        );
    );
);


*/

/*
    Get a string reference
*/

/*
//function mSL_allocateString()
local (z, cnt, in)
(
    cnt = mSL_StrsSize;
    z = -1;
    while ((cnt > 0) && (z <= 0)) (
        in = mSL_current_StrPtrs[mSL_PtrPtc];
        (in > 0) ? (
            // we will use this number, but we indicate it "used"
            z = in; mSL_current_StrPtrs[mSL_PtrPtc] = - in;
        ) : (
            mSL_PtrPtc = (mSL_PtrPtc+1) % mSL_StrsSize;
        );
        cnt -= 1;
    );
    (z < 0) ? (
        // provide a "last chance" very temporary string
        mSL_PtrTPtc = (mSL_PtrTPtc + 1) % 16;
        (mSL_PtrTPtc == 0) ? ( z = #mSL_temp_str_00; ) :
        (mSL_PtrTPtc == 1) ? ( z = #mSL_temp_str_01; ) :
        (mSL_PtrTPtc == 2) ? ( z = #mSL_temp_str_02; ) :
        (mSL_PtrTPtc == 3) ? ( z = #mSL_temp_str_03; ) :
        (mSL_PtrTPtc == 4) ? ( z = #mSL_temp_str_04; ) :
        (mSL_PtrTPtc == 5) ? ( z = #mSL_temp_str_05; ) :
        (mSL_PtrTPtc == 6) ? ( z = #mSL_temp_str_06; ) :
        (mSL_PtrTPtc == 7) ? ( z = #mSL_temp_str_07; ) :
        (mSL_PtrTPtc == 8) ? ( z = #mSL_temp_str_08; ) :
        (mSL_PtrTPtc == 9) ? ( z = #mSL_temp_str_09; ) :
        (mSL_PtrTPtc == 10) ? ( z = #mSL_temp_str_10; ) :
        (mSL_PtrTPtc == 11) ? ( z = #mSL_temp_str_11; ) :
        (mSL_PtrTPtc == 12) ? ( z = #mSL_temp_str_12; ) :
        (mSL_PtrTPtc == 13) ? ( z = #mSL_temp_str_13; ) :
        (mSL_PtrTPtc == 14) ? ( z = #mSL_temp_str_14; ) :
        ( z = #mSL_temp_str_ZZ; );
    );
    AA_StrAllocated = z; // TRACE
    //  sprintf(#s, "Allocate str    =>    %d", z);
    //  mSL_log(SysLogBox, #s);
    z;
);
*/


// Release a string reference...
/*
//function mSL_releaseString(sref)
local (cnt, ent, z, do_it)
(
    cnt = mSL_StrsSize;
    do_it = 1;
    sref < 0 ? sref = -sref;
    ent = (sref * 47) % mSL_StrsSize;
    while (do_it) (
        z = mSL_current_StrPtrs[ent];
        (z == -sref) ? (
            mSL_current_StrPtrs[ent] = sref;
            do_it = 0;
        ) :
        ((z == 0) || (z == sref)) ? (
            // The string doesn't belong to the table
            // or is already free
            do_it = 0;
        ) : (
            ent = (ent + 17) % mSL_StrsSize;
            cnt += 1;
            cnt > mSL_StrsSize ? do_it = 0;
        );
    );
);
*/



/*
function mSL_isString(sref)
local (res, ent, z, do_it)
(
    res = 0;
    (sref > 0) ? (
        cnt = mSL_StrsSize;
        ent = (sref * 47) % mSL_StrsSize;
        do_it = 1;
        while (do_it) (
            z = mSL_current_StrPtrs[ent];
            ((z == sref) || (z == - sref)) ? (
                do_it = 0; res = 1;
            ) : (
                ent = (ent + 17) % mSL_StrsSize;
                cnt += 1;
                cnt > mSL_StrsSize ? do_it = 0;
            );
        );
    );
    res;
);
*/




0 ? (
    packStr(serialBlock + Pr7_Date, #t); // and pack it
    packStr(serialBlock + Pr7_PlayModes, #PlayModes);
    packStr(serialBlock + Pr7_SpaceModes, #SpaceModes);
    packStr(serialBlock + Pr7_BanksDefs, #BanksDefs);
    packStr(serialBlock + Pr7_HPConfigs, #HPConfigs);
    packStr(serialBlock + Pr7_ClipsModifiers, #ClipsModifiers);
    packStr(serialBlock + Pr7_InSens_Name, #InSens_Name);
    packStr(serialBlock + Pr7_GM_mSL_ini, #GM_mSL_ini);
    packStr(serialBlock + Pr7_Script_Name, #Script_Name);
    packStr(serialBlock + Pr7_clDirectory, #clDirectory);
);



0 ? (
    p = serialBlock + Pr7_PlayModes; (p[0] != 0) ? unpackArray(#PlayModes, p); flagPMRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_PlMd;
    p = serialBlock + Pr7_SpaceModes; (p[0] != 0) ? unpackArray(#SpaceModes, p); flagSPRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_SpMd;
    p = serialBlock + Pr7_BanksDefs; (p[0] != 0) ? unpackArray(#BanksDefs, p); flagBKRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Bnks;
    p = serialBlock + Pr7_HPConfigs; (p[0] != 0) ? unpackArray(#HPConfigs, p); flagHPCRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_HPC;
    p = serialBlock + Pr7_ClipsModifiers; (p[0] != 0) ? unpackArray(#ClipsModifiers, p); flagClVRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Clips;
    p = serialBlock + Pr7_InSens_Name; (p[0] != 0) ? unpackArray(#InSens_Name, p); flagSnsrRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Sensrs;
    p = serialBlock + Pr7_GM_mSL_ini; (p[0] != 0) ? unpackArray(#GM_mSL_ini, p); flagGM_mSL_ini = FlagsTbVals[Flgs_TblUpd] & flag_ld_Profile;
    p = serialBlock + Pr7_Script_Name; (p[0] != 0) ? unpackArray(#Script_Name, p);
    p = serialBlock + Pr7_clDirectory; (p[0] != 0) ? (
        unpackArray(#t, p);
        strcmp(#clDirectory, #t) ? (
            // directory change !
            setClDirectory(#t, 0);
        );
    );
);


/*
function show_SysSliders()
local (h1, h2, uix_jneed, uix_jmini)
(
    h1 = uix_jpadHeight(2); // height
    h2 = JSFXSlShow ? ui_jd_slidh  + 4  : 0;
    uix_jneed = h1 + h2 + ui_jd_ctgr;
    uix_jmini = h1  + ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            (zzmi = ui_hover()) ? (
                ui_Xtime_period = 0.1; // some graphic acceleration when in this module
            );
            keepBlockInfos(blockSysSliders);
            control_group(blockDispNames[blockSysSliders]);
            ui_split_top(h1);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padJSFXSlLabs, padJSFXSlSiz);
                ii = 0; loop(padJSFXSlSiz,
                    strcpy(padJSFXSlLabs[ii], "");
                    padJSFXSlColrs[ii] = Col_Inactive;
                    ii+=1;
                );
                s = JSFXSlNb+1; // displayed slider
                padJSFXSlLabs[0] = "Sys.Sliders";
                padJSFXSlColrs[0] = JSFXSlShow ? Col_Cmnds : Col_Inactive;
                sprintf(padJSFXSlLabs[8], "Slider: %d", JSFXSlNb+1); // displayed in [1, 64]
                padJSFXSlColrs[8] = JSFXSlShow ? Col_Cmnds : Col_Inactive;

                (JSFXSlShow) ? (
                    (param_touch_count != param_touch_last) ? (
                        JSFXSlLinkType = 1;
                        param_touch_last = param_touch_count;
                        (param_current != param_last_touched) ? (
                            param_current = param_last_touched;
                            param_current_min_m = param_current_min = parGetPP(param_current, pp_Min);
                            param_current_max_m = param_current_max = parGetPP(param_current, pp_Max);
                        );
                    );
                    (param_current != param_last_current) ? (
                        param_last_current = param_current;
                        param_current_ent = findLink(param_current);
                        (param_current_ent >= 0) ? (
                            // The entry exists
                            param_current_min_m = Links_Par1[param_current_ent];
                            param_current_max_m = Links_Par2[param_current_ent];
                        );
                    );
                    padJSFXSlLabs[1] = "Link Sl.";
                    (sliders_flags[s] == param_current) ? (
                        padJSFXSlColrs[1] = Color_Goldenrod;
                    ) :
                    (sliders_flags[s] == Undef) ? (
                        padJSFXSlColrs[1] = Color_Limegreen;
                    ) : (
                        padJSFXSlColrs[1] = Color_Peach_Yellow;
                        // Indicate the actual #
                        p2 = sliders_flags[s];
                        padJSFXSlLabs[2+8] = parGetPP(p2, pp_Name) ;
                        padJSFXSlColrs[2+8] = Color_Peach_Yellow;
                    );

                    sprintf(padJSFXSlLabs[2], "n° %d", param_current);
                    padJSFXSlLabs[3] = parGetPP(param_current, pp_Name) ;
                    fmt = parGetPP(param_current, pp_SFmt);
                    val = parGetV(param_current);
                    sprintf(padJSFXSlLabs[4], fmt, param_current_min);
                    sprintf(padJSFXSlLabs[5], fmt, param_current_max);
                    padJSFXSlColrs[2] = Col_InfoC;
                    padJSFXSlColrs[3] = Col_InfoC;
                    padJSFXSlColrs[4] = Col_InfoC;
                    padJSFXSlColrs[5] = Col_InfoC;

                    (sliders_flags[s] == param_current) ? (
                        sprintf(padJSFXSlLabs[4+8], fmt, sliders_par_Min[s]);
                        sprintf(padJSFXSlLabs[5+8], fmt, sliders_par_Max[s]);
                        padJSFXSlColrs[4+8] = Color_Limegreen;
                        padJSFXSlColrs[5+8] = Color_Limegreen;
                    );
                );

                zz = control_jpad(padJSFXSlp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    zzch = padJSFXSlp[ui_jpad_lkey];
                    zzent = padJSFXSlp[ui_jpad_entkey]-1;
                    zzmcl = padJSFXSlp[ui_jpad_last]-1;
                    zzmmd = padJSFXSlp[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl == 0) ? (
                            JSFXSlShow = JSFXSlShow ? 0 : 1;
                            slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                        ) :
                        (zzmcl == 8) ? (
                            slider_show(2 ^ JSFXSlNb, 0);
                            JSFXSlNb = (JSFXSlNb + 63) % 64;
                            JSFXSlShow ? slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                        );

                        (JSFXSlShow) ? (
                            (zzmcl == 2) ? (
                                param_touch_count += 1;
                                param_last_touched = (param_current + paramCount - 1) % paramCount;
                            );
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl == 0) ? (
                            JSFXSlShow = JSFXSlShow ? 0 : 1;
                            slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                        ) :
                        (zzmcl == 8) ? (
                            slider_show(2 ^ JSFXSlNb, 0);
                            JSFXSlNb = (JSFXSlNb + 1) % 64;
                            JSFXSlShow ? slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                        );
                        (JSFXSlShow) ? (
                            (zzmcl == 2) ? (
                                param_touch_count += 1;
                                param_last_touched = (param_current + 1) % paramCount;
                            );
                        );
                   );
                );
            ui_pop();

            (JSFXSlShow) ? (
                ui_split_top(h2);
                    ui_pad(1,3,1,0);
                    flgm = parCtl(param_current);
                ui_pop();
            );

            do_ModuleKeySave();
        ui_pop();
    );
);
*/



/*
//// Ces fonctions sont disponibles...
#AAAA = "This is a string";
mSL_log(SysLogBox, #AAAA);
str_insert(#AAAA,"srcstr",12);
mSL_log(SysLogBox, #AAAA);


#AAAA = "This is a string";
mSL_log(SysLogBox, #AAAA);
str_delsub(#AAAA,4,4);
mSL_log(SysLogBox, #AAAA);

#AAAA = "This is a string";
mSL_log(SysLogBox, #AAAA);
str_setlen(#AAAA,12);
mSL_log(SysLogBox, #AAAA);
*/



/*
//// Celles-ci n'existent pas, mais il faudrait les inclure
atexit("AAA=0;");
AAAA = eval("2+3;");
AAA = fopen("toto", "r");
AAA = file_exists("Banks.txt");
GetAppVersion(#retval);
*/


/*
sprintf(#sfc, "Low/High:    %18.0f   %18.0f ",  mSL_Sym_Low, mSL_Sym_High);
mSL_log(SysLogBox, #sfc);


ttsym("variable");
ttsym("Color_Dark_Gray");
ttsym("configuration");
ttsym("free_blocks_chaining");
ttsym("processus_status");

ttsym("Identification");
ttsym("Identification_1");
ttsym("Identification_2");
ttsym("Identification_a");
ttsym("Identification_b");

ttsym("variable");
ttsym("variabld");
ttsym("variablf");
ttsym("variablg");
ttsym("variablh");
ttsym("variabli");
ttsym("variable1");
ttsym("variable2");
ttsym("variable3");
ttsym("variable_1");
ttsym("variable_2");
ttsym("variable_3");
ttsym("variable11");
ttsym("variable12");
ttsym("variable13");

ttsym("SysLogBox");
ttsym("Directory");
ttsym("Ident");


ttsym("A");
ttsym("AA");
ttsym("ABC");

ttsym("A1");
ttsym("AA1");
ttsym("ABC1");

ttsym("sin");

ttsym("Sin");

ttsym("atan2");

ttsym("Atan2");
ttsym("Hello");
ttsym("World");
ttsym("hello");
ttsym("world");
ttsym("Hello_World");
ttsym("SysLogBox2");


ttsym("A_Pretty_Long_Identifier_With_A_Lot_Of_Characters");
ttsym("A_Pretty_Long_Identifier_With_A_Lot_Of_Characters_Again");
ttsym("A_Pretty_Long_Identifier_Also_With_A_Lot_Of_Characters");
ttsym("A_Pretty_Long_Identifier_Still_With_A_Lot_Of_Characters");
ttsym("And_A_Last_Pretty_Long_Identifier_With_A_Lot_Of_Characters");

ttsym("padPlayStoreNL");
ttsym("padPlayStoreNC");
ttsym("padPlayStoreSiz");
ttsym("padPlayStorep");
ttsym("padPlayStoreLabs");
ttsym("padPlayStoreColrs");
ttsym("padPlayStoreCells");
ttsym("padPlayStoreVals");
ttsym("ui_jpad_values");
ttsym("ui_jpad_cells");
ttsym("ui_jpad_clrs");
ttsym("ui_jpad_labs");
ttsym("ui_jpad_mk_values");
ttsym("ui_jpad_mk_labs");
ttsym("ui_jpad_ty_act");
ttsym("ui_jbtype");
ttsym("ui_jbsize");
ttsym("ui_jbres");
ttsym("ui_jbmmods");
ttsym("ui_jbtmask");
ttsym("ui_jbfmask");
ttsym("ui_jmake_arraymax");
ttsym("ui_j_UnixTime");
ttsym("ui_j_cumul_time");
ttsym("bLeftMouse");
ttsym("bRightMouse");
ttsym("bcmdKey");
ttsym("bshiftKey");
ttsym("baltKey");
ttsym("bctrlKey");
ttsym("bMiddleMouse");
ttsym("str_new_slot");
ttsym("str_new_tmp_slot");
ttsym("str_explode");
ttsym("str_ch_count");
ttsym("ui_jround");
ttsym("uix_pack_color");

ttsym("mSL_W_Pairs");
ttsym("mSL_W_CAlgs");
ttsym("GetAppVersion");
ttsym("file_exists");
ttsym("str_delsub");
ttsym("mSL_W_sidt");
ttsym("mSL_W_idt");
ttsym("mSL_W_fidt");
ttsym("mSL_Sys_log320");
ttsym("QuiteALongIdentifier");

ttsym("Ab_ie_de_eph_ehe_ei_ie_aja_aka_A_E");

ttsym("Game_Player");
ttsym("configuration");
ttsym("initialisation");
ttsym("interpretation");
ttsym("modification");
ttsym("generateurs");
ttsym("studDispPPrev");
ttsym("Color_Dark_Gray_2");
ttsym("ui_jcolor_inactive_grey");

ttsym("mSL_smallest_free");
ttsym("mSL_lastmemory");
ttsym("mSL_current_memory");
ttsym("mSL_current_StrPtrs");
ttsym("mSL_new_memory");
ttsym("mSL_define_primitives");
ttsym("mSL_MM_HighAdId");
ttsym("mSL_MM_HighAd");
ttsym("SchedStatus");
ttsym("SchedNxtEnt");
ttsym("SchedPrvEnt");

ttsym("mSL_clearGCTab");
ttsym("mSL_enterGCode");
ttsym("mSL_symbol");
ttsym("mSL_symbol2");

ttsym("suppress");
ttsym("suppression");
ttsym("redundencies");
ttsym("replacable");
ttsym("str_setchar");
ttsym("mSL_id2Str");
ttsym("mSL_edit_value");


ttsym("A_first_long_identifier");
ttsym("A_second_long_identifier");
ttsym("A_third_long_identifier");
ttsym("A_fourth_long_identifier");

ttsym("mSL_MKey_min");
ttsym("mSL_MKey_max");
ttsym("mSL_CC_Chksum");
ttsym("mSL_make_block");
ttsym("mSL_bl_check");
ttsym("mSL_bl_clear");
ttsym("mSL_Mbl_check");
ttsym("mSL_blType");

ttsym("presetVersionCurrent");
ttsym("presetVersionLoaded");
ttsym("presetVersionMask");
ttsym("presetLoadError");
ttsym("presetCheckValue");
ttsym("presetCheckLoaded");

ttsym("Audacity");

ttsym("gmemLimit");
ttsym("clipLibVers");
ttsym("flagGInited");
ttsym("Ugmem");
ttsym("gmem");
ttsym("Undef");
ttsym("ULocPrime");
ttsym("tickShift");
ttsym("SubSection");
ttsym("gmset");
ttsym("getexpldstr");
ttsym("setexpldstr");
ttsym("str_getchar");
ttsym("loczerovalue");
ttsym("flagInited");
ttsym("flagIDate");
ttsym("flagSect");
ttsym("flagSubS");
ttsym("timeYear");
ttsym("timeMonth");
ttsym("timeDay");
ttsym("timeHour");
ttsym("timeMinute");
ttsym("timeSecond");
ttsym("timeDofWeek");
ttsym("timeSecOfDay");
ttsym("timeSecOfRun");
ttsym("timeTick");
ttsym("timeYisBissext");
ttsym("timeDofYear");
ttsym("timeStartUp");
ttsym("timeUnix");
ttsym("timeSubsec");

ttsym("PSetCLoop");
ttsym("PSetPLRatio");
ttsym("PSetAutoMd");
ttsym("PSetHPDsty");
ttsym("PSetRateCtl");
ttsym("PSetLoopDur");
ttsym("PSetTSTX0");
ttsym("PSetTSTX2");

ttsym("mSL_Sys_log041");
ttsym("mSL_Sys_log156");
ttsym("mSL_Sys_log247");
ttsym("mSL_Sys_log088");
ttsym("mSL_Sys_log244");
ttsym("processus_status");
ttsym("previous_pointer");
ttsym("free_blocks_chaining");

ttsym("SharedLowMemory");
ttsym("SharedLowMemorySize");
ttsym("Color_Forest_Green");
ttsym("Color_Peach_Yellow");
ttsym("Color_Dark_Gray");
ttsym("Color_Darker_Gray");
ttsym("Color_Dark_Orange");
ttsym("Color_Deep_Reddish_Orange");




ttsym("Hello");

ttsym("World");
ttsym("world");
ttshow(mSL_KW_SensorSize);

ttshow(mSL_KW_SensorSz);
ttshow(mSL_symbol("SensorSz"));
ttshow(mSL_KW_strclean);

ttshow(mSL_KW_PWeight);

ttshow(mSL_KW_globals2);

zzztruc = mSL_symbol("SensorSize");

mSL_KW_globals2 = mSL_symbol("globalsbals");

ttshow(mSL_KW_globals2);

ttshow(zzztruc);

ttshow(mSL_symbol("FLdoForcePlay"));

ttshow(mSL_symbol("SensorSize"));
mSL_KW_SensorSize = mSL_symbol("SensorSize");

ttshow(mSL_KW_SensorSize);
ttsym("#world");


ttsym("#Hello");

ttsym("FLdoForcePlay");

ttsym("HP_Set_Cntr");

ttsym("MIDISensDefTout");

ttsym("MIDISensMinWRep");

ttsym("SensorSize");

ttsym("FLdoForcePlay");

ttsym("SensorSize");

ttsdmp();

//  */

/*
sprintf(#sfc, "$pi=  %24.18f",  $pi);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "$e=  %24.18f",  $e);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "3.14...=  %24.18f",  3.1415926535897932384626433832795);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "2.718...=  %24.18f",  2.71828182845904523536);
mSL_log(SysLogBox, #sfc);



sprintf(#sfc, "1e-6 = %24.18f",  1e-6);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "-1e-6 = %24.18f",  -1e-6);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "0.000001 = %24.18f",  0.000001 );
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "-0.000001 = %24.18f",  -0.000001 );
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "1e16 = %24.18f",  1e16);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "-1e16 = %24.18f",  -1e16);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "X%0.16g", -0.0000002);
mSL_log(SysLogBox, #sfc);

sprintf(#sfc, "Y%0.13g", -0.0000002);
mSL_log(SysLogBox, #sfc);

val = -0.0000002;

mSL_edit_value(#sfc, val);
mSL_log(SysLogBox, #sfc);

mSL_edit_value(#sfc, 0.0000000003);
mSL_log(SysLogBox, #sfc);

mSL_edit_value(#sfc, 0.3);
mSL_log(SysLogBox, #sfc);


k = ((val < -0.0001) || (val > 0.0001));
sprintf(#sfc, "k = %d", k);
mSL_log(SysLogBox, #sfc);



AAAAAAEEEE1 = 1000000000000000;
AAAAAAEEEE2 = -1000000000000000;
AAAAAAEEEE6 = 1e-6;
AAAAAAEEEE7 = -1e-6;
AAAAAAEEEE8 = 1e6;
AAAAAAEEEE9 = -1e6;


*/


////////

/*
#sas = "&/BC";
va = str_getchar(#sas, 0, 'cu');
vb = str_getchar(#sas, 1, 'cu');
vc = str_getchar(#sas, 2, 'cu');
vd = str_getchar(#sas, 3, 'cu');
sprintf(#sat, " %s    %d %d %d %d", #sas, va, vb, vc, vd);
mSL_log(SysLogBox, #sat);
*/


/*
function setClipsCharacteristics()
local (ii, curVol, fH, ck, val, state, clp1)
(
    err_fclp = 0; // no error (yet)
    ClipConfigVersion = 0;  // undefined yet
    curVol = 0; // set default volume to 0
    state = 0; // automaton state
    ClMEntries = ClLEntry = 0;

    ii = 0; loop(clTSize, gmem[clClVolumes+ii]=0; ii+=1;); // reset all to 0dB
    val = 0;
    fH = GM_file_open(#ClipsModifiers);
    (ck = (fH >= 0 && file_text(fH))) ? (
        while (ck && (err_fclp == 0)) (
            // we need to read a new number from the file
            file_var(fH, val);
            !(ck = file_avail(fH)) ? val = End;

            // Etat 0
            (state == 0) ? (
                // expect a "ClVol" definition
                (val == ClVol) ? (
                    state = 1;
                ) :
                (val == FIdent) ? (
                    state = 5;
                ) :
                (  // else
                    err_fclp = 0606; // "ClVol" expected
                );
            ) :

            // Etat 1
            (state == 1) ? (
                // volume should be in [-120 20]
                ((val >= -120) && (val < 20)) ? (
                    // value is valid
                    curVol = val; // curVol = (val > -120) ? 10^(val/20) : 0 ;
                    state = 2;
                )  : (  // else
                    err_fclp = 0607; // "ClVol" parameter is invalid
                );
            ) :

            // Etat 2
            (state == 2) ? (
                // expect a clip range, a clip number, a clip volume or End
                ((val >= 0) && (val < clTSize) && (val == (0|val))) ? (
                      // set this clip volume
                      gmem[clClVolumes+val] = curVol;
                      ClLEntry = val;
                ) :
                (val == ClRange) ? (
                      // expect two parameters
                      state = 3;
                ) :
                (val == ClVol) ? (
                      state = 1;
                ) :
                (val == End) ? (
                      state = 0;
                ) : (  // else
                     err_fclp = 0608; // incorrect clip number
                );
            ) :

            // Etat 3
            (state == 3) ? (
                // expect a first clip number
                ((val >= 0) && (val < clTSize) && (val == (0|val))) ? (
                    clp1 = val;
                    state = 4;
                ) : (  // else
                    err_fclp = 0609; // incorrect range first clip number
                );
            ) :

            // Etat 4
            (state == 4) ? (
                // expect a second clip number
                ((val >= 0) && (val < clTSize) && (val == (0|val)) && (val >= clp1)) ? (
                    while (clp1 <= val) (
                        gmem[clClVolumes+clp1] = curVol; clp1 += 1;
                    );
                    ClLEntry = val;
                    state = 2;
                ) : (  // else
                    err_fclp = 0610; // incorrect range second clip number
                );
            ) :

            // Etat 5
            (state == 5) ? (
                // expect a file identification
                ((val < Mu) && (val > 0) && (val == (0|val))) ? (
                    ClipConfigVersion = val;
                ) : (
                    err_fclp = 0613; // incorrect config number
                );
                state = 0;
            ) :

            (  // else
                 err_fclp = 0601; // internal bug
            );
        );
    ) : (  // else
        err_fclp = 0604; // can't open
    );

    ii = 0; loop(clTSize, gmem[clClVolumes+ii]!=0 ? ClMEntries +=1; ii+=1;); // Count mod. entries
    fH >= 0 ? file_close(fH);

    (err_fclp == 0) ? (
        sprintf(#s, "Clips mods. load: %s", #ClipsModifiers);
    ) : (
        sprintf(#s, "Clips mods. err: %d %s", err_fclp, #ClipsModifiers);
    );
    mSL_log(SysLogBox, #s);
);*/
















(xop&0x80)?((xop&0x40)?((xop&0x20)?((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++255++++//
    mSL_errX=255;
    //++++255++++//

):(

    //++++254++++//
    mSL_errX=254;
    //++++254++++//

);):((xop&0x1)?(

    //++++253++++//
    mSL_errX=253;
    //++++253++++//

):(

    //++++252++++//
    mSL_errX=252;
    //++++252++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++251++++//
    mSL_errX=251;
    //++++251++++//

):(

    //++++250++++//
    mSL_errX=250;
    //++++250++++//

);):((xop&0x1)?(

    //++++249++++//
    mSL_errX=249;
    //++++249++++//

):(

    //++++248++++//
    mSL_errX=248;
    //++++248++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++247++++//
    mSL_errX=247;
    //++++247++++//

):(

    //++++246++++//
    mSL_errX=246;
    //++++246++++//

);):((xop&0x1)?(

    //++++245++++//
    mSL_errX=245;
    //++++245++++//

):(

    //++++244++++//
    mSL_errX=244;
    //++++244++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++243++++//
    mSL_errX=243;
    //++++243++++//

):(

    //++++242++++//
    mSL_errX=242;
    //++++242++++//

);):((xop&0x1)?(

    //++++241++++//
    mSL_errX=241;
    //++++241++++//

):(

    //++++240++++//
    mSL_errX=240;
    //++++240++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++239++++//
    mSL_errX=239;
    //++++239++++//

):(

    //++++238++++//
    mSL_errX=238;
    //++++238++++//

);):((xop&0x1)?(

    //++++237++++//
    mSL_errX=237;
    //++++237++++//

):(

    //++++236++++//
    mSL_errX=236;
    //++++236++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++235++++//
    mSL_errX=235;
    //++++235++++//

):(

    //++++234++++//
    mSL_errX=234;
    //++++234++++//

);):((xop&0x1)?(

    //++++233++++//
    mSL_errX=233;
    //++++233++++//

):(

    //++++232++++//
    mSL_errX=232;
    //++++232++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++231++++//
    mSL_errX=231;
    //++++231++++//

):(

    //++++230++++//
    mSL_errX=230;
    //++++230++++//

);):((xop&0x1)?(

    //++++229++++//
    mSL_errX=229;
    //++++229++++//

):(

    //++++228++++//
    mSL_errX=228;
    //++++228++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++227++++//
    mSL_errX=227;
    //++++227++++//

):(

    //++++226++++//
    mSL_errX=226;
    //++++226++++//

);):((xop&0x1)?(

    //++++225++++//
    mSL_errX=225;
    //++++225++++//

):(

    //++++224++++//
    mSL_errX=224;
    //++++224++++//

);););););):((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++223++++//
    mSL_errX=223;
    //++++223++++//

):(

    //++++222++++//
    mSL_errX=222;
    //++++222++++//

);):((xop&0x1)?(

    //++++221++++//
    mSL_errX=221;
    //++++221++++//

):(

    //++++220++++//
    mSL_errX=220;
    //++++220++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++219++++//
    mSL_errX=219;
    //++++219++++//

):(

    //++++218++++//
    mSL_errX=218;
    //++++218++++//

);):((xop&0x1)?(

    //++++217++++//
    mSL_errX=217;
    //++++217++++//

):(

    //++++216++++//
    mSL_errX=216;
    //++++216++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++215++++//
    mSL_errX=215;
    //++++215++++//

):(

    //++++214++++//
    mSL_errX=214;
    //++++214++++//

);):((xop&0x1)?(

    //++++213++++//
    mSL_errX=213;
    //++++213++++//

):(

    //++++212++++//
    mSL_errX=212;
    //++++212++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++211++++//
    mSL_errX=211;
    //++++211++++//

):(

    //++++210++++//
    mSL_errX=210;
    //++++210++++//

);):((xop&0x1)?(

    //++++209++++//
    mSL_errX=209;
    //++++209++++//

):(

    //++++208++++//
    mSL_errX=208;
    //++++208++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++207++++//
    mSL_errX=207;
    //++++207++++//

):(

    //++++206++++//
    mSL_errX=206;
    //++++206++++//

);):((xop&0x1)?(

    //++++205++++//
    mSL_errX=205;
    //++++205++++//

):(

    //++++204++++//
    mSL_errX=204;
    //++++204++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++203++++//
    mSL_errX=203;
    //++++203++++//

):(

    //++++202++++//
    mSL_errX=202;
    //++++202++++//

);):((xop&0x1)?(

    //++++201++++//
    mSL_errX=201;
    //++++201++++//

):(

    //++++200++++//
    mSL_errX=200;
    //++++200++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++199++++//
    mSL_errX=199;
    //++++199++++//

):(

    //++++198++++//
    mSL_errX=198;
    //++++198++++//

);):((xop&0x1)?(

    //++++197++++//
    mSL_errX=197;
    //++++197++++//

):(

    //++++196++++//
    mSL_errX=196;
    //++++196++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++195++++//
    mSL_errX=195;
    //++++195++++//

):(

    //++++194++++//
    mSL_errX=194;
    //++++194++++//

);):((xop&0x1)?(

    //++++193++++//
    mSL_errX=193;
    //++++193++++//

):(

    //++++192++++//
    mSL_errX=192;
    //++++192++++//

););););););):((xop&0x20)?((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++191++++//
    mSL_errX=191;
    //++++191++++//

):(

    //++++190++++//
    mSL_errX=190;
    //++++190++++//

);):((xop&0x1)?(

    //++++189++++//
    mSL_errX=189;
    //++++189++++//

):(

    //++++188++++//
    mSL_errX=188;
    //++++188++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++187++++//
    mSL_errX=187;
    //++++187++++//

):(

    //++++186++++//
    mSL_errX=186;
    //++++186++++//

);):((xop&0x1)?(

    //++++185++++//
    mSL_errX=185;
    //++++185++++//

):(

    //++++184++++//
    mSL_errX=184;
    //++++184++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++183++++//
    mSL_errX=183;
    //++++183++++//

):(

    //++++182++++//
    mSL_errX=182;
    //++++182++++//

);):((xop&0x1)?(

    //++++181++++//
    mSL_errX=181;
    //++++181++++//

):(

    //++++180++++//
    mSL_errX=180;
    //++++180++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++179++++//
    mSL_errX=179;
    //++++179++++//

):(

    //++++178++++//
    mSL_errX=178;
    //++++178++++//

);):((xop&0x1)?(

    //++++177++++//
    mSL_errX=177;
    //++++177++++//

):(

    //++++176++++//
    mSL_errX=176;
    //++++176++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++175++++//
    mSL_errX=175;
    //++++175++++//

):(

    //++++174++++//
    mSL_errX=174;
    //++++174++++//

);):((xop&0x1)?(

    //++++173++++//
    mSL_errX=173;
    //++++173++++//

):(

    //++++172++++//
    mSL_errX=172;
    //++++172++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++171++++//
    mSL_errX=171;
    //++++171++++//

):(

    //++++170++++//
    mSL_errX=170;
    //++++170++++//

);):((xop&0x1)?(

    //++++169++++//
    mSL_errX=169;
    //++++169++++//

):(

    //++++168++++//
    mSL_errX=168;
    //++++168++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++167++++//
    mSL_errX=167;
    //++++167++++//

):(

    //++++166++++//
    mSL_errX=166;
    //++++166++++//

);):((xop&0x1)?(

    //++++165++++//
    mSL_errX=165;
    //++++165++++//

):(

    //++++164++++//
    mSL_errX=164;
    //++++164++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++163++++//
    mSL_errX=163;
    //++++163++++//

):(

    //++++162++++//
    mSL_errX=162;
    //++++162++++//

);):((xop&0x1)?(

    //++++161++++//
    mSL_errX=161;
    //++++161++++//

):(

    //++++160++++//
    mSL_errX=160;
    //++++160++++//

);););););):((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++159++++//
    mSL_errX=159;
    //++++159++++//

):(

    //++++158++++//
    mSL_errX=158;
    //++++158++++//

);):((xop&0x1)?(

    //++++157++++//
    mSL_errX=157;
    //++++157++++//

):(

    //++++156++++//
    mSL_errX=156;
    //++++156++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++155++++//
    mSL_errX=155;
    //++++155++++//

):(

    //++++154++++//
    mSL_errX=154;
    //++++154++++//

);):((xop&0x1)?(

    //++++153++++//
    mSL_errX=153;
    //++++153++++//

):(

    //++++152++++//
    mSL_errX=152;
    //++++152++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++151++++//
    mSL_errX=151;
    //++++151++++//

):(

    //++++150++++//
    mSL_errX=150;
    //++++150++++//

);):((xop&0x1)?(

    //++++149++++//
    mSL_errX=149;
    //++++149++++//

):(

    //++++148++++//
    mSL_errX=148;
    //++++148++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++147++++//
    mSL_errX=147;
    //++++147++++//

):(

    //++++146++++//
    mSL_errX=146;
    //++++146++++//

);):((xop&0x1)?(

    //++++145++++//
    mSL_errX=145;
    //++++145++++//

):(

    //++++144++++//
    mSL_errX=144;
    //++++144++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++143++++//
    mSL_errX=143;
    //++++143++++//

):(

    //++++142++++//
    mSL_errX=142;
    //++++142++++//

);):((xop&0x1)?(

    //++++141++++//
    mSL_errX=141;
    //++++141++++//

):(

    //++++140++++//
    mSL_errX=140;
    //++++140++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++139++++//
    mSL_errX=139;
    //++++139++++//

):(

    //++++138++++//
    mSL_errX=138;
    //++++138++++//

);):((xop&0x1)?(

    //++++137++++//
    mSL_errX=137;
    //++++137++++//

):(

    //++++136++++//
    mSL_errX=136;
    //++++136++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++135++++//
    mSL_errX=135;
    //++++135++++//

):(

    //++++134++++//
    mSL_errX=134;
    //++++134++++//

);):((xop&0x1)?(

    //++++133++++//
    mSL_errX=133;
    //++++133++++//

):(

    //++++132++++//
    mSL_errX=132;
    //++++132++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++131++++//
    mSL_errX=131;
    //++++131++++//

):(

    //++++130++++//
    mSL_errX=130;
    //++++130++++//

);):((xop&0x1)?(

    //++++129++++//
    mSL_errX=129;
    //++++129++++//

):(

    //++++128++++//
    mSL_errX=128;
    //++++128++++//

);););););););):((xop&0x40)?((xop&0x20)?((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++127++++//
    mSL_errX=127;
    //++++127++++//

):(

    //++++126++++//
    mSL_errX=126;
    //++++126++++//

);):((xop&0x1)?(

    //++++125++++//
    mSL_errX=125;
    //++++125++++//

):(

    //++++124++++//
    mSL_errX=124;
    //++++124++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++123++++//
    mSL_errX=123;
    //++++123++++//

):(

    //++++122++++//
    mSL_errX=122;
    //++++122++++//

);):((xop&0x1)?(

    //++++121++++//
    mSL_errX=121;
    //++++121++++//

):(

    //++++120++++//
    mSL_errX=120;
    //++++120++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++119++++//
    mSL_errX=119;
    //++++119++++//

):(

    //++++118++++//
    mSL_errX=118;
    //++++118++++//

);):((xop&0x1)?(

    //++++117++++//
    mSL_errX=117;
    //++++117++++//

):(

    //++++116++++//
    mSL_errX=116;
    //++++116++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++115++++//
    mSL_errX=115;
    //++++115++++//

):(

    //++++114++++//
    mSL_errX=114;
    //++++114++++//

);):((xop&0x1)?(

    //++++113++++//
    mSL_errX=113;
    //++++113++++//

):(

    //++++112++++//
    mSL_errX=112;
    //++++112++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++111++++//
    mSL_errX=111;
    //++++111++++//

):(

    //++++110++++//
    mSL_errX=110;
    //++++110++++//

);):((xop&0x1)?(

    //++++109++++//
    mSL_errX=109;
    //++++109++++//

):(

    //++++108++++//
    mSL_errX=108;
    //++++108++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++107++++//
    mSL_errX=107;
    //++++107++++//

):(

    //++++106++++//
    mSL_errX=106;
    //++++106++++//

);):((xop&0x1)?(

    //++++105++++//
    mSL_errX=105;
    //++++105++++//

):(

    //++++104++++//
    mSL_errX=104;
    //++++104++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++103++++//
    mSL_errX=103;
    //++++103++++//

):(

    //++++102++++//
    mSL_errX=102;
    //++++102++++//

);):((xop&0x1)?(

    //++++101++++//
    mSL_errX=101;
    //++++101++++//

):(

    //++++100++++//
    mSL_errX=100;
    //++++100++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++99++++//
    mSL_errX=99;
    //++++99++++//

):(

    //++++98++++//
    mSL_errX=98;
    //++++98++++//

);):((xop&0x1)?(

    //++++97++++//
    mSL_errX=97;
    //++++97++++//

):(

    //++++96++++//
    mSL_errX=96;
    //++++96++++//

);););););):((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++95++++//
    mSL_errX=95;
    //++++95++++//

):(

    //++++94++++//
    mSL_errX=94;
    //++++94++++//

);):((xop&0x1)?(

    //++++93++++//
    mSL_errX=93;
    //++++93++++//

):(

    //++++92++++//
    mSL_errX=92;
    //++++92++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++91++++//
    mSL_errX=91;
    //++++91++++//

):(

    //++++90++++//
    mSL_errX=90;
    //++++90++++//

);):((xop&0x1)?(

    //++++89++++//
    mSL_errX=89;
    //++++89++++//

):(

    //++++88++++//
    mSL_errX=88;
    //++++88++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++87++++//
    mSL_errX=87;
    //++++87++++//

):(

    //++++86++++//
    mSL_errX=86;
    //++++86++++//

);):((xop&0x1)?(

    //++++85++++//
    mSL_errX=85;
    //++++85++++//

):(

    //++++84++++//
    mSL_errX=84;
    //++++84++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++83++++//
    mSL_errX=83;
    //++++83++++//

):(

    //++++82++++//
    mSL_errX=82;
    //++++82++++//

);):((xop&0x1)?(

    //++++81++++//
    mSL_errX=81;
    //++++81++++//

):(

    //++++80++++//
    mSL_errX=80;
    //++++80++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++79++++//
    mSL_errX=79;
    //++++79++++//

):(

    //++++78++++//
    mSL_errX=78;
    //++++78++++//

);):((xop&0x1)?(

    //++++77++++//
    mSL_errX=77;
    //++++77++++//

):(

    //++++76++++//
    mSL_errX=76;
    //++++76++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++75++++//
    mSL_errX=75;
    //++++75++++//

):(

    //++++74++++//
    mSL_errX=74;
    //++++74++++//

);):((xop&0x1)?(

    //++++73++++//
    mSL_errX=73;
    //++++73++++//

):(

    //++++72++++//
    mSL_errX=72;
    //++++72++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++71++++//
    mSL_errX=71;
    //++++71++++//

):(

    //++++70++++//
    mSL_errX=70;
    //++++70++++//

);):((xop&0x1)?(

    //++++69++++//
    mSL_errX=69;
    //++++69++++//

):(

    //++++68++++//
    mSL_errX=68;
    //++++68++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++67++++//
    mSL_errX=67;
    //++++67++++//

):(

    //++++66++++//
    mSL_errX=66;
    //++++66++++//

);):((xop&0x1)?(

    //++++65++++//
    mSL_errX=65;
    //++++65++++//

):(

    //++++64++++//
    mSL_errX=64;
    //++++64++++//

););););););):((xop&0x20)?((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++63++++//
    mSL_errX=63;
    //++++63++++//

):(

    //++++62++++//
    mSL_errX=62;
    //++++62++++//

);):((xop&0x1)?(

    //++++61++++//
    mSL_errX=61;
    //++++61++++//

):(

    //++++60++++//
    mSL_errX=60;
    //++++60++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++59++++//
    mSL_errX=59;
    //++++59++++//

):(

    //++++58++++//
    mSL_errX=58;
    //++++58++++//

);):((xop&0x1)?(

    //++++57++++//
    mSL_errX=57;
    //++++57++++//

):(

    //++++56++++//
    mSL_errX=56;
    //++++56++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++55++++//
    mSL_errX=55;
    //++++55++++//

):(

    //++++54++++//
    mSL_errX=54;
    //++++54++++//

);):((xop&0x1)?(

    //++++53++++//
    mSL_errX=53;
    //++++53++++//

):(

    //++++52++++//
    mSL_errX=52;
    //++++52++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++51++++//
    mSL_errX=51;
    //++++51++++//

):(

    //++++50++++//
    mSL_errX=50;
    //++++50++++//

);):((xop&0x1)?(

    //++++49++++//
    mSL_errX=49;
    //++++49++++//

):(

    //++++48++++//
    mSL_errX=48;
    //++++48++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++47++++//
    mSL_errX=47;
    //++++47++++//

):(

    //++++46++++//
    mSL_errX=46;
    //++++46++++//

);):((xop&0x1)?(

    //++++45++++//
    mSL_errX=45;
    //++++45++++//

):(

    //++++44++++//
    mSL_errX=44;
    //++++44++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++43++++//
    mSL_errX=43;
    //++++43++++//

):(

    //++++42++++//
    mSL_errX=42;
    //++++42++++//

);):((xop&0x1)?(

    //++++41++++//
    mSL_errX=41;
    //++++41++++//

):(

    //++++40++++//
    mSL_errX=40;
    //++++40++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++39++++//
    mSL_errX=39;
    //++++39++++//

):(

    //++++38++++//
    mSL_errX=38;
    //++++38++++//

);):((xop&0x1)?(

    //++++37++++//
    mSL_errX=37;
    //++++37++++//

):(

    //++++36++++//
    mSL_errX=36;
    //++++36++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++35++++//
    mSL_errX=35;
    //++++35++++//

):(

    //++++34++++//
    mSL_errX=34;
    //++++34++++//

);):((xop&0x1)?(

    //++++33++++//
    mSL_errX=33;
    //++++33++++//

):(

    //++++32++++//
    mSL_errX=32;
    //++++32++++//

);););););):((xop&0x10)?((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++31++++//
    mSL_errX=31;
    //++++31++++//

):(

    //++++30++++//
    mSL_errX=30;
    //++++30++++//

);):((xop&0x1)?(

    //++++29++++//
    mSL_errX=29;
    //++++29++++//

):(

    //++++28++++//
    mSL_errX=28;
    //++++28++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++27++++//
    mSL_errX=27;
    //++++27++++//

):(

    //++++26++++//
    mSL_errX=26;
    //++++26++++//

);):((xop&0x1)?(

    //++++25++++//
    mSL_errX=25;
    //++++25++++//

):(

    //++++24++++//
    mSL_errX=24;
    //++++24++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++23++++//
    mSL_errX=23;
    //++++23++++//

):(

    //++++22++++//
    mSL_errX=22;
    //++++22++++//

);):((xop&0x1)?(

    //++++21++++//
    mSL_errX=21;
    //++++21++++//

):(

    //++++20++++//
    mSL_errX=20;
    //++++20++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++19++++//
    mSL_errX=19;
    //++++19++++//

):(

    //++++18++++//
    mSL_errX=18;
    //++++18++++//

);):((xop&0x1)?(

    //++++17++++//
    mSL_errX=17;
    //++++17++++//

):(

    //++++16++++//
    mSL_errX=16;
    //++++16++++//

););););):((xop&0x8)?((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++15++++//
    mSL_errX=15;
    //++++15++++//

):(

    //++++14++++//
    mSL_errX=14;
    //++++14++++//

);):((xop&0x1)?(

    //++++13++++//
    mSL_errX=13;
    //++++13++++//

):(

    //++++12++++//
    // mSL_errX=12;
    // play a recorded item :
    doPlayRItem(ActPar1, ActPar2); //
    //++++12++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++11++++//
    // mSL_errX=11;
    // random play one clip of current group
    doPlayCmd(cmdClMdBase + GvPlayTypGroup);
    //++++11++++//

):(

    //++++10++++//====== mSL EXECUTION ======
    // mSL_errX=10;
    mSL_dispatch_entry = SchX;
    atomic_get(mSL_Lock) ? (
        // We are doing some exclusive operation. mSL Threads are not allowed to execute
        SchedInsertTail(SchedLockdPts, SchX); // insert the thread in locked pts
        SchX = -1;
    ) : (
        tstrt = time_precise() + timeD;
        mSL_active_Thread = SchedThrdPt[SchX]; // the thread
        ((SchedStatus[mSL_dispatch_entry] & SchmSLThrUsed) != SchmSLThrUsed) ? (
            (mSL_errX === 0) ? mSL_errX = 3381; // thread not noted active ?
        );
        mSL_load_thread(mSL_active_Thread);
        mSL_max_TOS = mSL_active_Thread[mSL_THR_basePhStack];

        (mSL_errX != 0) ? (
            thread_error(mSL_active_Thread, mSL_errX, SchX);
        ) : (
            mm_xec_mm[mm_xec_ptr] -=  mSL_ICount;
            mm_cyc_mm[mm_cyc_ptr] -=  mSL_ICount;
            // Curr_Block_Alloc
            AAAAAAAA_mSL_rpeat = mSL_rpeat = max(4096, 0|(mSL_insts_per_s * min(TLeft, Curr_Block_Alloc * 0.15))) ; // A large number
            mSL_evaluate();
            AAAAAAAA_mSL_evaluate_count += 1;
            mSL_High_Stack = max(mSL_High_Stack, mSL_max_TOS - mSL_active_Thread[mSL_THR_basePhStack]);
            //sprintf(#uuu, "End of evaluation - CR: %d - XC: %d", mSL_CodeStop, AAAAAAAA_mSL_evaluate_count);
            //mSL_log(SysLogBox, #uuu);
            mSL_save_thread(mSL_active_Thread);
            ((mSL_CodeStop === 0) || (mSL_CodeStop === mSL_RC_Yield)) ? (
                // reintroduce the thread in the queue
                SchedInsertTail(SchedActivPts, SchX);
                SchX = -1;
            ) :
            (mSL_CodeStop === mSL_RC_Wait) ? (
                (mSL_WaitDuration > 0) ? (
                    // introduce the entry in the wait queue
                    Schedule(SchedRelative, mSL_WaitDuration, 0, SchX, 0, 0, 0);
                ) : (
                    // reintroduce the thread in the queue
                    SchedInsertTail(SchedActivPts, SchX);
                );
                SchX = -1;
            ) :
            (mSL_CodeStop === mSL_RC_Stop) ? (
                // finished, free the thread
                freeSchedThread(SchX);
                // SchedStatus[SchX] &= SchThrNotUsed;
                // SchedInsertTail(SchedInactPts, SchX);
                mSL_dispatch_entry = SchX = -1;
            ) :
            (mSL_CodeStop === mSL_RC_WEvent) ? (
                // introduce the entry in the wait queue
                SchedInsertTail(SchedEvntPts, SchX);
                (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                    sprintf(#s, "Insert in Evnt : ent: %d thrd: %d siz: %d ", SchX, mSL_active_Thread, SchedListSize(SchedEvntPts));
                    mSL_log(SysLogBox, #s);
                );
                AAAAA__Schx = Schx;
                AAAAA__SchxNum = SchedEntryN[Schx];
                SchX = -1;
            ) :
            (mSL_CodeStop === mSL_RC_WAITGC) ? (
                // introduce in the wait for GC list
                SchedInsertTail(SchedLockdPts, SchX);
                SchX = -1;
            ) :
            (
                //AAAAAAAA_Errx = mSL_errX;
                thread_error(mSL_active_Thread, mSL_errX, mSL_CodeStop);
                // SchedStatus[SchX] &= SchThrNotUsed;
                // SchedInsertTail(SchedInactPts, SchX);
                // sprintf(#uuu, "End of evaluation [%d]  CR: %d  Err: %d", SchX, mSL_CodeStop, mSL_errX);
                (mSL_wbl != 0) ? (
                    sprintf(#uuu, "Block damaged @ %d", mSL_wbl);mSL_log(SysLogBox, #uuu);
                );
                mSL_error_analysis(mSL_active_Thread);
                SchedFree(SchX);
                SchX = -1;
                mSL_errC = 0; mSL_errX = 1717; // "error previously detected"
                mSL_errX = 0; // let other threads progress
            );
            mm_xec_mm[mm_xec_ptr] += mSL_ICount;
            mm_cyc_mm[mm_cyc_ptr] += mSL_ICount;
        );
        mm_dur_mm[mm_cyc_ptr] += time_precise() + timeD - tstrt;
    );
    mSL_active_Thread = -1;
    //++++10++++//

);):((xop&0x1)?(

    //++++9++++//
    // Random change max generators
    m = paramValues[p_Gen_MaxCnt] / 2.5;
    p = (10 + paramValues[p_Gen_VariVal])/90;
    //AAAAAAAA_p = p;
    (rand(1) > 0.4) ? (
        x = rand(1); m += x * x * p * 2.0 * m;
    ) : (
        m -= rand(1) * p * 1.2 * m;
    );
    //AAAAAAAA_m = m;
    parSet(p_maxGenerators, max(paramValues[p_Gen_MinCnt], min(paramValues[p_Gen_MaxCnt], paramValues[p_Gen_MinCnt]+m)));
    //++++9++++//

):(

    //++++8++++//
    // Stop play
    parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
    // clearCmd();
    doReader(-1, KmdQStop); BPLSTClear();
    //++++8++++//

);););):((xop&0x4)?((xop&0x2)?((xop&0x1)?(

    //++++7++++//
    // everybody play reverse !
    parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
    doReader(-1, KmdSpF1, 1);
    //++++7++++//

):(

    //++++6++++//
    // random play one clip of current group
    doPlayCmd(cmdClMdBase + GvPlayTypGroup);
    //++++6++++//

);):((xop&0x1)?(

    //++++5++++//
    // OP 5 : Modify Some/ALL players status
    // p1 === 0 : do nothing
    // p1 === 1 : lock all & set flags to Actpar2
    // p1 === 2 : unlock all & reset flags
    // p1 === 3 : toggle lock p2/p3
    // p1 === 4 : unlock p2/p3
    // p1 === 5 : solo p2/p3
    // p1 === 6 : mute/unmute p2/p3
    // p1 === 7 : stop p2/p3
    // p1 === 8 : unlock p2/p3
    xopKmd = ActPar1 & 0xff; // actual op code
    xopFlgs = ActPar1 & 0xffff00; // addtl. flags
    xopFlgs & ActFlg1 ? parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
    msk = uid = pid = 0;
    AAAAAAAA_Task5_1 = ActPar1;
    loop (uCnt,
        Un = UGAddr + UCBSize * uid;
        pid = gmem[Un+cbPadUnitIdt]; // the ID of the pad
        (((ty = gmem[Un+cbType]) === uPlayer)
        && ((st = gmem[Un+cbStat]) === uSBusy)
        && (((pm = gmem[Un+RCB_cbCKmd]) === KmdPlay) || (pm === KmdLoop))) ? ( // L=>C
            (xopKmd === 1) ? ( // lock and set all to p2
                gmem[Un+RCB_ClipLoop] = Actpar2;
                padUCells[pid] |= ui_jpad_ct_selec;
                msk = i_dB;
            ) :
            (xopKmd === 2) ? ( // unlock all
                gmem[Un+RCB_ClipLoop] = 0;
                padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                msk = i_dB;
            ) :
            ((xopKmd === 3) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                // toggle lock p2/p3
                (gmem[Un+RCB_ClipLoop] & 1) ? (
                    gmem[Un+RCB_ClipLoop] = 0;
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                ) : (
                    gmem[Un+RCB_ClipLoop] |= 1;
                    padUCells[pid] |= ui_jpad_ct_selec;
                );
                msk = i_dB;
            ) :
            ((xopKmd === 4) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                // unlock p2/p3
                gmem[Un+RCB_ClipLoop] = 0;
                padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                msk = i_dB;
            ) :
            (xopKmd === 5) ? (
                // solo p2/p3
                padUCells[pid] |= ui_jpad_ct_selec;
                gmem[Un+RCB_ClipLoop] =
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3)) ? 1 : 3;
                msk = i_dB;
            ) :
            ((xopKmd === 6) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                // toggle mute p2/p3
                AAAAAAAA_pid = pid;
                gmem[Un+RCB_ClipLoop] = (gmem[Un+RCB_ClipLoop] & 2) ? 1 : 3;
                padUCells[pid] |= ui_jpad_ct_selec;
                msk = i_dB;
                // padUCells[0] |= ui_jpad_ct_selec;
            ) :
            ((xopKmd === 7) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                gmem[Un + RCB_Kmd] = KmdQStop; // send stop command
            ) :
            (xopKmd === 8) ? (
                ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                    // Set play volume to Actpar4
                    gmem[Un+RCB_StdVol] = Actpar4;
                    msk = i_dB;
                );
            ) :
            (xopKmd === 9) ? (
                ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                    // Set play volume bias to Actpar4
                    // gmem[gVolBias] = gmem[Un+RCB_VolBias] = Actpar4;
                    parSet(p_VolGlobBias, Actpar4);
                    gmem[Un+RCB_VolBias] =  gmem[gVolBias];
                    msk = i_dB;
                );
            ) :
            ((xopKmd === 10) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                // lock p2/p3
                gmem[Un+RCB_ClipLoop] |= 1;
                padUCells[pid] |= ui_jpad_ct_selec;
                msk = i_dB;
            );
            gmem[Un+RCB_State_Changed]  |= 1 | msk;
        );
        uid += 1;
    );
    // mSL_errX=5;
    //++++5++++//

):(

    //++++4++++//
    // Switch to next group - or more
    m = 0|(1 + (paramValues[p_Grp_VariVal] / 8));
    GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', GvPlayGrp + m, 0);
    //++++4++++//

););):((xop&0x2)?((xop&0x1)?(

    //++++3++++//
    // OP 3 : Set a parameter
    //AAAAAAAA_03_parSet = ActPar1;
    //AAAAAAAA_03_parVal = ActPar2;
    parSet(ActPar1, ActPar2);
    //++++3++++//

):(

    //++++2++++//
    // Random Change global volume
    m = (paramValues[p_Vol_MaxVal] + paramValues[p_Vol_MinVal]) / 2;
    p = (10 + paramValues[p_Vol_VariVal])/90;
    u = (paramValues[p_Vol_MaxVal] - paramValues[p_Vol_MinVal]) / 2;
AAAAAAAA_p = p;
    (rand(1) > 0.5) ? (
        x = rand(1); m += x * x * p * 1.5 * u;
    ) : (
        m -= rand(1) * p * 1.1 * u;
    );
AAAAAAAA_m = m;
    m = max(paramValues[p_Vol_MinVal], min(paramValues[p_Vol_MaxVal], m));
    // gmem[commonGlobalVolume] = 10 ^ (m/20); // convert as a number
    // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
    parSet(p_Vol_Global, m);
    // parSet(p_VolGlobBias, 9);
    //++++2++++//

);):((xop&0x1)?(

    //++++1++++//
    // Play one of the exec pad
    // replaces "doPlayCmd"
    KSource = ActPar1; // unmodified source
    cmdCurrPar = ActPar2; // 2nd parameter
    (ActPar3 != Undef) ? ( GvPlayCl0 = ActPar3; );
    (ActPar4 != Undef) ? ( GvPlayPart = ActPar4; );
    KpFlags = ActPar1 & MskdoKeepHgFlgs;
    Kmnd = ActPar1 & MskdoKeepKmnd;
    // First, rebuild partial entry 0
    BKTab[idx_Grp] = GvPlayGrp;
    BKTab[idx_Bnk] = GvPlayBnk;
    BKTab[idx_Clps] = GvPlayCl1;
    BKTab[idx_Clps+1] = GvPlayCl2;
    BKTab[idx_PlM] = GvPlayPM;
    BKTab[idx_SpM] = GvPlaySM;
    BKTab[6] = 0;
    BKTab[7] = 0;
    BKTab[8] = 0;
    BKTab[9] = 0;
    BKTab[10] = 0;
    BKTab[11] = 0;
    Kptyp = Krtc = 0;

    0 ? (
        b = BKTab;
        sprintf(#s2, "**P4  %d %d %d %d --- %d %d %d %d",
            b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
        mSL_log(SysLogBox, #s2);
    );

    // Is there a "pad to play" ?
    ((Kmnd >= cmdPadBase) && (Kmnd < (cmdPadBase + padStTotSiz))) ? (
        Kmnd -= cmdPadBase;
        // KpFlags are the high bits from the command
        Krtc = 0;
        KbtpPlayed = Kmnd;
        Kpart = padStPVals[Kmnd]; // base Partial
        Kselect = pACinP; // play any clip from partial as default
        (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
        // (Kvu5 != padStDispNone) ? (
        Kvuu = (Kvu0 = padStPVals[Kmnd] % BKEcnt) * BKEsize; // Kvu0 : n° partiel
        Kvu4 = BKTab[Kvuu + idx_Clps]; // first clip of range
        // which mode are we using ?
        Kvu5 = padStFlags[Kmnd] & padStFlDspM;
        (Kvu5 === padStDispPar) ? (
            // we want to play a specific partial
            Kselect = pACinP; // the clip we want to play
        ) :
        (Kvu5 === padStDispGrp) ? (
            Kselect = pACinG; // any clip from the group of the partiel
        ) :
        (Kvu5 === padStDispGBk) ? (
            Kselect = pACinB; // any clip from bank and group of the partiel
        ) :
        (Kvu5 === padStDispRng) ? (
            Kselect = padStClipsL[Kmnd]; // the 1st clip of the range we want to play
            KpFlags |= abs(padStClipsH[Kmnd] - padStClipsL[Kmnd]); // the range
        ) :
        (Kvu5 === padStDispClip) ? (
            // we want to play a specific clip
            Kselect = padStClipsL[Kmnd]; // the clip we want to play
            Kptyp = GvPlayTypClip;
        ) :
        (Kvu5 === padStDispAct) ? (
            Kselect = Kpart; // we have an action to perform
            Kpart = -1; // nothing to play
            //
            m = padStClipsL[Kmnd]; p = q = r = 0;
            // temporary, accept various commands...
            ((m >= 1) && (m <= 7)) ? (
                // change global volume
                (m === 1) ? (q = -120; ) :
                (m === 2) ? (q = paramValues[p_Vol_MinVal]; ) :
                (m === 3) ? (q = paramValues[p_Vol_MaxVal]; ) :
                (m === 4) ? (q = -3; ) :
                (m === 5) ? (q = 0; ) :
                (m === 6) ? (q = 3; ) :
                (m === 7) ? (q = 6; ) ;
                // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
                // gmem[commonGlobalVolume] = 10 ^ (q/20); // convert as a number
                parSet(p_Vol_Global, q);
                // parSet(p_VolGlobBias, 9);
            );
            (p != 0) ? (
                SchedAddTask(p, q, r, s, t);
            );
        ) :
        (Kvu5 === padStDispSpec) ? (
            // we want to have a specific MIDI action to send
            Kselect = padStClipsL[Kmnd]; // the clip we want to play
            Kptyp = GvPlayTypClip;
        ) : (
            Kpart = -1; // nothing to play
        );
        (Kpart >= 0) ? (
            padStErrors[Kmnd] = Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp); // keep err. return
        );
        // );
        // return code from playing ?
        (Krtc != 0) ? (
            KbtpLast = Kmnd;
            padStFlags[Kmnd] = padStFlags[Kmnd] | padStFlErrbit;
            StdnumLastM = lastTime; StdnumUnchkd = 16;
        ) : (
            padStFlags[Kmnd] = padStFlags[Kmnd] & padStFlMsk7;
        );
        // StdnumLastM = lastTime; StdnumUnchkd = 16;
        ui_GFXdoNow |= 2;
        ui_GFXReason = 12;
    ) :

    // A play command in a specific mode ?
    ((Kmnd >= cmdClMdBase) && (Kmnd < (cmdClMdBase + 16))) ? (
        Kmnd -= cmdClMdBase;
        // play from a specific setting
        Kselect = pACinP;
        Kpart = 0;
        // select command according to current mode
        (Kmnd === GvPlayTypGrPlay) ? (
            // play a player from the "group"
            Kselect = pACinG;
            // Kpart = 0;
        ) :
        (Kmnd === GvPlayTypGrLoop) ? (
            // play a looper from the "group"
            Kselect = pACinG;
            // Kpart = 0;
        ) :
        (Kmnd === GvPlayTypGroup) ? (
            // play "group"
            Kselect = pACinG;
            // Kpart = 0;
        ) :
        (Kmnd === GvPlayTypBank) ? (
            // play "bank"
            Kselect = pACinB;
            // Kpart = 0;
        ) :
        (Kmnd === GvPlayTypPartial) ? (
            // play this "partial"
            Kselect = pACinP;
            Kpart = GvPlayPart;
        ) :
        (Kmnd === GvPlayTypClip) ? (
            // play "clip"
            Kselect = GvPlayCl0;
            Kpart = GvPlayPart;
            Kptyp = GvPlayTypClip;
        ) :
        (Kmnd === GvPlayTypRange) ? (
            // play "Range"
            Kselect = pACinSwP;
            Kpart = GvPlayPart;
        ) :
        (Kmnd === GvPlayTypAnyClip) ? (
            // play "Any clip"
            Kselect = pACinWwP;
            Kpart = GvPlayPart;
        ) :
        (Kmnd === GvPlayTypAnyBank) ? (
            // play "Any clip from a partial"
            Kselect = pACinRP;
        ) :
        (Kmnd === GvPlayClipClicked) ? (
            // play "clip"
            Kselect = GvPlayCl3;
            Kpart = GvPlayPart;
        ) : (
            // This is an error
            GvErr = 0500;
        ) ;

        // AAAA_doPlaycnt += 1;
        (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
        Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp);
        // (Krtc != 0) ? AAAA_Krtccnt += 1;
    );

    // Otherwise, ignore the command
    Kmnd = -1;

    //++++1++++//

):(

    //++++0++++//
    // This is a no-op
    0;
    //++++0++++//

););););););););




























//---------------------------------------------
//    A micro Script Language for JSFX plug-ins
//
//    Part2: the evaluator
//        mSL_Xlib.jsfx-inc
//    J.J. Girardot - 7/2020
//---------------------------------------------

mfcmax = 320; // max # of "costful" operations in a cycle.

//    Evaluation of an mSL expression

    function mSL_evaluate()
    local (rpeat, Xop, k, m, par, argc, p, bl, ty, fn, r, s, q, mfc)
    (
        // (mSL_current_evaluator === 0) ? (mSL_set_evaluator(mSL_new_evaluator););
        rpeat = mSL_rpeat;
        mSL_ICount += rpeat;
        mfc = 0; // malloc/free/xxx count "coastful" operations

        //// Inner equivalent loop
        while ((rpeat > 0) && (mSL_errX === 0)) (
            rpeat -= 1;
            Xop = mSL_NxtOp;
            mSL_PCode = mSL_CodePtr;
            mSL_CodePtr += 1;
            mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
            (

            // NOTE : All the bit tests after this comment are automatically generated by a "c" program.

            (Xop&0x80)?((Xop&0x40)?((Xop&0x20)?((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===255===//
                // mSL_errX=255;
                // Multi-adic "mSL_255" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_255(m, mSL_TOS);
                //===255===//

            ):(

                //===254===//
                // mSL_errX=254;
                // Multi-adic "mSL_254" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_254(m, mSL_TOS);
                //===254===//

            );):((Xop&0x1)?(

                //===253===//
                // mSL_errX=253;
                // Multi-adic "mSL_253" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_253(m, mSL_TOS);
                //===253===//

            ):(

                //===252===//
                // mSL_errX=252;
                // Multi-adic "mSL_252" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_252(m, mSL_TOS);
                //===252===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===251===//
                // mSL_errX=251;
                // Multi-adic "mSL_251" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_251(m, mSL_TOS);
                //===251===//

            ):(

                //===250===//
                // mSL_errX=250;
                // Multi-adic "mSL_250" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_250(m, mSL_TOS);
                //===250===//

            );):((Xop&0x1)?(

                //===249===//
                // mSL_errX=249;
                // Multi-adic "mSL_249" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_249(m, mSL_TOS);
                //===249===//

            ):(

                //===248===//
                // mSL_errX=248;
                // Multi-adic "mSL_248" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_248(m, mSL_TOS);
                //===248===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===247===//
                // mSL_errX=247;
                // Multi-adic "mSL_247" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_247(m, mSL_TOS);
                //===247===//

            ):(

                //===246===//
                // mSL_errX=246;
                // Multi-adic "mSL_246" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_246(m, mSL_TOS);
                //===246===//

            );):((Xop&0x1)?(

                //===245===//
                // mSL_errX=245;
                // Multi-adic "mSL_245" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_245(m, mSL_TOS);
                //===245===//

            ):(

                //===244===//
                // mSL_errX=244;
                // Multi-adic "mSL_244" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_244(m, mSL_TOS);
                //===244===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===243===//
                // mSL_errX=243;
                // Multi-adic "mSL_243" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_243(m, mSL_TOS);
                //===243===//

            ):(

                //===242===//
                // mSL_errX=242;
                // Multi-adic "mSL_242" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_242(m, mSL_TOS);
                //===242===//

            );):((Xop&0x1)?(

                //===241===//
                // mSL_errX=241;
                // Multi-adic "mSL_241" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_241(m, mSL_TOS);
                //===241===//

            ):(

                //===240===//
                // mSL_errX=240;
                // Multi-adic "mSL_240" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_240(m, mSL_TOS);
                //===240===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===239===//
                // mSL_errX=239;
                // Multi-adic "mSL_239" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_239(m, mSL_TOS);
                //===239===//

            ):(

                //===238===//
                // mSL_errX=238;
                // Multi-adic "mSL_238" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_238(m, mSL_TOS);
                //===238===//

            );):((Xop&0x1)?(

                //===237===//
                // mSL_errX=237;
                // Multi-adic "mSL_237" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_237(m, mSL_TOS);
                //===237===//

            ):(

                //===236===//
                // mSL_errX=236;
                // Multi-adic "mSL_236" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_236(m, mSL_TOS);
                //===236===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===235===//
                // mSL_errX=235;
                // Multi-adic "mSL_235" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_235(m, mSL_TOS);
                //===235===//

            ):(

                //===234===//
                // mSL_errX=234;
                // Multi-adic "mSL_234" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_234(m, mSL_TOS);
                //===234===//

            );):((Xop&0x1)?(

                //===233===//
                // mSL_errX=233;
                // Multi-adic "mSL_233" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_233(m, mSL_TOS);
                //===233===//

            ):(

                //===232===//
                // mSL_errX=232;
                // Multi-adic "mSL_232" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_232(m, mSL_TOS);
                //===232===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===231===//
                // mSL_errX=231;
                // Multi-adic "mSL_231" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_231(m, mSL_TOS);
                //===231===//

            ):(

                //===230===//
                // mSL_errX=230;
                // Multi-adic "mSL_230" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_230(m, mSL_TOS);
                //===230===//

            );):((Xop&0x1)?(

                //===229===//
                // mSL_errX=229;
                // Multi-adic "mSL_229" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_229(m, mSL_TOS);
                //===229===//

            ):(

                //===228===//
                // mSL_errX=228;
                // Multi-adic "mSL_228" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_228(m, mSL_TOS);
                //===228===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===227===//
                // mSL_errX=227;
                // Multi-adic "mSL_227" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_227(m, mSL_TOS);
                //===227===//

            ):(

                //===226===//
                // mSL_errX=226;
                // Multi-adic "mSL_226" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_226(m, mSL_TOS);
                //===226===//

            );):((Xop&0x1)?(

                //===225===//
                // mSL_errX=225;
                // Multi-adic "mSL_225" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_225(m, mSL_TOS);
                //===225===//

            ):(

                //===224===//
                // mSL_errX=224;
                // Multi-adic "mSL_224" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_224(m, mSL_TOS);
                //===224===//

            );););););):((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===223===//
                // mSL_errX=223;
                // Multi-adic "mSL_223" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_223(m, mSL_TOS);
                //===223===//

            ):(

                //===222===//
                // mSL_errX=222;
                // Multi-adic "mSL_222" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_222(m, mSL_TOS);
                //===222===//

            );):((Xop&0x1)?(

                //===221===//
                // mSL_errX=221;
                // Multi-adic "mSL_221" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_221(m, mSL_TOS);
                //===221===//

            ):(

                //===220===//
                // mSL_errX=220;
                // Multi-adic "mSL_220" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_220(m, mSL_TOS);
                //===220===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===219===//
                // mSL_errX=219;
                // Multi-adic "mSL_219" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_219(m, mSL_TOS);
                //===219===//

            ):(

                //===218===//
                // mSL_errX=218;
                // Multi-adic "mSL_218" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_218(m, mSL_TOS);
                //===218===//

            );):((Xop&0x1)?(

                //===217===//
                // mSL_errX=217;
                // Multi-adic "mSL_217" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_217(m, mSL_TOS);
                //===217===//

            ):(

                //===216===//
                // mSL_errX=216;
                // Multi-adic "mSL_216" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_216(m, mSL_TOS);
                //===216===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===215===//
                // mSL_errX=215;
                // Multi-adic "mSL_215" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_215(m, mSL_TOS);
                //===215===//

            ):(

                //===214===//
                // mSL_errX=214;
                // Multi-adic "mSL_214" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_214(m, mSL_TOS);
                //===214===//

            );):((Xop&0x1)?(

                //===213===//
                // mSL_errX=213;
                // Multi-adic "mSL_213" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_213(m, mSL_TOS);
                //===213===//

            ):(

                //===212===//
                // mSL_errX=212;
                // Multi-adic "mSL_212" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_212(m, mSL_TOS);
                //===212===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===211===//
                // mSL_errX=211;
                // Multi-adic "mSL_211" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_211(m, mSL_TOS);
                //===211===//

            ):(

                //===210===//
                // mSL_errX=210;
                // Multi-adic "mSL_210" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_210(m, mSL_TOS);
                //===210===//

            );):((Xop&0x1)?(

                //===209===//
                // mSL_errX=209;
                // Multi-adic "mSL_209" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_209(m, mSL_TOS);
                //===209===//

            ):(

                //===208===//
                // mSL_errX=208;
                // Multi-adic "mSL_208" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_208(m, mSL_TOS);
                //===208===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===207===//
                // mSL_errX=207;
                // Multi-adic "mSL_207" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_207(m, mSL_TOS);
                //===207===//

            ):(

                //===206===//
                // mSL_errX=206;
                // Multi-adic "mSL_206" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_206(m, mSL_TOS);
                //===206===//

            );):((Xop&0x1)?(

                //===205===//
                // mSL_errX=205;
                // Multi-adic "mSL_205" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_205(m, mSL_TOS);
                //===205===//

            ):(

                //===204===//
                // mSL_errX=204;
                // Multi-adic "mSL_204" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_204(m, mSL_TOS);
                //===204===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===203===//
                // mSL_errX=203;
                // Multi-adic "mSL_203" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_203(m, mSL_TOS);
                //===203===//

            ):(

                //===202===//
                // mSL_errX=202;
                // Multi-adic "mSL_202" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_202(m, mSL_TOS);
                //===202===//

            );):((Xop&0x1)?(

                //===201===//
                // mSL_errX=201;
                // Multi-adic "mSL_201" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_201(m, mSL_TOS);
                //===201===//

            ):(

                //===200===//
                // mSL_errX=200;
                // Multi-adic "mSL_200" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_200(m, mSL_TOS);
                //===200===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===199===//
                // mSL_errX=199;
                // Multi-adic "mSL_199" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_199(m, mSL_TOS);
                //===199===//

            ):(

                //===198===//
                // mSL_errX=198;
                // Multi-adic "mSL_198" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_198(m, mSL_TOS);
                //===198===//

            );):((Xop&0x1)?(

                //===197===//
                // mSL_errX=197;
                // Multi-adic "mSL_197" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_197(m, mSL_TOS);
                //===197===//

            ):(

                //===196===//
                // mSL_errX=196;
                // Multi-adic "mSL_196" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_196(m, mSL_TOS);
                //===196===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===195===//
                // mSL_errX=195;
                // Multi-adic "mSL_195" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_195(m, mSL_TOS);
                //===195===//

            ):(

                //===194===//
                // mSL_errX=194;
                // Multi-adic "mSL_194" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_194(m, mSL_TOS);
                //===194===//

            );):((Xop&0x1)?(

                //===193===//
                // mSL_errX=193;
                // Multi-adic "mSL_193" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_193(m, mSL_TOS);
                //===193===//

            ):(

                //===192===//
                // mSL_errX=192;
                // Multi-adic "mSL_192" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_192(m, mSL_TOS);
                //===192===//

            ););););););):((Xop&0x20)?((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===191===//
                // mSL_errX=191;
                // Multi-adic "mSL_191" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_191(m, mSL_TOS);
                //===191===//

            ):(

                //===190===//
                // mSL_errX=190;
                // Multi-adic "mSL_190" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_190(m, mSL_TOS);
                //===190===//

            );):((Xop&0x1)?(

                //===189===//
                // mSL_errX=189;
                // Multi-adic "mSL_189" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_189(m, mSL_TOS);
                //===189===//

            ):(

                //===188===//
                // mSL_errX=188;
                // Multi-adic "mSL_188" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_188(m, mSL_TOS);
                //===188===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===187===//
                // mSL_errX=187;
                // Multi-adic "mSL_187" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_187(m, mSL_TOS);
                //===187===//

            ):(

                //===186===//
                // mSL_errX=186;
                // Multi-adic "mSL_186" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_186(m, mSL_TOS);
                //===186===//

            );):((Xop&0x1)?(

                //===185===//
                // mSL_errX=185;
                // Multi-adic "mSL_185" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_185(m, mSL_TOS);
                //===185===//

            ):(

                //===184===//
                // mSL_errX=184;
                // Multi-adic "mSL_184" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_184(m, mSL_TOS);
                //===184===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===183===//
                // mSL_errX=183;
                // Multi-adic "mSL_183" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_183(m, mSL_TOS);
                //===183===//

            ):(

                //===182===//
                // mSL_errX=182;
                // Multi-adic "mSL_182" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_182(m, mSL_TOS);
                //===182===//

            );):((Xop&0x1)?(

                //===181===//
                // mSL_errX=181;
                // Multi-adic "mSL_181" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_181(m, mSL_TOS);
                //===181===//

            ):(

                //===180===//
                // mSL_errX=180;
                // Multi-adic "mSL_180" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_180(m, mSL_TOS);
                //===180===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===179===//
                // mSL_errX=179;
                // Multi-adic "mSL_179" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_179(m, mSL_TOS);
                //===179===//

            ):(

                //===178===//
                // mSL_errX=178;
                // Multi-adic "mSL_178" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_178(m, mSL_TOS);
                //===178===//

            );):((Xop&0x1)?(

                //===177===//
                // mSL_errX=177;
                // Multi-adic "mSL_177" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_177(m, mSL_TOS);
                //===177===//

            ):(

                //===176===//
                // mSL_errX=176;
                // Multi-adic "mSL_176" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_176(m, mSL_TOS);
                //===176===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===175===//
                // mSL_errX=175;
                // Multi-adic "mSL_175" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_175(m, mSL_TOS);
                //===175===//

            ):(

                //===174===//
                // mSL_errX=174;
                // Multi-adic "mSL_174" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_174(m, mSL_TOS);
                //===174===//

            );):((Xop&0x1)?(

                //===173===//
                // mSL_errX=173;
                // Multi-adic "mSL_173" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_173(m, mSL_TOS);
                //===173===//

            ):(

                //===172===//
                // mSL_errX=172;
                // Multi-adic "mSL_172" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_172(m, mSL_TOS);
                //===172===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===171===//
                // mSL_errX=171;
                // Multi-adic "mSL_171" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_171(m, mSL_TOS);
                //===171===//

            ):(

                //===170===//
                // mSL_errX=170;
                // Multi-adic "mSL_170" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_170(m, mSL_TOS);
                //===170===//

            );):((Xop&0x1)?(

                //===169===//
                // mSL_errX=169;
                // Multi-adic "mSL_169" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_169(m, mSL_TOS);
                //===169===//

            ):(

                //===168===//
                // mSL_errX=168;
                // Multi-adic "mSL_168" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_168(m, mSL_TOS);
                //===168===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===167===//
                // mSL_errX=167;
                // Multi-adic "mSL_167" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_167(m, mSL_TOS);
                //===167===//

            ):(

                //===166===//
                // mSL_errX=166;
                // Multi-adic "mSL_166" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_166(m, mSL_TOS);
                //===166===//

            );):((Xop&0x1)?(

                //===165===//
                // mSL_errX=165;
                // Multi-adic "mSL_165" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_165(m, mSL_TOS);
                //===165===//

            ):(

                //===164===//
                // mSL_errX=164;
                // Multi-adic "mSL_164" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_164(m, mSL_TOS);
                //===164===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===163===//
                // mSL_errX=163;
                // Multi-adic "mSL_163" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_163(m, mSL_TOS);
                //===163===//

            ):(

                //===162===//
                // mSL_errX=162;
                // Multi-adic "mSL_162" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_162(m, mSL_TOS);
                //===162===//

            );):((Xop&0x1)?(

                //===161===//
                // mSL_errX=161;
                // Multi-adic "mSL_161" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_161(m, mSL_TOS);
                //===161===//

            ):(

                //===160===//
                // mSL_errX=160;
                // Multi-adic "mSL_160" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_160(m, mSL_TOS);
                //===160===//

            );););););):((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===159===//
                // mSL_errX=159;
                // Multi-adic "mSL_159" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_159(m, mSL_TOS);
                //===159===//

            ):(

                //===158===//
                // mSL_errX=158;
                // Multi-adic "mSL_158" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_158(m, mSL_TOS);
                //===158===//

            );):((Xop&0x1)?(

                //===157===//
                // mSL_errX=157;
                // Multi-adic "mSL_157" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_157(m, mSL_TOS);
                //===157===//

            ):(

                //===156===//
                // mSL_errX=156;
                // Multi-adic "mSL_156" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_156(m, mSL_TOS);
                //===156===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===155===//
                // mSL_errX=155;
                // Multi-adic "mSL_155" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_155(m, mSL_TOS);
                //===155===//

            ):(

                //===154===//
                // mSL_errX=154;
                // Multi-adic "mSL_154" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_154(m, mSL_TOS);
                //===154===//

            );):((Xop&0x1)?(

                //===153===//
                // mSL_errX=153;
                // Multi-adic "mSL_153" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_153(m, mSL_TOS);
                //===153===//

            ):(

                //===152===//
                // mSL_errX=152;
                // Multi-adic "mSL_152" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_152(m, mSL_TOS);
                //===152===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===151===//
                // mSL_errX=151;
                // Multi-adic "mSL_151" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_151(m, mSL_TOS);
                //===151===//

            ):(

                //===150===//
                // mSL_errX=150;
                // Multi-adic "mSL_150" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_150(m, mSL_TOS);
                //===150===//

            );):((Xop&0x1)?(

                //===149===//
                // mSL_errX=149;
                // Multi-adic "mSL_149" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_149(m, mSL_TOS);
                //===149===//

            ):(

                //===148===//
                // mSL_errX=148;
                // Multi-adic "mSL_148" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_148(m, mSL_TOS);
                //===148===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===147===//
                // mSL_errX=148;
                // Multi-adic "mSL_147" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_147(m, mSL_TOS);
                //===147===//

            ):(

                //===146===//
                // mSL_errX=146;
                // Multi-adic "mSL_146" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_146(m, mSL_TOS);
                //===146===//

            );):((Xop&0x1)?(

                //===145===//
                // mSL_errX=145;
                // Multi-adic "mSL_145" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_145(m, mSL_TOS);
                //===145===//

            ):(

                //===144===//
                // mSL_errX=144;
                // Multi-adic "mSL_144" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_144(m, mSL_TOS);
                //===144===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===143===//
                // mSL_errX=143;
                // Multi-adic "mSL_143" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_143(m, mSL_TOS);
                //===143===//

            ):(

                //===142===//
                // mSL_errX=142;
                // Multi-adic "mSL_142" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_142(m, mSL_TOS);
                //===142===//

            );):((Xop&0x1)?(

                //===141===//
                // mSL_errX=141;
                // Multi-adic "mSL_141" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_141(m, mSL_TOS);
                //===141===//

            ):(

                //===140===//
                // mSL_errX=140;
                // Multi-adic "mSL_140" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_140(m, mSL_TOS);
                //===140===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===139===//
                // mSL_errX=139;
                // Multi-adic "mSL_139" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_139(m, mSL_TOS);
                //===139===//

            ):(

                //===138===//
                // mSL_errX=138;
                // Multi-adic "mSL_138" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_138(m, mSL_TOS);
                //===138===//

            );):((Xop&0x1)?(

                //===137===//
                // Multi-adic "mSL_137" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_137(m, mSL_TOS);
                //===137===//

            ):(

                //===136===//
                // Multi-adic "mSL_136" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_136(m, mSL_TOS);
                //===136===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===135===//
                // Multi-adic "mSL_135" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_135(m, mSL_TOS);
                //===135===//

            ):(

                //===134===//
                // Multi-adic "mSL_134" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_134(m, mSL_TOS);
                //===134===//

            );):((Xop&0x1)?(

                //===133===//
                // Multi-adic "mSL_133" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_133(m, mSL_TOS);
                //===133===//

            ):(

                //===132===//
                // Multi-adic "mSL_132" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_132(m, mSL_TOS);
                //===132===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===131===//
                // Multi-adic "mSL_131" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_131(m, mSL_TOS);
                //===131===//

            ):(

                //===130===//
                // Multi-adic "mSL_130" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_130(m, mSL_TOS);
                //===130===//

            );):((Xop&0x1)?(

                //===129===//
                // Multi-adic "mSL_event_ops"
                m = mSL_TOS[0];
                mSL_TOS -= m;
                ((m === 1) && ((p = mSL_TOS[1]) > TabAddrMin) && (p < TabAddrMax) && (p[-2] === 'data')) ? (
                    // parameter is a data bloc, pass it to the function
                    mSL_TOS[0] = mSL_event_ops(p[-1], p);
                ) : (
                    mSL_TOS[0] = mSL_event_ops(m, mSL_TOS);
                );
                (SchedmSLEvWait) ? (
                    // function has determined that we have to wait for an event
                    mSL_ICount -= rpeat; // deduce rest of count
                    rpeat = 0;
                    mSL_CodeStop = SchedmSLEvWait; // set "exit" reason
                    SchedmSLEvWait = 0;
                    (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                        sprintf(#s, "Waiting : thrd: %f ", mSL_active_Thread);
                        mSL_log(SysLogBox, #s);
                    );
                );
                //===129===//

            ):(

                //===128===//
                // Multi-adic "mSL_play_ops"
                m = mSL_TOS[0];
                mSL_TOS -= m;
                ((m === 1) && ((p = mSL_TOS[1]) > TabAddrMin) && (p < TabAddrMax) && (p[-2] === 'data')) ? (
                    // parameter is a data, pass it to the function
                    mSL_TOS[0] = mSL_play_ops(p[-1], p);
                ) : (
                    mSL_TOS[0] = mSL_play_ops(m, mSL_TOS);
                );
                //===128===//

            );););););););):((Xop&0x40)?((Xop&0x20)?((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?( //============ 128

                //===127===//
                // Push num - parameter becomes the new TOS
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_NxtOp;
                mSL_CodePtr += 1;
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===127===//

            ):(

                //===126===//
                // Jump on negative
                (mSL_TOS[0] < 0) ? (
                    mSL_CodePtr = mSL_NxtOp; // jump on true
                ) : (
                    mSL_CodePtr += 1;
                );
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===126===//

            );):((Xop&0x1)?(

                //===125===//
                //  mSL_K_jmpOnFalsePT
                (mSL_TOS[0]) ? (
                    mSL_TOS -= 1; // Pop if true
                    mSL_CodePtr += 1;
                ) : (
                    mSL_CodePtr = mSL_NxtOp; // jump on false
                );
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===125===//

            ):(

                //===124===//
                // Jump on false, Pop
                (!mSL_TOS[0]) ? (
                    mSL_CodePtr = mSL_NxtOp; // jump
                ) : (
                    mSL_CodePtr += 1;
                );
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                mSL_TOS -= 1; // Pop
                //===124===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===123===//
                // Jump on True, Pop False
                (mSL_TOS[0]) ? (
                    mSL_CodePtr = mSL_NxtOp; // jump on true
                ) : (
                    mSL_TOS -= 1; // Pop
                    mSL_CodePtr += 1;
                );
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===123===//

            ):(

                //===122===//
                // Jump on True, Pop True
                (mSL_TOS[0]) ? (
                    mSL_CodePtr = mSL_NxtOp; // jump on true
                    mSL_TOS -= 1; // Pop
                ) : (
                    mSL_CodePtr += 1;
                );
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===122===//

            );):((Xop&0x1)?(

                //===121===//
                // Jump always, pop
                mSL_CodePtr = mSL_NxtOp; // jump
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                mSL_TOS -= 1; // Pop
                //===121===//

            ):(

                //===120===//
                // Jump always
                mSL_CodePtr = mSL_NxtOp; // jump
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===120===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===119===//
                mSL_errX=119;
                //===119===//

            ):(

                //===118===//
                // mSL_errX=118;
                // SetTab : modify/update an internal table of the Game Master
                m = mSL_TOS[0]; // parameter count
                mSL_TOS -= m;
                bl = mSL_TOS[0];
                // is this a data bloc ?
                ((m === 1) && (bl > 2) && ((s = bl[-1]) >= 0) && ((ty = bl[-2]) >= mSL_MKey_min) && (ty <= mSL_MKey_max)
                    && (s === bl[s]) && (bl[s+1] === (ty ~ mSL_CC_Chksum))) ? (
                        mSL_TOS[0] = Set_Table(bl);
                ) : (
                    mSL_errX=118;
                );
                //===118===//

            );):((Xop&0x1)?(

                //===117===//
                // mSL_errX=117;
                // action : execute an internal action
                m = mSL_TOS[0]; // parameter count
                mSL_TOS -= m;
                (m >= 1) ? (
                    // unique code ?
                    bl = mSL_TOS[0];
                    sprintf(#sfc, "117. Action %d", bl);
                    mSL_log(SysLogBox, #sfc);
                    // is this a data bloc ?
                    ((m === 1) && (bl > 2) && ((s = bl[-1]) >= 0) && ((ty = bl[-2]) >= mSL_MKey_min) && (ty <= mSL_MKey_max)
                        && (s === bl[s]) && (bl[s+1] === (ty ~ mSL_CC_Chksum))) ? (
                            mSL_TOS[0] = Simple_Action(bl-1);
                    ) :
                    (bl != 0) ? (
                        mSL_TOS[0] = Simple_Action(bl, mSL_TOS+1);
                    );
                );
                //===117===//

            ):(

                //===116===//
                // Run Garbage collector gc()
                mSL_errX=116;
                //===116===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===115===//
                // mSL_errX=115;
                // malloc_retry
                m = mSL_TOS[0];
                r = 0;
                (m === 2) ? (
                    mSL_TOS -= 2;
                    r = mSL_malloc(mSL_TOS[0], mSL_TOS[1]);
                ) :
                (m === 1) ? (
                    mSL_TOS -= 1;
                    r = mSL_malloc(mSL_TOS[0], 'data');
                );
                mSL_TOS[0] = r;
                // mSL_log(SysLogBox, "    —- malloc retryed");
                //===115===//

            ):(

                //===114===//
                // sprintf(str, fmt, x, x, x, x, x...
                m = mSL_TOS[0]; // arg count
                (m >= 1) ? (
                    k = mSL_TOS[- m]; // the string
                    (k === 0) ? (k = mSL_Str_Tmp(););
                );
                (m === 2) ? (
                    mSL_TOS -= 2;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1]);
                ) :
                (m === 3) ? (
                    mSL_TOS -= 3;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2]);
                ) :
                (m === 4) ? (
                    mSL_TOS -= 4;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3]);
                ) :
                (m === 5) ? (
                    mSL_TOS -= 5;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4]);
                ) :
                (m === 6) ? (
                    mSL_TOS -= 6;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5]);
                ) :
                (m === 7) ? (
                    mSL_TOS -= 7;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5], mSL_TOS[6]);
                ) :
                (m === 8) ? (
                    mSL_TOS -= 8;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5], mSL_TOS[6], mSL_TOS[7]);
                ) :
                (m === 9) ? (
                    mSL_TOS -= 9;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5], mSL_TOS[6], mSL_TOS[7], mSL_TOS[8]);
                ) :
                (m === 10) ? (
                    mSL_TOS -= 10;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5], mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9]);
                ) :
                (m === 11) ? (
                    mSL_TOS -= 11;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10]);
                ) :
                (m === 12) ? (
                    mSL_TOS -= 12;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11]);
                ) :
                (m === 13) ? (
                    mSL_TOS -= 13;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12]);
                ) :
                (m === 14) ? (
                    mSL_TOS -= 14;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12], mSL_TOS[13]);
                ) :
                (m === 15) ? (
                    mSL_TOS -= 15;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12], mSL_TOS[13], mSL_TOS[14]);
                ) :
                (m === 16) ? (
                    mSL_TOS -= 16;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12], mSL_TOS[13], mSL_TOS[14], mSL_TOS[15]);
                ) :
                (m === 17) ? (
                    mSL_TOS -= 17;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12], mSL_TOS[13], mSL_TOS[14], mSL_TOS[15], mSL_TOS[16]);
                ) :
                (m === 18) ? (
                    mSL_TOS -= 18;
                    mSL_TOS[0] = sprintf(k, mSL_TOS[1], mSL_TOS[2], mSL_TOS[3], mSL_TOS[4], mSL_TOS[5],
                                mSL_TOS[6], mSL_TOS[7], mSL_TOS[8], mSL_TOS[9], mSL_TOS[10], mSL_TOS[11],
                                mSL_TOS[12], mSL_TOS[13], mSL_TOS[14], mSL_TOS[15], mSL_TOS[16], mSL_TOS[17]);
                ) :
                (
                    sprintf(#sfc, "*****Sprintf. PC %d", m);
                    mSL_log(SysLogBox, #sfc);
                    mSL_errX=1104; // incorrect sprintf
                );
                //===114===//

            );):((Xop&0x1)?(

                //===113===//
                mSL_TOS -= 3;
                mSL_TOS[0] = str_setchar(mSL_TOS[0], mSL_TOS[1], mSL_TOS[2], mSL_TOS[3]);
                //===113===//

            ):(

                //===112===//
                mSL_TOS -= 2;
                mSL_TOS[0] = str_getchar(mSL_TOS[0], mSL_TOS[1], mSL_TOS[2]);
                //===112===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===111===//
                mSL_TOS -= 1;
                mSL_TOS[0] = stricmp(mSL_TOS[0], mSL_TOS[1]);
                //===111===//

            ):(

                //===110===//
                mSL_TOS -= 1;
                mSL_TOS[0] = strcmp(mSL_TOS[0], mSL_TOS[1]);
                //===110===//

            );):((Xop&0x1)?(

                //===109===//
                mSL_TOS -= 1;
                mSL_TOS[0] = strcat(mSL_TOS[0], mSL_TOS[1]);
                //===109===//

            ):(

                //===108===//
                mSL_TOS -= 1;
                mSL_TOS[0] = strcpy(mSL_TOS[0], mSL_TOS[1]);
                //===108===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===107===//
                // irand(par)
                par = mSL_TOS[0];
                mSL_TOS[0] = rand(2147483647)%((par<1) ? 1 : (par>2147483647) ? 2147483647 : 0|par);
                //===107===//

            ):(

                //===106===//
                // strlen(string)
                mSL_TOS[0] = strlen(mSL_TOS[0]);
                //===106===//

            );):((Xop&0x1)?(

                //===105===//
                // set(obj, ref, value [,flgs]) => multiadic
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_set(m, mSL_TOS);
                //===105===//

            ):(

                //===104===//
                // get(obj, ref)
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_get(m, mSL_TOS);
                //===104===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===103===//
                // strfree(string)
                mSL_TOS[0] = mSL_Str_Free(mSL_TOS[0]);
                //===103===//

            ):(

                //===102===//
                // stralloc()
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_Str_Alloc();
                //===102===//

            );):((Xop&0x1)?(

                //===101===//
                // mfree(data)
                mSL_TOS[0] = mSL_mfree(mSL_TOS[0]);
                (mfc += 1) > mfcmax ? (
                    // stop thread temporary (as in a yield)
                    mSL_ICount -= rpeat; // deduce rest of count
                    rpeat = 0;
                );
                //===101===//

            ):(

                //===100===//
                // malloc(size, type) or malloc(size)
                m = mSL_TOS[0];
                (m === 2) ? (
                    mSL_TOS -= 2;
                    r = mSL_malloc(mSL_TOS[0], mSL_TOS[1]);
                ) :
                (m === 1) ? (
                    mSL_TOS -= 1;
                    r = mSL_malloc(mSL_TOS[0], 'data');
                ) : (
                    mSL_errX=1100; // incorrect malloc arity
                );
                (mSL_errX === 0) ? (
                    (r != 0) ? (
                        // we were able to find a block
                        mSL_TOS[0] = r;
                        (mfc += 2) > mfcmax ? (
                            // stop thread temporary (as in a yield)
                            mSL_ICount -= rpeat; // deduce rest of count
                            rpeat = 0;
                        );
                    ) : (
                        // we need a GC !
                        mSL_TOS += m; // restore stack.
                        // build a restart op as "malloc_retry"
                        mSL_NxtOp = 115; // malloc retry code
                        mSL_CodePtr = mSL_PCode; // be ready to continue
                        // stop thread temporary (as in a yield)
                        mSL_ICount -= rpeat; // deduce rest of count
                        rpeat = 0;
                        mSL_CodeStop = mSL_RC_WAITGC; // set "yield" flag
                        // run a GC
                        gc_run_phaz = 1;
                        atomic_add(mSL_Lock,1);
                        atomic_add(mSL_loc_tim,2);
                    );
                );
                //===100===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===99===//
                // compile("string")  //??? A réécrire
                // q = 0; // clear any previous code
                while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_baseAVars = mSL_baseAVars[mSL_baseAVars[-1]-1];
                    0 ? (
                        sprintf(#sfc, "Str. Forwarding to %d", mSL_baseAVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                );
                while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_baseOVars = mSL_baseOVars[mSL_baseOVars[-1]-1];
                    0 ? (
                        sprintf(#sfc, "Str. Forwarding to %d", mSL_baseOVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                );
                while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_basePVars = mSL_basePVars[mSL_basePVars[-1]-1];
                    0 ? (
                        sprintf(#sfc, "Str. Forwarding to %d", mSL_basePVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                );
                mSL_TOS[1] = mSL_baseAVars;
                mSL_TOS[2] = mSL_baseOVars;
                mSL_TOS[3] = mSL_basePVars;
                AAAAA_baseCode0 = mSL_baseCode;
                AAAAA_errX0 = mSL_errX ? mSL_errX : mSL_errC;
                mSL_compile(-1, -1, mSL_TOS[0], 3); // compile as function ; do not clear structures
                mSL_errX = mSL_errX ? mSL_errX : mSL_errC;
                ///AAAAA_errX1 = mSL_errX;
                ///AAAAA_cod = mSL_cod ;
                ///AAAAA_cod0 = mSL_cod[0];
                ///AAAAA_baseCode1 = mSL_baseCode;
                AAAAA_x_errX = mSL_errX;



                ((mSL_errX === 0) && (mSL_main_cod != 0) && (mSL_main_cod[-2] === mSL_CC_KeyCKod)) ? (
                    AAAAA_x_codpt = m = mSL_main_cod ;
                    AAAAA_x_codCheck = (m[m[-1]+1] === mSL_CC_KeyKEnd);
                    AAAAA_x_argcnt = m[mSL_CC_ParCnt];
                    AAAAA_x_flags = m[mSL_CC_Flags];
                    AAAAA_x_rpeat = rpeat;
                    while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link)  (
                        mSL_baseAVars = mSL_baseAVars[mSL_baseAVars[-1]-1];
                        0 ? (
                            sprintf(#sfc, "Cp. Forwarding to %d", mSL_baseAVars);
                            mSL_log(SysLogBox, #sfc);
                        );
                    );
                    while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link)  (
                        mSL_baseOVars = mSL_baseOVars[mSL_baseOVars[-1]-1];
                        0 ? (
                            sprintf(#sfc, "Cp. Forwarding to %d", mSL_baseOVars);
                            mSL_log(SysLogBox, #sfc);
                        );
                    );
                    while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link)  (
                        mSL_basePVars = mSL_basePVars[mSL_basePVars[-1]-1];
                        0 ? (
                            sprintf(#sfc, "Cp. Forwarding to %d", mSL_basePVars);
                            mSL_log(SysLogBox, #sfc);
                        );
                    );
                    mSL_TOS[0] = mSL_main_cod;
                ) : (
                    mSL_TOS[0] = (mSL_errX = (mSL_errX ? mSL_errX : mSL_errC ? mSL_errC : 1999));
                );
                //===99===//

            ):(

                //===98===//
                // is fun
                m = mSL_TOS[0];
                mSL_TOS[0] =
                    ((m[-2] === mSL_CC_KeyCKod) && (m[m[-1]+1] === mSL_CC_KeyKEnd))
                    ||
                    ((m > mSL_Prim_Low) && (m < mSL_Prim_High));
                //===98===//

            );):((Xop&0x1)?(

                //===97===//
                // is int(x)
                m = mSL_TOS[0]; mSL_TOS[0] = (m === floor(m));
                //===97===//

            ):(

                //===96===//
                // max memory address
                mSL_TOS += 1;
                mSL_TOS[0] = __memtop();
                //===96===//

            );););););):((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===95===//
                // gmem[x] = y
                mSL_TOS -= 1;
                gmem[mSL_TOS[1]] = mSL_TOS[0];
                //===95===//

            ):(

                //===94===//
                // Power
                mSL_TOS -= 1;
                mSL_TOS[0] ^= mSL_TOS[1];
                //===94===//

            );):((Xop&0x1)?(

                //===93===//
                // gmem[x] => gmem access
                mSL_TOS[0] = gmem[mSL_TOS[0]];
                //===93===//

            ):(

                //===92===//
                // ~ monadic : bit not
                mSL_TOS[0] = 0xFFFFFFFF ~ mSL_TOS[0];
                //===92===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===91===//
                // int
                mSL_TOS[0] |= 0;
                //===91===//

            ):(

                //===90===//
                mSL_TOS += 1;
                mSL_TOS[0] = tempo;
                //===90===//

            );):((Xop&0x1)?(

                //===89===//
                mSL_TOS += 1;
                mSL_TOS[0] = num_ch;
                //===89===//

            ):(

                //===88===//
                mSL_TOS += 1;
                mSL_TOS[0] = srate;
                //===88===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===87===//
                mSL_TOS += 1;
                mSL_TOS[0] = time_precise() + timeD;
                //===87===//

            ):(

                //===86===//
                mSL_TOS += 1;
                mSL_TOS[0] = time();
                //===86===//

            );):((Xop&0x1)?(

                //===85===//
                mSL_TOS[0] = mSL_TOS[0] * rand(1);
                //===85===//

            ):(

                //===84===//
                mSL_TOS[0] = invsqrt(mSL_TOS[0]);
                //===84===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===83===//
                mSL_TOS[0] = ceil(mSL_TOS[0]);
                //===83===//

            ):(

                //===82===//
                mSL_TOS[0] = floor(mSL_TOS[0]);
                //===82===//

            );):((Xop&0x1)?(

                //===81===//
                mSL_TOS[0] = log10(mSL_TOS[0]);
                //===81===//

            ):(

                //===80===//
                mSL_TOS[0] = sign(mSL_TOS[0]);
                //===80===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===79===//
                mSL_TOS[0] = abs(mSL_TOS[0]);
                //===79===//

            ):(

                //===78===//
                mSL_TOS[0] = log(mSL_TOS[0]);
                //===78===//

            );):((Xop&0x1)?(

                //===77===//
                mSL_TOS[0] = exp(mSL_TOS[0]);
                //===77===//

            ):(

                //===76===//
                mSL_TOS[0] = sqrt(mSL_TOS[0]);
                //===76===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===75===//
                mSL_TOS[0] = sqr(mSL_TOS[0]);
                //===75===//

            ):(

                //===74===//
                mSL_TOS -= 1;
                mSL_TOS[0] = pow(mSL_TOS[0], mSL_TOS[1]);
                //===74===//

            );):((Xop&0x1)?(

                //===73===//
                mSL_TOS -= 1;
                mSL_TOS[0] = atan2(mSL_TOS[0], mSL_TOS[1]);
                //===73===//

            ):(

                //===72===//
                mSL_TOS -= 1;
                mSL_TOS[0] = min(mSL_TOS[0], mSL_TOS[1]);
                //===72===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===71===//
                mSL_TOS -= 1;
                mSL_TOS[0] = max(mSL_TOS[0], mSL_TOS[1]);
                //===71===//

            ):(

                //===70===//
                mSL_TOS[0] = atan(mSL_TOS[0]);
                //===70===//

            );):((Xop&0x1)?(

                //===69===//
                mSL_TOS[0] = acos(mSL_TOS[0]);
                //===69===//

            ):(

                //===68===//
                mSL_TOS[0] = asin(mSL_TOS[0]);
                //===68===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===67===//
                mSL_TOS[0] = tan(mSL_TOS[0]);
                //===67===//

            ):(

                //===66===//
                mSL_TOS[0] = cos(mSL_TOS[0]);
                //===66===//

            );):((Xop&0x1)?(

                //===65===//
                mSL_TOS[0] = sin(mSL_TOS[0]);
                //===65===//

            ):(

                //===64===//
                // mkthread(code) => returns a thread ident.
                // mSL_errX=64;
                k = mSL_TOS[0]; // parameter
                ((mSL_bl_check(k, 9793) != 0) || (k[mSL_CC_Key] != mSL_CC_KeyCKod)) ? (
                    mSL_errX = 2407; // parameter not a function
                ) :
                (ent = getNewThread()) ? (
                    SchedPar1[ent] = k; // keep the code to execute
                    SchedPar4[ent] = 0; // use std locals
                    SchedCode[ent] = KRun_mSL_Thread; // ready to start
                    mSL_init_thread(ent);
                    SchedInsertTail(SchedSuspPts, ent);
                ) : (
                    mSL_errX = 2408; // can't get a thread
                );
                mSL_TOS[0] = ent; // return the thread identification
                //===64===//

            ););););););):((Xop&0x20)?((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===63===//
                // threadid() => returns the thread number
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_active_Thread[mSL_THR_SchedEnt];
                //===63===//

            ):(

                //===62===//
                // edn(string, value)  — edit "best" a number inside a string
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_edit_value(mSL_TOS[0], m)
                //===62===//

            );):((Xop&0x1)?(

                //===61===//
                // thread(operation, p1, p2, ..., pn)
                // mSL_errX=61;
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_thread_ops(m, mSL_TOS);
                //===61===//

            ):(

                //===60===//
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_Str_Tmp();
                //===60===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===59===//
                mSL_errX=59;
                //===59===//

            ):(

                //===58===//
                mSL_errX=58;
                //===58===//

            );):((Xop&0x1)?(

                //===57===//
                mSL_errX=57;
                //===57===//

            ):(

                //===56===//
                mSL_errX=56;
                //===56===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===55===//
                // ~=  Xor assign
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] ~= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===55===//

            ):(

                //===54===//
                // |=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] |= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===54===//

            );):((Xop&0x1)?(

                //===53===//
                // &=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] &= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===53===//

            ):(

                //===52===//
                // %=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] %= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===52===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===51===//
                // /=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] /= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===51===//

            ):(

                //===50===//
                // *=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] *= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===50===//

            );):((Xop&0x1)?(

                //===49===//
                // -=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] -= mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===49===//

            ):(

                //===48===//
                // +=
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                m[0] += mSL_TOS[0];
                mSL_TOS[0] = m[0];
                //===48===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===47===//
                // mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] -1;
                //===47===//

            ):(

                //===46===//
                mSL_errX=46;
                //===46===//

            );):((Xop&0x1)?(

                //===45===//
                // ! op
                mSL_TOS[0] = ! mSL_TOS[0];
                //===45===//

            ):(

                //===44===//
                mSL_TOS[0] = mSL_symbol(mSL_TOS[0]);
                //===44===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===43===//
                // Addition
                mSL_TOS -= 1;
                mSL_TOS[0] += mSL_TOS[1];
                //===43===//

            ):(

                //===42===//
                // Product
                mSL_TOS -= 1;
                mSL_TOS[0] *= mSL_TOS[1];
                //===42===//

            );):((Xop&0x1)?(

                //===41===//
                // Greater than
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] > mSL_TOS[1];
                //===41===//

            ):(

                //===40===//
                // Less than
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] < mSL_TOS[1];
                //===40===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===39===//
                // Or
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] | mSL_TOS[1];
                //===39===//

            ):(

                //===38===//
                // and
                mSL_TOS -= 1;
                mSL_TOS[0] &= mSL_TOS[1];
                //===38===//

            );):((Xop&0x1)?(

                //===37===//
                // Residute — check for zero ?
                mSL_TOS -= 1;
                mSL_TOS[0] %= mSL_TOS[1];
                //===37===//

            ):(

                //===36===//
                // !== Not Equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] !== mSL_TOS[1];
                //===36===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===35===//
                // === Equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] === mSL_TOS[1];
                //===35===//

            ):(

                //===34===//
                // Xclusive Or
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] ~ mSL_TOS[1];
                //===34===//

            );):((Xop&0x1)?(

                //===33===//
                // Substraction
                mSL_TOS -= 1;
                mSL_TOS[0] -= mSL_TOS[1];
                //===33===//

            ):(

                //===32===//
                // Divide — check for zero ?
                mSL_TOS -= 1;
                mSL_TOS[0] /= mSL_TOS[1];
                //===32===//

            );););););):((Xop&0x10)?((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===31===//
                // Left Shift
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] << mSL_TOS[1];
                //===31===//

            ):(

                //===30===//
                // Less than or equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] <= mSL_TOS[1];
                //===30===//

            );):((Xop&0x1)?(

                //===29===//
                // Right Shift
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] >> mSL_TOS[1];
                //===29===//

            ):(

                //===28===//
                // Greater than or equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] >= mSL_TOS[1];
                //===28===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===27===//
                // == Equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] == mSL_TOS[1];
                //===27===//

            ):(

                //===26===//
                // != Not Equal
                mSL_TOS -= 1;
                mSL_TOS[0] = mSL_TOS[0] != mSL_TOS[1];
                //===26===//

            );):((Xop&0x1)?(

                //===25===//
                // Multi-adic "Array" : build an array from values
                m = mSL_TOS[0]; mSL_TOS -= m;
                p = mSL_malloc(m, mSL_MT_Data);
                memcpy(p, mSL_TOS, m);
                mSL_TOS[0] = p;
                //===25===//

            ):(

                //===24===//
                // Multi-adic "sum" — to be redefined later
                m = mSL_TOS[0];
                mSL_TOS -= m;
                mSL_TOS[0] = mSL_prim_Sum(m, mSL_TOS);
                //===24===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===23===//
                // Monadic -
                mSL_TOS[0] = - mSL_TOS[0];
                //===23===//

            ):(

                //===22===//
                // Monadic +
                0; // one simple instruction - do not change the TOS
                //===22===//

            );):((Xop&0x1)?(

                //===21===//
                // mSL_errX=21;
                // Signal an error - and stop execution
                m = mSL_TOS[0];
                (mSL_errX === 0) ? (mSL_errX = mSL_TOS[0] = 10000 + (m & 0x7ffff));
                //===21===//

            ):(

                //===20===//
                //=====FUNCTION CALL=====
                // The TOS is supposed to be a function
                (mSL_baseHighStack[0] === mSL_End_Mark) ? ( // checks near the end of the stack
                    // AAAA_funAddr =
                    fn = mSL_TOS[0]; // the function pointer
                    AAAAA_y_TOS = mSL_TOS;
                    AAAAA_y_fn = fn;
                    AAAAA_y_rpeat = rpeat;
                    // AAAA_fun1 = fn[0];
                    mSL_TOS -= 1;
                    par = mSL_TOS[0]; // arg count
                    ((fn[-2] === mSL_CC_KeyCKod) && (fn[fn[-1]+1] === mSL_CC_KeyKEnd)) ? (
                        ((par != fn[mSL_CC_ParCnt]) && ((fn[mSL_CC_Flags] & 1) === 0)) ? (
                            mSL_errX=1621;
                        ) : (
                            (mSL_NxtOp === mSL_K_return) ? (
                                // Doing a tail rec optimisation.
                                AAAAA_tailrec += 1;
                                memcpy(mSL_wa2, mSL_baseAddStack, mSL_STK_DSiz); // save previous state
                                // install new TOS operands
                                s = par+1;
                                memcpy(mSL_wSt1, mSL_TOS - par, s); // save parameters in a lage area...
                                memcpy(mSL_baseTOS, mSL_wSt1, s); // copy parameters at the base stack
                                mSL_TOS = mSL_baseTOS + par; // add the number of parameters
                                (fn[mSL_CC_Flags] & 1) ? (
                                    // This is a variadic function
                                    mSL_baseLocals = mSL_baseTOS - 1 + par;
                                    // set the "second" parameter
                                    mSL_baseLocals[2] = mSL_baseTOS;
                                    mSL_TOS += 2; // add the two actual parameters of the function
                                ) : (
                                    mSL_baseLocals = mSL_baseTOS - 1;
                                );
                                mSL_TOS += fn[mSL_CC_LocCnt]; // plus the number of locals
                                memcpy(mSL_TOS, mSL_wa2, mSL_STK_DSiz); // restore saved information
                            ) : (
                                // Classical function call, using the stack...
                                s = bl = mSL_TOS - par; // points to first argument
                                (fn[mSL_CC_Flags] & 1) ? (
                                    // This is a variadic function
                                    bl += par; // 1st param is the arg count
                                    bl[1] = s; // 2nd param is the arg list
                                    mSL_TOS = bl+2; // new TOS value
                                );
                                mSL_TOS += fn[mSL_CC_LocCnt];
                                // Create the "new" baseStack
                                mSL_TOS[0] = mSL_baseAddStack;
                                mSL_TOS[1] = mSL_baseLocals;
                                mSL_TOS[2] = mSL_baseTOS; // return stack pointer
                                mSL_TOS[3] = mSL_baseCode;
                                mSL_TOS[4] = mSL_CodePtr;
                                while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link) (
                                    mSL_baseAVars = mSL_baseAVars[mSL_baseAVars[-1]-1];
                                    0 ? (
                                    sprintf(#sfc, "Fct.1A-Forwarding to %d", mSL_baseAVars);
                                    mSL_log(SysLogBox, #sfc);
                                    );
                                );
                                while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link) (
                                    mSL_baseOVars = mSL_baseOVars[mSL_baseOVars[-1]-1];
                                    0 ? (
                                    sprintf(#sfc, "Fct.1O-Forwarding to %d", mSL_baseOVars);
                                    mSL_log(SysLogBox, #sfc);
                                    );
                                );
                                while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link) (
                                    mSL_basePVars = mSL_basePVars[mSL_basePVars[-1]-1];
                                    0 ? (
                                    sprintf(#sfc, "Fct.1P-Forwarding to %d", mSL_basePVars);
                                    mSL_log(SysLogBox, #sfc);
                                    );
                                );
                                mSL_TOS[5] = mSL_baseAVars; // save current global table
                                mSL_TOS[6] = mSL_baseOVars; // save current own table
                                mSL_TOS[7] = mSL_basePVars; // save current pointers table
                                mSL_baseLocals = bl - 1; // new base locals
                                mSL_baseTOS = s;
                            );
                            mSL_baseAddStack = mSL_TOS;
                            mSL_TOS += mSL_STK_DSiz - 1; // New "tos"
                            mSL_baseCode = fn + fn[mSL_CC_dpCode]; // @ code
                            mSL_CodePtr = 0;
                            mSL_NxtOp = mSL_baseCode[0];
                            // Has the function its own global/own/pointers tables ?
                            (fn[mSL_CC_GlbTab] != 0) ? mSL_baseAVars = fn[mSL_CC_GlbTab];
                            while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link) (
                                mSL_baseAVars = fn[mSL_CC_GlbTab] = mSL_baseAVars[mSL_baseAVars[-1]-1];
                                0 ? (
                                sprintf(#sfc, "Fct.2A-Forwarding to %d", mSL_baseAVars);
                                mSL_log(SysLogBox, #sfc);
                                );
                            );
                            (fn[mSL_CC_OwnTab] != 0) ? mSL_baseOVars = fn[mSL_CC_OwnTab];
                            while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link) (
                                mSL_baseOVars = fn[mSL_CC_OwnTab] = mSL_baseOVars[mSL_baseOVars[-1]-1];
                                0 ? (
                                sprintf(#sfc, "Fct.2O-Forwarding to %d", mSL_baseOVars);
                                mSL_log(SysLogBox, #sfc);
                                );
                            );
                            (fn[mSL_CC_PtrTab] != 0) ? mSL_basePVars = fn[mSL_CC_PtrTab];
                            while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link) (
                                mSL_basePVars = fn[mSL_CC_PtrTab] = mSL_basePVars[mSL_basePVars[-1]-1];
                                0 ? (
                                sprintf(#sfc, "Fct.2P-Forwarding to %d", mSL_basePVars);
                                mSL_log(SysLogBox, #sfc);
                                );
                            );
                        );
                    ) :
                    ((fn > mSL_Prim_Low) && (fn < mSL_Prim_High)) ? (
                        fn = fn - mSL_Prim_Low;
                        argc = (fn >> 12) & 0xff;
                        (argc === mSL_TOS[0]) ? (
                            // suppress the TOS argc
                            mSL_TOS -= 1;
                            // call the function by providing its code in mSL_NxtOp
                            mSL_NxtOp = fn & 0xff;
                            mSL_CodePtr = mSL_PCode;
                        ) :
                        (argc === 0xff) ? (
                            // multiadic function - keep tos
                            mSL_NxtOp = fn & 0xff;
                            mSL_CodePtr = mSL_PCode;
                        ) : (
                            AAAAA_0622A = argc;
                            AAAAA_0622B = mSL_TOS[0];
                            AAAAA_0622M = fn;
                            mSL_errX=1622;
                        );
                    ) :
                    ((fn > mSL_OP_Low) && (fn < mSL_OP_High)) ? (
                        argc = 2; // (fn & 0x800000) ? 1 : 2;
                        par = fn & 0x3FF;
                        ((argc === mSL_TOS[0]) && (par >= 26) && (par <= 43)) ? (
                            // suppress the TOS argc
                            mSL_TOS -= 1;
                            // call the function by providing its code in mSL_NxtOp
                            mSL_NxtOp = par;
                            mSL_CodePtr = mSL_PCode;
                        ) : (
                            AAAAA_0623A = argc;
                            AAAAA_0623B = mSL_TOS[0];
                            AAAAA_0623M = fn;
                            AAAAA_0623P = par;
                            mSL_errX=1623;
                        );
                    ) :
                    (
                        AAAAA_0620M = fn;
                        mSL_errX=1620;
                    );
                ) : (
                    mSL_errX=1619; // stack overflow
                );
                //===20===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===19===//
                // Index address
                p = mSL_TOS[0];
                mSL_TOS -= 1;
                m = mSL_TOS[0];
                (m >= 0) ? (
                    mSL_TOS[0] = m + p;
                ) : (
                    mSL_TOS[0] = m - p;
                );
                //===19===//

            ):(

                //===18===//
                // Indexing
                p = mSL_TOS[0];
                mSL_TOS -= 1;
                m = mSL_TOS[0];
                (m >= 0) ? (
                    mSL_TOS[0] = 0[m + p];
                ) : (
                    mSL_TOS[0] = gmem[p - m];
                );
                //===18===//

            );):((Xop&0x1)?(

                //===17===//
                // Push negative short - parameter becomes the new TOS
                mSL_TOS += 1;
                mSL_TOS[0] = - (0|(Xop / mSL_X_OpShDiv));
                //===17===//

            ):(

                //===16===//
                // Push short - parameter becomes the new TOS
                mSL_TOS += 1;
                mSL_TOS[0] = 0|(Xop / mSL_X_OpShDiv);
                //===16===//

            ););););):((Xop&0x8)?((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===15===//
                // wait(x)
                mSL_WaitDuration = mSL_TOS[0];
                mSL_ICount -= rpeat; // deduce rest of count
                rpeat = 0;
                mSL_CodeStop = mSL_RC_Wait; // set "wait" flag
                //===15===//

            ):(

                //===14===//
                // yield() — release control
                mSL_TOS += 1;
                mSL_TOS[0] = 0; // no specific return value
                mSL_ICount -= rpeat; // deduce rest of count
                rpeat = 0;
                mSL_CodeStop = mSL_RC_Yield; // set "yield" flag
                //===14===//

            );):((Xop&0x1)?(

                //===13===//
                // Load the address of a pointer variable
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_basePVars[(0|(Xop / mSL_X_OpShDiv))];
                //===13===//

            ):(

                //===12===//
                // Load the value of a pointer variable
                mSL_TOS += 1;
                mSL_TOS[0] = 0[mSL_basePVars[(0|(Xop / mSL_X_OpShDiv))]];
                //===12===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===11===//
                // Load the address of a semi-global variable
                mSL_TOS += 1;
                mSL_TOS[0] = (0|(Xop / mSL_X_OpShDiv)) + mSL_baseOVars;
                //===11===//

            ):(

                //===10===//
                // Load the value of a semi-global variable
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_baseOVars[(0|(Xop / mSL_X_OpShDiv))];
                //===10===//

            );):((Xop&0x1)?(

                //===9===//
                // Load the address of a global variable
                mSL_TOS += 1;
                mSL_TOS[0] = (0|(Xop / mSL_X_OpShDiv)) + mSL_baseAVars;
                //===9===//

            ):(

                //===8===//
                // Load the value of a global variable
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_baseAVars[(0|(Xop / mSL_X_OpShDiv))];
                //===8===//

            );););):((Xop&0x4)?((Xop&0x2)?((Xop&0x1)?(

                //===7===//
                // Load the address of a local variable
                mSL_TOS += 1;
                mSL_TOS[0] = (0|(Xop / mSL_X_OpShDiv)) + mSL_baseLocals;
                //===7===//

            ):(

                //===6===//
                // Load the value of a local variable
                mSL_TOS += 1;
                mSL_TOS[0] = mSL_baseLocals[(0|(Xop / mSL_X_OpShDiv))];
                //===6===//

            );):((Xop&0x1)?(

                //===5===//
                // Set and Pop —
                // TOS is a memory address,
                // TOS - 1 the value
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                (m > 0) ? (
                    m[0] = mSL_TOS[0];
                ) :
                (m < 0) ? (
                    gmem[-m] = mSL_TOS[0];
                ) : (
                    mSL_errX = 1628;
                );
                mSL_TOS -= 1;
                //===5===//

            ):(

                //===4===//
                // Set —
                // TOS is a memory address,
                // TOS - 1 the value
                // keep the value
                m = mSL_TOS[0];
                mSL_TOS -= 1;
                (m > 0) ? (
                    m[0] = mSL_TOS[0];
                ) :
                (m < 0) ? (
                    gmem[-m] = mSL_TOS[0];
                ) : (
                    mSL_errX = 1628;
                );
                //===4===//

            ););):((Xop&0x2)?((Xop&0x1)?(

                //===3===//
                // Pop : suppress TOS
                mSL_TOS -= 1;
                //===3===//

            ):(

                //===2===//
                //======RETURN======
                // Return from a function
                m = mSL_TOS[0]; // returned value
                mSL_TOS = mSL_baseTOS; // set new tos
                mSL_CodePtr = mSL_baseAddStack[4];
                mSL_baseCode = mSL_baseAddStack[3];
                mSL_baseTOS = mSL_baseAddStack[2];
                mSL_baseLocals = mSL_baseAddStack[1];
                mSL_baseAddStack = mSL_baseAddStack[0];
                // Do we have to restore context symbol tables ?
                (mSL_baseAddStack[5] != 0) ? mSL_baseAVars = mSL_baseAddStack[5];
                while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_baseAddStack[5] = mSL_baseAVars = mSL_baseAVars[mSL_baseAVars[-1]-1];
                    0 ? (
                    sprintf(#sfc, "Ret.A-Forwarding to %d", mSL_baseAVars);
                    mSL_log(SysLogBox, #sfc);
                    );
                );
                (mSL_baseAddStack[6] != 0) ? mSL_baseOVars = mSL_baseAddStack[6];
                while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_baseAddStack[6] = mSL_baseOVars = mSL_baseOVars[mSL_baseOVars[-1]-1];
                    0 ? (
                    sprintf(#sfc, "Ret.O-Forwarding to %d", mSL_baseOVars);
                    mSL_log(SysLogBox, #sfc);
                    );
                );
                (mSL_baseAddStack[7] != 0) ? mSL_basePVars = mSL_baseAddStack[7];
                while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link)  (
                    mSL_baseAddStack[7] = mSL_basePVars = mSL_basePVars[mSL_basePVars[-1]-1];
                    0 ? (
                    sprintf(#sfc, "Ret.P-Forwarding to %d", mSL_basePVars);
                    mSL_log(SysLogBox, #sfc);
                    );
                );
                mSL_TOS[0] = m; // transmit the return value
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                //===2===//

            );):((Xop&0x1)?(

                //===1===//
                // exit —
                mSL_ExitValue = mSL_TOS[0]; // exit value
                mSL_ICount -= rpeat; // deduce rest of count
                rpeat = 0;
                mSL_CodePtr = mSL_PCode; // lock on current address
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                mSL_CodeStop = mSL_RC_Stop; // set "stop" flag
                //===1===//

            ):(

                //===0===//
                // illegal instruction "0"
                mSL_errX=1901;
                mSL_CodePtr = mSL_PCode; // lock on current address
                mSL_NxtOp = mSL_baseCode[mSL_CodePtr];
                mSL_CodeStop = mSL_RC_IllInst; // illegal inst "stop" flag
                //===0===//

            ););););););););

            );

            mSL_max_TOS = max(mSL_max_TOS, mSL_TOS);
            // xxtrace(mSL_PCode, mSL_TOS - mSL_current_stack);
        );
        //// End of Inner Loop


        // Check the various cases

        (mSL_errX != 0) ? (
            mSL_ICount -= rpeat; // deduce rest of count
            rpeat = 0;
            mSL_CodeStop = mSL_RC_XErr; // error "stop" flag

            SchedLockAll = 1; // debug mode, temprary lock all processes
            atomic_add(mSL_Lock,1); // lock every one
        );

        // );

        mSL_ICount -= rpeat;
        mSL_result = mSL_TOS[0];
    );









/*
    Events management operations
*/
function mSL_event_ops(argc, argv)
local (res, kw, ent, k, ipca)
(
    res = 0;
    ipca = mSL_active_Thread[mSL_THR_IPCA];
    (argc > 0) ? (
        kw = argv[0];
        (kw === mSL_KW_wait) ? (
            // expect a description - but first, get the scheduler entry
            ent = mSL_active_Thread[mSL_THR_SchedEnt];
            (argc > 1) ? (
                k = argv[1];
                (k === mSL_KW_MIDI) ? (
                    res = mSL_KW_MIDI;
                );
                (res != 0) ? (
                    mSL_bl_clear(ipca); // clear ipca
                    ipca[mSL_IPCA_EVTy] = res;  // The event waited for
                    argc -= 2; argv += 2;
                    argc = min(argc, 8); k = 0;
                    ipca[mSL_IPCA_EVPCnt] = argc;
                    loop (argc,
                        ipca[mSL_IPCA_EVP1 + k] = argv[k];
                        k += 1;
                    );
                    ipca[mSL_IPCA_EVP1 + k] = -1;
                    // provide a stop code as return
                    SchedmSLEvWait = mSL_RC_WEvent;
                );
            );
        );
    ) : (
        res = ipca;
    );
    res;
);






/*
   Signal an event to a waiting thread
*/
//  mSL_signal_b = make_array(8);
function mSL_signal_event(evt, cnt, p1, p2, p3, p4, p5, p6, p7, p8)
local (ent, nxt, tl, flg, thrd, ipca, k)
(
    flg = 1;
    // look for a waiting thread
    tl = SchedEvntPts[SchedOtherEnd];
    ent = SchedEvntPts[SchedNxtEnt];
    mSL_signal_b[0] = p1; mSL_signal_b[1] = p2; mSL_signal_b[2] = p3; mSL_signal_b[3] = p4;
    mSL_signal_b[4] = p5; mSL_signal_b[5] = p6; mSL_signal_b[6] = p7; mSL_signal_b[7] = p8;
    while ((flg != 0) && (ent != tl)) (
        nxt = SchedNxtEnt[ent] ; // next
        (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                    sprintf(#s, "Event : test: %d ...", ent);
                    mSL_log(SysLogBox, #s);
        );
        // is this the event that was expected
        ((SchedStatus[ent] & SchThreadmSL) && ((thrd = SchedThrdPt[ent]) != 0) && ((ipca = thrd[mSL_THR_IPCA]) != 0)) ? (
            // est-ce bon ?
            tyc = (evt === ipca[mSL_IPCA_EVTy]); k = ipca[mSL_IPCA_EVPCnt];
            (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                    sprintf(#s, "Event : ent: %d  tyc: %d / %d", ent, tyc, k);
                    mSL_log(SysLogBox, #s);
            );
            while (tyc && (k > 0)) (
                k -= 1;
                tyc = (ipca[mSL_IPCA_EVP1 + k] === mSL_signal_b[k]);
            );
            (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                    sprintf(#s, "Event : ent: %d  tyc: %d / %d", ent, tyc, k);
                    mSL_log(SysLogBox, #s);
            );
            (tyc) ? (
                // we signal the event
                ipca[mSL_IPCA_Status] = 1; ipca[mSL_IPCA_Notified] = 1;
                ipca[mSL_IPCA_NType] = evt; ipca[mSL_IPCA_NCnt] = cnt;
                k = 0;
                loop (cnt,
                    ipca[mSL_IPCA_NP1 + k] = mSL_signal_b[k]; k += 1;
                );
                SchedUnchainEnt(SchedEvntPts, ent, SchETypeThrd);
                SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
                flg = 0; // good
                (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                    sprintf(#s, "Event : thrd: %d %s  %d %d ...", thrd, mSL_edit_value(0, evt), p1, p2);
                    mSL_log(SysLogBox, #s);
                );
            );
        );
        ent = nxt;
    );
    flg ? (
        (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flagsffFF
            sprintf(#s, "No process for  %s %d %d ...", mSL_edit_value(0, evt), p1, p2);
            mSL_log(SysLogBox, #s);
        );
    );
    flg;
);




/*
    Build a memblock from a part of main memory
    "type" should be valid, and not equal to "free"

function mSL_make_block(mem, size, type)
local (res, s)
(
    size = max(0, (0|size));
    (size < 4) ? (
        res = 0;
    ) : (
        ((type < mSL_MKey_min) || (type > mSL_MKey_max) ) ? ( type = mSL_MT_Data; );
        res = mem + 2;
        mem[0] = type;
        mem[1] = mem[size-2] = s = size - 4;
        mem[size - 1] = type ~ mSL_CC_Chksum;
        (s > 0) ? memset(res, 0, s);
    );
    res;
);
*/





//======= Test Operations
HSZ_Siz = 1431;  //  1033; // 2999;
H_Table = make_array(HSZ_Siz); // Set to zero
memset(H_Table, -1, HSZ_Siz);
H_Codes = make_array(HSZ_Siz); // Set to zero
H_Dupl = make_array(HSZ_Siz); // Set to zero
H_Colls = 0;
H_Tsts = 0;



function ttsym(str)
local(res, zu, fl, h, e, k)
(
    zu = mSL_symbol(str);
    fl = (zu > mSL_Sym_Low) && (zu < mSL_Sym_High);
    res = mSL_symbol2(str);
    h = mSL_symhash(zu); e = h % HSZ_Siz;
    sprintf(#sfc, "\"%s\"  =>  \"%s\"  => %18.0f/%d =>  \"%s\" :  %d   %d", str, res, zu, fl, mSL_id2Str(zu), h, e);
    mSL_log(SysLogBox, #sfc);
    // Enter the object
    k = H_Table[e];
    (k === -1) ? (
        // enter the object
        H_Table[e] = zu; H_Codes[e] = h;
    ) : (
        H_Dupl[e] = zu;  // a synonym
        H_Colls += 1;
    );
    H_Tsts += 1;

    /*
    res = mSL_symbol2(str);
    sprintf(#sfc, "\"%s\"  =>  \"%s\" ", str, res);
    mSL_log(SysLogBox, #sfc);
    */
);


function ttsdmp()
local (e)
(
    sprintf(#sfc, "** Collisions : %d/%d/%d **", H_Colls, H_Tsts, HSZ_Siz);
    mSL_log(SysLogBox,#sfc);
    e = 0; loop(HSZ_Siz,
        (H_Dupl[e] != 0) ? (
            sprintf(#sfc, "Dup %d \"%s\"/%d  \"%s\"/%d", e, mSL_id2Str(H_Table[e]), mSL_symhash(H_Table[e]), mSL_id2Str(H_Dupl[e]), mSL_symhash(H_Dupl[e]));
            mSL_log(SysLogBox, #sfc);
        );
        e += 1;
    );
    mSL_log(SysLogBox,"** End **");
);









// Check if some object is in the hash table
function gc_check(obj, flg)
local (ent, cnt, k, ty, s)
(
    cnt = 0;
    ((obj >= mm_lowblocks) && (obj < mm_highblocks)) ? ( // no address less that that can be an object
        ty = obj[-2]; s = obj[-1];
        ((s >= 0) && (s <= mm_sizmem) && (ty >= mSL_MKey_min) && (ty <= mSL_MKey_max) && (s === obj[s])
        && (obj[s+1] === (ty ~ mSL_CC_Chksum))) ? (
            cnt = mm_hash_siz;
            ent = obj % mm_hash_siz;
            while (((k = mm_hash_mm[ent]) != 0) && (cnt > 0)) (
                (k === obj) ? cnt = -1;
                ent = (ent + 191) % mm_hash_siz;
                cnt -= 1;
            );
            (k === 0) ? (
                // enter the object at this location
                mm_hash_mm[ent] = obj;
                (flg & 1) ? (
                    // and in the list
                    mm_list_mm[mm_list_in] = obj;  mm_list_in = (mm_list_in + 1) % mm_list_siz;
                    cnt = mm_Knew;
                    (FlagsTbVals[Flgs_GC] & 1) ? (
                        sprintf(#ms, "* Enter: %d", obj);
                        mSL_log(SysLogBox, #ms);
                    );
                );
            );
        );
    );
    cnt;
);






// Try compacting algos.
mSL_log(SysLogBox, "***STRING TEST***");
mSL_g6packStr(xplStr1, "This is a long string, with a lot of chars in it.", 0, 511, 0);


mSL_log(SysLogBox, mSL_g6unpackArray(#sfc, xplStr1, 0));


mSL_log(SysLogBox, "***STRING TEST END***");













//#################### INFO BLOCKS MANAGEMENT ##############
// Allocate a new info block
// This is an unique allocation ! no free !
// n.b. = usable size will be size - infoBiFirst
function infoB_New(size) local(uB, a, i)
(
    uB = gmem[iBDummy]; // dummy bloc / default
    // uB = -1;
    ((size >= 8) && (size <= infoBMaxSize)) ? (
        a = gmem[iBFirst];
        ((a >= infoBStarts) && ((a + size) <= infoBMaxSize)) ? (
            uB = a;
            gmem[iBFirst] += size;
            i = 0; loop(size, gmem[uB+i] = 0; i+=1;);
            gmem[uB] = size;
        );
    );
    uB;
);



// Clear an infoBlock
function infoB_clear(uB, size) local(i)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        (size == -1) ? size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            i = 0; loop(size, gmem[uB+i] = 0; i+=1;);
            gmem[uB] = size;
        );
    );
);




// Sort content of a block
// blocks are small, we use a very simple bubble sort in O(n2)
function infoB_sort_unchecked(uB) local (size, k, l, v)
(
    size = gmem[uB];
    k = infoBiFirst;
    while (k < size-1) (
        l = k+1;
        while (l < size) (
            (gmem[uB+k] > gmem[uB+l]) ? (
                v = gmem[uB+k]; gmem[uB+k] = gmem[uB+l]; gmem[uB+l] = v;
            );
            l += 1;
        );
        k += 1;
    );
);



// Sort a block
// and check validity first
function infoB_sort(uB) local (size, k, l, v)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst;
            while (k < size-1) (
                l = k+1;
                while (l < size) (
                    (gmem[uB+k] > gmem[uB+l]) ? (
                        v = gmem[uB+k]; gmem[uB+k] = gmem[uB+l]; gmem[uB+l] = v;
                    );
                    l += 1;
                );
                k += 1;
            );
        );
    );
);



// add an entry to a block
//
function infoB_add(uB, v) local (size, k, index)
(
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst; index = 0;
            while ((k < size) && (index == 0)) (
                ((0|v) == (0|gmem[uB+k])) ? (index = k; gmem[uB+k] = v);
                k += 1;
            );
            (index == 0) ? (
                gmem[uB+infoBiFirst] = v;
                infoB_sort_unchecked(uB);
            );
        );
    );
);



// delete an entry from a bloc
//
function infoB_del(uB, v) local (size, k, index)
(
    infoRemoved = 0;
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            k = infoBiFirst; index = 0;
            while ((k < size) && (index == 0)) (
                (v == gmem[uB+k]) ? index = k;
                k += 1;
            );
            (index != 0) ? (
                gmem[uB+index] = 0;
                infoRemoved = v;
                infoB_sort_unchecked(uB);
            );
        );
    );
    index; // as a return code...
);



// get "next" non null value from a block
//
function infoB_next(uB) local (size, i, v, c)
(
    v = 0;
    ((uB >= infoBStarts) && (uB < infoBEnds)) ? (
        size = gmem[uB];
        ((size >= 8) && (size <= infoBMaxSize)) ? (
            // do actual work
            c = 0; i = gmem[uB+infoBent];
            while ((v == 0) && (c < size)) (
                i = (i + 1) % size; (i < infoBiFirst) ? i = infoBiFirst;
                v = gmem[uB + i];
                c += 1;
            );
            gmem[uB+infoBent] = i; // last accessed entry
        );
    );
    v; // return v
);



//##################### ERRORS MANAGEMENT ##################
function signalError(errnum)
(
    infoB_add(infoBErrs, errnum);
    gmem[errSignal] = errnum;
    gmem[errSFlag] = 1;
);




//#### Info blocks management.
infoB_clear(infoBErrs,infoBEsize);
gmem[iBErrSignal] = infoBErrs;
infoB_clear(infoBDummy,infoBDsize);
gmem[iBDummy] = infoBDummy;
gmem[iBFirst] = infoBDummy + infoBDsize; // first free entry



/*

   Memory for info blocks

   one is dedicated to keep trace of errors

   start at infoBStarts
   end at infoBEnds

*/

infoBMaxSize = 256;
infoBtime = 1; // time accessed
infoBent = 2; // entry last accessed
infoBsl = 3; // associated slider entry
infoBiFirst = 4; // first free index

infoBErrs = infoBStarts; // error signalling bloc
infoBEsize = 64; // size
infoBDummy = infoBErrs + infoBEsize;
infoBDsize = 64;
gmem[iBDummy] = infoBDummy;
gmem[iBFirst] = infoBDummy + infoBDsize;


// info blocks description
gmem[iBDummy] = infoBDummy;
gmem[iBFirst] = infoBDummy + infoBDsize;

iBDummy = 0x282; // dummy block pointer
iBFirst = 0x283; // first infoBlock area available






// Code a string as an "integer" value
// An identifier is coded as 8 (6 bits) chars in a number.
function mSL_symbol2(str)
local (lg, ch, pch, code, x, y, z, s, pa, del, p, cp, cg, alg, ik, jk, kk, cnt, fl16, fl17)
(
    #rez = "";
    ((lg = strlen(str)) > 0) ? (
        ch = str_getchar(str, 0, 'cu');
        memset(mSL_W_idt, 0, mSL_W_sidt+2);
        memset(mSL_W_fidt, 0, mSL_W_sidt+2);

        // Step 1 : copy chars in work array
        pch = 0;
        while ((pch < mSL_W_sidt) && (lg > 0)) (
            (((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z'))
            || ((ch >= '0') && (ch <= '9')))  ?  (
                ((ch >= 'A') && (ch <= 'Z')) ? (
                    mSL_W_fidt[pch] = 1;
                    ch = ch + 'a' - 'A';
                );
            ) : (
                ch = '_'; // change unrecognized chars to "_"
            );
            mSL_W_idt[pch] = ch;
            lg -= 1; pch += 1;
            ch = str_getchar(str, pch, 'cu');
        );
        lg = pch;

        // Step 2 : add a char in front of long identifiers (yes)
        (lg > 8) ? (
            x = y = lg;
            loop (lg,
                x -= 1; mSL_W_idt[y] = mSL_W_idt[x]; mSL_W_fidt[y] = mSL_W_fidt[x]; y -= 1;
            );
            mSL_W_idt[0] = '0' + (lg % 10);
            mSL_W_fidt[0] = 0;
            lg += 1; // therefore longer
        );

        // Step 3 : apply reducing algos
        fl16 = fl17 = 1;
        cp = pa = 2;
        while (lg > 8) (
            cg = 0; del = -1; cp = cp % lg;
            alg = mSL_W_Algs[pa]; pa = (pa + 1) % mSL_W_CAlgs;
            (alg == 1) ? (
                // suppress a '_'
                while ((cp < lg) && (del < 0)) (
                    ch = mSL_W_idt[cp];
                    (ch == '_') ? del = cp;
                    cp += 1;
                );
            ) :
            (alg == 2) ? (
                // suppress some redundencies
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == mSL_W_idt[cp+1]) ? (del = cp;  cg = 3;);
                    cp += 1;
                );
            ) :
            (alg == 3) ? (
                // look for a replacable pair
                while ((cp < lg) && (del < 0)) (
                    kk = (mSL_W_idt[cp] << 8) | mSL_W_idt[cp+1];
                    p = 0;
                    while ((p < mSL_W_CPrs) && (del < 0)) (
                        (kk == mSL_W_Pairs[p]) ? (
                            del = cp+1;
                            ch = mSL_W_PReps[p];
                            ((ch >= 'A') && (ch <= 'Z')) ? (
                                ch = ch + 'a' - 'A';
                                mSL_W_fidt[cp] |= 1;
                            );
                            mSL_W_idt[cp] = ch;
                        ) ;
                        p += 1;
                    );
                    cp += 1;
                );
            ) :
            (alg == 4) ? (
                cnt = 0;
                // delete 3rd e
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'e') ? (
                        cnt += 1;
                        (cnt == 3) ? del = cp;
                    );
                    cp += 1;
                );
            ) :
            (alg == 5) ? (
                cnt = 0;
                // change 2nd e to '3'
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'e') ? (
                        cnt += 1;
                        (cnt == 2) ? (mSL_W_idt[cp] = '3'; cg = 3;)
                    );
                    cp += 1;
                );
            ) :
            (alg == 6) ? (
                cnt = 0;
                // delete 3rd a
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'a') ? (
                        cnt += 1;
                        (cnt == 3) ? del = cp;
                    );
                    cp += 1;
                );
            ) :
            (alg == 7) ? (
                cnt = 0;
                // change 2nd a to '4'
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'a') ? (
                        cnt += 1;
                        (cnt == 2) ? (mSL_W_idt[cp] = '4';  cg = 4;)
                    );
                    cp += 1;
                );
            ) :
            (alg == 8) ? (
                cnt = 0;
                // delete 3rd i
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'i') ? (
                        cnt += 1;
                        (cnt == 3) ? del = cp;
                    );
                    cp += 1;
                );
            ) :
            (alg == 9) ? (
                cnt = 0;
                // change 2nd i to '1'
                while ((cp < lg) && (del < 0)) (
                    (mSL_W_idt[cp] == 'i') ? (
                        cnt += 1;
                        (cnt == 2) ? (mSL_W_idt[cp] = '1';  cg = 5;)
                    );
                    cp += 1;
                );
            ) :
            (alg == 10) ? (
                // delete a letter nearer the end
                del = 0|(3 * lg / 4); cg = 4;
            ) :
            (alg == 11) ? (
                // delete a letter near the end
                del = 0|(2 * lg / 3); cg = 5;
            ) :
            (alg == 12) ? (
                // delete a letter near the middle
                del = 0|(lg / 2);
            ) :
            (alg == 13) ? (
                // delete a letter near the start
                del = 0|(lg / 3); cg = 6;
            ) :
            (alg == 14) ? (
                // delete preceding last letter
                del = lg - 2;
            ) :
            (alg == 15) ? (
                // delete last woyel
                while (cp < lg) (
                    ((mSL_W_idt[cp] == 'a') || (mSL_W_idt[cp] == 'e') || (mSL_W_idt[cp] == 'i') ||
                        (mSL_W_idt[cp] == 'o') || (mSL_W_idt[cp] == 'u') || (mSL_W_idt[cp] == '_')) ? del = cp;
                    cp += 1;
                );
            ) :
            (alg == 16) ? (
                // exchange last with a previous one
                fl16 ? (
                    ik = lg - 1; jk = 0|(lg / 4.2);
                    // AAAA_ik3 = AAAA_ik2; AAAA_jk3 = AAAA_jk2;
                    // AAAA_ik2 = AAAA_ik1; AAAA_jk2 = AAAA_jk1;
                    ///AAAA_ik1 = AAAA_ik; AAAA_jk1 = AAAA_jk;
                    /// AAAA_ik = ik; AAAA_jk = jk;
                    ch = mSL_W_idt[ik];  mSL_W_idt[ik] = mSL_W_idt[jk];  mSL_W_idt[jk] = ch;
                    fl16 = 0; cg = 1 + ch;
                );
            ) :
            (alg == 17) ? (
                // exchange last with a previous one
                fl17 ? (
                    ik = lg - 1; jk = 0|(lg / 2.7);
                    // AAAA_ik3 = AAAA_ik2; AAAA_jk3 = AAAA_jk2;
                    // AAAA_ik2 = AAAA_ik1; AAAA_jk2 = AAAA_jk1;
                    // AAAA_ik1 = AAAA_ik; AAAA_jk1 = AAAA_jk;
                    // AAAA_ik = ik; AAAA_jk = jk;
                    ch = mSL_W_idt[ik];  mSL_W_idt[ik] = mSL_W_idt[jk];  mSL_W_idt[jk] = ch;
                    fl17 = 0; cg = 1 + ch;
                );
            );

            (del >= 0) ? (
                mSL_W_fidt[del+1] |= mSL_W_fidt[del];
                cg += 1 + mSL_W_idt[del];
                while (del < lg) (
                    mSL_W_idt[del] = mSL_W_idt[del+1];
                    mSL_W_fidt[del] = mSL_W_fidt[del+1];
                    del += 1;
                );
                lg -= 1;
            );

            (cg > 0) ? (mSL_W_idt[0] = '0' + (((mSL_W_idt[0] & 0xf) + cg) % 10););
        );

        // end of algorithm - restore capital letters
        p = 0; loop(lg,
            ch = mSL_W_idt[p];
            (mSL_W_fidt[p] && (ch >= 'a') && (ch <= 'z')) ? (
                ch = ch + 'A' - 'a';
            );
            str_setchar(#rez, p, ch, 'cu');
            p+= 1;
        );

    );
    #rez;
);



function mSL_symbol(str)
local (lg, ch, pch, code, x, y, z, s)
(
    code = 0; pch = s = 0;
    ((lg = strlen(str)) > 0) ? (
        ch = str_getchar(str, 0, 'cu');
        (((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')) || (ch == '_') || (ch == '.') || (ch == '#')) ? (
            (lg <= 8) ? (
                while ((lg > 0) && (((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z'))
                    || ((ch >= '0') && (ch <= '9')) || (ch == '_') || (ch == '.') || (ch == '#')))  (
                    ((ch >= '0') && (ch <= '9')) ? (
                        ch = ch - '0' + 1;
                    ) :
                    ((ch >= 'A') && (ch <= 'Z')) ? (
                        ch = ch - 'A' + 11;
                    ) :
                    ((ch >= 'a') && (ch <= 'z')) ? (
                        ch = ch - 'a' + 37;
                    ) :
                    (
                        ch = 63; // for _ or any other char
                    );
                    (s < 8) ? (
                        code = code * 64 + ch; s += 1;
                    );
                    lg -= 1; pch += 1;
                    ch = str_getchar(str, pch, 'cu');
                );
                while (s < 8) (
                    code = code * 64; s+= 1;
                );
            ) : (
                code = mSL_symbol2(str);
                lg = 0;
            );
        ) :
        ((ch > 0x20) && (ch < 0x7f)) ? (
            while ((lg > 0) && (ch > 0x20) && (ch < 0x7f)) (
                code = (code << 7) | ch;
                lg -= 1; pch += 1;
                ch = str_getchar(str, pch, 'cu');
            );
            code = (code << 8) | 0x40;
        ) :
        (ch >= 0x80) ? (
            // Multi byte char - other bytes follow...
            pch += 1; lg -= 1;
            ((ch & 0xE0) == 0xC0) ? (
                // a 2 bytes UNICODE char
                x = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                ch = ((ch & 0x1f) << 6) | (x & 0x3f);
            ) :
            ((ch & 0xF0) == 0xE0) ? (
                // a 3 bytes UNICODE char
                x = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                y = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                ch = ((ch & 0x0F) << 12) | ((x & 0x3F) << 6) | (y & 0x3F);
            ) :
            ((ch & 0xF8) == 0xF0) ? (
                // a 4 bytes UNICODE char
                x = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                y = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                z = str_getchar(str, pch, 'cu'); pch += 1; lg -= 1;
                ch = ((ch & 0x07) << 18) | ((x & 0x3F) << 12) | ((y & 0x3F) << 6) | (z & 0x3F);
            );
            code = (ch << 8) | 0x80;
        ) : (
            code = (ch << 8) | 0xC0;
            lg -= 1;
        );
    ) : (
        code = -1;
    );
    (lg != 0) ? code = -1;
    code;
);







// Integer returning random generator : return in [0 .. k-1]
function mSL_irand(k)
(
   k = (k<1) ? 1 : (k>2147483647) ? 2147483647 : 0|k;
   rand(2147483647)%k;
);





function irand(k)
local(r)
(
   k = (k<1) ? 1 : (k>2147483647) ?
   2147483647 : 0|k;
   //rand(2147483647)%k;
   r = rand(2147483647);
   (k < 100000) ? (r >> 4) % k : r % k;
);


// Provide more "random numbers"
//randomSeed = 1 + tStart % 55001;
//loop (randomSeed, rand(1););


//===107===//
// irand(par)
par = mSL_TOS[0];
mSL_TOS[0] = rand(2147483647)%((par<1) ? 1 : (par>2147483647) ? 2147483647 : 0|par);
//===107===//







(studDispPCnt === 4)  ? (
    ui_split_leftratio(1/4);
        genericItemsPos(TabIdt * dcbPannelsMax);
    ui_split_next(); ;
        genericItemsPos(TabIdt * dcbPannelsMax + 1);
    ui_split_next();
        genericItemsPos(TabIdt * dcbPannelsMax + 2);
    ui_split_next();
        genericItemsPos(TabIdt * dcbPannelsMax + 3);
    ui_pop();
) :
(studDispPCnt === 3)  ? (
    (ffff2 != 0) ? (
        ffff2 = 0;
        sprintf(#sx, "3 Panes: %d  %d  %d  --- %f  %f  %f ", p[0], p[1], p[2],
            max(1, p[0])/max(1, p[0] + p[1] + p[2]),
            max(1, p[1])/max(1, p[1] + p[2]), 1);
        mSL_log(SysLogBox, #sx);
    );
    ui_split_leftratio(max(1, p[0])/max(1, p[0] + p[1] + p[2]));
        genericItemsPos(TabIdt * dcbPannelsMax);
    ui_pop();
    ui_split_leftratio(max(1, p[1])/max(1, p[1] + p[2]));
        genericItemsPos(TabIdt * dcbPannelsMax + 1);
    ui_pop();
    //ui_split_leftratio(1);
        genericItemsPos(TabIdt * dcbPannelsMax + 2);
    //ui_pop();
) :
(studDispPCnt === 2)  ? (
    ui_split_leftratio(0.5);
        genericItemsPos(TabIdt * dcbPannelsMax);
    ui_split_next();
        genericItemsPos(TabIdt * dcbPannelsMax + 1);
    ui_pop();
) : (
    genericItemsPos(TabIdt * dcbPannelsMax);
);









//==========================================
// Control structures for the play log
plTInfo =  gMemFree;
gMemFree += 40;
plTpt = 7;
function plTrace(u)
(
    gmem[plTInfo +  gmem[plTInfo+plTpt] + 8] = u;
    gmem[plTInfo+plTpt] = (gmem[plTInfo+plTpt] + 1) % 32;
);
plHDStrt = gMemFree;  gMemFree += 4;
plTLStrt = gMemFree;  gMemFree += 4;
plHDEnd = gMemFree;  gMemFree += 4;
plTLEnd = gMemFree;  gMemFree += 4;

RecordHEAD = gMemFree;  gMemFree += 8;
RecordTAIL = gMemFree;  gMemFree += 8;
FreeHEAD = gMemFree;  gMemFree += 8;
FreeTAIL = gMemFree;  gMemFree += 8;

plocksize = 8;
idx = -1;
plockidt = (idx += 1); // 'fsnd'
plockfwd = (idx += 1); // pointer to next frozen sound
plockbwd = (idx += 1); // pointer to previous frozen sound
plockstrt = (idx += 1); // date of start of sound (seconds, decimal)
plockdur = (idx += 1); // duration of sound (seconds, decimal)
plockfskod = (idx += 1); // code of the FS [index : 32 bits, position : 16 bits]
plockflgs = (idx += 1); // associated flags (solo, mute, etc.)
plockdelta = (idx += 1); // delta time for start of sound


// Play log area
playLogHdrSize = 0; // 16; // Size of the header
playLogESize = RCB_Size + playLogHdrSize;
playLogStrt = gMemFree;
playLogEcnt = 65536; // 20000; //  100; // during the tests 8192;
playLogMaxCnt = 0|((gmemLimit - gMemFree - 16) /playLogESize);
playLogSize = playLogESize * playLogEcnt;
gMemFree = playLogLimit = playLogStrt +  playLogSize;
plLastInserted = plHDStrt;
XPoint = playLogStrt;

gmem[plTInfo+0] = 'Info';
gmem[plTInfo+1] = playLogStrt;
gmem[plTInfo+2] = playLogSize;
gmem[plTInfo+3] = playLgoLimit;
gmem[plTInfo+4] = 0;
gmem[plTInfo+5] = 0;
gmem[plTInfo+6] = 0;
gmem[plTInfo+7] = 0;

plFwd = 0; // forward pointer
plBwd = 1; // backward pointer
plVal = 2; // associated value
plBpt = 3; // block pointer
plStrt = 4; // position of Start pointer
plEndp = 8; // position of End pointer
plEUId = 1; // play "unique" Id
plURef = 2; // player unit reference





// Initialize to "nil" a play back entry
function plLBclear(q)
local (i, add)
(
    add = playLogStrt + q * playLogESize;
    i=add; loop(playLogHdrSize, gmem[i] = -1; i += 1;);
    gmem[add] = plIDNT; gmem[add+1] = q; gmem[add+3] = 0;
    gmem[add+7] = -4; gmem[add+11] = -8; gmem[add+15] = -12;
    add;
);


// Check a play block, returns its address or 0
function plChckEnt(baddr)
(
    ((baddr >= playLogStrt) && (baddr < playLogLimit)) ? (
        (gmem[baddr] === plIDNT) ? (
            baddr;
        ) :
        (gmem[baddr - playLogHdrSize] === plIDNT) ? (
            baddr - playLogHdrSize;
        ) :
        (gmem[baddr - plStrt] === plIDNT) ? (
            baddr - plStrt;
        ) :
        (gmem[baddr - plEndp] === plIDNT) ? (
            baddr - plEndp;
        ) : (
            0;
        );
    ) : (
        0;
    );
);


// Unchain a double linked entry
// "q" has been verified.
function plUnch(q)
local(p, r)
(
    (((p = gmem[q+plBwd]) > 0) && ((r = gmem[q+plFwd]) > 0)) ? (
        gmem[p+plFwd] = r; gmem[r+plBwd] = p;
        gmem[q+plFwd] = gmem[q+plBwd] = -1;
    );
);

// Remove a play block from its chain
function plRemove(plent)
local(baddr)
(
    (baddr = plChckEnt(plent)) ? (
        // now a true/correct address
        plUnch(baddr+plStrt); // remove from 1st chaining
        plUnch(baddr+plEndp); // remove from 2nd chaining
    );
    baddr; // return correct address
);



// Insert "q" in a correct position around "point"
// pointers have been verified
function plInsrt(q, point)
local(p,r,vq,vp,vr)
(
    vq = gmem[q+plVal]; // the value to compare
    // start with point and its successor
    p = point; vp = gmem[p+plVal];
    (vq >= vp) ? (
        r = gmem[p+plFwd]; vr = gmem[r+plVal];
        // may insert after p.
        while (vq >= vr) (
            // advance
            p = r; vp = vr; r = gmem[p+plFwd]; vr = gmem[r+plVal];
        );
    ) : (
        r = p; vr = vp; p = gmem[r+plBwd]; vp = gmem[p+plVal];
        while (vq < vp) (
            // go back
            r = p; vr = vp; p = gmem[r+plBwd]; vp = gmem[p+plVal];
        );
    );
    // Insert q between p and r
    gmem[p+plFwd] = q; gmem[q+plBwd] = p;
    gmem[r+plBwd] = q; gmem[q+plFwd] = r;
    XPoint = p + gmem[p+plBpt]; // an appropriate "Xpoint"
);


// Reinsert a bloc in its appropriate location, based on a neighborough
function plBReinsert(bloc, voisin)
local(badd,loneibc)
(
    ((baddr = plChckEnt(bloc)) && ((neib = plChckEnt(voisin)) )) ? (
        plInsrt(baddr+plStrt, neib+plStrt);
        plInsrt(baddr+plEndp, neib+plEndp);
    ) : (
        plTrace(6600); plTrace(bloc);  plTrace(voisin);  // A real error !
    );
);

// "Reallocate" the most ancien entry for a new clip
function plBlReallocate()
local (k)
(
    k = gmem[plHDStrt]; // first in the chain
    plRemove(k);
);

function SLCheckAdd(add)
local (k)
(
    k = 0;
    (add > 0) ? (
        k = add[plockidt];
    ) :
    (add < 0) ? (
        k = gmem[-add + plockidt];
    ) ;
    (k == plIDNT) || (k == 'HEAD') || (k == 'TAIL') ;
);


function SLPutAfter(add, list)
local (next, z)
(
    // put "add" after "list"
    z = 0;
    (SLCheckAdd(add) && SLCheckAdd(list)) ? (
        (list > 0) ? ( next = list[plockfwd]; ) : ( next = gmem[-list + plockfwd]; );
        SLCheckAdd(next) ? (
            (list > 0) ? ( list[plockfwd] = add; ) : ( gmem[-list + plockfwd] = add; );
            (next > 0) ? next[plockbwd] = add : gmem[-next + plockbwd] = add;
            (add > 0) ? (
                add[plockfwd] = next;  add[plockbwd] = list;
            ) : (
                gmem[-add + plockfwd] = next; gmem[-add + plockbwd] = list;
            );
            z = 1;
        );
    );
    z;
);


function SLPutBefore(add, list)
local (prev, z)
(
    // put "add" before "list"
    z = 0;
    (SLCheckAdd(add) && SLCheckAdd(list)) ? (
        (list > 0) ? ( prev = list[plockbwd]; ) : ( prev = gmem[-list + plockbwd]; );
        SLCheckAdd(prev) ? (
            (list > 0) ? ( list[plockbwd] = add; ) : ( gmem[-list + plockbwd] = add; );
            (prev > 0) ? prev[plockfwd] = add : gmem[-prev + plockfwd] = add;
            (add > 0) ? (
                add[plockbwd] = prev;  add[plockfwd] = list;
            ) : (
                gmem[-add + plockbwd] = prev; gmem[-add + plockfwd] = list;
            );
            z = 1;
        );
    );
    z;
);

// Initialize all
function plBlInitChain()
local (ii)
(
    // create correct blocks
    gmem[plHDStrt+plFwd] = plTLStrt; gmem[plHDStrt+plBwd] = -1;
    gmem[plHDStrt+plVal] = - 0x7fffffff; gmem[plHDStrt+plBpt] = 0; // -2147483648
    gmem[plTLStrt+plBwd] = -1; gmem[plTLStrt+plBwd] = plHDStrt;
    gmem[plTLStrt+plVal] = 0x7fffffff; gmem[plTLStrt+plBpt] = 0;   // 2147483648
    gmem[plHDEnd+plFwd] = plTLEnd; gmem[plHDEnd+plBwd] = -1;
    gmem[plHDEnd+plVal] = - 0x7fffffff; gmem[plHDEnd+plBpt] = 0; // -2147483648
    gmem[plTLEnd+plBwd] = -1; gmem[plTLEnd+plBwd] = plHDEnd;
    gmem[plTLEnd+plVal] = 0x7fffffff; gmem[plTLEnd+plBpt] = 0;   // 2147483648
    // initialize blocks to a -1 time pointer
    ii = 0; loop(playLogEcnt,
        add = plLBclear(ii);
        plInsrt(add + plStrt, plTLStrt);
        plInsrt(add + plEndp, plTLEnd);
        ii += 1;
    );
);

/*
function plBlInitChain()
local (ii)
(
    // Recording Head
    gmem[RecordHEAD+plockidt] = 'HEAD';
    gmem[RecordHEAD+plockfwd] = RecordTAIL;
    gmem[RecordHEAD+plockbwd] = 0;
    gmem[RecordHEAD+plockstrt] = -2;
    gmem[RecordHEAD+plockdur] = 0;
    gmem[RecordHEAD+plockfskod] = 0;
    gmem[RecordHEAD+plockflgs] = 0;
    gmem[RecordHEAD+plockdelta] = 0;
    // Recording tail
    gmem[RecordTAIL+plockidt] = 'TAIL';
    gmem[RecordTAIL+plockfwd] = 0;
    gmem[RecordTAIL+plockbwd] = RecordHEAD;
    gmem[RecordTAIL+plockstrt] = 0x7fffffff;
    gmem[RecordTAIL+plockdur] = 0;
    gmem[RecordTAIL+plockfskod] = 0;
    gmem[RecordTAIL+plockflgs] = 0;
    gmem[RecordTAIL+plockdelta] = 0;
    // Free Head
    gmem[FreeHEAD+plockidt] = 'HEAD';
    gmem[FreeHEAD+plockfwd] = FreeTAIL;
    gmem[FreeHEAD+plockbwd] = 0;
    gmem[FreeHEAD+plockstrt] = -2;
    gmem[FreeHEAD+plockdur] = 0;
    gmem[FreeHEAD+plockfskod] = 0;
    gmem[FreeHEAD+plockflgs] = 0;
    gmem[FreeHEAD+plockdelta] = 0;
    // Free tail
    gmem[FreeTAIL+plockidt] = 'TAIL';
    gmem[FreeTAIL+plockfwd] = 0;
    gmem[FreeTAIL+plockbwd] = FreeHEAD;
    gmem[FreeTAIL+plockstrt] = 0x7fffffff;
    gmem[FreeTAIL+plockdur] = 0;
    gmem[FreeTAIL+plockfskod] = 0;
    gmem[FreeTAIL+plockflgs] = 0;
    gmem[FreeTAIL+plockdelta] = 0;
    // initialize blocks to a -1 time pointer
    ii = 0; loop(playLogEcnt,
        add = plLBclear(ii);
        SLPutAfter(add, FreeHEAD);
        ii += 1;
    );
);
*/






/*
    Create the data structure

    first, compute the needed size for some specific "entrycount"

function SchedNeeded()
(
    SchedNEmax = min(8192, max(128, 0|SchedNEmax));
    SchedNeeds = SchedLstCnt * SchedLstSiz +  SchedNEmax * SchedEntSiz + SchedLstCnt ; // what we need
);

// Then provide some memory for the structures and build them
function SchedSetup(mem, size)
local (cr, i)
(
    Sched_TStart = time_precise() + gmem[timeDelta];
    Sched_TimeLast = Sched_TimeNow = 0;
    (cr = (size == SchedNeeds)) ? (
        // we have the memory we need
        memset(mem, 0, SchedNeeds); // Clear the area
        SchedLPtrs = mem; mem += SchedLstCnt;
        SchedLPtrs[0] = SchedFreePts = SchedInitHQB(mem, 'Free'); mem += SchedLstSiz; // Head & Tail of free list
        SchedLPtrs[1] = SchedDlydPts = SchedInitHQB(mem, 'Dlay'); mem += SchedLstSiz; // H&T of waiting process list
        SchedLPtrs[2] = SchedActivPts = SchedInitHQB(mem, 'Actv'); mem += SchedLstSiz; // H&T of active process list
        SchedLPtrs[3] = SchedInactPts = SchedInitHQB(mem, 'Fthr'); mem += SchedLstSiz; // H&T of inactive threads
        SchedLPtrs[4] = SchedEvntPts = SchedInitHQB(mem, 'Wait'); mem += SchedLstSiz; // H&T of waiting processes
        SchedLPtrs[5] = SchedSuspPts = SchedInitHQB(mem, 'Pndg'); mem += SchedLstSiz; // H&T of suspended processes
        SchedLPtrs[6] = SchedLockdPts = SchedInitHQB(mem, 'Lckd'); mem += SchedLstSiz; // H&T of Locked mSL processes
        SchedLPtrs[7] = SchedRcyclPts = SchedInitHQB(mem, 'Rcyc'); mem += SchedLstSiz; // H&T of temporary processes
        SchedDelay = 0;
        SchedDlydTailPts = SchedDlydPts + 4; // position of the tail
        // An entry number is always > 0
        SchedFirstEnt = mem; // @ of first entry
        SchedLastEnt = mem + SchedEntSiz * (SchedNEmax-1); // @ of last entry
        i = 0; loop (SchedNEmax,  // start counting at 0
            SchedInsertTail(SchedFreePts, mem, SchETypeThrd);
            mem[SchedEntryN] = i; // the entry number
            mem[SchedThrName] = 'Thrd'; // a default identification
            SchedInitHQB(mem+SchedHQB, 'Evnt'); // and the local HQB
            mem += SchedEntSiz; i+= 1;
        );
    );
    cr;
);
*/

//*/
/*/
function SchedSetup()
local (i, ent)
(
    Sched_TStart = time_precise() + gmem[timeDelta];
    Sched_TimeLast = Sched_TimeNow = 0;
    // Create permanent lists
    SchedLPtrs = make_array(SchedLstCnt); // The array of lists
    i=0; loop(SchedLstCnt,
        SchedLPtrs[i] = make_array(SchedLstSiz, 'list');
        i += 1;
    );
    // Some lists have names
    SchedFreePts = SchedLPtrs[0]; SchedInitHQB(SchedFreePts, 'Free');
    SchedDlydPts = SchedLPtrs[1]; SchedInitHQB(SchedDlydPts, 'Dlay'); SchedDlydTailPts = SchedDlydPts + 4; // position of the tail
    SchedActivPts = SchedLPtrs[2]; SchedInitHQB(SchedActivPts, 'Actv');
    SchedInactPts = SchedLPtrs[3]; SchedInitHQB(SchedInactPts, 'Fthr');
    SchedEvntPts = SchedLPtrs[4]; SchedInitHQB(SchedEvntPts, 'Wait');
    SchedSuspPts =  SchedLPtrs[5]; SchedInitHQB(SchedSuspPts, 'Pndg');
    SchedLockdPts = SchedLPtrs[6]; SchedInitHQB(SchedLockdPts, 'Lckd');
    SchedNxtBlPts = SchedLPtrs[7]; SchedInitHQB(SchedNxtBlPts, 'DlNx');
    SchedRcyclPts = SchedLPtrs[8]; SchedInitHQB(SchedRcyclPts, 'Rcyc');
    SchedInitHQB(SchedLPtrs[9], 'undf');
    SchedInitHQB(SchedLPtrs[10], 'undf');
    SchedInitHQB(SchedLPtrs[11], 'undf');
    SchedInitHQB(SchedLPtrs[12], 'undf');
    SchedInitHQB(SchedLPtrs[13], 'undf');
    SchedInitHQB(SchedLPtrs[14], 'undf');
    SchedInitHQB(SchedLPtrs[15], 'undf');
    SchedDelay = 0;
    // Create tasks - All tasks are contiguous in memory
    SchedArea = mSL_StM_FreePt;
    SchedFirstEnt = SchedArea + 2; // @ of first entry
    SchedLastEnt = SchedFirstEnt + SchedEntSiz * (SchedNEmax-1); // @ of last entry
    i=0; loop(SchedNEmax,
        ent = make_array(SchedEntInSiz, 'task');
        ent[SchedEntryN] = i; // the entry number
        ent[SchedThrName] = 'Thrd'; // a default identification
        SchedInitHQB(ent+SchedHQB, 'Evnt'); // and the local HQB
        SchedInsertTail(SchedFreePts, ent, SchETypeThrd); // insert entry in free list
        i+= 1;
    );
);

//*/



function SchedSetup()
local (i, ent, mm, idx)
(
    Sched_TStart = time_precise() + gmem[timeDelta];
    Sched_TimeLast = Sched_TimeNow = 0;
    SchedDelay = 0;
    i = 0; while (((mSL_StM_FreePt + 2 + i) % 8) != 0) (i+= 1;);
    SchedArea = mm = make_array(ListSzmax * 8 + i, 'LSTS'); // a large block, zeroed
    // Align to a frontier of 8
    while (i > 0) (mm[0] = 'fill'; mm += 1; i -= 1;);
    // Create permanent lists
    SchedLElSizes = mm; mm += SchedLstCnt; // Space for list elements sizes
    SchedLPtrs = mm; mm += SchedLstCnt; // Space for list heads
    i = 0;
    loop (SchedLstCnt,
        SchedLPtrs[i] = mm; SchedLElSizes[i] = 0; mm += SchedLstSiz; i += 1;
    );
    // Some lists have names
    idx = -1;
    SchedFreePts = SchedLPtrs[idx = 0]; SchedInitHQB(SchedFreePts, 'Free'); SchedLElSizes[idx] = 24;
    SchedDlydPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedDlydPts, 'Dlay'); SchedLElSizes[idx] = 24;
    SchedDlydTailPts = SchedDlydPts + 4; // position of the tail
    SchedActivPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedActivPts, 'Actv'); SchedLElSizes[idx] = 24;
    SchedInactPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedInactPts, 'Fthr'); SchedLElSizes[idx] = 24;
    SchedEvntPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedEvntPts, 'Wait'); SchedLElSizes[idx] = 24;
    SchedSuspPts =  SchedLPtrs[idx += 1]; SchedInitHQB(SchedSuspPts, 'Pndg'); SchedLElSizes[idx] = 24;
    SchedLockdPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedLockdPts, 'Lckd'); SchedLElSizes[idx] = 24;
    SchedNxtBlPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedNxtBlPts, 'DlNx'); SchedLElSizes[idx] = 24;
    SchedRcyclPts = SchedLPtrs[idx += 1]; SchedInitHQB(SchedRcyclPts, 'Rcyc'); SchedLElSizes[idx] = 24;
    PlLogFree = SchedLPtrs[idx += 1]; SchedInitHQB(PlLogFree, 'PLFR'); SchedLElSizes[idx] = 8;
    PlLogMain = SchedLPtrs[idx += 1]; SchedInitHQB(PlLogMain, 'PLLM'); SchedLElSizes[idx] = 8;
    // Some lists, (now empty) with various elements in them
    ListCellAllocs  = idx + 1;
    ListCell008 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell008, 'C008'); SchedLElSizes[idx] = 8; // k = 0
    ListCell016 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell016, 'C016'); SchedLElSizes[idx] = 16;// k = 1
    ListCell024 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell024, 'C024'); SchedLElSizes[idx] = 24;// k = 2
    ListCell032 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell032, 'C032'); SchedLElSizes[idx] = 32;// k = 3
    ListCell080 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell080, 'C080'); SchedLElSizes[idx] = 80;// k = 4
    ListCell128 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell128, 'C128'); SchedLElSizes[idx] = 128;// k = 5
    ListCell512 = SchedLPtrs[idx += 1]; SchedInitHQB(ListCell128, 'C512'); SchedLElSizes[idx] = 512;// k = 6
    ListCellMax = idx - ListCellAllocs;
    i = idx + 1;
    while (i < SchedLstCnt) (
        SchedInitHQB(SchedLPtrs[i], 'undf'); i += 1;
    );
    SchedFirstEnt = mm;
    SchBlcksEnd = SchedArea + SchedArea[-1]; // first non allocatable
    SchedLastEnt = SchBlcksEnd - 8;
    // Create tasks - All tasks are contiguous in memory and use SchedEntSiz words
    i = 0; loop(SchedNEmax,
        ent = mm;
        ent[SchedEntryN] = i; // the entry number
        ent[SchedThrName] = 'Thrd'; // a default identification
        SchedInitHQB(ent+SchedHQB, 'Evnt'); // and the local HQB
        SchedInsertTail(SchedFreePts, ent, SchETypeThrd); // insert entry in free list
        i += 1;
        mm += SchedEntSiz;
    );
    // Create a first set of 8 cells words
    loop (8192,
        SchedInsertTail(ListCell008, mm, 0); mm += 8;
    );
    SchBlcksStart = mm; // first allocatable
//    sprintf(#dbg_trace4, "LSTS: [%d   %d   %d]", SchedArea, SchBlcksStart, SchBlcksEnd);
//  sprintf(#dbg_trace5,"FREE TASKS: %d (%d/%d) ", SchedListSize(SchedFreePts), SchedListNonEmpty(SchedFreePts), SchedListEmpty(SchedFreePts));
//  sprintf(#dbg_trace6,"FREE CELLS: %d (%d/%d) ", SchedListSize(ListCell008), SchedListNonEmpty(ListCell008), SchedListEmpty(ListCell008));
//  sprintf(#dbg_trace7,"Unused TASKS: %d (%d/%d) ", SchedListSize(SchedInactPts), SchedListNonEmpty(SchedInactPts), SchedListEmpty(SchedInactPts));

);





(zz & ui_jpad_ev_lmc) ? (  // left mouse clic
pp = clTab[zzmcl];
(pp > 0) ? (

    sprintf(#sfc, "key = %d  ->  Item = %d [%.3f  - %d -  %.3f]", zzmcl, pp, pp[7], pp[5], pp[6]); mSL_log(SysLogBox, #sfc);
    /*
    flPl = 0;
    (jmc & bctrlKey) ? SchedAddTask(5, 2, 0, 0, 0, 0, 0); // when 'ctrl' key, unlock all existing items
    (jmc & (bctrlKey|bcmdKey)) ? flPl = 1; // 'ctrl' or 'cmd' to lock new created items
    ((jmc & (bcmdKey|baltKey)) === (bcmdKey|baltKey)) ? (
        while (pp[0] >= 0) (
            ii = pp[0] ; pp += 1;
            zi = (ii % playLogEcnt) * playLogESize + playLogStrt; // Point to actual entry
            ((ii = gmem[zi + plStrt + plVal]) < da) ? ( da = ii; );
        );
        // now, restart playing from this date
        playRMode = playRModePlay;
        pTimeCurrent = pTimeRPlayd = da - 0.1;
        parSet(p_VirtualTime, pTimeCurrent);
    ) : (
        while (pp[0] >= 0) (
            ii = pp[0] ; pp += 1;
            zi = (ii % playLogEcnt) * playLogESize + playLogStrt; // Point to actual entry
            (ii === gmem[zi + plEUId]) ? (
                // doPlayRItem(ii, flPl); //
                SchedAddTask(12, ii, flPl, 0, 0, 0, 0);

                sprintf(#sfc, "key = %d  ->  Item = %d [%4d]", zzmcl, ii, gmem[zi + RCB_ClipNb]); mSL_log(SysLogBox, #sfc);
            ) : (
                sprintf(#sfc, "key = %d  ->  # = %d, new = %d", zzmcl, ii, gmem[zi + plEUId]); mSL_log(SysLogBox, #sfc);

            );
        );
    );
    */
);
);





            // Should we reinsert the player in its time-line ?

            (gmem[Uxa+RCB_Rec_Flag]) ? (
                gmem[Uxa+RCB_Rec_Flag] = 0; // will be done
                // is the block "really" unchained ?
                pp = gmem[Uxa+RCB_Rec_Entry]; // The address
                ((pp >= playLogStrt) && (pp < playLogLimit) && (gmem[pp] === plIDNT)
                        && (gmem[pp+plStrt+plFwd] === -1) && (gmem[pp+plStrt+plBwd] === -1)) ? (
                    // First, update the values of start and end time
                    gmem[pp+plStrt+plVal] = gmem[Uxa+RCB_Rec_Time];
                    gmem[pp+plEndp+plVal] = gmem[Uxa+RCB_Rec_Last];

                    sprintf(#s, "—> Rechain %d/%d[%04d]   %.1f %.1f @ %d" , pp, gmem[pp+1],
                         gmem[Uxa+RCB_ClipNb], gmem[Uxa+RCB_Rec_Time], gmem[pp+plStrt+plVal], pp+plStrt+plVal);
                    mSL_log(SysLogBox, #s);

                    plBReinsert(pp, gmem[plTLStrt + plBwd]);


                    sprintf(#s, "—> Rechain %d/%d[%04d] %.3f @ %d" , pp, gmem[pp+1],
                         gmem[Uxa+RCB_ClipNb], gmem[pp+plStrt+plVal], pp+plStrt+plVal);
                    mSL_log(SysLogBox, #s);

                ) : (
                    sprintf(#s, "—> Rechain error: %d   [%04d]", pp, gmem[Uxa+RCB_ClipNb]);
                    mSL_log(SysLogBox, #s);
                );
            );









lstrt = time_precise() + timeD;
XeSched = 1; // set to 1 to make sure we execute at least 1 task during each @block execution
//============ GLOBAL Interpreter ==============
while (SchedActive &&
    ((((TLeft = ptBlockLimit - (gstrt = time_precise() + timeD)) > TLeftMin)) || XeSched) &&
    ((SchX = SchedDetachHead(SchedActivPts)) != SchedNone))
(
    // Get some parameters
    // Execute the action
    XeSched = 0;
    xop = SchedCode[SchX];   // actually, only 1 to 13 are being used
    curr_Proc_PID = SchedPid[SchX]; // current process ident
    curr_Proc_Name = SchedThrName[SchX]; // current process name
    mSL_xop_cnt = (mSL_xop_cnt + 1) % 1000000;



    //++++++++++++++++++++++++++++++++++++


    (xop<10)?((xop<5)?((xop<2)?((xop<1)?(

        //++++0++++//
        0;
        //++++0++++//

    ):(

        //++++1++++//
        // Play one of the exec pad / auto play
        // replaces "doPlayCmd"
        KSource = ActPar1 = SchedPar1[SchX]; // unmodified source
        cmdCurrPar = SchedPar2[SchX]; // 2nd parameter
        (SchedPar3[SchX] != Undef) ? ( GvPlayCl0 = SchedPar3[SchX]; );
        (SchedPar4[SchX] != Undef) ? ( GvPlayPart = SchedPar4[SchX]; );
        KpFlags = ActPar1 & MskdoKeepHgFlgs;
        Kmnd = ActPar1 & MskdoKeepKmnd;
        // First, rebuild partial entry 0
        memset(BKTab, 0, BKEsize);
        BKTab[idx_Grp] = GvPlayGrp;
        BKTab[idx_Bnk] = GvPlayBnk;
        BKTab[idx_Clps] = GvPlayCl1;
        BKTab[idx_Clps+1] = GvPlayCl2;
        BKTab[idx_PlM] = GvPlayPM;
        BKTab[idx_SpM] = GvPlaySM;
        BKTab[idx_PWeight] = 1;
        Kptyp = Krtc = 0;

        (FlagsTbVals[Flgs_Pdbg] & 1) ? (
            b = BKTab;
            sprintf(#s2, "**P[%X]  %d %d %d %d --- %d %d %d %d --- %d %d %d %d",
                ActPar1, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11]);
            mSL_log(SysLogBox, #s2);
        );

        // Is there a "pad to play" ?
        ((Kmnd >= cmdPadBase) && (Kmnd < (cmdPadBase + padStTotSiz))) ? (
            Kmnd -= cmdPadBase;
            // KpFlags are the high bits from the command
            Krtc = 0;
            KbtpPlayed = Kmnd;
            Kpart = padStPVals[Kmnd]; // base Partial
            Kselect = pACinP; // play any clip from partial as default
            (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
            // (Kvu5 != padStDispNone) ? (
            Kvuu = (Kvu0 = padStPVals[Kmnd] % BKEcnt) * BKEsize; // Kvu0 : n° partiel
            Kvu4 = BKTab[Kvuu + idx_Clps]; // first clip of range
            // which mode are we using ?
            Kvu5 = padStFlags[Kmnd] & padStFlDspM;
            (Kvu5 === padStDispPar) ? (
                // we want to play a specific partial
                Kselect = pACinP; // the clip we want to play
            ) :
            (Kvu5 === padStDispGrp) ? (
                Kselect = pACinG; // any clip from the group of the partiel
            ) :
            (Kvu5 === padStDispGBk) ? (
                Kselect = pACinB; // any clip from bank and group of the partiel
            ) :
            (Kvu5 === padStDispRng) ? (
                Kselect = padStClipsL[Kmnd]; // the 1st clip of the range we want to play
                KpFlags |= abs(padStClipsH[Kmnd] - padStClipsL[Kmnd]); // the range
            ) :
            (Kvu5 === padStDispClip) ? (
                // we want to play a specific clip
                Kselect = padStClipsL[Kmnd]; // the clip we want to play
                Kptyp = GvPlayTypClip;
            ) :
            (Kvu5 === padStDispAct) ? (
                Kselect = Kpart; // we have an action to perform
                Kpart = -1; // nothing to play
                //
                m = padStClipsL[Kmnd]; p = q = r = 0;
                // temporary, accept various commands...
                ((m >= 1) && (m <= 7)) ? (
                    // change global volume
                    (m === 1) ? (q = -120; ) :
                    (m === 2) ? (q = paramValues[p_Vol_MinVal]; ) :
                    (m === 3) ? (q = paramValues[p_Vol_MaxVal]; ) :
                    (m === 4) ? (q = -3; ) :
                    (m === 5) ? (q = 0; ) :
                    (m === 6) ? (q = 3; ) :
                    (m === 7) ? (q = 6; ) ;
                    // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
                    // gmem[commonGlobalVolume] = 10 ^ (q/20); // convert as a number
                    parSet(p_Vol_Global, q);
                    // parSet(p_VolGlobBias, 9);
                );
                (p != 0) ? (
                    SchedAddTask(p, q, r, s, t, 0, 0);
                );
            ) :
            (Kvu5 === padStDispSpec) ? (
                // we want to have a specific MIDI action to send
                Kselect = padStClipsL[Kmnd]; // the clip we want to play
                Kptyp = GvPlayTypClip;
            ) : (
                Kpart = -1; // nothing to play
            );
            (Kpart >= 0) ? (
                padStErrors[Kmnd] = Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp); // keep err. return
            );
            // );
            // return code from playing ?
            (Krtc != 0) ? (
                KbtpLast = Kmnd;
                padStFlags[Kmnd] = padStFlags[Kmnd] | padStFlErrbit;
                StdnumLastM = lastTime; StdnumUnchkd = 16;
            ) : (
                padStFlags[Kmnd] = padStFlags[Kmnd] & padStFlMsk7;
            );
            // StdnumLastM = lastTime; StdnumUnchkd = 16;
            ui_GFXdoNow |= 2;
            ui_GFXReason = 12;
        ) :

        // A play command in a specific mode ?
        ((Kmnd >= cmdClMdBase) && (Kmnd < (cmdClMdBase + 16))) ? (
            Kmnd -= cmdClMdBase;
            // play from a specific setting
            Kselect = pACinP;
            Kpart = 0;
            // select command according to current mode
            (Kmnd === GvPlayTypGrPlay) ? (
                // play a player from the "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd === GvPlayTypGrLoop) ? (
                // play a looper from the "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd === GvPlayTypGroup) ? (
                // play "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd === GvPlayTypBank) ? (
                // play "bank"
                Kselect = pACinB;
                // Kpart = 0;
            ) :
            (Kmnd === GvPlayTypPartial) ? (
                // play this "partial"
                Kselect = pACinP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd === GvPlayTypClip) ? (
                // play "clip"
                Kselect = GvPlayCl0;
                Kpart = GvPlayPart;
                Kptyp = GvPlayTypClip;
            ) :
            (Kmnd === GvPlayTypRange) ? (
                // play "Range"
                Kselect = pACinSwP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd === GvPlayTypAnyClip) ? (
                // play "Any clip"
                Kselect = pACinWwP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd === GvPlayTypAnyBank) ? (
                // play "Any clip from a partial"
                Kselect = pACinRP;
            ) :
            (Kmnd === GvPlayClipClicked) ? (
                // play "clip"
                Kselect = GvPlayCl3;
                Kpart = GvPlayPart;
            ) : (
                // This is an error
                GvErr = 0500;
            ) ;
            // AAAA_doPlaycnt += 1;
            (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
            (FlagsTbVals[Flgs_Pdbg] & 2) ? (
                sprintf(#s2, "**Q[%X]  Kpa:%d  Kse:%d  KpF:%X  Kty:%d",
                            Kmnd, Kpart, Kselect, KpFlags, Kptyp);
                mSL_log(SysLogBox, #s2);
            );
            Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp);
            // (Krtc != 0) ? AAAA_Krtccnt += 1;
        );

        // Otherwise, ignore the command
        Kmnd = -1;

        //++++1++++//

    );):((xop<3)?(

        //++++2++++//
        // Random Change global volume
        m = (paramValues[p_Vol_MaxVal] + paramValues[p_Vol_MinVal]) / 2;
        p = (10 + paramValues[p_Vol_VariVal])/90;
        u = (paramValues[p_Vol_MaxVal] - paramValues[p_Vol_MinVal]) / 2;
    AAAAAAAA_p = p;
        (frand() > 0.5) ? (
            x = frand(); m += x * x * p * 1.5 * u;
        ) : (
            m -= frand() * p * 1.1 * u;
        );
    AAAAAAAA_m = m;
        m = max(paramValues[p_Vol_MinVal], min(paramValues[p_Vol_MaxVal], m));
        // gmem[commonGlobalVolume] = 10 ^ (m/20); // convert as a number
        // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
        parSet(p_Vol_Global, m);
        // parSet(p_VolGlobBias, 9);
        //++++2++++//

    ):((xop<4)?(

        //++++3++++//
        // OP 3 : Set a parameter
        parSet(SchedPar1[SchX], SchedPar2[SchX]);
        //++++3++++//

    ):(

        //++++4++++//
        // Switch to next group - or more
        m = 0|(1 + (paramValues[p_Grp_VariVal] / 8));
        GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', GvPlayGrp + m, 0);
        //++++4++++//

    );););):((xop<7)?((xop<6)?(

        //++++5++++//
        // OP 5 : Modify Some/ALL players status
        // p1 === 0 : do nothing
        // p1 === 1 : lock all & set flags to p2
        // p1 === 2 : unlock all & reset flags
        // p1 === 3 : toggle lock p2/p3
        // p1 === 4 : unlock p2/p3
        // p1 === 5 : solo p2/p3
        // p1 === 6 : mute/unmute p2/p3
        // p1 === 7 : stop p2/p3
        // p1 === 8 : unlock p2/p3
        xopKmd = (ActPar1 = SchedPar1[SchX]) & 0xff; // actual op code
        Actpar2 = SchedPar2[SchX];
        Actpar3 = SchedPar3[SchX];
        Actpar4 = SchedPar4[SchX];
        xopFlgs = ActPar1 & 0xffff00; // addtl. flags
        xopFlgs & ActFlg1 ? parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
        msk = uid = pid = 0;
        AAAAAAAA_Task5_1 = ActPar1;
        loop (uCnt,
            Un = UGAddr + UCBSize * uid;
            pid = gmem[Un+cbPadUnitIdt]; // the ID of the pad
            (((ty = gmem[Un+cbType]) === uPlayer)
            && ((st = gmem[Un+cbStat]) === uSBusy)
            && (((pm = gmem[Un+RCB_cbCKmd]) === KmdPlay) || (pm === KmdLoop))) ? ( // L=>C
                (xopKmd === 1) ? ( // lock and set all to p2
                    gmem[Un+RCB_ClipLoop] = LockSet = Actpar2;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                (xopKmd === 2) ? ( // unlock all
                    gmem[Un+RCB_ClipLoop] = LockSet = 0;
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                ((xopKmd === 3) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // toggle lock p2/p3
                    (gmem[Un+RCB_ClipLoop] & 1) ? (
                        gmem[Un+RCB_ClipLoop] = 0;
                        padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    ) : (
                        gmem[Un+RCB_ClipLoop] |= 1;
                        padUCells[pid] |= ui_jpad_ct_selec;
                    );
                    msk = i_dB;
                ) :
                ((xopKmd === 4) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // unlock p2/p3
                    gmem[Un+RCB_ClipLoop] = 0;
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                (xopKmd === 5) ? (
                    // solo p2/p3
                    padUCells[pid] |= ui_jpad_ct_selec;
                    gmem[Un+RCB_ClipLoop] =
                        ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3)) ? 1 : 3;
                    msk = i_dB;
                ) :
                ((xopKmd === 6) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // toggle mute p2/p3
                    AAAAAAAA_pid = pid;
                    gmem[Un+RCB_ClipLoop] = (gmem[Un+RCB_ClipLoop] & 2) ? 1 : 3;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                    // padUCells[0] |= ui_jpad_ct_selec;
                ) :
                ((xopKmd === 7) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    gmem[Un + RCB_Kmd] = KmdQStop; // send stop command
                ) :
                (xopKmd === 8) ? (
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                    ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                        // Set play volume to Actpar4
                        gmem[Un+RCB_StdVol] = Actpar4;
                        msk = i_dB;
                    );
                ) :
                (xopKmd === 9) ? (
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                    ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                        // Set play volume bias to Actpar4
                        parSet(p_VolGlobBias, Actpar4);
                        gmem[Un+RCB_VolBias] =  gmem[gVolBias];
                        msk = i_dB;
                    );
                ) :
                ((xopKmd === 10) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // lock p2/p3
                    gmem[Un+RCB_ClipLoop] |= 1;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                );
                gmem[Un+RCB_State_Changed]  |= 0 | msk;
            );
            uid += 1;
        );
        //++++5++++//

    ):(

        //++++6++++//
        // random play one clip of current group
        doPlayCmd(cmdClMdBase + GvPlayTypGroup);
        //++++6++++//

    );):((xop<8)?(

        //++++7++++//
        // everybody play reverse !
        parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
        doReader(-1, KmdSpF1, 1);
        //++++7++++//

    ):((xop<9)?(

        //++++8++++//
        // Stop play
        parSet(p_GvAutoMd, 0); // paramValues[p_GvAutoMd] = 0;
        // clearCmd();
        doReader(-1, KmdQStop); BPLSTClear();
        //++++8++++//

    ):(

        //++++9++++//
        // Random change max generators
        m = paramValues[p_Gen_MaxCnt] / 2.5;
        p = (10 + paramValues[p_Gen_VariVal])/90;
        //AAAAAAAA_p = p;
        (frand() > 0.4) ? (
            x = frand(); m += x * x * p * 2.0 * m;
        ) : (
            m -= frand() * p * 1.2 * m;
        );
        //AAAAAAAA_m = m;
        parSet(p_maxGenerators, max(paramValues[p_Gen_MinCnt], min(paramValues[p_Gen_MaxCnt], paramValues[p_Gen_MinCnt]+m)));
        //++++9++++//

    ););););):((xop<13)?((xop<11)?(

        //++++10++++//
        //====== mSL EXECUTION ======
        // mSL_errX=10;
        mSL_dispatch_entry = SchX;
        atomic_get(mSL_Lock) ? (
            // We are doing some exclusive operation. mSL Threads are not allowed to execute
            SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd); // insert the thread in locked pts
            SchX = -1;
        ) : (
            tstrt = time_precise() + timeD;
            mSL_active_Thread = SchedThrdPt[SchX]; // the thread
            ((SchedStatus[mSL_dispatch_entry] & SchmSLThrUsed) != SchmSLThrUsed) ? (
                (mSL_errX === 0) ? mSL_errX = 3381; // thread not noted active ?
            );
            mSL_load_thread(mSL_active_Thread);
            mSL_max_TOS = mSL_active_Thread[mSL_THR_basePhStack];

            (mSL_errX != 0) ? (
                thread_error(mSL_active_Thread, mSL_errX, SchX);
            ) : (
                mm_xec_mm[mm_xec_ptr] -=  mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] -=  mSL_ICount;
                // Curr_Block_Alloc
                AAAAAAAA_mSL_rpeat = mSL_rpeat = max(4096, 0|(mSL_insts_per_s * min(TLeft, Curr_Block_Alloc * 0.15))) ; // A large number
                // XV ? mSL_evaluate() : mSL_evaluate0();
                mSL_evaluate();
                AAAAAAAA_mSL_evaluate_count += 1;
                mSL_High_Stack = max(mSL_High_Stack, mSL_max_TOS - mSL_active_Thread[mSL_THR_basePhStack]);
                //sprintf(#uuu, "End of evaluation - CR: %d - XC: %d", mSL_CodeStop, AAAAAAAA_mSL_evaluate_count);
                //mSL_log(SysLogBox, #uuu);
                mSL_save_thread(mSL_active_Thread);
                ((mSL_CodeStop === 0) || (mSL_CodeStop === mSL_RC_Yield)) ? (
                    // reintroduce the thread in the queue
                    SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Wait) ? (
                    (mSL_WaitDuration > 0) ? (
                        // introduce the entry in the wait queue
                        Schedule(SchedRelative, mSL_WaitDuration, 0, SchX, 0, 0, 0);
                    ) : (
                        // reintroduce the thread in the queue
                        SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    );
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Stop) ? (
                    // finished, free the thread
                    freeSchedThread(SchX);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    mSL_dispatch_entry = SchX = -1;
                    flagShowMemory = 1;
                ) :
                (mSL_CodeStop === mSL_RC_WEvent) ? (
                    // introduce the entry in the wait queue
                    SchedInsertTail(SchedEvntPts, SchX, SchETypeThrd);
                    (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                        sprintf(#s, "Insert in Evnt : ent: %d thrd: %d siz: %d ", SchX, mSL_active_Thread, SchedListSize(SchedEvntPts));
                        mSL_log(SysLogBox, #s);
                    );
                    AAAAA__Schx = Schx;
                    AAAAA__SchxNum = SchedEntryN[Schx];
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_WAITGC) ? (
                    // introduce in the wait for GC list
                    SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (
                    //AAAAAAAA_Errx = mSL_errX;
                    thread_error(mSL_active_Thread, mSL_errX, mSL_CodeStop);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    // sprintf(#uuu, "End of evaluation [%d]  CR: %d  Err: %d", SchX, mSL_CodeStop, mSL_errX);
                    (mSL_wbl != 0) ? (
                        sprintf(#uuu, "Block damaged @ %d", mSL_wbl);mSL_log(SysLogBox, #uuu);
                    );
                    mSL_error_analysis(mSL_active_Thread);
                    SchedFree(SchX);
                    SchX = -1;
                    flagShowMemory = 1;
                    mSL_errC = 0; mSL_errX = 1717; // "error previously detected"
                    mSL_errX = 0; // let other threads progress
                );
                mm_xec_mm[mm_xec_ptr] += mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] += mSL_ICount;
            );
            mm_dur_mm[mm_cyc_ptr] += time_precise() + timeD - tstrt;
        );
        mSL_active_Thread = -1;

        //++++10++++//

    ):((xop<12)?(

        //++++11++++//
        // random play one clip of current group
        doPlayCmd(cmdClMdBase + GvPlayTypGroup);
        //++++11++++//

    ):(

        //++++12++++//
        // play a recorded item :
        doPlayRItem(SchedPar1[SchX], SchedPar2[SchX]); //
        //++++12++++//

    ););):((xop<14)?(

        //++++13++++//
        // play a frozen sound/sequence
        pp = SchedPar1[SchX]; // the 88 w block
        sprintf(#u, "playing a FSND !  -> %d   [%d %d %d %d %d]",  pp,  pp[4],  pp[5],  pp[6],  pp[7],  pp[8]); mSL_log(SysLogBox, #u);
        pl = pp + lppEPsnd; // list of sounds
        itm = pp[lppECurItem]; // number of sound to play
        scnt = pp[lppEElct]; // number of sounds
        /*
        // Play first item / selected item
        doPlayRItem(pp[lppEPsnd+itm], 0); // send the itm FSND reference
        //  Play a random sound in the list
        doPlayRItem(pl[irand(pp[lppEElct])], 0); // send a random reference in the list
        */
        // Play items in round robin mode
        doPlayRItem(pp[lppEPsnd+2*itm], 0); // send the itm FSND reference
        pp[lppECurItem] = (itm + 1) % scnt;
        //++++13++++//

    ):((xop<15)?(

        //++++14++++//
        mSL_errX=14;
        //++++14++++//

    ):(
        //++++15++++//
        mSL_errX=15;
        //++++15++++//

    ););););



    //++++++++++++++++++++++++++++++++++++

    // Free the block if necessary
    SchX > 0 ? SchedFree(SchX);
    gmaxd = max(gmaxd, time_precise() + timeD - gstrt);
);









//// PLAYLOG


// Keep the last allocated in the table
0 ? ( // !!! Correct that sometimes
    (playLastTime >= playKeepNext) ? (
        ((playLastTime != playSVLastTime) && (playLastAlloc != playSVLastAlloc))  ?(
            playTimes[playPos] = playSVLastTime = playLastTime;
            playEntries[playPos] = playSVLastAlloc = playLastAlloc;
            playpos += 1;
        );
        playKeepNext += playStep;
        /*
        sprintf(#sfc, "Record= %d/%.1f[%d] Player %.1f ",
            playpos,
            playLastTime,
            playEntries[playPos],
            playKeepNext);
            mSL_log(SysLogBox, #sfc);
        */
        (playpos >= playpttbsSize) ? (
            ix = 0; iy = 0;
            while (iy < playpttbsSize) (
                playTimes[ix] = playTimes[iy];
                playEntries[ix] = playEntries[iy];
                ix += 1; iy += 2;
            );
            playpos = ix; playStep *= 2;
            memset(playTimes+playpos, 0, playpttbsSize-playpos);
            playTimes[playpttbsSize] = playStep;
        );
    );
);





function doClearLog()
(
    plBlInitChain();
    // reset read/write pointer
    pTimePrevious = pTBlockStart;
    pRecTimeCurrent = pTimeRPlayd = pTimeRecorded = 0.1;
    playModeRSpeed = 1.0;
    parSet(p_VirtTimSpeed, playModeRSpeed);
    ppb_VirtualTime[pp_Max] = 60;
    parSet(p_VirtualTime, pRecTimeCurrent);
    recordMode = recModePause;
    memset(clTabE, -1, clESize);
    memset(playTimes, 0, playpttbsSize+2);
    memset(playEntries, -2, playpttbsSize+2);
    playableNexT = 0;
    playNextTime = 0;
    playSVLastTime = playKeepNext = playLastTime = -1;
    playTimes[playpttbsSize] = playStep = 1;
    playSVLastAlloc = playLastAlloc = -1;
    playPos = 0;
);




/*
((kmd === 1) || (kbf === 0x4)) ? ( // md
    //(recordMode != replayModeOn) ? recordMode = replayModePause;
    dt = pp[lppEDate]; // date
    // pb[pp_Max] = max(pb[pp_Max], dt + 60);
    gmem[playLogDate] = parSet(p_VirtualTime, dt);
    0 ? (
        pb = paramBlock + p_VirtualTime * paramEntSize;
        sprintf(#u, "Vtime: %.2f [%.2f %.2f  /  %.2f  %d]", dt,  pb[pp_Min] , pb[pp_Max] ,pb[pp_SwLim] ,pb[pp_Altent] );
        mSL_log(SysLogBox, #u);
    );
) :
*/



// Update slider
/*
pTupdtR = 1;
) :
pRecTimeCurrent = (pTimeRPlayd += pTDelta * max(0.1, parV(p_VirtTimSpeed)));
pTupdtR = 1;
// Can we play something ?
(playableNexT === 0) ? (
    playableNexT = playEntries[lastBefore(pRecTimeCurrent)];
    playableNexT = playableNexT +  gmem[playableNexT+plBpt];
);
(playableNexT >=  playLogStrt) ? (
    (pRecTimeCurrent >= gmem[playableNexT+plStrt+plVal]) ? (
        //  Play this one.
        doPlayRItem(gmem[playableNexT+plEUId], 0);
        playableNexT = gmem[playableNexT+plStrt+plFwd];
        playableNexT = playableNexT +  gmem[playableNexT+plBpt];
    );
);
(pRecTimeCurrent > pTimeRecorded) ? (
    pRecTimeCurrent = pTimeRPlayd = pTimeRecorded;
    recordMode = replayModePause;
);
*/

/*
(pTupdtR) ? (
    pTupdtR = 0;
    ppb_VirtualTime[pp_Max] = max(ppb_VirtualTime[pp_Max], pRecTimeCurrent + 60);
    gmem[playLogDate] = parSet(p_VirtualTime, pRecTimeCurrent);
);
*/

/*
((playVTMod != 0) && (pTBlockStart - playVTMod > 3.5)) ? (
    playVTMod = 0;
    setPModePlay();
    pRecTimeCurrent = pTimeRPlayd = pPlayTimeCurrent;
    pTupdtR = 1;
    playableNexT = 0;
    lastBefore(pPlayTimeCurrent);
);
*/


/*
function lastBefore(date)
local (sp, BL, BH, BI)
(
    // find a starting point
    BL = 0 ; BH = max(0, playPos-1);
    while ((BH - BL) > 1) (
        BI = 0|((BL + BH) / 2);
        (playTimes[BI] > date) ? BH = BI : BL = BI;
    );
    sp = 0|((BL + BH) / 2);
    sprintf(#sfc, "Date => %.2f  =>  pos %d  [%.2f] ", date, sp, playTimes[sp]);
    mSL_log(SysLogBox, #sfc);
    sp;
);
*/



/*
    Look for an entry in a record list
*/
function replayJumpTo(plg, ent, date, flgs)
local (pld, ple, plg, plgtpln, pt, k)
(
    pt = pld = ple = pln = 0;
    plg === 0 ? plg = PlLogCurrent;
    plg === 0 ? plg = PlLogMain;
    gmem[playLogRef] = 0;
    (plg) ? (
        plgt = plg + 4; // tail of current play log
        gmem[playLogDate] = parSet(p_VirtualTime, date);
        // look for the first entry from this date
        ((ent > 0) && ((k = ent[lppEElct]) > 0)) ? (
            // should look from the first sound
            pt = ent[lppEPsnd];
        ) : (
            // sorry, no reference, start from head of the list
            pt = plg[SchedNxtEnt];
        );
        while ((pt > 0) && (pt[SchevEvntName] === plIDNT) && (date-pTEpsilon > pt[plLEntRcrd])) (
            pt = pt[SchedNxtEnt]; // jump to next.
        );
        ((pt > 0) && (pt[SchevEvntName] === plIDNT) && (date-pTEpsilon <= pt[plLEntRcrd])) ? (
            ple = pt; pld = ple[plLEntRcrd];
        );
        ((ple === 0) && (playModeSpeed < 0)) ? (
            // try the last entry of the list
            (plg[5] !== plg) ? (ple = plg[5];);
        );
        ((ple !== 0) && (ple[SchevEvntName] === plIDNT)) ? (
            replayEntry = ple;
            pPlayTimeCurrent = date;
            repDate = replayEntry[plLEntRcrd];
            playTime2Next = abs((pPlayTimeCurrent - repDate) / (max (0.0001, abs(playModeSpeed))));
            replayLogActive = plg;
            gmem[playLogRef] = pln = ple[plLEINum];
            // if found, jump to it
            1 ? (
                sprintf(#s, "replayJumpTo(%d, %.2f, %d) -> [%d/%d, %.2f] id = %d", ent, date, flgs, pln, ple, pld, ple[2]);
                mSL_log(SysLogBox, #s);
            );
        ) : (
            playTime2Next = 0;
        );
    );
    ple; // return the Jump Entry
);










URingSiz = 3*uCnt;
URingAdd = make_array(URingSiz);
URingPtr = 0;
pplaying = 0;
UplayControl = 0;

function URingPut(Ua)
local (rpt, ict)
(
    rpt = 1; ict = 0;
    while (rpt && (ict < URingSiz)) (
        URingPtr = (URingPtr + 1) % URingSiz; ict += 1;
        (URingAdd[URingPtr] === 0)  ? (
            rpt = 0;
        );
    );
    URingAdd[URingPtr] = Ua;
);

function URingClean()
local (ipt, Ua, xwct, stat)
(
    ipt = 0; xwct = 0; loop(URingSiz,
        (((Ua = URingAdd[ipt]) >= UGAddr) && (Ua < UGAddrLast) && (gmem[Ua+cbType] === uPlayer)) ? (
            stat = gmem[Ua+cbStat];
            ((stat === uSReady) || (stat === uSUnused)) ? (
                // consider it now unused
                URingAdd[ipt] = 0;
            ) :
            (stat === uSHalting) ? (
                // count out this one - it will stop soon
                0;
            ) : (
                xwct += 1;
            );
        ) : (
            URingAdd[ipt] = 0;
        );
        ipt += 1;
    );
    xwct; // return count
);



            // Check/clear Play Ring
            // pplaying = URingClean();
                // ui_show("pplaying", pplaying, "%d");





// Previous, correct


function
clipFromSet(set)
local (cl, ps, i, j, f, flgs, g, pp, cnt, cp, c1, c2, r, p, a, mclu, mcluc, lprtr)
(
    cl = -2; ClSet_ErrRe = 0;
    Y = K1 = K2 = 0; W = 0;
    ((set >= 0) && (set < ClSetPSize) && (set === (0|set)) && ((ps = ClSetPtr[set]) >= ClSetTab) && (set === ps[ClSet_num])) ? (
        // Do we already have some clip number computed ?
        cl = ps[ClSet_UCLA]; // Unique Clip Left Available case
        f = (flgs = ps[ClSet_Algo]) & 0x100; // PLUC flag
        lprtr = 3;
        i = ClSet_1stC; while ((cl < 0) && (i < ClSet_lCl)) (
            ((cl = ps[i]) >= 0) ? ps[i] = -2;
            i += 1;
        );
        while ((cl === -2) && (lprtr > 0))  (
            // explore the set and create entries
            // First, build the whole conf in clipsWorkArea
            lprtr -= 1;
            pp = ps + ClSet_lCl; mclu = K = ps[ClSet_mclu]; mcluc = 0;
            cnt = 0; g = 1; clipsWorkArea[0] = -1;  // set might be empty
            while ((cp = pp[0]) >= 0) (
                c1 = 0|(cp / clipsWorkAreaSize); c2 = cp % clipsWorkAreaSize;
                while (c1 <= c2) (
                    //is c1 an acceptable clip ?
                    i = gmem[clClDurations+c1]; j = gmem[clInfStart+c1];
                    // nb: j is < 0 if the clip has been locked or is in error
                    ((j >= 0) && (i >= ps[ClSet_MinL]) && (i <= ps[ClSet_MaxL])) ? (
                        // clip could be selected
                        (f === 0) ? (
                            mcluc += 1;
                            clipsWorkArea[cnt] = c1;
                            cnt += 1;
                        ) :
                        (j <= mclu) ? (
                            (mclu > j) ? (
                                mclu = j; mcluc = 0; cnt = 0;
                            );
                            mcluc += 1;
                            clipsWorkArea[cnt] = c1;
                            cnt += 1;
                        );
                    ) :
                    (((i === 0) || (j === 0)) && (g === 1)) ? (
                        // do 1 exploration of a clip
                        gmem[clClInfos+c1] = gmem[clInfStart+c1] = 0; // will force recheck the clip
                        (gmem[clClDurations+c1] === 0) ? gmem[clClDurations+c1] = -1; // eliminate the clip for now
                        checkClip(c1, 1); g = 0; // but force recheck
                        ClCheckFlag = 1; // ask for clips rechecking
                        ClCheckView = 1; cBk4 = 0;
                        1 ? (
                            sprintf(#s, "   clipFromSet(%d) explore [%d => %f]", set, c1, gmem[clClDurations+c1]); mSL_log(SysLogBox, #s);
                        );
                    );
                    c1 += 1;
                );
                pp += 1;
            );
            ps[ClSet_cnt] = cnt; // keep count of selected clips
            // mclu + ((cnt < 32) | (mcluc < 4))
            //(f !== 0) ? (ps[ClSet_mclu] = Y = max(1, mclu); W |= 0x100;);
            (cnt > 0) ? (
                W |= 0x10;
                a = ((flgs & 0xFF) === 2);
                // Provide a first random clip as immediate result
                ((p = ps[ClSet_Lst] % cnt) === (ps[ClSet_Start] % cnt)) ? (
                    ((flgs & 0xFF)  === 0) ? (
                        // Change random prime
                        ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
                    );
                    ps[ClSet_Genc] = 0;
                    (flgs & 1) ? (
                        p = 0; // always restart from first selected
                    ) : (
                        p = (ps[ClSet_Start] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];) % cnt;
                    );
                );
                //
                (cnt <= 1) ? (
                    // just one clip in the set. Simplify the rest
                    cl = clipsWorkArea[0];
                    (ps[ClSet_Algo] & 0x100) ? (
                        ps[ClSet_mclu] += 1; W |= 0x20;
                    ) : (
                        ps[ClSet_UCLA] = cl;
                    );
                ) : (
                    ps[ClSet_UCLA] = -2; // no shortcut
                    r = ps[ClSet_Rnd] + cnt; // the random
                    // (ps[ClSet_Start] < 0) ? (ps[ClSet_Start] = p =  ((p + r ) % cnt););
                    cl = clipsWorkArea[p]; // this result
                    p = a ? (irand(cnt)) : ((p + r) % cnt); // the next result
                    0 ? (sprintf(#s, "   clipFromSet(%d)  Alg:%d  #%d", set, ps[ClSet_Algo], p );
                        mSL_log(SysLogBox, #s);
                    );
                    // Save some more in the structure if clip reading is completed
                    g ? (
                        i = ClSet_1stC; while ((i < ClSet_lCl) && (p != (ps[ClSet_Start] % cnt))) (
                            ps[i] = clipsWorkArea[p]; i += 1;
                            p = a ? (irand(cnt)) : ((p + r) % cnt);
                        );
                    );
                );
                ps[ClSet_Lst] = p; // save next entry to use
            ) : (
                // Current selection is empty. Create a new one
                ClSet_ErrRe += 1; // set is empty, mcluc is 0
                (flgs & 1) ? (
                    ps[ClSet_Start] = ps[ClSet_Lst] = 0; // always restart from first selected
                );
                Z = ps[ClSet_mclu];
                sprintf(#s, "       empty(%d): cl: %d   ErrRe: %d   lprtr: %X   mclu: %d   W: %X   Y: %d", set, cl, ClSet_ErrRe, lprtr | f, Z, W, Y);
                mSL_log(SysLogBox, #s);
                ps[ClSet_mclu] += 1; // add 1 to min. count to enlarge selection
                (lptr == 1) ? (f = 0); K2 = K1; K1 = K; // set f to 0 to choose any clip
            );
            0 ? (sprintf(#s, "   clipFromSet(%d) - new entries [%d %d %d]", set, cnt, ps[ClSet_Lst], ps[ClSet_Rnd]); mSL_log(SysLogBox, #s););
        );
        ps[ClSet_Genc] += 1;
    ) : (
        ClSet_ErrRe = 8; // set undefined
    );
    (cl < 0) ? (
        sprintf(#s, "   clipFromSet(%d) => %d  |  %d  |  %d / %d / %d / %d", set, cl, ClSet_ErrRe, K1, K2, lprtr); mSL_log(SysLogBox, #s);
        parSet(p_GvAutoMd, 0); // and stop playing
    );
    (cl >= 0) ? cl : -1; // return a clip # or -1
);


















// Incorrect ?


function
clipFromSet(set)
local (cl, ps, i, j, f, flgs, g, pp, cnt, cp, c1, c2, r, p, a, mclu, lprtr)
(
    cl = -2; ClSet_ErrRe = 0;
    Y = K1 = K2 = 0; W = 0;
    ((set >= 0) && (set < ClSetPSize) && (set === (0|set)) && ((ps = ClSetPtr[set]) >= ClSetTab) && (set === ps[ClSet_num])) ? (
        // Do we already have some clip number computed ?
        cl = ps[ClSet_UCLA]; // Unique Clip Left Available case
        f = (flgs = ps[ClSet_Algo]) & 0x100; // PLUC flag
        i = ClSet_1stC; while ((cl < 0) && (i < ClSet_lCl)) (
            ((cl = ps[i]) >= 0) ? ps[i] = -2;
            i += 1;
        );

        (cl < 0) ? (
            // no saved clip found
            flgs = ps[ClSet_Algo];
            // Should we Play Less Used Clips (PLUC) ?
            (f = (flgs & 0x100)) ? (



                lprtr = 3;
                // PLUC flag set
                mpl = 999999999; // minimumly played clip
                while ((cl === -2) && (lprtr > 0))  (
                    lprtr -= 1;
                    // explore the set and create entries
                    // First, build the whole conf in clipsWorkArea
                    pp = ps + ClSet_lCl;
                    mclu = K = ps[ClSet_mclu];
                    cnt = 0; g = 1; clipsWorkArea[0] = -1;  // set might be empty
                    while ((cp = pp[0]) >= 0) (
                        c1 = 0|(cp / clipsWorkAreaSize); c2 = cp % clipsWorkAreaSize;
                        while (c1 <= c2) (
                            //is c1 an acceptable clip ?
                            i = gmem[clClDurations+c1]; j = gmem[clInfStart+c1];
                            // nb: j is < 0 if the clip has been locked or is in error
                            ((j >= 0) && (i >= ps[ClSet_MinL]) && (i <= ps[ClSet_MaxL])) ? (
                                // size correct
                                mpl = min(j, mpl); // keep mpl info
                                (j <= mclu) ? (
                                    // clip could be selected
                                    (mclu > j) ? (
                                        mclu = j; cnt = 0;
                                    );
                                    clipsWorkArea[cnt] = c1;
                                    cnt += 1;
                                );
                            ) :
                            (((i === 0) || (j === 0)) && (g === 1)) ? (
                                // do 1 exploration of a clip
                                gmem[clClInfos+c1] = gmem[clInfStart+c1] = 0; // will force recheck the clip
                                (gmem[clClDurations+c1] === 0) ? gmem[clClDurations+c1] = -1; // eliminate the clip for now
                                checkClip(c1, 1); g = 0; // but force recheck
                                ClCheckFlag = 1; // ask for clips rechecking
                                ClCheckView = 1; cBk4 = 0;
                                1 ? (
                                    sprintf(#s, "   clipFromSet(%d) explore [%d => %f]", set, c1, gmem[clClDurations+c1]); mSL_log(SysLogBox, #s);
                                );
                            );
                            c1 += 1;
                        );
                        pp += 1;
                    );
                    ps[ClSet_cnt] = cnt; // keep count of selected clips
                    clipsWorkArea[cnt] = -1;
                    (cnt > 0) ? (
                        W |= 0x10;
                        a = ((flgs & 0xFF) === 2);
                        // Provide a first random clip as immediate result
                        ((p = ps[ClSet_Lst] % cnt) === (ps[ClSet_Start] % cnt)) ? (
                            ((flgs & 0xFF) === 0) ? (
                                // Change random prime
                                ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
                            );
                            p = (ps[ClSet_Start] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];) % cnt;
                        );
                        //
                        (cnt <= 1) ? (
                            // just one clip in the set. Simplify the rest
                            cl = clipsWorkArea[0];
                            ps[ClSet_mclu] = mclu+1; W |= 0x20;
                        ) : (
                            // more than 1 clip in the set - try to keep a few
                            cl = clipsWorkArea[p]; // this result
                            ps[ClSet_UCLA] = -2; // no shortcut
                            r = ps[ClSet_Rnd] + cnt; // the random
                            p = a ? (irand(cnt)) : ((p + r) % cnt); // the next result
                            0 ? (sprintf(#s, "   clipFromSet(%d)  Alg:%d  #%d", set, ps[ClSet_Algo], p );
                                mSL_log(SysLogBox, #s);
                            );
                            // Save some more in the structure if clip reading is completed
                            g ? (
                                i = ClSet_1stC; while ((i < ClSet_lCl) && (p != (ps[ClSet_Start] % cnt))) (
                                    ps[i] = clipsWorkArea[p]; i += 1;
                                    p = a ? (irand(cnt)) : ((p + r) % cnt);
                                );
                            );
                        );
                        ps[ClSet_Lst] = p; // save next entry for future use
                    ) : (
                        // Current selection is empty. Create a new one
                        ClSet_ErrRe += 1; // set is empty
                        (flgs & 1) ? (
                            ps[ClSet_Start] = ps[ClSet_Lst] = 0; // always restart from first selected
                        );
                        Z = ps[ClSet_mclu]; // what we tried
                        sprintf(#s, "       empty(%d): cl: %d   ErrRe: %d   lprtr: %X   mclu: %d   W: %X   Y: %d", set, cl, ClSet_ErrRe, lprtr | f, Z, W, Y);
                        mSL_log(SysLogBox, #s);
                        ps[ClSet_mclu] = max(ps[ClSet_mclu] + 1, mpl); // add 1 to min. count to enlarge selection
                        K2 = K1; K1 = K; // set f to 0 to choose any clip
                    );
                    0 ? (sprintf(#s, "   clipFromSet(%d) - new entries [%d %d %d]", set, cnt, ps[ClSet_Lst], ps[ClSet_Rnd]); mSL_log(SysLogBox, #s););
                );
                ps[ClSet_Genc] += 1;



            ) : (



                // Just explore the set
                while ((cl === -2))  (
                    // explore the set and create entries
                    // First, build the whole conf in clipsWorkArea
                    lprtr -= 1;
                    mclu = K = ps[ClSet_mclu];
                    cnt = 0; g = 1; clipsWorkArea[0] = -1;  // set might be empty
                    pp = ps + ClSet_lCl;
                    while ((cp = pp[0]) >= 0) (
                        c1 = 0|(cp / clipsWorkAreaSize); c2 = cp % clipsWorkAreaSize;
                        while (c1 <= c2) (
                            //is c1 an acceptable clip ?
                            i = gmem[clClDurations+c1]; j = gmem[clInfStart+c1];
                            // nb: j is < 0 if the clip has been locked or is in error
                            ((j >= 0) && (i >= ps[ClSet_MinL]) && (i <= ps[ClSet_MaxL])) ? (
                                    clipsWorkArea[cnt] = c1;
                                    cnt += 1;
                            ) :
                            (((i === 0) || (j === 0)) && (g === 1)) ? (
                                // do 1 exploration of a clip
                                gmem[clClInfos+c1] = gmem[clInfStart+c1] = 0; // will force recheck the clip
                                (gmem[clClDurations+c1] === 0) ? gmem[clClDurations+c1] = -1; // eliminate the clip for now
                                checkClip(c1, 1); g = 0; // but force recheck
                                ClCheckFlag = 1; // ask for clips rechecking
                                ClCheckView = 1; cBk4 = 0;
                                1 ? (
                                    sprintf(#s, "  A clipFromSet(%d) explore [%d => %f]", set, c1, gmem[clClDurations+c1]); mSL_log(SysLogBox, #s);
                                );
                            );
                            c1 += 1;
                        );
                        pp += 1;
                    );
                    ps[ClSet_cnt] = cnt; // keep count of selected clips
                    clipsWorkArea[cnt] = -1;
                    (cnt > 0) ? (
                        W |= 0x10;
                        a = ((flgs & 0xFF) === 2);
                        // Provide a first random clip as immediate result
                        ((p = ps[ClSet_Lst] % cnt) === (ps[ClSet_Start] % cnt)) ? (
                            ((flgs & 0xFF) === 0) ? (
                                // Change random prime
                                ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
                            );
                            p = (ps[ClSet_Start] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];) % cnt;
                        );
                        //
                        (cnt <= 1) ? (
                            // just one clip in the set. Simplify the rest
                            cl = clipsWorkArea[0];W |= 0x20;
                        ) : (
                            // more than 1 clip in the set - try to keep a few
                            cl = clipsWorkArea[p]; // this result
                            ps[ClSet_UCLA] = -2; // no shortcut
                            r = ps[ClSet_Rnd] + cnt; // the random
                            p = a ? (irand(cnt)) : ((p + r) % cnt); // the next result
                            0 ? (sprintf(#s, "   clipFromSet(%d)  Alg:%d  #%d", set, ps[ClSet_Algo], p );
                                mSL_log(SysLogBox, #s);
                            );
                            // Save some more in the structure if clip reading is completed
                            g ? (
                                i = ClSet_1stC; while ((i < ClSet_lCl) && (p != (ps[ClSet_Start] % cnt))) (
                                    ps[i] = clipsWorkArea[p]; i += 1;
                                    p = a ? (irand(cnt)) : ((p + r) % cnt);
                                );
                            );
                        );
                        ps[ClSet_Lst] = p; // save next entry to use
                    ) : (
                        cl = -1;
                    );
                    0 ? (sprintf(#s, "  B clipFromSet(%d) - new entries [%d %d %d]", set, cnt, ps[ClSet_Lst], ps[ClSet_Rnd]); mSL_log(SysLogBox, #s););
                );
            );

        );

    ) : (
        ClSet_ErrRe = 8; // set undefined
    );

    (cl < 0) ? (
        sprintf(#s, "   clipFromSet(%d) => %d  |  %d  |  %d / %d / %d / %d", set, cl, ClSet_ErrRe, K1, K2, lprtr); mSL_log(SysLogBox, #s);
        parSet(p_GvAutoMd, 0); // and stop playing
    );


    (cl >= 0) ? cl : -1; // return a clip # or -1
);









// we need a "r" relatively prime with "cnt"
r += cnt + cnt;
/*
i = 1;
while (i) (
    k = r; l = cnt;
    while (k > 0) (
        (k < l) ? (j = k; k = l; l = j); // now k >= l
        k = k % l;
    );
    (l === 1) ? (i = 0) : (r += 1);
);
*/


//Z = ps[ClSet_mclu]; // what we tried
1 ? (
    sprintf(#s, "       empty(%d): cl: %d   ErrRe: %d   lprtr: %X   mclu: %d   W: %X   Y: %d", set, cl, ClSet_ErrRe, lprtr | f, mclu, W, Y);
    mSL_log(SysLogBox, #s);
);

/*
0 ? (
    sprintf(#s, "   clipFromSet(%d) explore [%d => %f]", set, c1, gmem[clClDurations+c1]);
        mSL_log(SysLogBox, #s);
);
*/



/*
0 ? (
    sprintf(#s, "   clipFromSet(%d)  Alg:%d  #%d", set, ps[ClSet_Algo], p );
    mSL_log(SysLogBox, #s);
);
*/


//ps[ClSet_mclu] = max(ps[ClSet_mclu] + 1, mpl+1); // add 1 to min. count to enlarge selection
//K2 = K1; K1 = K; // set f to 0 to choose any clip
W = W << 8;
/*
0 ? (
    sprintf(#s, "   clipFromSet(%d) - new entries [%d %d %d]", set, cnt, ps[ClSet_Lst], ps[ClSet_Rnd]);
    mSL_log(SysLogBox, #s);
);
*/

0 ? (
    sprintf(#s, "  A clipFromSet(%d) explore [%d => %f]", set, c1, gmem[clClDurations+c1]); mSL_log(SysLogBox, #s);
);
0 ? (sprintf(#s, "   clipFromSet(%d)  Alg:%d  #%d", set, ps[ClSet_Algo], p );
    mSL_log(SysLogBox, #s);
);
0 ? (
    sprintf(#s, "  B clipFromSet(%d) - new entries [%d %d %d]", set, cnt, ps[ClSet_Lst], ps[ClSet_Rnd]);
    mSL_log(SysLogBox, #s);
);
(cl < 0) ? (
    sprintf(#s, "   clipFromSet(%d) => %d  |  %d  |  %d / %d / %d / %d", set, cl, ClSet_ErrRe, K1, K2, lprtr);
    mSL_log(SysLogBox, #s);
    parSet(p_GvAutoMd, 0); // and stop playing
);



(dpa) ? (
    //sprintf(#s, "?? %s", #efs);
    //mSL_log(SysLogBox, #s);
    //sprintf(#s, "[%d   %d   %d]   [%d   %d   %d]", ui_left_retina(), dropped_x , ui_right_retina(),
    //ui_top_retina(), dropped_y, ui_bottom_retina());
    //mSL_log(SysLogBox, #s);
    doneDroppedFile();
);








// Check first words of memory, to detect eventual bugs
((!GMW()) && (XDcount > 0)) ? (
    sprintf(#s2, "Game Master Damaged! %s %s %s %s %s %s %s %s", mSL_edit_value(#, 0[0]), mSL_edit_value(#, 0[1]),
                mSL_edit_value(#, 0[2]), mSL_edit_value(#, 0[3]), mSL_edit_value(#, 0[4]), mSL_edit_value(#, 0[5]),
                mSL_edit_value(#, 0[6]), mSL_edit_value(#, 0[7]));
    mSL_log(SysLogBox, #s2);
    XDcount -= 1;
    XDcount > 0 ? GMI();
);





function GMW0(msg)
(
    sprintf(#s2, "[%s]  %s %s %s %s %s %s %s %s", msg, mSL_edit_value(#AA0, 0[0]), mSL_edit_value(#AA1, 0[1]),
                mSL_edit_value(#AA2, 0[2]), mSL_edit_value(#AA3, 0[3]), mSL_edit_value(#AA4, 0[4]), mSL_edit_value(#AA5, 0[5]),
                mSL_edit_value(#AA6, 0[6]), mSL_edit_value(#AA7, 0[7]));
    mSL_log(SysLogBox, #s2);
);




function xed(str, val)
(
    sprintf(str, "%d", val);
    str;
);

sprintf(#res1, "Ex-1:  %s  %s", xed(#A1, 345), xed(#A2, 678));

xed(#A3, 345);
xed(#A4, 678);

sprintf(#res2, "Ex-2:  %s  %s", #A3, #A4);




















//========================================================================================================



ActivePlaying ? (
    // we are playing, and not waiting
    gmem[UAdd + cbPDisp + 15] += 1;


smUpdateFlag ? (
    (smUpdateFlag & smUFlagVol) ? (
        (FP_GlobVol >= FP_GlobSet) ? (
            // decreasing volume
            FP_GlobVol -= PF_Coeff * FP_GlobVol + PF_Const;
            ((FP_GlobVol <= FP_GlobSet)) ? (
                FP_GlobVol = FP_GlobSet;
                smUpdateFlag &= -1 ~ smUFlagVol;
            );
        ) : (
            // increasing volume
            FP_GlobVol += PF_Coeff * FP_GlobVol + PF_Const;
            ((FP_GlobSet <= FP_GlobVol)) ? (
                FP_GlobVol = FP_GlobSet;
                smUpdateFlag &= -1 ~ smUFlagVol;
            );
        );
    );
    (smUpdateFlag & smUFlagWidth) ? (
        (FP_GlobWSet >= FP_GlobWidth) ? (
            FP_GlobWidth = FP_GlobWidth * 1.000001 + 0.000001;
            (FP_GlobWidth >= FP_GlobWSet) ? (
                FP_GlobWidth = FP_GlobWSet;
                smUpdateFlag &= -1 ~ smUFlagWidth;
            );
        ) : (
            FP_GlobWidth = FP_GlobWidth * 0.999999 - 0.000001;
            (FP_GlobWidth <= FP_GlobWSet) ? (
                FP_GlobWidth = FP_GlobWSet;
                smUpdateFlag &= -1 ~ smUFlagWidth;
            );
        );
        gmem[ModWidthL] = FP_GlobWidth;
    );
);




(Pmode == ActPlaying) ? (
    gmem[ModTR2] = 333;
    pflg = 1;
    TPL = tplA;
    pvol = FP_GlobVol;
    ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
        // are we finished ?
        ((ClRIndex <  GrStLLimit) || (ClRIndex > GrStHLimit)) ? (
            // no more samples to generate - return all zeros tupples
            TPL = tplZ;
            (gmem[UAdd+RCB_ClipLoop] & 1) ? (
                // loop
                pflg = 1;
                ClRIndex = gmem [UAdd+RCB_StartIndex];
                Pmode = WaitPlaying; // ready to resync
                doSynchro(); // starts synchro
            ) : (
                pflg = 0;
            );
        ) : (
            // compute an appropriate fade volume
            d = (ClRIndex < ClLowArea) ? (
                    (ClRIndex - GrStLLimit) / (ClLowArea - GrStLLimit)
                ) : (
                    (GrStHLimit - ClRIndex) / (GrStHLimit - ClHighArea)
                );
            pvol *= min(1,d*d); // use a quadratic coeff.
        );
    );
    (pflg) ? (
        (pvol == 0) ? (
            TPL = tplZ;
        ) : (
            // do actual interpolation
            index = floor(ClRIndex);
            delta = ClRIndex - index;
            // Convert to samples
            index *= CCCC;
            ((delta < 0.0001) || (delta > 0.9999)) ? (
                // return sample to optimize
                (delta > 0.5) ? index += CCCC;
                (CCCC == 2) ? (
                    // stereo case
                    tplA[0] = pvol * UBuffer[index];
                    tplA[1] = pvol * UBuffer[index+1];
                ) :
                (CCCC == 1) ? (
                    // mono case
                    tplA[0] = pvol * UBuffer[index];
                ) : (
                    // multi channels case
                    i = 0;
                    loop(CCCC,
                        tplA[i] = pvol * UBuffer[index];
                        i +=1; index += 1;
                    );
                );
            ) : (
                // We need to interpolate
                (CCCC == 1) ? (
                    // mono case
                    xm1 = UBuffer[index-1];
                    x0 = UBuffer[index];
                    x1 = UBuffer[index+1];
                    x2 = UBuffer[index+2];
                    tplA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                    * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                ) :
                (CCCC == 2) ? (
                    // stereo case
                    xm1 = UBuffer[index-2];
                    x0 = UBuffer[index];
                    x1 = UBuffer[index+2];
                    x2 = UBuffer[index+4];
                    tplA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                    * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                    index += 1;
                    xm1 = UBuffer[index-2];
                    x0 = UBuffer[index];
                    x1 = UBuffer[index+2];
                    x2 = UBuffer[index+4];
                    tplA[1] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                    * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                ) : (
                    // multi channels case
                    i = 0;
                    loop(CCCC,
                        xm1 = UBuffer[index-CCCC];
                        x0 = UBuffer[index];
                        x1 = UBuffer[index+CCCC];
                        x2 = UBuffer[index+CCCC+CCCC];
                        tplA[i] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                    * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                        * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        i +=1; index += 1;
                    );
                );
            );
        );
        // Next index
        ClRIndex += clRSpeed * FAdjRate;


        i = 0;
        loop (HPCnt,
            spl(gmem[UAddChs+i]) += TPL[i % CCCC];
            i += 1;
        );


        // gmem[UAdd + cbPDisp  + 26] = pvol;
        // gmem[UAdd + cbPDisp  + 17] = ClRIndex;
        // gmem[UAdd + cbPDisp  + 19] = ClHighArea;
        // gmem[UAdd + cbPDisp  + 20] = GrStHLimit;
        // gmem[UAdd + cbPDisp  + 18] = (xxcnt += 1);

        doStop ? (
            VolumeMod0_u = FP_GlobSet = 0;
            smUpdateFlag |= smUFlagVol;
            ActivePlaying = 1;
            (FP_GlobVol == 0) ? Pmode = Inactive;
        );
    ) : (
        ActivePlaying = 0;
        sactClear();
        Pmode = Inactive;
        gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
    );
) :



(Pmode == ActPlaying2) ? (
    gmem[ModTR2] = 444;
    pflg = 1;
    TPL = tplA;
    pvol = FP_GlobVol;
    ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
        // are we finished ?
        ((ClRIndex <  GrStLLimit) || (ClRIndex > GrStHLimit)) ? (
            // no more samples to generate - return all zeros tupples
            TPL = tplZ;
            (gmem[UAdd+RCB_ClipLoop] & 1) ? (
                // loop
                pflg = 1;
                ClRIndex = gmem [UAdd+RCB_StartIndex];
                Pmode = WaitPlaying; // ready to resync
                doSynchro(); // starts synchro
            ) : (
                pflg = 0;
            );
        ) : (
            // compute an appropriate fade volume
            d = (ClRIndex < ClLowArea) ? (
                    (ClRIndex - GrStLLimit) / (ClLowArea - GrStLLimit)
                ) : (
                    (GrStHLimit - ClRIndex) / (GrStHLimit - ClHighArea)
                );
            pvol *= min(1,d*d); // use a quadratic coeff.
        );
    );
    (pflg) ? (
        (pvol == 0) ? (
            TPL = tplZ;
        ) : (
            i = 0; loop(CCCC, tplA[i]=0; i += 1;);
            // do actual interpolation
            gmem[ModTR3] = lpcnt = max(1, min(gmem[ModDepth], 4));
            xind = 0; loop(lpcnt,
                // For each "modulation" perform a read
                mdtb = ModTabPtrs[xind];
                ph = mdtb[2]; // phase
                iph = floor(ph);
                bfsx = mdtb[0];
                gmem[ModTR4] = uu = FP_GlobWidth * mdtb[4] * (bfsx[iph] + (bfsx[iph+1] - bfsx[iph]) * (ph - iph));
                // Compute next phase
                gmem[ModTR5] = ph = ph + gmem[ModFreq] * mdtb[3]; (ph >= mdtb[5]) ? ph = ph - mdtb[5]; mdtb[2] = ph;
                // access
                ipos = ClRIndex + uu;
                ((ipos > 0) && (ipos < gmem [UAdd+RCB_CSiz_tpl])) ? (
                    // Read/Interpolate only when we are inside the clip
                    index = floor(ipos);
                    delta = ipos - index;
                    // Convert to samples
                    index *= CCCC;
                    ((delta < 0.0001) || (delta > 0.9999)) ? (
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        (CCCC == 2) ? (
                            // stereo case
                            tplA[0] = tplA[0] + pvol * UBuffer[index];
                            tplA[1] = tplA[1] + pvol * UBuffer[index+1];
                        ) :
                        (CCCC == 1) ? (
                            // mono case
                            tplA[0] = tplA[0] + pvol * UBuffer[index];
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                tplA[i] = tplA[i] + pvol * UBuffer[index];
                                i +=1; index += 1;
                            );
                        );
                    ) : (
                        // We need to interpolate
                        (CCCC == 1) ? (
                            // mono case
                            xm1 = UBuffer[index-1];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+1];
                            x2 = UBuffer[index+2];
                            tplA[0] = plA[0] + pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (CCCC == 2) ? (
                            // stereo case
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tplA[0] = plA[0] + pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            index += 1;
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tplA[1] = tplA[1] + pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                tplA[i] = tplA[i] + pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                                * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                                i +=1; index += 1;
                            );
                        );
                    );
                );
                xind += 1;
            );
        );
        // Next index
        ClRIndex += clRSpeed * FAdjRate;


        i = 0;
        loop (HPCnt,
            spl(gmem[UAddChs+i]) += TPL[i % CCCC];
            i += 1;
        );


        // gmem[UAdd + cbPDisp  + 26] = pvol;
        // gmem[UAdd + cbPDisp  + 17] = ClRIndex;
        // gmem[UAdd + cbPDisp  + 19] = ClHighArea;
        // gmem[UAdd + cbPDisp  + 20] = GrStHLimit;
        // gmem[UAdd + cbPDisp  + 18] = (xxcnt += 1);

        doStop ? (
            VolumeMod0_u = FP_GlobSet = 0;
            smUpdateFlag |= smUFlagVol;
            ActivePlaying = 1;
            (FP_GlobVol == 0) ? Pmode = Inactive;
        );
    ) : (
        ActivePlaying = 0;
        sactClear();
        Pmode = Inactive;
        gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
    );
) :



(Pmode == ActLooping) ? (
    abp = 0; maxu = -1; fbuff = -1; pct = 0;
    while (abp <= GCBactM) (
        (GCBL = GCBacts[abp]) ? (
            pct += 1; // this counts as a playing buffer
            maxu = abp; // note the last used buffer
            (GCBL[gStatus] == 0) ? (
                (doSync && (currSmpl >= synchroPos)) ? (
                    doSync = 0;
                    // restart a new bloc
                    GCBL[gStatus] = 1;
                    // choose a random tupple
                    GCBL[gClLowLimit] = k = GrStLLimit + irand(max(1,GrStHLimit - GrMaxTpl - GrStLLimit + 1));
                    GCBL[gClHighLimit] = m = k + GrMinTpl + irand(GrMaxTpl - GrMinTpl + 1);
                    GCBL[gclRSpeed] = clRSpeed * FAdjRate;
                    (clRSpeed > 0) ? (
                        GCBL[gClRIndex] = k;
                        GCBL[gClLowArea] = k + GrFInTpl;
                        GCBL[gClHighArea] = m - GrFOutTpl;
                    ) : (
                        GCBL[gClRIndex] = m;
                        GCBL[gClLowArea] = k + GrFOutTpl;
                        GCBL[gClHighArea] = m - GrFInTpl;
                    );
                    GCBL[gChOffset] = irand(CCCC);
                    GCBL[gChCount] = 1;
                    GCBL[gChNum] = gmem[UAddChs+HPIndx]; HPIndx = (HPIndx + 1) % HPCnt;
                    xxcnt += 1;
                    // gmem[UAdd + cbPDisp  + 21] = k / FFrRate;
                    // gmem[UAdd + cbPDisp  + 22] = m / FFrRate;
                    // gmem[UAdd + cbPDisp  + 7] = ccs = (m - k + 1) / SpdFact;
                    // gmem[UAdd + cbPDisp  + 9] = xxcnt;
                    // gmem[UAdd + cbPDisp  + 12] = max(gmem[UAdd + cbPDisp  + 12], ccs);
                    // gmem[UAdd + cbPDisp  + 13] = min(gmem[UAdd + cbPDisp  + 13], ccs);
                    // gmem[UAdd + cbPDisp  + 26] = FP_GlobVol;
                );
            ) : (
                // BLoopNext(GCBL);
                pflg = 1;
                pvol = FP_GlobVol;
                gspl = 0;
                ClRIndex = GCBL[gClRIndex];
                ClLowArea = GCBL[gClLowArea];
                ClHighArea = GCBL[gClHighArea];
                ClLowLimit = GCBL[gClLowLimit];
                ClHighLimit = GCBL[gClHighLimit];
                ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
                    // are we finished ?
                    ((ClRIndex <  ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                        pflg = pvol = 0;
                    ) : (
                        // compute an appropriate fade volume
                        d = (ClRIndex < ClLowArea) ? (
                                (ClRIndex - ClLowLimit) / (ClLowArea - ClLowLimit)
                            ) : (
                                (ClHighLimit - ClRIndex) / (ClHighLimit - ClHighArea)
                            );
                        pvol *= min(1,d*d); // use a quadratic coeff.
                    );
                );
                ((pflg) && (pvol != 0)) ? (
                    // do actual interpolation
                    index = floor(ClRIndex);
                    delta = ClRIndex - index;
                    // Convert to samples, add channel offset
                    index *= CCCC; index += GCBL[gChOffset];
                    ((delta < 0.0001) || (delta > 0.9999)) ? (
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        gspl = pvol * UBuffer[index];
                    ) : (
                        xm1 = UBuffer[index-CCCC];
                        x0 = UBuffer[index];
                        x1 = UBuffer[index+CCCC];
                        x2 = UBuffer[index+CCCC+CCCC];
                        gspl = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                    * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                    * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                    );
                );
                GCBL[gClRIndex] += GCBL[gclRSpeed];
                // GCBL[gStatus] = pflg;
                // gspl = max(-1.1, min(1.1, gspl)); // hard limiter !

                spl(GCBL[gChNum]) += gspl;
                (!pflg) ? (
                    // free the buffer
                    GCBacts[abp] = 0;
                    // Pmode = WaitLooping;
                    // doSynchro(); // starts synchro
                    doStop ? (
                        GrXpect = 0;
                    );
                );
            );
        ) : (
            // unused buffer
            fbuff < 0 ? fbuff = abp; // note the first free buffer
        );
        abp += 1;
    );
    // Update active buffer count
    // gmem[UAdd + cbPDisp  + 18] = pct; // keep
    maxu < GCBactM ? (
        GCBactM = maxu;
        // gmem[UAdd + cbPDisp  + 5] = GCBactM;
    );
    // should we start a new buffer ?
    ((GrXpect > pct) && (currSmpl >= synchroPos)) ? (
        // allocate a new buffer
        GCBactM = min(MaxGr, GCBactM); // limit this
        fbuff < 0 ? fbuff = GCBactM + 1;
        GCBactM = max(GCBactM, fbuff);
        // gmem[UAdd + cbPDisp  + 5] = GCBactM;
        GCBacts[fbuff] = GCBL = GCBpts[fbuff];
        GCBL[gStatus] = 0; // will be initialized at next sample
        doSynchro(); // starts synchro
    ) : (
        ((pct == 0) && (GrXpect <= 0)) ? (
            // no more buffer playing
            Pmode = Inactive;
            gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
        );
    );
) :


(Pmode == WaitPlaying) ? (
    (doSync && (currSmpl >= synchroPos)) ? (
        doSync = 0;
        Pmode = CurrentActPlaying;
        endclip = guarddog = second + 1 + clRepeatDur;
        gmem [UAdd+RCB_CPStart_tim] = time_precise() + gmem[timeDelta];
    ) :
    (
        guarddog = second + 5;
    );
) :


(Pmode == WaitLooping) ? (
    (second > guarddog) ? (
        doSync = 0;
        endclip = guarddog = second + 15;
        doStop ? (
            Pmode = Inactive;
        ) : (
            // time to stop
            doSynchro();
            doStop = 1;
        );
    ) :
    (doSync && (currSmpl >= synchroPos)) ? (
        Pmode = ActLooping;
        GCBactM = -1; // max. indice of active pointers
    );
);






// (Pmode != Inactive) ? (
//     gmem[UAdd + cbPDisp  + 15] += 1;
// );



);









            //===3===//
            // === Std Loop ===
            abp = 0; maxu = -1; fbuff = -1; A_Gp_ct = 0;
            while (abp <= GCBactM) (
                (GCBL = GCBacts[abp]) ? (
                    A_Gp_ct += 1; // this counts as a playing buffer
                    maxu = abp; // note the last used buffer
                    (GCBL[gStatus] == 0) ? (
                        (doSync && (currSmpl >= synchroPos)) ? (
                            doSync = 0;
                            // restart a new bloc
                            GCBL[gStatus] = 1;
                            // choose a random tupple : position and length
                            GCBL[gClLowLimit] = k = GrStLLimit + irand(max(1,GrStHLimit - GrMaxTplU - GrStLLimit + 1));
                            GCBL[gClHighLimit] = m = min(GrStHLimit, k + GrMinTplU + irand(GrMaxTplU - GrMinTplU + 1));
                            GCBL[gClRSpeed] = ClRIndInc;
                            (clRSpeed > 0) ? (
                                GCBL[gClRIndex] = k;
                                GCBL[gClLowArea] = k + GrFInTplU;
                                GCBL[gClHighArea] = m - GrFOutTplU;
                            ) : (
                                GCBL[gClRIndex] = m;
                                GCBL[gClLowArea] = k + GrFOutTplU;
                                GCBL[gClHighArea] = m - GrFInTplU;
                            );
                            GCBL[gChOffset] = irand(CCCC); // Choose on channel
                            GCBL[gChCount] = 1;
                            GCBL[gChNum] = gmem[UAddChs+HPIndx]; HPIndx = (HPIndx + 1) % HPCnt;
                            xxcnt += 1;
                            // gmem[UAdd + cbPDisp  + 21] = k / FFrRate;
                            // gmem[UAdd + cbPDisp  + 22] = m / FFrRate;
                            // gmem[UAdd + cbPDisp  + 7] = ccs = (m - k + 1) / SpdFact;
                            // gmem[UAdd + cbPDisp  + 9] = xxcnt;
                            // gmem[UAdd + cbPDisp  + 12] = max(gmem[UAdd + cbPDisp  + 12], ccs);
                            // gmem[UAdd + cbPDisp  + 13] = min(gmem[UAdd + cbPDisp  + 13], ccs);
                            // gmem[UAdd + cbPDisp  + 26] = FP_GlobVol;
                        );
                    ) : (
                        // BLoopNext(GCBL);
                        pflg = 1;
                        pvol = FP_GlobVol;
                        gspl = 0;
                        ClRIndex = GCBL[gClRIndex];
                        ClLowArea = GCBL[gClLowArea];
                        ClHighArea = GCBL[gClHighArea];
                        ClLowLimit = GCBL[gClLowLimit];
                        ClHighLimit = GCBL[gClHighLimit];
                        ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
                            // are we finished ?
                            ((ClRIndex <  ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                                pflg = pvol = 0;
                            ) : (
                                // compute an appropriate fade volume
                                d = (ClRIndex < ClLowArea) ? (
                                        (ClRIndex - ClLowLimit) / (ClLowArea - ClLowLimit)
                                    ) : (
                                        (ClHighLimit - ClRIndex) / (ClHighLimit - ClHighArea)
                                    );
                                pvol *= min(1,d*d); // use a quadratic coeff.
                            );
                        );
                        ((pflg) && (pvol != 0)) ? (
                            // do actual interpolation
                            index = floor(ClRIndex);
                            delta = ClRIndex - index;
                            // Convert to samples, add channel offset
                            index *= CCCC; index += GCBL[gChOffset];
                            ((delta < 0.0001) || (delta > 0.9999)) ? (
                                // return sample to optimize
                                (delta > 0.5) ? index += CCCC;
                                gspl = pvol * UBuffer[index];
                            ) : (
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                gspl = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            );
                        );
                        GCBL[gClRIndex] += GCBL[gClRSpeed];
                        // GCBL[gStatus] = pflg;
                        // gspl = max(-1.1, min(1.1, gspl)); // hard limiter !

                        spl(GCBL[gChNum]) += GrXVol * gspl;
                        (!pflg) ? (
                            // free the buffer
                            GCBacts[abp] = 0;
                            // Pmode = WaitLooping;
                            // doSynchro(); // starts synchro
                            doStop ? (
                                GrXpect = 0;
                            );
                        );
                    );
                ) : (
                    // unused buffer
                    fbuff < 0 ? fbuff = abp; // note the first free buffer
                );
                abp += 1;
            );
            // Update active buffer count
            // gmem[UAdd + cbPDisp  + 18] = A_Gp_ct; // keep
            maxu < GCBactM ? (
                GCBactM = maxu;
                // gmem[UAdd + cbPDisp  + 5] = GCBactM;
            );
            // should we start a new buffer ?
            ((GrXpect > A_Gp_ct) && (currSmpl >= synchroPos)) ? (
                // allocate a new buffer
                GCBactM = min(MaxGr, GCBactM); // limit this
                fbuff < 0 ? fbuff = GCBactM + 1;
                GCBactM = max(GCBactM, fbuff);
                // gmem[UAdd + cbPDisp  + 5] = GCBactM;
                GCBacts[fbuff] = GCBL = GCBpts[fbuff];
                GCBL[gStatus] = 0; // will be initialized at next sample
                doSynchro(); // starts synchro
            ) : (
                ((A_Gp_ct == 0) && (GrXpect <= 0)) ? (
                    // no more buffer playing
                    Pmode = mdInactive;
                    gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
                    sprintf(#dbg_trace4, "* %s * End loop3 : %.3fs %.0f", edTime(tUnix - tStart), (currSmpl - SmpPStart)/currSrate, currSmpl);
                );
            );
            //===3===//



            //===4===//
            // === New Loop ===
            TPL = tplA; memset(tplA, 0, tpChNb);
            abp = 0; maxu = -1; fbuff = -1; A_Gp_ct = 0;
            while (abp <= GCBactM) (
                (GCBL = GCBacts[abp]) ? (
                    A_Gp_ct += 1; // this counts as a playing buffer
                    maxu = abp; // note the last used buffer
                    (GCBL[gStatus] == 0) ? (
                        (doSync && (currSmpl >= synchroPos)) ? (
                            doSync = 0;
                            // restart a new bloc
                            GCBL[gStatus] = 1;
                            // choose a random tupple : position and length
                            // First choose a length (in tpl)
                            GrLen = 0 | (GrMinTplU + (GrMaxTplU - GrMinTplU) * frand());
                            // Adapt the top percent :  FP_GL_GTWd in [0 100]
                            GrLen2 = (Grlen * (100 - FP_GL_GTWd) / 100) / (GrFInTplU + GrFOutTplU) ;
                            // determine fadein and fade out
                            GrFIn = 0|(GrFInTplU * GrLen2);
                            GrFOut = 0|(GrFOutTplU * GrLen2);
                            // Modify slant point ?  FP_GL_Slant in [-100 100]
                            (FP_GL_Slant > 0) ? (
                                // longer fade in, shorter fade out
                                // remove from GrFOut to add to GrFIn
                                qt = 0|(GrFOut * (FP_GL_Slant / 100));
                                GrFOut -= qt; GrFIn += qt;
                            ) :
                            (FP_GL_Slant < 0) ? (
                                // longer fade out, shorter fade in
                                // remove from GrFIn to add to GrFOut
                                qt = 0|(GrFIn * (- FP_GL_Slant / 100));
                                GrFIn -= qt; GrFOut += qt;
                            );
                            GrFIn = max(6, GrFIn); GrFOut = max(6, GrFOut);
                            // decide a starting point
                            // when FP_G_PVar is 100%, qv is zero,  GRLL is  GrStLLimit and GRHL is GrStHLimit
                            // when FP_G_PVar is 0 %, qv is 1,
                            //             qw is usable clip length, GRLL is a position propotional to FP_G_PPos
                            //             and GRHL is equal to GRLL
                            qv = (100 - FP_G_PVar) / 100; qw = GrStHLimit - GrStLLimit - GrLen;
                            GRLL = 0|(GrStLLimit + qv * qw * FP_G_PPos / 100);
                            GRHL = 0|(GrStHLimit - qv * qw * (100 - FP_G_PPos)/ 100);
                            //
                            /*
                            GRLL = GrStLLimit;
                            GRHL = GrStHLimit;
                            */
                            GCBL[gClLowLimit] = k = GRLL + irand(max(1, GRHL - GrLen - GRLL + 1));
                            GCBL[gClHighLimit] = m = min(GRHL, k + GrLen);
                            GCBL[gClRSpeed] = ClRIndInc;
                            (clRSpeed > 0) ? (
                                GCBL[gClRIndex] = k;
                                GCBL[gClLowArea] = k + GrFIn;
                                GCBL[gClHighArea] = m - GrFOut;
                            ) : (
                                GCBL[gClRIndex] = m;
                                GCBL[gClLowArea] = k + GrFOut;
                                GCBL[gClHighArea] = m - GrFIn;
                            );
                            GCBL[gChOffset] = irand(CCCC); // Choose on channel
                            GCBL[gChCount] = 1;
                            GCBL[gChNum] = gmem[UAddChs+HPIndx]; HPIndx = (HPIndx + 1) % HPCnt;
                            xxcnt += 1;
                            // gmem[UAdd + cbPDisp  + 21] = k / FFrRate;
                            // gmem[UAdd + cbPDisp  + 22] = m / FFrRate;
                            // gmem[UAdd + cbPDisp  + 7] = ccs = (m - k + 1) / SpdFact;
                            // gmem[UAdd + cbPDisp  + 9] = xxcnt;
                            // gmem[UAdd + cbPDisp  + 12] = max(gmem[UAdd + cbPDisp  + 12], ccs);
                            // gmem[UAdd + cbPDisp  + 13] = min(gmem[UAdd + cbPDisp  + 13], ccs);
                            // gmem[UAdd + cbPDisp  + 26] = FP_GlobVol;
                        );
                    ) : (
                        // BLoopNext(GCBL);
                        pflg = 1;
                        pvol = FP_GlobVol;
                        gspl = 0;
                        ClRIndex = GCBL[gClRIndex];
                        ClLowArea = GCBL[gClLowArea];
                        ClHighArea = GCBL[gClHighArea];
                        ClLowLimit = GCBL[gClLowLimit];
                        ClHighLimit = GCBL[gClHighLimit];
                        ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
                            // are we finished ?
                            ((ClRIndex <  ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                                pflg = pvol = 0;
                            ) : (
                                // compute an appropriate fade volume
                                d = (ClRIndex < ClLowArea) ? (
                                        (ClRIndex - ClLowLimit) / (ClLowArea - ClLowLimit)
                                    ) : (
                                        (ClHighLimit - ClRIndex) / (ClHighLimit - ClHighArea)
                                    );
                                pvol *= min(1,d*d); // use a quadratic coeff.
                            );
                        );
                        ((pflg) && (pvol != 0)) ? (
                            // do actual interpolation
                            index = floor(ClRIndex);
                            delta = ClRIndex - index;
                            // Convert to samples, add channel offset
                            index *= CCCC; index += GCBL[gChOffset];
                            ((delta < 0.0001) || (delta > 0.9999)) ? (
                                // return sample to optimize
                                (delta > 0.5) ? index += CCCC;
                                gspl = pvol * UBuffer[index];
                            ) : (
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                gspl = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            );
                        );
                        GCBL[gClRIndex] += GCBL[gClRSpeed];
                        // GCBL[gStatus] = pflg;
                        // gspl = max(-1.1, min(1.1, gspl)); // hard limiter !

                        // spl(GCBL[gChNum]) += GrXVol * gspl;
                        // spl(GCBL[gChNum]) += max(-0.99, min(0.99, GrXVol * gspl));
                        // tplA[GCBL[gChNum]] += max(-0.99, min(0.99, GrXVol * gspl));
                        xx = GCBL[gChNum];
                        tplA[xx] = max(-0.99, min(0.99, GrXVol * gspl));
                        spl(xx) += tplA[xx];
                        (!pflg) ? (
                            // free the buffer
                            GCBacts[abp] = 0;
                            // Pmode = WaitLooping;
                            // doSynchro(); // starts synchro
                            doStop ? (
                                GrXpect = 0;
                            );
                        );
                    );
                ) : (
                    // unused buffer
                    fbuff < 0 ? fbuff = abp; // note the first free buffer
                );
                abp += 1;
            );
            // Update active buffer count
            // gmem[UAdd + cbPDisp  + 18] = A_Gp_ct; // keep
            maxu < GCBactM ? (
                GCBactM = maxu;
                // gmem[UAdd + cbPDisp  + 5] = GCBactM;
            );
            // should we start a new buffer ?
            ((GrXpect > A_Gp_ct) && (currSmpl >= synchroPos)) ? (
                // allocate a new buffer
                GCBactM = min(MaxGr, GCBactM); // limit this
                fbuff < 0 ? fbuff = GCBactM + 1;
                GCBactM = max(GCBactM, fbuff);
                // gmem[UAdd + cbPDisp  + 5] = GCBactM;
                GCBacts[fbuff] = GCBL = GCBpts[fbuff];
                GCBL[gStatus] = 0; // will be initialized at next sample
                doSynchro(); // starts synchro
            ) : (
                ((A_Gp_ct == 0) && (GrXpect <= 0)) ? (
                    // no more buffer playing
                    Pmode = mdInactive;
                    gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
                    sprintf(#dbg_trace4, "* %s * End loop4 : %.3fs %.0f", edTime(tUnix - tStart), (currSmpl - SmpPStart)/currSrate, currSmpl);
                );
            );
            //===4===//




);


                // Temporary trace
                /*
                (FlagsTbVals[Flgs_Logs] & 0x10) ? (
                    sprintf(padPlayStoreLabs[16], "%d", gmem[GXUnit + cbPDisp + 0]);
                    sprintf(padPlayStoreLabs[17], "%d", gmem[GXUnit + cbPDisp + 1]);
                    sprintf(padPlayStoreLabs[18], "%d", gmem[GXUnit + cbPDisp + 2]);
                    sprintf(padPlayStoreLabs[19], "%d", gmem[GXUnit + cbPDisp + 3]);
                    sprintf(padPlayStoreLabs[20], "%d", gmem[GXUnit + cbPDisp + 4]);
                    sprintf(padPlayStoreLabs[21], "%d", gmem[GXUnit + cbPDisp + 5]);
                    sprintf(padPlayStoreLabs[22], "%d", gmem[GXUnit + cbPDisp + 6]);
                    sprintf(padPlayStoreLabs[23], "%d", gmem[GXUnit + cbPDisp + 7]);
                    sprintf(padPlayStoreLabs[24], "%d", gmem[GXUnit + cbPDisp + 8]);
                    sprintf(padPlayStoreLabs[25], "%d", gmem[GXUnit + cbPDisp + 9]);
                    sprintf(padPlayStoreLabs[26], "%d", gmem[GXUnit + cbPDisp + 10]);
                    sprintf(padPlayStoreLabs[27], "%d", gmem[GXUnit + cbPDisp + 11]);
                    sprintf(padPlayStoreLabs[28], "%d", gmem[GXUnit + cbPDisp + 12]);
                    sprintf(padPlayStoreLabs[29], "%d", gmem[GXUnit + cbPDisp + 13]);
                    sprintf(padPlayStoreLabs[30], "%d", gmem[GXUnit + cbPDisp + 14]);
                    sprintf(padPlayStoreLabs[31], "%d", gmem[GXUnit + cbPDisp + 15]);
                    sprintf(padPlayStoreLabs[32], "%d", gmem[GXUnit + cbPDisp + 16]);
                    sprintf(padPlayStoreLabs[33], "%d", gmem[GXUnit + cbPDisp + 17]);
                    sprintf(padPlayStoreLabs[34], "%d", gmem[GXUnit + cbPDisp + 18]);
                    sprintf(padPlayStoreLabs[35], "%d", gmem[GXUnit + cbPDisp + 19]);
                    sprintf(padPlayStoreLabs[36], "%d", gmem[GXUnit + cbPDisp + 20]);
                    sprintf(padPlayStoreLabs[37], "%d", gmem[GXUnit + cbPDisp + 21]);
                    sprintf(padPlayStoreLabs[38], "%d", gmem[GXUnit + cbPDisp + 22]);
                    sprintf(padPlayStoreLabs[39], "%d", gmem[GXUnit + cbPDisp + 23]);
                );
                */

                /*
                sprintf(padPlayStoreLabs[0], "%d", pKP);
                sprintf(padPlayStoreLabs[1], "%d", UXstat);
                */

        /*
    paramDyn[idx += 1] = p_Dyn_Type;
    paramDyn[idx += 1] = p_Dyn_Flgs1;
    paramDyn[idx += 1] = p_Dyn_Flgs2;
    paramDyn[idx += 1] = p_Dyn_Vol;
    paramDyn[idx += 1] = p_Dyn_GS;
    paramDyn[idx += 1] = p_dyn_Rate;
    paramDyn[idx += 1] = p_Transpose;
    paramDyn[idx += 1] = p_Dyn_Direct;
    paramDyn[idx += 1] = p_Dyn_Slant;
    paramDyn[idx += 1] = p_Dyn_GTWd;
    paramDyn[idx += 1] = p_Dyn_GrFISh;
    paramDyn[idx += 1] = p_Dyn_GrFOSh;
    paramDyn[idx += 1] = p_Dyn_PlPos;
    paramDyn[idx += 1] = p_Dyn_PlLat;
    paramDyn[idx += 1] = p_Dyn_PlMass;
    paramDyn[idx += 1] = p_Dyn_Asynch;
    paramDyn[idx += 1] = p_Harmonic_Shape;
    paramDyn[idx += 1] = p_Inharmonicity;
    */





ui_split_top(h3);
    ui_hover() ? (
        (jmc == 0) ? (
            (KeyedT === 'left') ? (iKPar = (iKPar + paramDynCnt - 1) % paramDynCnt; KeyedT = 0; ) :
            (KeyedT === 'rght') ? (iKPar = (iKPar + 1) % paramDynCnt; KeyedT = 0; ) ;
        );
    );
    ui_pad(1,2,3,2);
    ik = iKPar;
    ig = 0; loop (4,
        (ig === 0) ? ui_new_column(1/4) : ui_new_column();
        chz = 0;
        ui_hover() ? (
            ui_push();
                ui_color(Col_SubFrame);
                ui_border();
            ui_pop();
            (jmc & 1) ? chz = 1;
        );
        prn = paramDyn[ik];
        ui_show(parGetPP(prn, pp_Name), (v = (currpad < 0) ? gmem[- currpad + prn - p_Dyn_First] :
                (currpad > 0) ? currpad[prn - p_Dyn_First] : paramValues[prn]),
                parGetPP(prn, pp_SFmt));

        chz ? (chz = 0; clone_parameter(p_Interact, prn); parSet(p_Interact, v); cpsrc = prn; );
        ig += 1;
        ik = (ik + 1) % paramDynCnt;


    );

    ui_pop();

ui_pop();






(
    // Manage global grains size/shape/params/speed etc.
    flSpdmod = flGmod = 0;
    FP_F = FP_Flg & gmem[dynGlFlags];
    ((FP_F & smUFlagVol) && (FP_Dyn_Vol != gmem[paramGCopy+p_Dyn_Vol])) ? (
        FP_Dyn_Vol = gmem[paramGCopy+p_Dyn_Vol];
        smUpdateFlag |= smUFlagVol;
    );
    ((FP_F & smUFlagGSize) && (FP_GL_GSiz != gmem[paramGCopy+p_Dyn_GS])) ? (
        FP_GL_GSiz = gmem[paramGCopy+p_Dyn_GS];
        flGmod |= 1;
    );
    ((FP_F & smUFlagGspeed) && (FP_GL_GSpd1 != gmem[paramGCopy+p_dyn_Rate])) ? (
        FP_GL_GSpd1 = gmem[paramGCopy+p_dyn_Rate];
        gmem[UAdd+RCB_SpeedMod1_u] = FP_GL_GSpd1;
        flSpdmod = 1;
    );
    ((FP_F & smUFlagGspeed) && (FP_GL_GSpd2 != gmem[paramGCopy+p_Transpose])) ? (
        FP_GL_GSpd2 = gmem[paramGCopy+p_Transpose];
        gmem[UAdd+RCB_SpeedMod2_u] = scale_12TET[max(0, min(96, 48 + FP_GL_GSpd2))];
        flSpdmod = 1;
    );
    ((FP_F & smUFlagGSlant) && (FP_GL_Slant != gmem[paramGCopy+p_Dyn_Slant])) ? (
        FP_GL_Slant = gmem[paramGCopy+p_Dyn_Slant];
    );
    ((FP_F & smUFlagGSust) && (FP_GL_GTWd != gmem[paramGCopy+p_Dyn_GTWd])) ? (
        FP_GL_GTWd = gmem[paramGCopy+p_Dyn_GTWd];
    );
    ((FP_F & smUFlagGPos) && (FP_G_PPos != gmem[paramGCopy+p_Dyn_PlPos])) ? (
        FP_G_PPos = gmem[paramGCopy+p_Dyn_PlPos];
    );
    ((FP_F & smUFlagGPVar) && (FP_G_PVar != gmem[paramGCopy+p_Dyn_PlLat])) ? (
        FP_G_PVar = gmem[paramGCopy+p_Dyn_PlLat];
    );
    ((FP_F & smUFlagGMass) && (FP_G_PMass != gmem[paramGCopy+p_Dyn_PlMass])) ? (
        FP_G_PMass = gmem[paramGCopy+p_Dyn_PlMass];
        GrXpect = max(GrMinXpect, min(gmem [UAdd+RCB_GrXpect] * FP_G_PMass, MaxGr-1));
        GrXVol = (GrXVolAdj + invsqrt(max(1,GrXpect)) / (GrXVolAdj + 1)); // (N + a)/(N + 1)
        flGmod |= 2;
    );
    ((FP_F & smUFlagAsync) && (FP_G_PAsyn != gmem[paramGCopy+p_Dyn_Asynch])) ? (
        FP_G_PAsyn = gmem[paramGCopy+p_Dyn_Asynch];
    );
    ((FP_F & smUFlagDDir) && (FP_G_Direct != gmem[paramGCopy+p_Dyn_Direct])) ? (
        FP_G_Direct = gmem[paramGCopy+p_Dyn_Direct];
    );
    ((FP_F & smUFlagInharm) && (FP_G_Inharm != gmem[paramGCopy+p_Inharmonicity])) ? (
        FP_G_Inharm = gmem[paramGCopy+p_Inharmonicity];
    );
    ((FP_F & smUFlagHarmShp) && (FP_G_HarmShp != gmem[paramGCopy+p_Harmonic_Shape])) ? (
        FP_G_HarmShp = gmem[paramGCopy+p_Harmonic_Shape];
    );
    ((FP_F & smUFlagGrISh) && (KmdKurrent == KmdLoop) && (FP_G_FI_Shp != gmem[paramGCopy+p_Dyn_GrFISh])) ? (
        FP_G_FI_Shp = gmem[paramGCopy+p_Dyn_GrFISh];
        buildShape(GrShpIn, FP_G_FI_Shp);
    );
    ((FP_F & smUFlagGrOSh) && (KmdKurrent == KmdLoop) && (FP_G_FO_Shp != gmem[paramGCopy+p_Dyn_GrFOSh])) ? (
        FP_G_FO_Shp = gmem[paramGCopy+p_Dyn_GrFOSh];
        buildShape(GrShpOut, FP_G_FO_Shp);
    );
    flGmod ? manageGrainsMods(flGmod);
    flSpdmod ? manageSpeed();

    (editDelay > 0) ? (
        ((gmem[UAdd+cbStat] === uSReady) || (gmem[UAdd+cbStat] === uSSaving) || (gmem[UAdd+cbStat] === uSEditing)) ? (
            gmem[UAdd+cbStat] = editDelay <= 2 ? uSSaving : uSEditing;  // not playing
            Pmode = ActEdit;
        );
    ) : (
        ((gmem[UAdd+cbStat] === uSEditing) || (gmem[UAdd+cbStat] === uSSaving)) ? (
            // reset to available
            gmem[UAdd+cbStat] = uSReady;
            Pmode = mdInactive;
        );
    );
);
xCount -= 1;




//=========================

        //----- Channels management
        // Because data is saved in 32 bits float rather than 64 bits float
        // we can't represent correctly 32 bits integers,
        // so we use only 16 bits integers in this case...
        hpfold = max(1, paramValues[p_GvChnUse]);
        ((HPCnt = gmem [UAdd+RCB_Channels_cnt_used]) <= 0) ? (
            // No channel specified - use 1st stereo as default
            gmem [UAdd+RCB_Channels_cnt_used] = HPCnt = 2;
            gmem [UAdd+RCB_ChSet1_set] = 0xC000; // use channels 0 & 1
            gmem [UAdd+RCB_ChSet2_set] = 0;
            gmem [UAdd+RCB_ChSet3_set] = 0;
            gmem [UAdd+RCB_ChSet4_set] = 0;
            gmem [UAddChs+0] = 0;
            gmem [UAddChs+1] = 1;
        );
        HPCnt = max(0, min(128, HPCnt));
        cu1 = gmem [UAdd+RCB_ChSet1_set];
        cu2 = gmem [UAdd+RCB_ChSet2_set];
        cu3 = gmem [UAdd+RCB_ChSet3_set];
        cu4 = gmem [UAdd+RCB_ChSet4_set];

        ((cu1 == 0) && (cu2 == 0) && (cu3 == 0) && (cu4 == 0)) ? (
            ix = 0;
            // recompute channels use
            loop(HPCnt,
                c = max(0, min(63, gmem [UAddChs+ix])) ;
                c < 16 ? cu1 |= 0x8000 >> c :
                c < 32 ? cu2 |= 0x8000 >> (c-16) :
                c < 48 ? cu3 |= 0x8000 >> (c-32) :
                         cu4 |= 0x8000 >> (c-48);
                ix += 1;
            );
            gmem [UAdd+RCB_ChSet1_set] = cu1;
            gmem [UAdd+RCB_ChSet2_set] = cu2;
            gmem [UAdd+RCB_ChSet3_set] = cu3;
            gmem [UAdd+RCB_ChSet4_set] = cu4;
        ) : (
            // recreate channels from the sets
            ix = 0;
            loop(64,
                gmem [UAddChs+ix] = 0; ix += 1;
            );
            ix = 0;
            ch = 15;
            loop(16,
                cu1 & 1 ? (gmem [UAddChs+ix] = ch; ix += 1; );
                cu1 = cu1 >> 1; ch -= 1;
            );
            ch = 31;
            loop(16,
                cu2 & 1 ? (gmem [UAddChs+ix] = ch; ix += 1; );
                cu2 = cu2 >> 1; ch -= 1;
            );
            ch = 47;
            loop(16,
                cu3 & 1 ? (gmem [UAddChs+ix] = ch; ix += 1; );
                cu3 = cu3 >> 1; ch -= 1;
            );
            ch = 63;
            loop(16,
                cu4 & 1 ? (gmem [UAddChs+ix] = ch; ix += 1; );
                cu4 = cu4 >> 1; ch -= 1;
            );
        );
         // Add copies of existing channels
         iy = 0;
         while (ix < 64) (
             gmem [UAddChs+ix] = gmem [UAddChs+iy];
             ix +=1; iy += 1;
         );
         // randomize channels
         (((clPFlags & FLdoForceFChs) == 0) && (HPCnt > 1)) ? (
             ix = 0;
             loop(HPCnt-1,
                 iy = ix + irand(HPCnt-ix);
                 (ix != iy) ? (
                     v = gmem [UAddChs+ix];
                     gmem [UAddChs+ix] = gmem [UAddChs+iy];
                     gmem [UAddChs+iy] = v;
                 );
                 ix += 1;
             );
             // Should we reduce the number of used channels ?
             c1 = max(1, gmem [UAdd+RCB_Channels_cnt_min]);
             c2 = max(1, gmem [UAdd+RCB_Channels_cnt_max]);
             (c2 > c1) ? c1 += irand(c2+1-c1);
             c1 = ceil(c1 * max(2, gmem [UAdd+RCB_Channels_density]) / 100);
             HPCnt = min(c1, HPCnt);
         );
         gmem [UAdd+RCB_Channels_cnt_used] = HPCnt = max(1,HPCnt);

//==================



/*
function
checkHPconfig(xcf)
local(ty, hb, ent, cnt, cf, i, j, c, k, kent)
(
    // (paramValues[p_HP_Algo] === 1) ? (
        ent = 0;
        AAxcf = cf = xcf;
        AAi = AAh1sthp = -1;
        AAalgo = gmem[paramGCopy+p_HP_Algo]; // paramValues[p_HP_Algo];
        ty = 100 * (0|(cf/100)); // conf. type

        hb = cf % 100; // hp base
        ((cf <= 0) || (cf >= HPPSize)) ? (
            GvErr = 0140;
        ) :
        (HPPTab[cf] > 0) ? (
            // regular config, return it
            ent = HPPTab[cf];
        ) :
        (
            cf = 0;
        );


        ((cf === 0) && (GvErr === 0)) ? (
            // not a regular config - choose a random one
            // in the same subclass/class
            (ty != 0) ? (
                // is the "next" entry valid ?
                (HPPTab[xcf+1] > 0) ? (
                    i = 1;
                    while (HPPTab[xcf+i] > 0) (
                        i += 1;
                    );
                    AAi = i;
                    // choose a random entry in this
                    (gmem[paramGCopy+p_HP_Algo] === 1) ? (
                        // algo 1 : random used
                        ent = HPPTab[xcf+1+irand(i-1)];
                    ) : (
                        (i <= 2) ? (
                            // there is just one entry ; use it
                            ent = HPPTab[xcf+1];
                        ) : (
                            // evaluate the score of the various entries
                            ent = HPPTab[xcf+1]; AAscr = 100000000;
                            j = 1;
                            loop (i-1,
                                kent = HPPTab[xcf+j]; AAkcr = 0;
                                c = kent[0]; k = 1;
                                loop(c,
                                    AAkcr += HP_Set_Cntr[kent[k]]; k += 1;
                                );
                                (AAkcr < AAscr) ? (
                                    AAscr = AAkcr; ent = kent;
                                );
                                j += 1;
                            );
                        );
                        AAh1sthp = ent[1];
                    );
                );
            ) ;
            ((hb === 0)||(ent === 0)) ? (
                ent = 0;  cnt = 200;
                while ((ent === 0) && (cnt > 0)) (
                    i = ty + irand(100);
                    ent = HPPTab[i];
                    cnt -= 1;
                    // AAAA_HP_cent = ent; cnt -= 1;
                    // AAAA_HP_cnt = cnt;
                    // AAAA_HP_ty2 = i;
                );
            );
        );
        ((ent === 0) && (GvErr === 0)) ? (
            (HPPTab[HPCurrCDef] > 0) ? (
                ent = HPPTab[HPCurrCDef];
            ) : (
                GvErr = 0142;
            );
        );

        (GvErr != 0) ? GvErrP1 = xcf;
        // AAAA_HP_ent = ent;
        ent; // return ent

    //);

);


function
HPInstall()
local(hpc, it, dec, pflgs, hpent, zz, hpmin, hpmax, hpncf)
(
    (reSelectHpSet > 0) ? (
        hpent = reSelectHpSet; reSelectHpSet = Undef;
        gmem[GPlUnit+RCB_KFlgs] |= FLdoForceFChs; // use as provided
        hpmin = hpmax = hpent[0];
        hpncf = pflgs =  0;
    ) :
    (reSelectHpent > 0) ? (
        hpent = HPPTab[reSelectHpent]; reSelectHpent = Undef;
        gmem[GPlUnit+RCB_KFlgs] |= FLdoForceFChs; // use as provided
        hpmin = hpmax = hpent[0];
        hpncf = pflgs =  0;
    ) : (
        hpent = checkHPconfig(SMAddr[idx_HPSet]);
        hpmin = SMAddr[idx_HPCnt1];
        hpmax = SMAddr[idx_HPCnt2];
        pflgs = SMAddr[idx_HPFlags];
        hpncf = hpent[-1];
    );

    (GvErr === 0) ? (
        //
        // ADump(hpent);
        //memset(HPArray, 0, HPwaSize);
        //memset(HPMerge, 0, HPwaSize*HPmrgCnt);
        hpc = hpent[0]; dec = 1; // get the entry description
        ((pflgs & HPFlButFrst) && (hpc > 1)) ? (dec +=1; hpc -= 1); // suppress 1st
        gmem[GPlUnit+RCB_Channels_cnfDup] = gmem[GPlUnit+RCB_Channels_conf1] = hpncf;
        gmem[GPlUnit+RCB_Channels_cnt_used] = hpc;
        gmem[GPlUnit+RCB_Channels_cnt_min] = hpmin;
        gmem[GPlUnit+RCB_Channels_cnt_max] = hpmax;
        gmem[GPlUnit+RCB_Channels_flgs] = pflgs;
        gmem[GPlUnit+RCB_Channels_density] = gmem[paramGCopy+p_HP_Density]; // paramValues[p_HP_Density];
        gmem[GPlUnit+RCB_ChSet1_set] = 0;
        gmem[GPlUnit+RCB_ChSet2_set] = 0;
        gmem[GPlUnit+RCB_ChSet3_set] = 0;
        gmem[GPlUnit+RCB_ChSet4_set] = 0;
        hpfold = max(1, gmem[paramGCopy+p_GvChnUse]);
        // Send all HP - Change origin (from 1 to 0)
        it = 0; loop(hpc,
            gmem[GPlUnit+cbPch00+it] = zz = (hpent[it+dec] - 1) % hpfold;
            HP_Set_Cntr[zz] += HP_Cost;
            it += 1;
        );
    );
);
*/














        // Now, modInst is the instance in this position of the module prototype
        chk = mSL_bl_check(modInst, 'umod');

        (chk) ? (
            ut = user_top = ui_top();
            ul = user_left = ui_left();
            uw = user_width = ui_width();
            uh = user_height = ui_height(); // total available height
            // Are our computations still valid ?
            (ui_Resized || (modInst[ubx_flgs] & 1) || (user_top !== modInst[ubx_t]) || (user_left !== modInst[ubx_l]) ||
                (user_width !== modInst[ubx_w])) ? (    //  || (user_height < modInst[ubx_h])
                // Recompute positions off all fields
                modInst[ubx_flgs] &= 0x7ffffffe;
                rptb = ubx_isiz; ptbl = modInst[-1];
                recomp = 1;
                modInst[ubx_t] = user_top;
                modInst[ubx_l] = user_left;
                modInst[ubx_w] = user_width;
                modInst[ubx_h] = ui_jd_ctgr;
                // Compute internal needed height
                //sprintf(#u, "Recomputing umod %x positions", ucod);
                // mSL_log(SysLogBox, #u);
                state = 1; prvstk = ptstk = 0; stack = wa256;
                // AWA! Almost Working Algorithm
                // First, provide work areas
                /*
                stack[ptstk] = 0; ptstk += 1;
                stack[ptstk] = 0; ptstk += 1;
                stack[ptstk] = 0; ptstk += 1;
                stack[ptstk] = 0; ptstk += 1;
                stack[ptstk] = 0; ptstk += 1;
                */
                uh = 0;
                while (state != 0) (
                    (state === 1) ? (
                        // Handling a sequence of vertical boxes
                        (rptb < ptbl) ? (
                            // push the module box
                            stack[ptstk] = 0; ptstk += 1;
                            stack[ptstk] = uh; ptstk += 1; // [-3] : computed height so far
                            stack[ptstk] = 1; ptstk += 1; // [-2] : return state
                            stack[ptstk] = 0; ptstk += 1; // [-1] : return stack
                            stack[ptstk] = crptb = rptb; // [0] ref of box
                            typtb = modInst[crptb + ubx_ty]; // type of box
                            prvstk = ptstk; // after the return
                            rptb += ubx_isiz; // next ref.
                            state = 2;
                        ) : (
                            uh = stack[prvstk - 3];
                            state =  0;
                        );
                    ) :
                    (state === 2) ? (
                        (typtb === 'sbox') ? (
                            // Add the size of the sbox
                            uh = (stack[ptstk - 3] += modInst[crptb + ubx_h]); // add height
                            // Return
                            state = stack[ptstk - 2];
                            ptstk = stack[ptstk - 1];
                        ) :
                        (typtb === 'tbox') ? (
                            // Get the size with the text wrap function
                            blk = modInst[crptb + ubx_mref]; // ref to the text box
                            txt = blk[ubx_isiz]; // the text string
                            // evaluate the height
                            uh = (stack[ptstk - 3] += (modInst[crptb + ubx_h] = w1 = ui_wraptext_height(txt)));
                            state = stack[ptstk - 2];
                            ptstk = stack[ptstk - 1];
                        ) :
                        (
                            err = 0871;
                            state = 0;
                        );
                    ) :
                    (
                        err = 0870;
                        state = 0;
                    );
                );
                modInst[ubx_h] = uh+ui_jd_ctgr;
            );

            uix_jneed = uix_jmini = modInst[ubx_h];
            (chk && (ui_height() >= uix_jmini)) ? (
                ui_split_top(uix_jneed);
                    ui_set_rect(ui_left(), ui_top(), max(ui_MinSize1Pane, min(ui_BestSize1Pane, ui_width())), ui_height());
                    zzmi = ui_hover();  // true if we are "in"
                    // Keep block position
                    keepBlockInfos(mod);
                    (zzmi) ? (
                        ui_push();
                            // stack is now 2 levels deep
                            ui_color(Col_Frame);
                            ui_border(); // draws in orange
                        ui_pop();
                    );
                    control_group(blockDispNames[blockDispInverts[mod]]);

                    ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
                    ut = ui_top();
                    ul = ui_left();
                    uw = ui_width();
                    uh = ui_height();

                    // Should we recomp item sizes ?
                    (recomp) ? (
                        state = 1; prvstk = ptstk = 0; stack = wa256;
                        rptb = ubx_isiz; ptbl = modInst[-1];
                        while (state != 0) (
                            (state === 1) ? (
                                (rptb < ptbl) ? (
                                    // push the module box
                                    stack[ptstk] = 0; ptstk += 1;
                                    stack[ptstk] = 0; ptstk += 1; // [-3] : computed height
                                    stack[ptstk] = 1; ptstk += 1; // [-2] : return state
                                    stack[ptstk] = 0; ptstk += 1; // [-1] : return stack
                                    stack[ptstk] = crptb = rptb; // [0] ref of box
                                    typtb = modInst[rptb + ubx_ty]; // type of box
                                    prvstk = ptstk; // after the return
                                    rptb += ubx_isiz; // next ref.
                                    state = 2;
                                ) : (
                                    state = 0;
                                );
                            ) :
                            (state === 2) ? (
                                (typtb === 'sbox') ? (
                                    // Set the size of the rectangle
                                    modInst[crptb + ubx_t] = ut;
                                    ut += modInst[crptb + ubx_h];
                                    modInst[crptb + ubx_l] = ul;
                                    modInst[crptb + ubx_w] = uw;
                                    // Return
                                    state = stack[ptstk - 2];
                                    ptstk = stack[ptstk - 1];
                                ) :
                                (typtb === 'tbox') ? (
                                    // recheck the size
                                    blk = modInst[crptb + ubx_mref]; // ref to the text box
                                    txt = blk[ubx_isiz]; // the text string
                                    // re-evaluate the height
                                    reh = (modInst[crptb + ubx_h] = w2 = ui_wraptext_height(txt));
                                    modInst[crptb + ubx_t] = ut;
                                    ut += reh;
                                    modInst[crptb + ubx_l] = ul;
                                    modInst[crptb + ubx_w] = uw;
                                    // Return
                                    state = stack[ptstk - 2];
                                    ptstk = stack[ptstk - 1];
                                ) :
                                (
                                    err = 0881;
                                    state = 0;
                                );
                            ) :
                            (
                                err = 0880;
                                state = 0;
                            );
                        );


                        (FlagsTbVals[Flgs_Umods] & 2) ? (
                    sprintf(#u, "User Block %x : %d / %d / %d / %d / %d => %d [t:%d  l:%d  w:%d  h:%d]  =>  [%d  %d  %d  %d]",
                    ucod, mod, umid, statn, blockUsrChecks[statn], blockUsrRefs[statn], modInst, user_top, user_left, user_width,
                    user_height, ut, ul, uw, uh); mSL_log(SysLogBox, #u);
                        );

                    );
                    // ui_text(#u);
                );
            );








/*
=== STRUCTURES ===
*/

//-------------
// Play Mode
PMEsize = 36; //  size of a playmode entry
idx_Kmd = 0;  // Commande des players,
idx_FLM = 1;  // flags de modification de la commande des players
idx_FLM2 = 2; //  "
idx_Speed = 3; // vitesse de lecture - min, max, inversion
idx_Speed2 = 4; // "
idx_Speed3 = 5; // "
idx_GDepth = 6; // superposition des voix - min, max
idx_GDepth2 = 7; // "
idx_PVol = 8; // volume - min, max
idx_PVol2 = 9; // "
idx_PDur = 10; // play duration - min, max
idx_PDur2 = 11; // "
idx_Gsize = 12; // grain size in seconds, min, max
idx_Gsize2 = 13; // "
idx_FX1 = 14; // Effect 1
idx_FX1_2 = 15; // "
idx_FX2 = 16; // Effect 2
idx_FX2_2 = 17; // "
idx_PFdIn = 18; // Play Fade-in
idx_PFdIn2 = 19; // Play Fade-in2
idx_PFdOut = 20; // Play Fade-out
idx_PFdOut2 = 21; // Play Fade-out2
idx_GPFdIn = 22; // Grain Fade-in
idx_GPFdIn2 = 23; // Grain Fade-in2
idx_GPFdOut = 24; // Grain Fade-out
idx_GPFdOut2 = 25; // Grain Fade-out2
idx_GPFdTy = 26; // Grain Fade Type
idx_ChCnt = 27; // Gen Channel Count
idx_Spec = 29; // Special modifieurs
idx_PmdN = 35; // Play mode number
//-------------




//-------------
// Play Mode
PMEsize = 36; //  size of a playmode entry
idx_PmdN = 0; // Play mode number
idx_Kmd = 1;  // Commande des players,
idx_FLM = 2;  // flags de modification de la commande des players
idx_FLM2 = 3; //  "
idx_Speed = 4; // vitesse de lecture - min, max, inversion
idx_Speed2 = 5; // "
idx_Speed3 = 6; // "
idx_GDepth = 7; // superposition des voix - min, max
idx_GDepth2 = 8; // "
idx_PVol = 9; // volume - min, max
idx_PVol2 = 10; // "
idx_PDur = 11; // play duration - min, max
idx_PDur2 = 12; // "
idx_Gsize = 13; // grain size in seconds, min, max
idx_Gsize2 = 14; // "
idx_FX1 = 15; // Effect 1
idx_FX1_2 = 16; // "
idx_FX2 = 17; // Effect 2
idx_FX2_2 = 18; // "
idx_PFdIn = 19; // Play Fade-in
idx_PFdIn2 = 20; // Play Fade-in2
idx_PFdOut = 21; // Play Fade-out
idx_PFdOut2 = 22; // Play Fade-out2
idx_GPFdIn = 23; // Grain Fade-in
idx_GPFdIn2 = 24; // Grain Fade-in2
idx_GPFdOut = 25; // Grain Fade-out
idx_GPFdOut2 = 26; // Grain Fade-out2
idx_GPFdTy = 27; // Grain Fade Type
idx_ChCnt = 28; // Gen Channel Count
idx_Spec = 30; // Special modifieurs
//-------------



//-------------
// Play Mode
PMEsize = 36; //  size of a playmode entry
idx_PmdN = 0; // Play mode number
idx_Kmd = 1;  // Commande des players,
idx_FLM = 2;  // flags de modification de la commande des players
idx_FLM2 = 3; //  "
idx_Speed = 4; // vitesse de lecture - min, max, inversion
idx_Speed2 = 5; // "
idx_Speed3 = 6; // "
idx_GDepth = 7; // superposition des voix - min, max
idx_GDepth2 = 8; // "
idx_PVol = 9; // volume - min, max
idx_PVol2 = 10; // "
idx_PDur = 11; // play duration - min, max
idx_PDur2 = 12; // "
idx_Gsize = 13; // grain size in seconds, min, max
idx_Gsize2 = 14; // "
idx_FX1 = 15; // Effect 1
idx_FX1_2 = 16; // "
idx_FX2 = 17; // Effect 2
idx_FX2_2 = 18; // "
idx_PFdIn = 19; // Play Fade-in
idx_PFdIn2 = 20; // Play Fade-in2
idx_PFdOut = 21; // Play Fade-out
idx_PFdOut2 = 22; // Play Fade-out2
idx_GPFdIn = 23; // Grain Fade-in
idx_GPFdIn2 = 24; // Grain Fade-in2
idx_GPFdOut = 25; // Grain Fade-out
idx_GPFdOut2 = 26; // Grain Fade-out2
idx_GPFdTy = 27; // Grain Fade Type
idx_ChCnt = 28; // Gen Channel Count
idx_Spec = 30; // Special modifieurs
//-------------








function
checkPartial(part, xflgs)
(
    // Is the partial valid ?
    GvErrP1 = part; GvErrP4 = BKDEcnt;
    ((part >= 0) && (part < BKDEcnt)) ? (
       xpAddr = BKTab + part * BKEsize; // the partial Address
        XcGrp = xpAddr[idx_Pa_Grp]; // group
        XcBnk = xpAddr[idx_Pa_Bnk]; // bank
        XsM = (reSelectSpaceMode >= 0) ? reSelectSpaceMode : xpAddr[idx_Pa_SpM]; // space mode
        GvErrP2 = XsM; GvErrP3 = reSelectSpaceMode;
        ((XsM >= 0) && (XsM < SMEcnt)) ? (
            SMAddr = SMTab + XsM * SMESize;
            (SMAddr[idx_Sm_HPSet1] === Undef) ? (
                GvErr = 0509; // HP set undefined in XsM
            );
            // (SMAddr[idx_Sm_HPSet2] === Undef) ? (
            //    SMAddr[idx_Sm_HPSet2] = SMAddr[idx_Sm_HPSet1];
            //);
        ) : (
            GvErr = 0508; // XsM probably undefined
        );
        XpM = (reSelectPlayMode >= 0) ? reSelectPlayMode : xpAddr[idx_Pa_PlM]; // play mode
        GvErrP2 = XpM; GvErrP3 = reSelectPlayMode;
        ((XpM >= 0) && (XpM < PMEcnt)) ? (
            PMAddr = PMTab + XpM * PMEsize;
            (PMAddr[idx_Pm_Kmd] === Undef) ? (
                GvErr = 0507;
                (FlagsTbVals[Flgs_Pdbg] & 4) ? (
                    // Imprimons voir...
                    sprintf(#ws01, "Err. 507 - PM %d has no command.", XpM);
                    mSL_log(SysLogBox, #ws01);
                );
            );
        );
        //sprintf(#s, "Play:  Part:%d  Sel:%d  Grp:%d  Bnk:%d  XpM:%d  XsM:%d", part, xsel, XcGrp, XcBnk, XpM, XsM);
        //mSL_log(SysLogBox, #s);
    ) : (
        GvErr = ((BKDEcnt <= 0) ? 0503 : 0504); // partial invalid
    );
    ((GvErr != 0) && (FlagsTbVals[Flgs_Play] & 1)) ? (
        sprintf(#s, "checkPartial(%d, %X) Err: %04d [%d %d %d %d]", part, xflgs, GvErr, GvErrP1, GvErrP2, GvErrP3, GvErrP4);
        mSL_log(SysLogBox, #s);
    );
    (FlagsTbVals[Flgs_Play] & 8) ? (
        sprintf(#s, "checkPartial_(%d, %X) Err: %04d [%d %d %d %d]", part, xflgs, GvErr, GvErrP1, GvErrP2, GvErrP3, GvErrP4);
        mSL_log(SysLogBox, #s);
    );

); //checkPartial






// Returns a pointer to an entry acceptable for configuration "xcf"
HPcErr = 0;
function
checkHPconfig(xcf, UList)
local(ty, hb, ent, cnt, cf, cpr, i, j, c, k, kent)
(
    ent = cf = hb = 0;
    (xcf === Undef) ? (
        xcf = 99;
    ) : (
        (GvErr === 0) ? (
            AAxcf = xcf;
            AAi = AAh1sthp = -1;
            ((xcf != (0|xcf)) || (xcf <= 0) || (xcf >= HPPSize)) ? (
                xcf = 99;
            ) :
            (((k = HPPTab[xcf]) > HPATab) && (k[-1] === xcf)) ? (
                // regular config, return it
                cf = xcf;
                ent = k;
            );
        );
    );

    ((cf === 0) && (GvErr === 0)) ? (
        // not a regular config - choose a random one
        // in the same subclass/class
        ty = 100 * (0|(xcf/100)); // conf. type
        hb = xcf % 100; // hp base
        (ty != 0) ? (
            // is the "next" entry valid ?
            (HPPTab[xcf+1] > 0) ? (
                i = 1;
                while (HPPTab[xcf+i] > 0) (
                    i += 1;
                );
                AAi = i;
                // choose a random entry in this
                (paramValues[p_HP_Algo] === 1) ? (
                    // algo 1 : random used
                    ent = HPPTab[cf=xcf+1+irand(i-1)];
                ) : (
                    (i <= 2) ? (
                        // there is just one entry ; use it
                        ent = HPPTab[xcf+1];
                    ) : (
                        // evaluate the score of the various entries
                        ent = HPPTab[xcf+1]; AAscr = 100000000;
                        j = 1;
                        loop (i-1,
                            kent = HPPTab[xcf+j]; AAkcr = 0;
                            c = kent[0]; k = 1;
                            loop(c,
                                AAkcr += HP_Set_Cntr[kent[k]]; k += 1;
                            );
                            (AAkcr < AAscr) ? (
                                AAscr = AAkcr; ent = kent;
                            );
                            j += 1;
                        );
                    );
                    AAh1sthp = ent[1];
                );
            );
        );

        ((hb === 0) && (ent === 0)) ? (
            // Choose a random entry of the same class
            cnt = 200;
            cf = ty + irand(100);
            cpr = gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];
            while ((ent === 0) && (cnt > 0)) (
                k = HPPTab[cf];
                ((k > HPATab) && (k[-1] === cf)) ? (ent = k; );
                cnt -= 1;
                cf = (cf + cpr) % 100 + ty;
            );
        );
    );

    ((ent === 0) && (GvErr === 0)) ? (
        (((k = HPPTab[HPCurrCDef % HPPSize]) > HPATab) && (k[-1] === HPCurrCDef)) ? (
            ent = k;
        ) : (
            GvErr = 0142;
        );
    );

    (GvErr != 0) ? (GvErrP1 = xcf;);
    // AAAA_HP_ent = ent;


    (ent === 0) ? (
        ent = HPPTab[21]; // entry by default : std stereo with channels 1 & 2
    );

    0 ? (sprintf(#s, "checkHPconfig: %d => %d (%d / %d) => %d %d | %d", xcf, cf,
             ent, HPATab, ent[-1], ent[0], paramValues[p_HP_Algo]);
         mSL_log(SysLogBox, #s););

    ent; // return ent

); // checkHPconfig()



////// VERSION 1
// Returns a pointer to an entry acceptable for configuration "xcf"
function
checkHPconfig(xcf, Z)
local(ty, hb, ent, cnt, cf, i, j, c, k, kent)
(
    ent = cf = 0;
    (xcf != Undef) ?
    (
        (GvErr === 0) ? (
            AAxcf = xcf;
            AAi = AAh1sthp = -1;
            ((xcf != (0|xcf)) || (xcf <= 0) || (xcf >= HPPSize)) ? (
                GvErr = 0140;
            ) :
            (((k = HPPTab[xcf]) > HPATab) && (k[-1] === xcf)) ? (
                // regular config, return it
                cf = xcf;
                ent = k;
            );
        );

        ((cf === 0) && (GvErr === 0)) ? (
            // not a regular config - choose a random one
            // in the same subclass/class
            ty = 100 * (0|(xcf/100)); // conf. type
            hb = xcf % 100; // hp base
            (ty != 0) ? (
                // is the "next" entry valid ?
                (HPPTab[xcf+1] > 0) ? (
                    i = 1;
                    while (HPPTab[xcf+i] > 0) (
                        i += 1;
                    );
                    AAi = i;
                    // choose a random entry in this
                    (paramValues[p_HP_Algo] === 1) ? (
                        // algo 1 : random used
                        ent = HPPTab[cf=xcf+1+irand(i-1)];
                    ) : (
                        (i <= 2) ? (
                            // there is just one entry ; use it
                            ent = HPPTab[xcf+1];
                        ) : (
                            // evaluate the score of the various entries
                            ent = HPPTab[xcf+1]; AAscr = 100000000;
                            j = 1;
                            loop (i-1,
                                kent = HPPTab[xcf+j]; AAkcr = 0;
                                c = kent[0]; k = 1;
                                loop(c,
                                    AAkcr += HP_Set_Cntr[kent[k]]; k += 1;
                                );
                                (AAkcr < AAscr) ? (
                                    AAscr = AAkcr; ent = kent;
                                );
                                j += 1;
                            );
                        );
                        AAh1sthp = ent[1];
                    );
                );
            );

            ((hb === 0) && (ent === 0)) ? (
                // Choose a random entry of the same class
                cnt = 200;
                while ((ent === 0) && (cnt > 0)) (
                    cf = ty + irand(100);
                    k = HPPTab[cf];
                    ((k > HPATab) && (k[-1] === cf)) ? (ent = k; );
                    cnt -= 1;
                );
            );
        );

        ((ent === 0) && (GvErr === 0)) ? (
            (((k = HPPTab[HPCurrCDef % HPPSize]) > HPATab) && (k[-1] === HPCurrCDef)) ? (
                ent = k;
            ) : (
                GvErr = 0142;
            );
        );

        (GvErr != 0) ? (GvErrP1 = xcf;);
        // AAAA_HP_ent = ent;
    );

    (ent === 0) ? (
        ent = HPPTab[21]; // entry by default : std stereo with channels 1 & 2
    );

    0 ? (sprintf(#s, "checkHPconfig: %d => %d (%d / %d) => %d %d | %d", xcf, cf,
             ent, HPATab, ent[-1], ent[0], paramValues[p_HP_Algo]);
         mSL_log(SysLogBox, #s););

    ent; // return ent

); // checkHPconfig()



///// VERSION 2

// Returns a pointer to an entry acceptable for configuration "xcf"
function
checkHPconfig(xcf, hpuse, winfo)
local(ty, hb, ent, cnt, cf, i, j, c, k, kent, lerr, rtc1, rtc2)
(
    lerr = ent = cf = 0;
    // Check/create hpuse
    ((hpuse === 0) || (hpuse === Undef)) ? (
        hpuse = HP_use_wa; memset(HP_use_wa, 0, HP_use_siz);
    ) : (
        lerr = mSL_StM_Check(hpuse);
        (lerr === 0) ? (
            (hpuse[-1] != HP_use_siz) ? (lerr = 0137;);
        );
    );
    ((winfo === 0) || (winfo === Undef)) ? (
        winfo = HP_info_wa; memset(HP_info_wa, 0, HP_info_siz);
    ) : (
        lerr = mSL_StM_Check(winfo);
        (lerr === 0) ? (
            (winfo[-1] != HP_info_siz) ? (lerr = 0137;);
        );
    );
    (lerr === 0) ? (
        // Update local addresses
        rtc1 = winfo + HP_info_rtc1;
        rtc2 = winfo + HP_info_rtc2;
    );
    (xcf != Undef) ?
    (
        (GvErr === 0) ? (
            AAxcf = xcf;
            AAi = AAh1sthp = -1;
            ((xcf != (0|xcf)) || (xcf <= 0) || (xcf >= HPPSize)) ? (
                GvErr = 0140;
            ) :
            (((k = HPPTab[xcf]) > HPATab) && (k[-1] === xcf)) ? (
                // regular config, return it
                cf = xcf;
                ent = k;
            );
        );

        ((cf === 0) && (GvErr === 0)) ? (
            // not a regular config - choose a random one
            // in the same subclass/class
            ty = 100 * (0|(xcf/100)); // conf. type
            hb = xcf % 100; // hp base
            (ty != 0) ? (
                // is the "next" entry valid ?
                (HPPTab[xcf+1] > 0) ? (
                    i = 1;
                    while (HPPTab[xcf+i] > 0) (
                        i += 1;
                    );
                    AAi = i;
                    // choose a random entry in this
                    (paramValues[p_HP_Algo] === 1) ? (
                        // algo 1 : random used
                        ent = HPPTab[cf=xcf+1+irand(i-1)];
                    ) : (
                        (i <= 2) ? (
                            // there is just one entry ; use it
                            ent = HPPTab[xcf+1];
                        ) : (
                            // evaluate the score of the various entries
                            ent = HPPTab[xcf+1]; AAscr = 100000000;
                            j = 1;
                            loop (i-1,
                                kent = HPPTab[xcf+j]; AAkcr = 0;
                                c = kent[0]; k = 1;
                                loop(c,
                                    AAkcr += HP_Set_Cntr[kent[k]]; k += 1;
                                );
                                (AAkcr < AAscr) ? (
                                    AAscr = AAkcr; ent = kent;
                                );
                                j += 1;
                            );
                        );
                        AAh1sthp = ent[1];
                    );
                );
            );

            ((hb === 0) && (ent === 0)) ? (
                // Choose a random entry of the same class
                cnt = 200;
                while ((ent === 0) && (cnt > 0)) (
                    cf = ty + irand(100);
                    k = HPPTab[cf];
                    ((k > HPATab) && (k[-1] === cf)) ? (ent = k; );
                    cnt -= 1;
                );
            );
        );

        ((ent === 0) && (GvErr === 0)) ? (
            (((k = HPPTab[HPCurrCDef % HPPSize]) > HPATab) && (k[-1] === HPCurrCDef)) ? (
                ent = k;
            ) : (
                GvErr = 0142;
            );
        );

        (GvErr != 0) ? (GvErrP1 = xcf;);
        // AAAA_HP_ent = ent;
    );

    (ent === 0) ? (
        ent = HPPTab[21]; // entry by default : std stereo with channels 1 & 2
    );

    0 ? (sprintf(#s, "checkHPconfig: %d => %d (%d / %d) => %d %d | %d", xcf, cf,
             ent, HPATab, ent[-1], ent[0], paramValues[p_HP_Algo]);
         mSL_log(SysLogBox, #s););

    ent; // return ent

); // checkHPconfig()




/*
// Definitions used in the text files (reduplication, don't change)
Mu=0x10000000; // base des codes "universels"
End=Mu+1;     // fin de definition
Idem=Mu+2;    // copy a previous entry
FIdent=Mu+3;    // File identification
PMd=Mu+10;     // Début d'un mode de jeu - attend un numéro de 0 à N
SMd=Mu+20;  // Début d'un mode d'espace - attend un numéro de 0 à N
WJ=0xff000000; // masque des codes "modes de jeu"
MA=0xff;      // masque des déplacements
//;  Définition des modes de jeu
KJ=0x11000000; // base des codes "modes de jeu"
//;  Définition des modes d'espace
KEs=0x12000000; // base des codes "modes d'espace"
//; Définition des banques
KBk=0x13000000; // base des codes "banques"
//; Infos sur les clips
KCl=0x14000000; // base des codes clips
P1=0x1000;    // le code attend un paramètre unique
P2=0x2000;    // le code attend deux paramètres
P3=0x3000;    // le code attend trois paramètres
P4=0x4000;    // le code attend quatre paramètres
P5=0x5000;    // le code attend cinq paramètres
P6=0x6000;    // le code attend six paramètres
*/
/*
//; Commandes des clips
ClVol=KCl+P1;  // Set current volume
ClRange=KCl+P2+1; // Define a range of clips
//;  Structure du bloc: sequence de valeurs
Kmd=KJ+P1+0;   // Commande des players,
FLM=KJ+P2+1;  // flags de modification de la commande des players
Speed=KJ+P3+3;  // vitesse de lecture - min, max, inversion
GDepth=KJ+P2+6;  // superposition des voix - min, max
PVol=KJ+P2+8;   // volume - min, max
Gsize=KJ+P2+10;  // grain size in seconds, min, max
FX1=KJ+P2+12;  // Effet un - volume min, volume max
FX2=KJ+P2+14;  // Effet deux - volume min, volume max
*/
//; Some constants with a name
// KmdPlay; // start playing — defined in clip lib
// KmdLoop; // start looping — defined in clip lib

/*
//; Quelques constantes
HPFlLRU=0x10;  // "Last recently used"
HPFlLFU=0x20;  // "Least frequently used"
HPFlRoRo=0x8; // "Round Robin"
HPFlRndm=0x4; // "Random"
HPFlFrst=0x1; // "First"
HPFlButFrst=0x2; // "But first" : all, except the first HP of the list
HPSet=KEs+P4+0; // Jusqu'à 4 "groupes de HP"
HPCnt=KEs+P2+4; // Nb. de HP
HPMode=KEs+P1+6; // mode
HPFlags=KEs+P1+7; // flags
HPdisp=KEs+P1+8; // Sound dispersion
HPEv=KEs+P4+8; // Evolution
*/

//; Définition des banques
//; Structure d'une banque [en fait, un partiel]
//Grp=KBk+P1+0; // Set group number
//Bnk=KBk+P1+1;  // Set bank number
//=KBk+P4+2; // Set clip range, and Playmode, and Spacemode
//PlM=KBk+P1+4;  // Playmode, separate
//SpM=KBk+P1+5;  // Spacemode, separate
//prVol=KBk+P2+6; // Vol. correction
//PWeight=KBk+P1+8; // Poids associé aux clips du partiel
//PClass=KBk+P1+9; // "classe" des clips du partiel
//PBFlgs=KBk+P1+10; // Flags du partiels
//PNumb=KBk+P1+11; // numéro du partiel

/*
//; A "play script"
PSKd=0x18000000+Mu;
PSStop=PSKd+1; // stop script
PSWait=PSKd+2; // wait for some seconds
PSetGrp=PSKd+3; // set the group to play
PSetCGens=PSKd+4; // set the generators count
PSetCPlay=PSKd+5; // set the players count
PSetCLoop=PSKd+6; // set the loopers count
PSetPLRatio=PSKd+7; // set the players/loopers ratio
PSetAutoMd=PSKd+8; // set the autoplay mode
PSetHPDsty=PSKd+9; // set the HP Density
PSetLoopVol=PSKd+10; // set the loopers volume
PSetPlayVol=PSKd+11; // set the players volume
PSetRateCtl=PSKd+12; // set the play rate control
PSetLoopDur=PSKd+13; // set the loops duration
PSetPlayDur=PSKd+14; // set the plays duration
PSetGenRand=PSKd+15; // set the generator count at random
PSetTSTX0=PSKd+16; // test the "exec" extension
PSetTSTX1=PSKd+17; // test the "exec" extension
PSetTSTX2=PSKd+18; // test the "exec" extension
*/

// Sensors
/*
MMode=Mu+17;  // MIDI Mode (in [0  3])
DefSeq=Mu+18;  // Definition d'une séquence de capteurs
SDur=Mu+19;  // Durée max. de détection de la séquence
DoKmd=Mu+20; // Définition d'une Suite de Commandes
Enter=Mu+21; // Entry in a MIDI
Exit=Mu+22;  // exit from a MIDI
*/



