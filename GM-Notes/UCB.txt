// Various unit control blocks
UGAddr = 0x300; // units global addresses in shared memory
UCBSize = 260+16; // size of a unit Control block description
uCnt = 128; // 80; // 64; // unit count
UGAddrLast = UGAddr + UCBSize * uCnt;
// Global vars for Unit control
UId = UAdd = UType = UnewId = UIrId = -1;
plIDNT = 'fsnd'; // frozen sound identification
//  New Read Control Block Description
RCB_Saved_Size = 80; // Size of the RCB block
// Lay out :
// RCB                   FSND
// usage                 |  constant 'fsnd'
   RCB_RMode =           RCB_FSND =            idxpt = 0;
// Address in gmem       |  Reference couter
   RCB_Rec_Entry =       RCB_RefCnt =          (idxpt += 1);
// Addresse in GM        |  unused
   RCB_Log_Entry =                             (idxpt += 1);
playLogHdrSize = idxpt + 1; // specific HDR in gmem
playLogCopySize = RCB_Saved_Size - playLogHdrSize; // size of infos to save
// =============== 1st field  @ 3
RCB_Kmd = (idxpt += 1); // # command for unit
RCB_KFlgs = (idxpt += 1); // # Flags for the command
RCB_PlyerFlgs = (idxpt += 1); // # Debug Flags for the players
RCB_PM_Flgs1 = (idxpt += 1); // Flags from the play mode
RCB_PM_Flgs2 = (idxpt += 1); // Flags from the play mode
RCB_Cl_Flgs = (idxpt += 1); // Clip play mode Flags : loop, mute, etc.
RCB_Random_seed = (idxpt += 1); // seed for player local random number
RCB_ClipNb = (idxpt += 1); // # Clip Number to read
// Speed Play conditions
RCB_PmMdSpd1 = (idxpt += 1); // speed field 1 from Play Mode
RCB_PmMdSpd2 = (idxpt += 1); // speed field 2 from Play Mode
RCB_PmMdSpd3 = (idxpt += 1); // speed field 3 from Play Mode
RCB_SpeedAbs_u = (idxpt += 1); // Asked Speed by the Game Master
RCB_SpeedMod1_u = (idxpt += 1); // # Speed Modifier 1
RCB_SpeedMod2_u = (idxpt += 1); // Speed Modifier 2
RCB_Transpose_u = (idxpt += 1); // # Speed transpose
RCB_CFrCorr_u = (idxpt += 1); // Clip Frequency correction (v.s. srate)
RCB_Speed_Dir_u = (idxpt += 1); // Speed direction 1/-1
// Duration
RCB_PmMdDur1 = (idxpt += 1); // duration field 1 from Play Mode
RCB_PmMdDur2 = (idxpt += 1); // duration field 2 from Play Mode
RCB_PlayTime = (idxpt += 1); // Clip play duration
// Volume
RCB_VolumeTarget_dB = (idxpt += 1); // "Target" Volume
RCB_StdVol = (idxpt += 1); // std clip playing volume
RCB_VolBias = (idxpt += 1); // volume change coefficiant
RCB_VolumeMod1_u = (idxpt += 1); // Volume Modifier 1
RCB_VolumeMin_dB = (idxpt += 1); // Volume low value
RCB_VolumeMax_dB = (idxpt += 1); // Volume high value
// Global Fades
RCB_FadeIn_ms = (idxpt += 1); // # Fade-in in milliseconds
RCB_FadeOut_ms = (idxpt += 1); // # Fade-out in milliseconds
RCB_PlayTime_sec = (idxpt += 1); // # Play Time in seconds
// Looper Add. infos
RCB_GrAlgo_enu = (idxpt += 1); // # Looper Algorithm
RCB_GrAPar1_v = (idxpt += 1); // # Looper Algorithm Parameter 1
RCB_MinGrains_ms = (idxpt += 1); // # Min. Grains duration, milliseconds
RCB_MaxGrains_ms = (idxpt += 1); // # Max. Grains duration, milliseconds
//////
RCB_MinNGrains_u = (idxpt += 1); // # Min. Grains depth
RCB_MaxNGrains_u = (idxpt += 1); // # Max. Grains depth
RCB_GrFdIn_ms = (idxpt += 1); // # Grains Fade-in in milliseconds
RCB_GrFdOut_ms = (idxpt += 1); // # Grains Fade-Out in milliseconds
RCB_Gr_FdType = (idxpt += 1); // Grains Fade Type
// Output Channels
RCB_Channels_cnt_tot = (idxpt += 1); // # Number of total defined out channels
RCB_Channels_cnt_used = (idxpt += 1); // # Number of used output channels
RCB_Channels_cnt_min = (idxpt += 1); // # min Number of output channels to use
RCB_Channels_cnt_max = (idxpt += 1); // # max Number of output channels to use
RCB_Channels_flgs = (idxpt += 1); // # Flags for output channels
RCB_Channels_density = (idxpt += 1); // # Density asked for output channels
RCB_ChSet1_set = (idxpt += 1); // # Output channels Set 1
RCB_ChSet2_set = (idxpt += 1); // # Output channels Set 2
RCB_ChSet3_set = (idxpt += 1); // # Output channels Set 3
RCB_ChSet4_set = (idxpt += 1); // # Output channels Set 4
RCB_Channels_conf = (idxpt += 1); // channels configuration
RCB_Synchro_source = (idxpt += 1); // source for synchronisation
// Some infos, actually unused
RCB_Serial = (idxpt += 1); // this play number [session relative]
//
// Other unnecessary informations
// Sent, but currently unused
RCB_CGrp_nbr = (idxpt += 1); // Clip Group Number
RCB_CBnk_nbr = (idxpt += 1); // Clip Bank Number
RCB_CPart_nbr = (idxpt += 1); // Clip Partial Number
RCB_CPlMd_nbr = (idxpt += 1); // Clip Play Mode
RCB_CSpMd_nbr = (idxpt += 1); // Clip space Mode
RCB_PlaySource = (idxpt += 1); // detailed play command
RCB_SmpPStart = (idxpt += 1); // start date as a sample number
//
// Locally (in FilePlayer) computed informations
RCB_CFty_enu = (idxpt += 1); // Clip File Type, an internal enumeration
RCB_CSiz_smp = (idxpt += 1); // Clip total Size, in Samples
RCB_CSiz_tpl = (idxpt += 1); // Clip Size, in Tuples
RCB_CCh_cnt = (idxpt += 1); // Clip Channel count
RCB_CFreq_sps = (idxpt += 1); // Clip sampling frequency, Hz
RCB_GrXpect = (idxpt += 1); // number of grains expected
RCB_StartIndex = (idxpt += 1); // Play start index
RCB_CPStart_tim = (idxpt += 1); // Clip Play Start (ptime)
RCB_CPStop_tim = (idxpt += 1); // Clip Play Stop (ptime)
RCB_ClStart = (idxpt += 1); // Clip Play Start Location (% of sample)
RCB_ClEnd = (idxpt += 1); // Clip Play End Location (% of sample)
RCB_CKstart_tim = (idxpt += 1); // Command Start Time (ptime)
//
RCB_Errc = (idxpt += 1); // RCB Error code
RCB_ClipDup = (idxpt += 1); // # Duplicate of the clip number
RCB_Channels_cnfDup = (idxpt += 1); // channels configuration
RCB_cbCKmd = (idxpt += 1); // current command - copy
//
// --
RCB_ActiveSize = idxpt + 1;
// --
// This doesn't really need to be saved
RCB_Mem_Avail = (idxpt += 1); // memory available
RCB_State_Changed = (idxpt += 1); // External State Change... Do something !
RCB_Item_Changed = (idxpt += 1); // External State Change... Do something !
RCB_Rec_Time = (idxpt += 1); // "Record Time" When started
RCB_Rec_Last = (idxpt += 1); // "Record Time" When started
RCB_Rec_Duration = (idxpt += 1); // Duration time
RCB_Rec_Flag  = (idxpt += 1); // Flag "ready to reinsert"
cbPch00 = (idxpt += 1); // list of output chan. description
idxpt += 65; // size for 64 channels + 1 limit
// Display infos
cbPDisp = (idxpt += 1); idxpt += 32; // Traces
// Other information
cbPtrPos = (idxpt += 1);

pcbVSpl0 = (idxpt += 1); // volume array for 64 channels
idxpt += 64;
// Last entry
UCBparCnt = (idxpt += 1); // last

RCB_ActualSize = (idxpt += 1); // RCB Actual Size
// --

// Keep last few words as unique non zeroed part of the UCB
// This doesn't need to be saved as part of the preset
idxpt = UCBSize; // restart from the end !
//
cbLocPrime = (idxpt -= 1); // a given prime, last entry
cbRUniq = (idxpt -= 1); // Unique device identification
cbType = (idxpt -= 1); // Unit type
cbUSt = (idxpt -= 1); // last Use time
cbStat = (idxpt -= 1); // unit global status
cbDclass = (idxpt -= 1); // MIDI units
cbChkUM = (idxpt -= 1);
cbChkGP = (idxpt -= 1);
cbInacFlg = (idxpt -= 1); // inactive flag
cbUnitIdt = (idxpt -= 1); // Unique Unit number
cbERR = (idxpt -= 1); // Error return code
cbLKmd = (idxpt -= 1); // last command
cbP08 = (idxpt -= 1); // add. cmd info
cbClipCnt = (idxpt -= 1); // Clip count
cbErC = (idxpt -= 1); // err counter
RCB_My_Track = (idxpt -= 1); // The track I'm on
RCB_My_Pos = (idxpt -= 1); // My position in the track
cbPlIdt = (idxpt -= 1); // Player number in the player list
// cbPadUnitIdt = (idxpt -= 1); // Pad UNIT Id
cbPlavail = (idxpt -= 1); // available mplayer memory (seconds)
cbMemory = (idxpt -= 1); // available mplayer memory (words)
cbClipLoop = (idxpt -= 1); // alt/clip loop flags
RCB_Repl_Src  = (idxpt -= 1); // Source of a replay
RCD_Sample_Start = (idxpt -= 1); // Sample to play
UCBparHCnt = (idxpt -= 1); // last

PCBsize = UCBSize;


// std commands
KmdNone = 0; // no command
KmdInq1 = 1; // Inquiry 1
KmsInq2 = 2; // Inquiry 2
KmdDoIt = 3; // also default usual command for the unit
KmdStop = 4; // stop playing
KmdQStop = 5; // stop playing ASAP
/*
*/
KmdCClear = 8; // counters clear
KmdSlowStop = 9; // very slow stop playing (with delay)
KmdSpF1 = 10; // special function 1
KmdKeepBusy = 11; // special function 1
KmdLock = 12; // lock player
KmdUnlock = 13; // unlock player
KmdDrone = 13; // experimental player type...


KmdPlLow = 16;
KmdPlay = 16; // start playing
KmdLoop = 17; // start looping
KmdPlItem = 18; // play "item"
// ...
KmdPlHigh = 31;


FLdoForcePlay = 0x100000; // force play flags
FLdoForceLoop = 0x200000;
FLdoForceRead = 0x400000;
FLdoForceLock = 0x080000; // play and lock
MskForcePlay = FLdoForceLoop | FLdoForceRead;
MskdoKeepKmnd = 0x0003ffff;
MskdoKeepHgFlgs = 0x7ffc0000;
FLdoForceKeep = 0x40;  // keep it always playing
FLdoForceVol = 0x20;  // play at fixed volume
FLdoForceFChs = 0x10;  // do not randomize channels
FLdoForcePFS = 0x8;  // play from start
FLdoForceSpeed1 = 0x4;  // play at speed 1
FLdoForceFadesSL = 0x2; // short fade-in, long fade-out
FLdoForceIntegral = 0x1; // play full clip

FLdoClipRpeat = 0x100; // force clip repeat


// Std unit status
uSUnused = 0;
uSReady = 1;
uSBusy = 2;
uSStarting = 3;
uSDone = 4; // not used
uSError = 5; // not used
uSInited = 6; // not used
uSReserved = 7; // not used
uSHalting = 8;
uSDummy = 11;
uSUnreachable = 12;

// Std player flags and infos
highPSpeed = 10; // max. read positive speed
highNSpeed = - highPSpeed; // max. read negative speed
lowPSpeed = 0.01; // min. read positive speed
lowNSpeed = - lowPSpeed; // min. read negative speed


// Add a dummy block for now
UGDummy = UGAddrLast; // a dummy block
gMemFree = UGDummy + UCBSize;

