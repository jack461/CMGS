/*
   Game Master ---
*/
@init

//    A micro Script Language for JSFX plug-ins
//
//    Part1 : the compiler
//        mSL_Comp_lib.jsfx-inc
//    J.J. Girardot - 7/2020
//
//
//    Note that "mSL_Utilities.jsfx-inc" must be
//    imported before this file




//==== Globals Adjustment parameters
//  for the compiler
mSL_minCpSize = 24576; // min. memory size required for compilation
mSL_intCSiz = 4096; // min. chained unit size
// mSL_StrsSize = 0; // size of an array of string references
mSL_GCSiz = 571; // sym. tab size (* 4) -- modified later
mSL_LCSiz = 131; // local table size
mSL_CstsSize = 64; // an array of symbolic constants definition
mSL_CMaxStrSiz = 8192;

// for the evaluator
mSL_minXcSize = 16384; // min. memory size required for execution
mSL_rpeat = 256 * 4096; // Inner exec loop repet. count
mSL_baseAVSPc = 0.010; // proportion for the global variables table "var"
mSL_baseAVSMin = 256;
mSL_baseAVSMax = 1536;
mSL_baseOVSPc = 0.006; // proportion for the semi-global variables table "loc"
mSL_baseOVSMin = 128;
mSL_baseOVSMax = 256;
mSL_basePVSPc = 0.003; // proportion for the semi-external variables table "ext"
mSL_basePVSMin = 64;
mSL_basePVSMax = 128;
mSL_baseStkPc = 0.040; // proportion for the stack
mSL_baseStkMin = 512;
mSL_baseStkMax = 3072;
mSL_baseMemPc = 0.001; // Static. alloc. memory
mSL_baseMemMin = 4; // actually, not used
mSL_baseMemMax = 4;


mSL_CMarkSiz = 32;
mSL_CGlobSiz = 2048; // max number of external definition FROM the plug-in
mSL_F2CSize = 256; // max number of defined functions in a code segment
mSL_CpStSiz = 256; // size of the Compiler Stack (for temp. subexpressions)
mSL_Flat_Siz = 32; // flattening a tree

// Code area - make sure the 3 next values are consistant based on mSL_Code_IShift...
mSL_Code_IShift = 12; // code pages with 4096 word
mSL_Code_ISize = 1 << mSL_Code_IShift;
mSL_Code_IMask = mSL_Code_ISize - 1;
mSL_Code_MainSize = 1024; // max number of code pages
// Tree area. Up to mSL_TreeBlPSize * mSL_TreePgMax cells
mSL_TreeCellUSize = 6; // each cell uses 6 words
mSL_TreeBlPSize = 1024; // number of cells in each allocated page
mSL_TreePgMax = 4096; // number of pointers to cell pages
// The chain unit blocks
mSL_rptr = 0; // The right pointer
mSL_lptr = 1; // The left pointer array
mSL_tyun = 2; // The array of types
mSL_valu = 3; // The array of values
mSL_upos = 4; // The array of unit positions
mSL_flgs = 5; // the associated flags
mSL_nullPtr = -1;
mSL_ChFree = mSL_nullPtr; // The free list head
mSL_TreeMainStruc = 0;
mSL_maxTrace = 0;
// Compiler global pointers
mSL_start = mSL_nullPtr;
mSL_HEAD = mSL_nullPtr;
mSL_end = mSL_nullPtr;
mSL_CP_Flags = 0; // trace flags

//=============================================
//==== NO ADJUSTABLE PARAMETER AFTER THIS POINT
//==== Main Globals
mSL_errC = -2;  // is set to 0 after a successful init
mSL_errX = -2;  // is set to 0 after a successful init
mSL_current_compiler = 0;
mSL_new_compiler = 0;
mSL_current_evaluator = 0;
mSL_new_evaluator = 0;
mSL_current_memory = 0; // points to the current memory block [at block+2]
mSL_new_memory = 0;
mSL_current_thread = 0;
mSL_new_thread = 0;
mSL_current_stack = 0;
// mSL_new_stack = 0;
mSL_CodeStop = 0; // reason for stopping execution
mSL_ExitValue = 0; // the exit value of the code


// Used strings
#mSL_fName = ""; // The file-name
#mSL_cline = ""; // current line
#mSL_wS1 = ""; // decoding an identifier
#mSL_wS2 = ""; // or a string
#mSL_wS3 = "";
#mSL_wS4 = ""; #mSL_wS5 = ""; #mSL_wS6 = ""; #mSL_wS7 = "";
#mSL_wS8 = ""; #mSL_wS9 = ""; #mSL_wSA = ""; #mSL_wSB = "";
#mSL_wSC = ""; #mSL_wSD = ""; #mSL_wSE = ""; #mSL_wSF = "";
#directory = ""; // import directory





// Some constants & sometimes combinable bits
mSL_tyOperand =    0x04000000;  // The unit is an operand
mSL_tySep =        0x02000000;  // The unit is a separator
mSL_tyOP =         0x01000000;  // The unit is an operator
mSL_tyOPMon =      0x00800000;  // The unit is a monadic operator
mSL_tyNeedLAddr =  0x00400000;  // the operation needs an address to the left
mSL_tyValuasPtr =  0x00200000;  // the value of the cell is a pointer
mSL_tyPrimFun   =  0x00100000;  // primitive or predefined operation
//                 0x0000FC00;  // The priority level, on 6 bits
//                 0x000003FF;  // The opcode on 10 bits
mSL_prtyShift = 10;  // shift const. for the priority value
mSL_prtyMask = 0x3F; // mask after shift
mSL_opKodMask = 0x3FF; // the op-code mask
mSL_tyChZ = mSL_tyOP | mSL_tySep;
// Codification of various Syntactic Units, Op Codes
mSL_tyHEAD = 1 | mSL_tySep;
mSL_tyTAIL = 2 | mSL_tySep;
mSL_tyIdent = 3 | mSL_tyOperand;
mSL_tyIdAddr = 4 | mSL_tyOperand;
mSL_tyKeywrd = 5 | mSL_tySep;
mSL_tyPrimF = 6 | mSL_tyOP;
mSL_tyPrimMF = 6 | mSL_tyOP | mSL_tyOPMon;
mSL_tyNum = 7 | mSL_tyOperand;
mSL_tyString = 8 | mSL_tyOperand;
mSL_tySubExp = 10 | mSL_tyOperand | mSL_tyValuasPtr;
mSL_tyParExp = 12 | mSL_tyOperand | mSL_tyValuasPtr; // parenthesed exp.
mSL_tyBrkExp = 13 | mSL_tyOperand | mSL_tyValuasPtr; // bracketed (?) exp.
// Special operators
mSL_prFCall = '()' ; // printable code for a function call
mSL_tyFCall = mSL_prFCall | mSL_tyOP;
mSL_prFdef = '(_' ; // printable code for a function definition
mSL_tyFdef = mSL_prFdef | mSL_tyOP;
mSL_prBrkInd = '[]' ; // printable code for an indexation
mSL_tyBrkInd = mSL_prBrkInd | mSL_tyOP;
mSL_tyBrkIndA = mSL_prBrkInd | mSL_tyNeedLAddr | mSL_tyOP;
mSL_prSpcF = '<>' ; // printable code for a special form
mSL_tyFSpcF = mSL_prSpcF | mSL_tyOP;
mSL_prList = '__';
mSL_tyList = mSL_prList | mSL_tyOP | mSL_tyValuasPtr;
// Parentheses
mSL_tyLPar = '('  | mSL_tySep;
mSL_tyRPar = ')'  | mSL_tySep;
mSL_tyLBrk = '['  | mSL_tySep;
mSL_tyRBrk = ']'  | mSL_tySep;
// Priorities levels, shifted
mSL_prty1 = 1 << mSL_prtyShift;
mSL_prty2 = 2 << mSL_prtyShift;
mSL_prty3 = 3 << mSL_prtyShift;
mSL_prty4 = 4 << mSL_prtyShift;
mSL_prty5 = 5 << mSL_prtyShift;
mSL_prty6 = 6 << mSL_prtyShift;
mSL_prty7 = 7 << mSL_prtyShift;
mSL_prty8 = 8 << mSL_prtyShift;
mSL_prty9 = 9 << mSL_prtyShift;
mSL_prty10 = 10 << mSL_prtyShift;
mSL_prty11 = 11 << mSL_prtyShift;
mSL_prty12 = 12 << mSL_prtyShift;
mSL_prty13 = 13 << mSL_prtyShift;
mSL_prty14 = 14 << mSL_prtyShift;
mSL_prty15 = 15 << mSL_prtyShift;
mSL_prty16 = 16 << mSL_prtyShift;
//

/*
== OPCODES ==
*/
//This indicates that the code op is a "long" opcode (on 2 words)
mSL_K_longInst = 0x200;
// Could have machine ops from 0 to 511, but we use only
// from 0 to 255 for now (with 128 actually unused)
// Short opcode use 10 bits, and have an operand of up to
// 22 bits, shifted 10 bits to the left.
// mSL_X_OpShift = 10; // the shift for the operand
mSL_X_OpShDiv = 1024; // but we use an int. multiply/divide, rather
mSL_X_OpMask = 0x3FF; // The mask for the operator code
// The machine op codes
// when possible, ASCII codes are used
// These numbers MUST match the actions in the "mSL_evaluate" procedure

// 0: illegal instrucion
mSL_K_stop = 1;
mSL_K_return = 2;
mSL_K_Pop = 3;
mSL_K_Set = 4;
mSL_K_SetAndPop = 5;
mSL_K_ldLVar = 6;
mSL_K_ldLAddr = 7;
mSL_K_ldGVar = 8;
mSL_K_ldGAddr = 9;
mSL_K_ldOVar = 10;
mSL_K_ldOAddr = 11;
mSL_K_ldPVar = 12;
mSL_K_ldPAddr = 13;
mSL_K_pYield = 14;
mSL_K_pWait = 15;
mSL_K_pushShort = 16;
mSL_K_pushNShort = 17;
mSL_K_indexVal = 18;
mSL_K_indexAdd = 19;
mSL_K_fCall = 20;
mSL_K_fError = 21;
mSL_K_fIdt = 22;
mSL_K_fNeg = 23;
mSL_K_Sum = 24;
mSL_K_Array = 25;
mSL_K_NotEq = 26;
mSL_K_Eq = 27;
mSL_K_fGTE = 28;
mSL_K_RShift = 29;
mSL_K_fLTE = 30;
mSL_K_LShift = 31;
mSL_K_fDiv = 32;
mSL_K_fMinus = 33;
mSL_K_fXOr = 34;
mSL_K_TrEq = 35;
mSL_K_TrNotEq = 36;
mSL_K_fRes = 37;
mSL_K_fAnd = 38;
mSL_K_fOr = 39;
mSL_K_fLT = 40;
mSL_K_fGT = 41;
mSL_K_fTimes = 42;
mSL_K_fAdd = 43;
mSL_K_fStrcode = 44;
mSL_K_fNot = 45;
// free : 46
mSL_K_DecrTos = 47;
mSL_K_Aff_Plus = 48; // v += ...
mSL_K_Aff_Minus = 49; // v -= ...
mSL_K_Aff_Times = 50; // v *= ...
mSL_K_Aff_Div = 51;  //  v /= ...
mSL_K_Aff_Mod = 52;  //  v %= ...
mSL_K_Aff_And = 53;  //  v &= ...
mSL_K_Aff_Or = 54;  //  v |= ...
mSL_K_Aff_XOr = 55;  //  v ~= ...
mSL_K_pIsString = 56;
mSL_K_pISize = 57;
mSL_K_pIsBlock = 58;
mSL_K_pmemcpy = 59;
mSL_K_pstrtmp = 60;
mSL_K_pthread = 61;
mSL_K_pedn = 62;
// free : 63;
// free : 64;
mSL_K_pSin = 65;
mSL_K_pCos = 66;
mSL_K_pTan = 67;
mSL_K_pASin = 68;
mSL_K_pACos = 69;
mSL_K_pATan = 70;
mSL_K_pMax = 71;
mSL_K_pMin = 72;
mSL_K_pAtan2 = 73;
mSL_K_pPow = 74;
mSL_K_pSqr = 75;
mSL_K_pSqrt = 76;
mSL_K_pExp = 77;
mSL_K_pLog = 78;
mSL_K_pAbs = 79;
mSL_K_pSign = 80;
mSL_K_pLog10 = 81;
mSL_K_pFloor = 82;
mSL_K_pCeil = 83;
mSL_K_pInvsqrt = 84;
mSL_K_pRand = 85;
mSL_K_pTime = 86;
mSL_K_pTPrecise = 87;
mSL_K_pSrate = 88;
mSL_K_pNum_ch = 89;
mSL_K_pTempo = 90;
mSL_K_pInt = 91;
mSL_K_pBNot = 92;
mSL_K_pgmem = 93;
mSL_K_fPow = 94;
mSL_K_pgmem2 = 95;
mSL_K_pMemtop = 96;
mSL_K_pIsInt = 97;
mSL_K_pIsFun = 98;
mSL_K_pCompile = 99;
mSL_K_pMalloc = 100;
mSL_K_pMfree = 101;
mSL_K_pStralloc = 102;
mSL_K_pStrfree = 103;
mSL_K_pGet = 104;
mSL_K_pSet = 105;
mSL_K_pStrlen = 106;
mSL_K_pIRand = 107;
mSL_K_pStrcpy = 108;
mSL_K_pStrcat = 109;
mSL_K_pStrcmp = 110;
mSL_K_pStricmp = 111;
mSL_K_pStrgetch = 112;
mSL_K_pStrsetch = 113;
mSL_K_pSprintf = 114;
// 115: internal : malloc retry
// 116: internal : gc()
mSL_K_pGMAction = 117;
mSL_K_pGMSetTab = 118;
// free : 119
mSL_K_jmpAlways = 120 | mSL_K_longInst;
mSL_K_jmpAlwaysPop = 121 | mSL_K_longInst;
mSL_K_jmpOnTruePT = 122 | mSL_K_longInst;
mSL_K_jmpOnTruePopF = 123 | mSL_K_longInst;
mSL_K_jmpOnFalsePop = 124 | mSL_K_longInst;
mSL_K_jmpOnFalsePT = 125 | mSL_K_longInst;
mSL_K_JNegEP = 126 | mSL_K_longInst;
mSL_K_pushNum = 127 | mSL_K_longInst;
// reserved for local extensions : 128 to 255
mSL_K_PlayOps = 128;
mSL_K_EventOps = 129;
mSL_K_CallOps = 130;
mSL_K_PlayerOps = 131;
mSL_K_GuiOps = 132;


//----------------------
mSL_tyCondOP = '?' | mSL_tyOP| mSL_prty13;
mSL_tyCondElse = ':' | mSL_tyOP| mSL_prty13;
mSL_tyComma = ',' | mSL_tyOP | mSL_prty15;
mSL_tySemiCol = ';' | mSL_tyOP| mSL_prty16;
mSL_tySet = mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
mSL_maskSet = 0xFFFFC00;
mSL_opSet = '=' | mSL_tySet;
// Special condt. functions
mSL_prCond1 = '?'; // printable cond. 1
mSL_tyFCond1 = mSL_prCond1 | mSL_tyOP;
mSL_prCond2 = '?:'; // printable cond. 2
mSL_tyFCond2 = mSL_prCond2 | mSL_tyOP;
// mSL_tyFLogAnd = '&&' | mSL_tyOP | mSL_prty11 ;
mSL_tyFLogAnd = 'x' | mSL_tyOP | mSL_prty11 ;
// mSL_tyFLogOr = '||' | mSL_tyOP | mSL_prty12 ;
mSL_tyFLogOr = 'o' | mSL_tyOP | mSL_prty12 ;
// Some dyadic operators and the corresponding monadic operators
mSL_tyDadd = mSL_K_fAdd | mSL_tyOP | mSL_prty5 ;
mSL_tyMIdt = mSL_tyDadd | mSL_tyOPMon ;
mSL_tyDMinus = mSL_K_fMinus | mSL_tyOP | mSL_prty5 ;
mSL_tyDDiv = mSL_K_fDiv | mSL_tyOP | mSL_prty4 ;
mSL_tyMNeg = mSL_tyDMinus | mSL_tyOPMon ;
mSL_tyDNot = mSL_K_fNot | mSL_tyOP | mSL_prty2 ;
mSL_tyMNot = mSL_tyDNot | mSL_tyOPMon ;
mSL_tyDOr = mSL_K_fOr | mSL_tyOP | mSL_prty10 ;
mSL_tyDAnd = mSL_K_fAnd | mSL_tyOP | mSL_prty9 ;
mSL_tyMInt = mSL_tyDOr | mSL_tyOPMon ;
mSL_tyDXor = mSL_K_fXOr | mSL_tyOP| mSL_prty9;
mSL_tyMBNot = mSL_tyDXor | mSL_tyOPMon ;
mSL_tyMgmem = 'g[]' | mSL_tyOP | mSL_tyOPMon ;
mSL_tyMgmem2 = 'G[]' | mSL_tyOP ;
// Some special keywords
mSL_ckwVar = 0; // provided later
mSL_ckwLoc = 0; // provided later
mSL_ckwPtr = 0; // provided later
// mSL_ckwShr = 0; // provided later
mSL_ckwFunction = 0; // provided later
mSL_ckwLocal = 0; // provided later
mSL_ckwWhile = 0; // provided later
mSL_ckwLoop = 0; // provided later
mSL_ckwGmem = 0; // provided later
mSL_ckwImport = 0; // provided later
mSL_ckwData = 0; // provided later
// Some intermediate operations for codgen
mSL_Action = 0xF0F00000; idx = 0;
mSL_ActionSC =    mSL_Action + (idx += 1); // for the ";"
mSL_ActionAff =   mSL_Action + (idx += 1); // for the "="
mSL_ActionWhil1 = mSL_Action + (idx += 1); // for the while construct
mSL_ActionWhil2 = mSL_Action + (idx += 1); // for the while construct
mSL_ActionWhil3 = mSL_Action + (idx += 1); // for the while construct
mSL_ActionCond1 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCond2 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCond3 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCond4 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCond5 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCond6 = mSL_Action + (idx += 1); // for the ? : construct
mSL_ActionCall  = mSL_Action + (idx += 1); // call operation
mSL_ActionPrim  = mSL_Action + (idx += 1); // call operation
mSL_ActionOR1 = mSL_Action + (idx += 1); // OR 1
mSL_ActionOR2 = mSL_Action + (idx += 1); // OR 2
mSL_ActionAnd1 = mSL_Action + (idx += 1); // And 1
mSL_ActionAnd2 = mSL_Action + (idx += 1); // And 2
mSL_ActionLoop1 = mSL_Action + (idx += 1); // Loop 1
mSL_ActionLoop2 = mSL_Action + (idx += 1); // Loop 2
mSL_ActionLoop3 = mSL_Action + (idx += 1); // Loop 3
mSL_ActionLoop4 = mSL_Action + (idx += 1); // Loop 4
mSL_ActionGmem2 = mSL_Action + (idx += 1); // Write in gmem
mSL_ActionSigErr1 = mSL_Action + (idx += 1); // Halt on error
mSL_ActionSigErr2 = mSL_Action + (idx += 1); // Halt on error


mSL_lastmemory = __memtop() - 8;

mSL_actXcSize = 0; // taille effective
mSL_memXcStart = 0; // the area allocated for execution
mSL_memXcEnd = 0; // end of area allocated for execution
mSL_XlastStatic = 0; // Allocation start
mSL_Xfree = 0; // free area size
mSL_a_cxcmem = 0; // the allocator in mSL_memXcStart
mSL_ICount = 0;

//==== inside mSL_memX
mSL_baseXSMem = 0; // The base address for evaluator work areas    ==ARRAY==
mSL_baseXSMSize = 0; // the size for this memory
mSL_baseAVars = 0; // The base address for individual variables    ==ARRAY==
mSL_baseAVSize = 0; // the size of the AVars
mSL_baseOVars = 0; // The base address for own variables    ==ARRAY==
mSL_baseOVSize = 0; // the size of the OVars
mSL_basePVars = 0; // The base address for Pointers variables    ==ARRAY==
mSL_basePVSize = 0; // the size of the PVars
mSL_current_stack = 0; // the array for the stack    ==ARRAY==
//mSL_baseASSize = 0; // the size of the AStack
mSL_baseStack = 0; // the current base Stack
mSL_baseHighStack = 0; // high stack position
mSL_TOS = 0; // current TOS: Top Of Stack
mSL_baseCode = 0; // The "byte" code base
mSL_PCode = 0; // pointer inside the base code
mSL_baseAddStack = 0; // current base of the stack
mSL_baseLocals = 0; // current table of local vars
mSL_baseTOS = 0; // current base TOS
mSL_mCheckCnt = 0;

// Various structures
mSL_Obj_Type = 0; // all objects
mSL_Obj_Size = 1; // all objects
mSL_Free_Next = 2; // free blocks chaining
mSL_Free_Prev = 3; // free blocks chaining


//=====Blocks Kodes====
// Main Cell Structure Bloc
mSL_STRUCT_hd = 'stru';
// Compiler Kod
mSL_CPWA_cpl = 'cpwa';
// Evaluator code
mSL_KODE_evl = 'xcwa';
// Constant array
mSL_KODE_constants = 'cstw';
// Global vars
mSL_KODE_gvars = 'vars';
// Semi-Local vars
mSL_KODE_locals =  'locs';
// Pointers
mSL_KODE_pointers = 'ptrs';
// Stack
mSL_KODE_stack = 'stak';
// GC-Protect
mSL_KODE_protect = 'prot';
// Main tree structure
mSL_KODE_tree = 'tree';
// A tree block
mSL_KODE_trbl = 'trbl';


mSL_BLOCK_Key = -2;
mSL_BLOCK_Size = -1;

mSL_RC_Stop = 1; // exit() return code
mSL_RC_IllInst = 2; // illegal inst.
mSL_RC_XErr = 3; // execution error
mSL_RC_Yield = 4; // yield() return code
mSL_RC_Wait = 5; // wait return code
mSL_RC_WAITGC = 6; // need a GC first !
mSL_RC_WEvent = 7; // wait/want an event

// Compiled code structure
mSL_CC_KeyCKod = 'ccod';
mSL_CC_KeyKEnd = (mSL_CC_Chksum ~ mSL_CC_KeyCKod);
mSL_CC_Key = mSL_BLOCK_Key; // 1st entry is a unique "key" -- mSL_CC_KeyCKod
mSL_CC_Size = idx = mSL_BLOCK_Size; // 2nd entry is size
mSL_CC_Flags_Idt = (idx += 1); // various infos
mSL_CC_Flags = (idx += 1); // various infos
mSL_CC_dpCode_Idt = (idx += 1); // position (relative) of the code
mSL_CC_dpCode = (idx += 1); // position (relative) of the code
mSL_CC_CodSize_Idt = (idx += 1); // length of the code
mSL_CC_CodSize = (idx += 1); // length of the code
mSL_CC_Name_Idt = (idx += 1); // compacted identifier = name of the bloc code
mSL_CC_Name = (idx += 1); // compacted identifier = name of the bloc code
mSL_CC_ParCnt_Idt = (idx += 1); // parameter count
mSL_CC_ParCnt = (idx += 1); // parameter count
mSL_CC_LocCnt_Idt = (idx += 1); // locals count
mSL_CC_LocCnt = (idx += 1); // locals count
mSL_CC_GlbCnt_Idt = (idx += 1); // global references count
mSL_CC_GlbCnt = (idx += 1); // global references count
mSL_CC_GlbTab_Idt = (idx += 1); // global symbol table
mSL_CC_GlbTab = (idx += 1); // global symbol table
mSL_CC_OwnTab_Idt = (idx += 1); // local symbol table
mSL_CC_OwnTab = (idx += 1); // local symbol table
mSL_CC_PtrTab_Idt = (idx += 1); // pointers symbol table
mSL_CC_PtrTab = (idx += 1); // pointers symbol table
mSL_CC_last = (idx += 1); // lock
mSL_CC_1stId = (idx += 1); // first ident. position
// Last word is a unique "key" -- mSL_CC_KeyKEnd


// Thread Structure
// Thread
mSL_THR_KeyStrt = 'thrd' ;
mSL_THR_KeyEnd = mSL_THR_KeyStrt ~ mSL_CC_Chksum ;
mSL_THR_Key = idx = -2; // 1st entry is a unique "key" -- mSL_THR_KeyStrt
mSL_THR_Size = (idx += 1); // 2nd entry is size
//---
mSL_THR_State_Idt = (idx += 1); // State of the thread
mSL_THR_State = (idx += 1); // State of the thread
mSL_THR_UTId_Idt = (idx += 1); // Unique Id for the thread
mSL_THR_UTId = (idx += 1); // Unique Id for the thread
mSL_THR_SchedEnt_Idt = (idx += 1); // scheduler entry
mSL_THR_SchedEnt = (idx += 1); // scheduler entry
mSL_THR_baseAVars_Idt = (idx += 1); // Global var. table
mSL_THR_baseAVars = (idx += 1); // Global var. table
mSL_THR_baseLocals_Idt = (idx += 1); // Local var. table
mSL_THR_baseLocals = (idx += 1); // Local var. table
mSL_THR_baseOVars_Idt = (idx += 1); // semilocal var. table
mSL_THR_baseOVars = (idx += 1); // semilocal var. table
mSL_THR_basePVars_Idt = (idx += 1); // pointers var. table
mSL_THR_basePVars = (idx += 1); // pointers var. table
mSL_THR_basePhStack_Idt = (idx += 1); // start of the physical stack
mSL_THR_basePhStack = (idx += 1); // start of the physicalstack
mSL_THR_baseTOS_Idt = (idx += 1); // start of the logical stack
mSL_THR_baseTOS = (idx += 1); // start of the logical stack
mSL_THR_StackSize_Idt = (idx += 1); // size of the stack
mSL_THR_StackSize = (idx += 1); // size of the stack
mSL_THR_baseAddStack_Idt = (idx += 1); // base of the stack
mSL_THR_baseAddStack = (idx += 1); // base of the stack
mSL_THR_StackCurr_Idt = (idx += 1); // current stack
mSL_THR_StackCurr = (idx += 1); // current stack
mSL_THR_baseHighStack_Idt = (idx += 1); // current stack
mSL_THR_baseHighStack = (idx += 1); // current stack
mSL_THR_TOS_Idt = (idx += 1); // current top of stack
mSL_THR_TOS = (idx += 1); // current top of stack
mSL_THR_baseCode_Idt = (idx += 1); // start of the code
mSL_THR_baseCode = (idx += 1); // start of the code
mSL_THR_CodeSize_Idt = (idx += 1); // size of the code
mSL_THR_CodeSize = (idx += 1); // size of the code
mSL_THR_CodeCurr_Idt = (idx += 1); // current code address
mSL_THR_CodeCurr = (idx += 1); // current code address
mSL_THR_CodePtr_Idt = (idx += 1); // pointer in code
mSL_THR_CodePtr = (idx += 1); // pointer in code
mSL_THR_NxtOp_Idt = (idx += 1); // next operation in code
mSL_THR_NxtOp = (idx += 1); // next operation in code
mSL_THR_rtrnVal_Idt = (idx += 1); // return value
mSL_THR_rtrnVal = (idx += 1); // return value
mSL_THR_errX_Idt = (idx += 1); // Error code (if any)
mSL_THR_errX = (idx += 1); // Error code (if any)
mSL_THR_PCode_Idt = (idx += 1); // Error location
mSL_THR_PCode = (idx += 1); // Error location
mSL_THR_ICount_Idt = (idx += 1); // count location
mSL_THR_ICount = (idx += 1); // count location
mSL_THR_MxStk_Idt = (idx += 1); // high stack location
mSL_THR_MxStk = (idx += 1); // high stack location
mSL_THR_Evnt_Idt = (idx += 1); // event location
mSL_THR_Evnt = (idx += 1); // event location
// ----
mSL_THR_TotSize = (idx += 1); // Total Size - about 50
mSL_THR_Z = 60; // > mSL_THR_TotSize
mSL_STK_DSiz = 8; // Size of info values to save in the stack
mSL_STK_Chck = 0x2F3C5E17; // an arbitrary check value
// Thread status


// Evaluator structure
mSL_EV_var = idx = 0;
mSL_EV_varAddr = (idx += 1);
mSL_EV_loc = (idx += 1);
mSL_EV_locAddr = (idx += 1);
mSL_EV_ext = (idx += 1);
mSL_EV_extAddr = (idx += 1);
mSL_EV_strs = (idx += 1);
mSL_EV_strsAddr = (idx += 1);
mSL_EV_mem = (idx += 1);
mSL_EV_memAddr = (idx += 1);
mSL_EV_last = (idx += 1);






// Work areas
mSL_fileNames = 0; // an array of file names  ==ARRAY==
mSL_wa1 = 0; // a 16 numbers work area  ==ARRAY==
mSL_wa2 = 0; // a 16 numbers work area  ==ARRAY==
mSL_wSt1 = 0; // a "mSL_CMaxStrSiz" chars temporary code-points string  ==ARRAY==
mSL_current_StrPtrs = 0; // a "mSL_StrsSize" array of pointers to mutables strings  ==ARRAY==
mSL_current_constants = 0; // an array of symbolic constants definitions  ==ARRAY==
mSL_new_constants = 0; // newly created constants

// We keep this array across compilations...
mSL_CGlobalsN = 0; // a list of global variables names for a code segment ==ARRAY==
mSL_CGlobalsT = 0; // a list of global variables types for a code segment ==ARRAY==
mSL_CGlobalsL = 0; // a list of global variables location for a code segment ==ARRAY==
mSL_CGlobalsV = 0; // a list of global variables values for a code segment ==ARRAY==
mSL_CGlobCnt = 0; // count of globals
mSL_CplStack = 0; // The compiler stack 1 ==ARRAY==
mSL_pCStack = 0;
mSL_Flat_List = 0; // a work area

mSL_CG_MainGen = 0; // main bloc of generated code
mSL_pCCode = 0; //
mSL_CMarkA = 0; // a "mark" array in the Kod ==ARRAY==
mSL_F2CList = 0; // functions to compile  ==ARRAY==
mSL_F2CCode = 0; // functions to compile  ==ARRAY==
mSL_op_codes = 0; // array of op code names
// mSL_op_arities = 0; // array of op code arities
mSL_F2CPt = 0;

mSL_fileNptr = 1; // next file name
mSL_errPos = 0;
mSL_memCpStart = 0; // Memory address of compiler's work area
mSL_a_cpmem = 0; // pseudo allocator for various compilers's arrays
mSL_lastStatic = 0; // last static limit (+1)
mSL_maxCpAddr = 0; // size allocated for the compiler's work area
mSL_PtrPtc = 0; // pointer for allocating strings
mSL_PtrTPtc = 0; // pointer for allocating temporary strings
mSL_CstsPtc = 0; // allocating pointer in constants available
mSL_memCleanStart = 0;
mSL_memCleanSize = 0;

mSL_C_fH = -1;
mSL_C_cavail = -1;
mSL_C_numLine = 0;
mSL_posChar = 0;

// The compiler internal global table
mSL_GCTab = 0; //  ==ARRAY==
mSL_GCTyp = 0; //   ==ARRAY==
mSL_GCCod = 0; //  ==ARRAY==
mSL_GCVal = 0; //  ==ARRAY==
mSL_GCTabSize = 0;
mSL_GlbFlg = 0;  // "var" type
mSL_gvar = 0; // allocator for glob. var #
mSL_OwnFlg = 0x10000;  // "Local/Own" type
mSL_ovar = mSL_OwnFlg; // allocator for "own" var. #
mSL_PtrFlg = 0x20000;  // "Pointer/Indirect" type
mSL_pvar = mSL_PtrFlg; // allocator for "special" var. #
mSL_FlgMask = 0xf0000;
mSL_NumMask = 0xffff;
// The compiler internal local table
mSL_LCTab = 0; //  ==ARRAY==
mSL_LCTyp = 0; //   ==ARRAY==
mSL_LCCod = 0; //  ==ARRAY==
mSL_LCTabSize = 0;
mSL_lvar = 0; // allocator for loc. var #

mSL_C_chPos = 0;
mSL_C_chcurr = 0;
mSL_lcod = 0;
mSL_cod = 0;




//============BASIC OPERATIONS===============
xcnt = 0;
function xxtrace(xch, cod)
(
    (xcnt === 0) ? (AA_00 = xch; AA_00c = cod; AA_01 = 0;);
    (xcnt === 1) ? (AA_01 = xch; AA_01c = cod; AA_02 = 0;);
    (xcnt === 2) ? (AA_02 = xch; AA_02c = cod; AA_03 = 0;);
    (xcnt === 3) ? (AA_03 = xch; AA_03c = cod; AA_04 = 0;);
    (xcnt === 4) ? (AA_04 = xch; AA_04c = cod; AA_05 = 0;);
    (xcnt === 5) ? (AA_05 = xch; AA_05c = cod; AA_06 = 0;);
    (xcnt === 6) ? (AA_06 = xch; AA_06c = cod; AA_07 = 0;);
    (xcnt === 7) ? (AA_07 = xch; AA_07c = cod; AA_08 = 0;);
    (xcnt === 8) ? (AA_08 = xch; AA_08c = cod; AA_09 = 0;);
    (xcnt === 9) ? (AA_09 = xch; AA_09c = cod; AA_10 = 0;);
    (xcnt === 10) ? (AA_10 = xch; AA_10c = cod; AA_11 = 0;);
    (xcnt === 11) ? (AA_11 = xch; AA_11c = cod; AA_12 = 0;);
    (xcnt === 12) ? (AA_12 = xch; AA_12c = cod; AA_13 = 0;);
    (xcnt === 13) ? (AA_13 = xch; AA_13c = cod; AA_14 = 0;);
    (xcnt === 14) ? (AA_14 = xch; AA_14c = cod; AA_15 = 0;);
    (xcnt === 15) ? (AA_15 = xch; AA_15c = cod; AA_00 = 0;);
    xcnt = (xcnt + 1) % 16;
);



function mSL_type_Name(type)
local (op)
(
    op = type & 0x3FF;
    (op === 1) ? (
        #id = "HEAD";
    ) :
    (op === 2) ? (
        #id = "TAIL";
    ) :
    (op === 3) ? (
        #id = "Ident";
    ) :
    (op === 4) ? (
        #id = "Addr";
    ) :
    (op === 5) ? (
        #id = "Keyword";
    ) :
    (op === 6) ? (
        #id = "Primitive";
    ) :
    (op === 7) ? (
        #id = "Number";
    ) :
    (op === 8) ? (
        #id = "String";
    ) :
    (op === 10) ? (
        #id = "Sub.Expr.";
    ) :
    (op === 11) ? (
        #id = "Par.Expr.";
    ) :
    (op === 12) ? (
        #id = "Brck.Expr.";
    ) :
    (type & mSL_tySep) ? (
        sprintf(#id, "SEP:'%c'", op & 0x7f);
    ) :
    (type & mSL_tyOP) ? (
        sprintf(#id, "%s", mSL_op_codes[op & 0x7f]);
    ) :
    (
        sprintf(#id, "%X", type);
    );
    sprintf(#tn, "Ty:%s", #id);
    #tn;
);


//
//   Enter the "names' of internal code operations in a given table.
//   The size should be large enough - typically 256
//
function
mSL_define_opnames(dsttab, size)
local (ii)
(
    ii = 0; loop(size, dsttab[ii] = "?"; ii += 1;);
    dsttab[0] = "illegal:0";
    dsttab[mSL_K_stop] = "exit";
    dsttab[mSL_K_return] = "return";
    dsttab[mSL_K_Pop] = "pop";
    dsttab[mSL_K_Set] = "set,np";
    dsttab[mSL_K_SetAndPop] = "set,Pop";
    dsttab[mSL_K_ldLVar] = "ld_loc_var";
    dsttab[mSL_K_ldLAddr] = "ld_loc_var&";
    dsttab[mSL_K_ldGVar] = "ld_glob_var";
    dsttab[mSL_K_ldGAddr] = "ld_glob_var&";
    dsttab[mSL_K_ldOVar] = "ld_own_var";
    dsttab[mSL_K_ldOAddr] = "ld_own_var&";
    dsttab[mSL_K_ldPVar] = "ld_ptr_var";
    dsttab[mSL_K_ldPAddr] = "ld_ptr_var&";
    dsttab[mSL_K_pushShort] = "push_short";
    dsttab[mSL_K_pushNShort] = "push_short -";
    dsttab[mSL_K_indexVal] = "[]";
    dsttab[mSL_K_indexAdd] = "[]&";
    dsttab[mSL_K_fCall] = "()";
    dsttab[mSL_K_fIdt] = "mop +";
    dsttab[mSL_K_fNeg] = "mop -";
    dsttab[mSL_K_Sum] = "sum";
    dsttab[mSL_K_Array] = "array";
    dsttab[mSL_K_NotEq] = "op !=";
    dsttab[mSL_K_Eq] = "op ==";
    dsttab[mSL_K_fGTE] = "op >=";
    dsttab[mSL_K_RShift] = "op >>";
    dsttab[mSL_K_fLTE] = "op <=";
    dsttab[mSL_K_LShift] = "op <<";
    dsttab[mSL_K_DecrTos] = "decr TOS";
    dsttab[mSL_K_fNot] = "mop !";
    dsttab[mSL_K_fXOr] = "op ~";
    dsttab[mSL_K_TrEq] = "===";
    dsttab[mSL_K_TrNotEq] = "!==";
    dsttab[mSL_K_fRes] = "op %";
    dsttab[mSL_K_fAnd] = "op &";
    dsttab[mSL_K_fOr] = "op |";
    dsttab[mSL_K_fLT] = "op <";
    dsttab[mSL_K_fGT] = "op >";
    dsttab[mSL_K_fTimes] = "op *";
    dsttab[mSL_K_fAdd] = "op +";
    dsttab[mSL_K_fStrcode] = "symbol";
    dsttab[mSL_K_fMinus] = "op -";
    dsttab[mSL_K_fDiv] = "op /";
    dsttab[mSL_K_Aff_Plus] = "+=";
    dsttab[mSL_K_Aff_Minus] = "-=";
    dsttab[mSL_K_Aff_Times] = "*=";
    dsttab[mSL_K_Aff_Div] = "/=";
    dsttab[mSL_K_Aff_Mod] = "%=";
    dsttab[mSL_K_Aff_And] = "&=";
    dsttab[mSL_K_Aff_Or] = "|=";
    dsttab[mSL_K_Aff_XOr] = "~=";
    dsttab[mSL_K_pstrtmp] = "strtmp";
    dsttab[mSL_K_pthread] = "thread";
    dsttab[mSL_K_pmemcpy] = "memcpy";
    dsttab[mSL_K_pedn] = "edn";
    dsttab[mSL_K_pSin] = "sin";
    dsttab[mSL_K_pCos] = "cos";
    dsttab[mSL_K_pTan] = "tan";
    dsttab[mSL_K_pASin] = "asin";
    dsttab[mSL_K_pACos] = "acos";
    dsttab[mSL_K_pATan] = "atan";
    dsttab[mSL_K_pMax] = "max";
    dsttab[mSL_K_pMin] = "min";
    dsttab[mSL_K_pAtan2] = "atan2";
    dsttab[mSL_K_pPow] = "pow";
    dsttab[mSL_K_pSqr] = "sqr";
    dsttab[mSL_K_pSqrt] = "sqrt";
    dsttab[mSL_K_pExp] = "exp";
    dsttab[mSL_K_pLog] = "log";
    dsttab[mSL_K_pAbs] = "abs";
    dsttab[mSL_K_pSign] = "sign";
    dsttab[mSL_K_pLog10] = "log10";
    dsttab[mSL_K_pFloor] = "floor";
    dsttab[mSL_K_pCeil] = "ceil";
    dsttab[mSL_K_pInvsqrt] = "invsqrt";
    dsttab[mSL_K_pRand] = "rand";
    dsttab[mSL_K_pTime] = "time";
    dsttab[mSL_K_pTPrecise] = "ptime";
    dsttab[mSL_K_pSrate] = "srate";
    dsttab[mSL_K_pNum_ch] = "num_ch";
    dsttab[mSL_K_pTempo] = "tempo";
    dsttab[mSL_K_pInt] = "mop |";
    dsttab[mSL_K_pBNot] = "mop ~";
    dsttab[mSL_K_pgmem] = "gmem[]";
    dsttab[mSL_K_fPow] = "op ^";
    dsttab[mSL_K_pgmem2] = "gmem[]=";
    dsttab[mSL_K_pMemtop] = "memtop";
    dsttab[mSL_K_pIsInt] = "isint";
    dsttab[mSL_K_pIsFun] = "isfun";
    dsttab[mSL_K_pIsString] = "isstring";
    dsttab[mSL_K_pIsBlock] = "isblock";
    dsttab[mSL_K_pISize] = "size";
    dsttab[mSL_K_pCompile] = "compile";
    dsttab[mSL_K_pMalloc] = "malloc";
    dsttab[mSL_K_pMfree] = "mfree";
    dsttab[mSL_K_pStralloc] = "stralloc";
    dsttab[mSL_K_pStrfree] = "strfree";
    dsttab[mSL_K_pGet] = "get";
    dsttab[mSL_K_pSet] = "set";
    dsttab[mSL_K_pGMAction] = "action";
    dsttab[mSL_K_pGMSetTab] = "table";
    dsttab[mSL_K_pStrlen] = "strlen";
    dsttab[mSL_K_pIRand] = "irand";
    dsttab[mSL_K_pStrcpy] = "strcpy";
    dsttab[mSL_K_pStrcat] = "strcat";
    dsttab[mSL_K_pStrcmp] = "strcmp";
    dsttab[mSL_K_pStricmp] = "stricmp";
    dsttab[mSL_K_pStrgetch] = "strgetch";
    dsttab[mSL_K_pStrsetch] = "strsetch";
    dsttab[mSL_K_pSprintf] = "sprintf";
    dsttab[mSL_K_jmpAlways] = "jump";
    dsttab[mSL_K_jmpAlwaysPop] = "jump,Pop";
    dsttab[mSL_K_jmpOnTruePT] = "jumpOnTrue,PT";
    dsttab[mSL_K_jmpOnTruePopF] = "jumpOnTrue,PF";
    dsttab[mSL_K_jmpOnFalsePop] = "jumpOnFalse,Pop";
    dsttab[mSL_K_jmpOnFalsePT] = "jumpOnFalse,PT";
    dsttab[mSL_K_JNegEP] = "jumpNeg";
    dsttab[mSL_K_pushNum] = "push_num";
    dsttab[mSL_K_pYield] = "yield";
    dsttab[mSL_K_pWait] = "wait";
    //---------------
    dsttab[mSL_K_PlayOps] = "play";
    dsttab[mSL_K_EventOps] = "event";
    dsttab[mSL_K_CallOps] = "call";
    dsttab[mSL_K_PlayerOps] = "player";
    dsttab[mSL_K_GuiOps] = "gui";
);


// Build an independant "main" symbol table
function mSL_buildGVTab(mem, size, aprime)
(
    (size === (4 * (aprime + 1))) ? (
        mSL_GCSiz = aprime;
        mSL_GCTabSize = 4 * (mSL_GCSiz + 1);
        mSL_GCTab = mem + 1;
        mSL_GCCod = mSL_GCTab + mSL_GCSiz + 1;
        mSL_GCTyp = mSL_GCCod + mSL_GCSiz + 1;
        mSL_GCVal = mSL_GCTyp + mSL_GCSiz + 1;
        mSL_GCTab ;
    ) : (
        mSL_GCTab = 0;
    );
);




// Build an independant "local" symbol table
function mSL_buildLCTab(mem, size, aprime)
(
    (size === (4 * (aprime + 1))) ? (
        mSL_LCSiz = aprime;
        mSL_LCTabSize = 4 * (mSL_LCSiz + 1);
        mSL_LCTab = mem + 1;
        mSL_LCCod = mSL_LCTab + mSL_LCSiz + 1;
        mSL_LCTyp = mSL_LCCod + mSL_LCSiz + 1;
        mSL_LCVal = mSL_LCTyp + mSL_LCSiz + 1; // actually not used
        mSL_LCTab ;
    ) : (
        mSL_LCTab = 0;
    );
);


// Local table reset
function mSL_clearLCTab()
(
    memset(mSL_LCTab-1, 0, mSL_LCTabSize);
    mSL_lvar = 0;
);



function mSL_checkCLimits()
(
    ((mSL_errC === 0) && (mSL_a_cpmem >= mSL_memCpStart + mSL_maxCpAddr)) ? (
        mSL_errC = 1002; mSL_errPos = 0;
    );
);




// This looks for a identifier in the global symbol table
// and introduce it if it is not in the "right" place
// The symbol table is already populated with the keywords and
// the external definitions of functions and variables
// It returns the correct entry or (alas) -1 when table is full
function mSL_findGId(name) local (pt, ent, cnt)
(
    ent = -1; cnt = mSL_GCSiz;
    pt = name % mSL_GCSiz; // first guess and probable hit
    while ((mSL_GCTab[pt] != name) && (cnt > 0)) (
        (mSL_GCTab[pt] === 0) ? (
            mSL_GCTab[pt] = name;
        ) : (
            pt = (pt + 73) % mSL_GCSiz; cnt -= 1;
        );
    );
    (mSL_GCTab[pt] === name) ? ent = pt;
    ent;
);


// Just look for the identifier, but don't enter it
function mSL_checkGId(name) local (pt, ent, cnt)
(
    ent = -2; cnt = mSL_GCSiz;
    pt = name % mSL_GCSiz; // first guess and probable hit
    while ((ent === -2) && (cnt > 0)) (
        (mSL_GCTab[pt] === 0) ? (
            ent = -1; // not found
        ) :
        (mSL_GCTab[pt] === name) ? (
            ent = pt; // here
        ) : (
            pt = (pt + 73) % mSL_GCSiz; cnt -= 1;
        );
    );
    ent;
);



//    Define a global object
//        name = compacted identifier
//        code = the nature of the object, which is
//            0 : a global variable
//            0x10000 : a semi-local var
//            0x20000 : a pointer var
//            n : a spectial gizmo
//        type = typically, mSL_tyIdent, or mSL_tyKeywrd, or mSL_tyPrimFun, etc.
//        value = the value to associate to the object

function mSL_enterGCode(name, code, type, value) local (pt)
(
    ((pt = mSL_findGId(name)) >= 0) ? (
        (mSL_GCCod[pt] === 0) ? (
            ((type === mSL_tyIdent) && ((code & 0xffff) === 0)) ? (
                code = code & mSL_FlgMask;
                (code === 0) ? (
                    mSL_GCCod[pt] = (mSL_gvar += 2);
                ) :
                (code === mSL_OwnFlg) ? (
                    mSL_GCCod[pt] = (mSL_ovar += 2);
                ) :
                (code === mSL_PtrFlg) ? (
                    mSL_GCCod[pt] = (mSL_pvar += 2);
                ) :
                (
                    mSL_GCCod[pt] = (mSL_gvar += 2);
                );
            ) : (
                mSL_GCCod[pt] = code;
            );
            mSL_GCTyp[pt] = type;
        );
        mSL_GCVal[pt] = value;
    );
    pt;
);


// This looks for a identifier in the local symbol table
// It returns the correct entry or (alas) -1 when table is full
function mSL_findLId(name) local (pt, ent, cnt)
(
    ent = -1; cnt = mSL_LCSiz;
    pt = name % mSL_LCSiz; // first guess and probable hit
    while ((mSL_LCTab[pt] != name) && (cnt > 0)) (
        (mSL_LCTab[pt] === 0) ? (
            mSL_LCTab[pt] = name;
        ) : (
            pt = (pt + 73) % mSL_LCSiz; cnt -= 1;
        );
    );
    (mSL_LCTab[pt] === name) ? ent = pt;
    ent;
);


// Just look for the identifier, but don't enter it
function mSL_checkLId(name) local (pt, ent, cnt)
(
    ent = -2; cnt = mSL_LCSiz;
    pt = name % mSL_LCSiz; // first guess and probable hit
    while ((ent === -2) && (cnt > 0)) (
        (mSL_LCTab[pt] === 0) ? (
            ent = -1; // not found
        ) :
        (mSL_LCTab[pt] === name) ? (
            ent = pt; // here
        ) : (
            pt = (pt + 73) % mSL_LCSiz; cnt -= 1;
        );
    );
    ent;
);



function mSL_enterLCode(name, code, type) local (pt)
(
    pt = mSL_findLId(name);
    (mSL_LCCod[pt] === 0) ? (
        ((type === mSL_tyIdent) && (code === 0)) ? (
            mSL_LCCod[pt] = (mSL_lvar += 1);
        ) : (
            mSL_LCCod[pt] = code;
        );
        mSL_LCTyp[pt] = type;
    );
    pt;
);


// Clean all execution symbol tables
function mSL_clean_vtabs(glbs, ownv, extv)
(
    memset(glbs, 0, glbs[-1]);
    memset(ownv, 0, ownv[-1]);
    memset(extv, 0, extv[-1]);
);


// Update the values in the runtime variables area from the compiler main symbol table
function mSL_retrieveGlobals(glbs, ownv, extv)
local (ip, v, ent)
(
    ip = 0;
    loop(mSL_GCSiz,
        ((mSL_GCTab[ip] != 0) && (mSL_GCTyp[ip] === mSL_tyIdent) && ((v = mSL_GCCod[ip]) != 0)) ? (
            ent = v & 0xffff;
            v = v & mSL_FlgMask;
            (v === mSL_OwnFlg) ? (
                ownv[ent] = mSL_GCVal[ip];
                ownv[ent-1] = mSL_GCTab[ip];
            ) :
            (v === mSL_PtrFlg) ? (
                extv[ent] = mSL_GCVal[ip];
                extv[ent-1] = mSL_GCTab[ip];
            ) :
            (
                glbs[ent] = mSL_GCVal[ip];
                glbs[ent-1] = mSL_GCTab[ip];
            )
        ); ip += 1;
    );
);


// Update the values from the runtime variables area to the compiler main symbol table
function mSL_updateGlobals(table, type)
local (ip, id, lg)
(
    //sprintf(#zz1, "@Tbl : %d,  ", table);
    //mSL_log(SysLogBox, #zz1);
    ip = 0; lg = table[-1];
    while ((ip < lg) && ((id = table[ip]) != 0))  (
        mSL_enterGCode(id, type, mSL_tyIdent, table[ip+1]);
        //sprintf(#zz1, " ==> var %s -  %f", mSL_id2Str(id), table[ip+1]);
        //mSL_log(SysLogBox, #zz1);
        ip += 2;
    );
);



//    Optionnal = provide our own array of constants references

function mSL_make_constants_array(mem, size)
(
    size = size & 0x7fffe; // size is even
    ((mSL_new_constants != 0) || (size < 64)) ? (
        mSL_errX = 1010; mSL_errPos = 0;
    ) : (
        mem[0] = mSL_KODE_constants; // as "constants Work area"
        mem[1] = mem[size-2] = mSL_CstsSize = size - 4;
        mem[size - 1] = mem[0] ~ mSL_CC_Chksum;
        mSL_new_constants = mem + 2;
        memset(mSL_new_constants, 0, mSL_CstsSize); // set it empty for now
        mSL_CstsPtc = 0; // allocating pointer in constants available
    );
    (mSL_current_constants === 0) ?
        mSL_current_constants = mSL_new_constants;
    mSL_new_constants;
);




// Build a string in "dst" (provided if > 0, allocated otherwise)
// from an array of UTF-8 coded chars, ending with 0.
function mSL_mk_string(dst, src)
local (strd, ix, c)
(
    (dst > 0) ? (
        strd = dst;
    ) : (
        strd = mSL_Str_Alloc();
    );
    (strd >= 0) ? (
        // build a string from code points in src
        ix = 0; c = 1;
        while (c && (ix < mSL_CMaxStrSiz)) (
            c = src[ix]; ix += 1;
        ); ix -= 1;
        // ix is the number of chars to change into a string...
        strcpy(strd, ""); // clear the destination
        while (ix >= 8) (  // 8 chars at a time
            sprintf(#mSL_wS1, "%c%c%c%c%c%c%c%c", src[0], src[1], src[2], src[3], src[4], src[5], src[6], src[7]);
            strcat(strd, #mSL_wS1); src += 8; ix -= 8;
        );
        while (ix > 0) (  // 1 char at a time
            sprintf(#mSL_wS1, "%c", src[0]);
            strcat(strd, #mSL_wS1); src += 1; ix -= 1;
        );
    );
    strd;
);




// Enter a Chain Entry in the free chain list
function mSL_freeChEnt(ent)
(
    // Check the entry
    // ((ent <= 0) || (ent >= mSL_intCSiz)) ? (
    //
    (ent < 100) ? (
        mSL_errC = 2011; // error at free
    ) : (
        // Clean the entry and chain it
        mSL_rptr[ent] = mSL_ChFree;
        mSL_lptr[ent] = mSL_nullPtr;
        mSL_flgs[ent] = mSL_tyun[ent] = mSL_valu[ent] = mSL_upos[ent] = 0;
        mSL_ChFree = ent; // new head;
    );
    mSL_errC;
);





function mSL_getAMarker()
local (pt, mk)
(
    pt = 0; mk = -1;
    while ((mk < 0) && (pt < mSL_CMarkSiz)) (
        (mSL_CMarkA[pt] < 0) ? (
            mSL_CMarkA[pt] = 0; mk = pt;
        );
        pt += 1;
    );
    (mk < 0) ? (
        mSL_errC = 3001; // system error possible
    );
    mk;
);



// Define, from program, a mSL global variable with a pre-defined value
function mSL_defGlobal(strname, loc, type, value)
local (name)
(
    name = mSL_symbol(strname);
    mSL_CGlobalsN[mSL_CGlobCnt] = name;
    mSL_CGlobalsL[mSL_CGlobCnt] = loc;
    mSL_CGlobalsT[mSL_CGlobCnt] = type;
    mSL_CGlobalsV[mSL_CGlobCnt] = value;
    mSL_CGlobCnt = min(mSL_CGlobCnt+4, mSL_CGlobSiz-4);
);




function
mSL_define_primitives()
(
    mSL_defGlobal("thread", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pthread);
    mSL_defGlobal("memcpy", 0, mSL_tyPrimF, mSL_tyPrimFun | (3 << 12) | mSL_K_pmemcpy);
    mSL_defGlobal("strtmp", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pstrtmp);
    mSL_defGlobal("edn", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pedn);
    mSL_defGlobal("sin", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pSin);
    mSL_defGlobal("cos", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pCos);
    mSL_defGlobal("tan", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pTan);
    mSL_defGlobal("asin", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pASin);
    mSL_defGlobal("acos", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pACos);
    mSL_defGlobal("atan", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pATan);
    mSL_defGlobal("max", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pMax);
    mSL_defGlobal("min", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pMin);
    mSL_defGlobal("atan2", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pAtan2);
    mSL_defGlobal("pow", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pPow);
    mSL_defGlobal("sqr", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pSqr);
    mSL_defGlobal("sqrt", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pSqrt);
    mSL_defGlobal("exp", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pExp);
    mSL_defGlobal("log", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pLog);
    mSL_defGlobal("abs", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pAbs);
    mSL_defGlobal("int", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pInt);
    mSL_defGlobal("sign", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pSign);
    mSL_defGlobal("log10", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pLog10);
    mSL_defGlobal("floor", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pFloor);
    mSL_defGlobal("ceil", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pCeil);
    mSL_defGlobal("invsqrt", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pInvsqrt);
    mSL_defGlobal("rand", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pRand);
    mSL_defGlobal("time", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pTime);
    mSL_defGlobal("ptime", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pTPrecise);
    mSL_defGlobal("srate", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pSrate);
    mSL_defGlobal("num_ch", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pNum_ch);
    mSL_defGlobal("tempo", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pTempo);
    mSL_defGlobal("memtop", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pMemtop);
    mSL_defGlobal("isint", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pIsInt);
    mSL_defGlobal("isfun", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pIsFun);
    mSL_defGlobal("isstring", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pIsString);
    mSL_defGlobal("isblock", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pIsBlock);
    mSL_defGlobal("size", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pISize);
    mSL_defGlobal("exit", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_stop);
    mSL_defGlobal("return", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_return);
    mSL_defGlobal("symbol", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_fStrcode);
    mSL_defGlobal("sum", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_Sum);
    mSL_defGlobal("array", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_Array);
    mSL_defGlobal("compile", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pCompile);
    mSL_defGlobal("malloc", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pMalloc);
    mSL_defGlobal("mfree", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pMfree);
    mSL_defGlobal("stralloc", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pStralloc);
    mSL_defGlobal("strfree", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pStrfree);
    mSL_defGlobal("get", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pGet);
    mSL_defGlobal("strlen", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pStrlen);
    mSL_defGlobal("irand", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pIRand);
    mSL_defGlobal("strcpy", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pStrcpy);
    mSL_defGlobal("strcat", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pStrcat);
    mSL_defGlobal("strcmp", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pStrcmp);
    mSL_defGlobal("stricmp", 0, mSL_tyPrimF, mSL_tyPrimFun | (2 << 12) | mSL_K_pStricmp);
    mSL_defGlobal("strgetch", 0, mSL_tyPrimF, mSL_tyPrimFun | (3 << 12) | mSL_K_pStrgetch);
    mSL_defGlobal("strsetch", 0, mSL_tyPrimF, mSL_tyPrimFun | (4 << 12) | mSL_K_pStrsetch);
    mSL_defGlobal("sprintf", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pSprintf);
    mSL_defGlobal("error", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_fError);
    mSL_defGlobal("set", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pSet);
    mSL_defGlobal("action", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pGMAction);
    mSL_defGlobal("table", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_pGMSetTab);
    mSL_defGlobal("yield", 0, mSL_tyPrimF, mSL_tyPrimFun | (0 << 12) | mSL_K_pYield);
    mSL_defGlobal("wait", 0, mSL_tyPrimF, mSL_tyPrimFun | (1 << 12) | mSL_K_pWait);
    //----
    mSL_defGlobal("play", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_PlayOps);
    mSL_defGlobal("event", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_EventOps);
    mSL_defGlobal("call", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_CallOps);
    mSL_defGlobal("player", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_PlayerOps);
    mSL_defGlobal("gui", 0, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | mSL_K_GuiOps);
);



// Symbol table management
function mSL_clearGCTab()
local(pt)
(
    memset(mSL_GCTab-1, 0, mSL_GCTabSize);
    mSL_gvar = -1;  // allocator for glob. var #
    mSL_ovar = mSL_OwnFlg-1; // allocator for "own" var. #
    mSL_pvar = mSL_PtrFlg-1; // allocator for "special" var. #
    mSL_enterGCode((mSL_ckwVar = mSL_KW_var), 1, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwLoc = mSL_KW_loc), 2, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwPtr = mSL_KW_ptr), 3, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwFunction = mSL_KW_function), 5, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwLocal = mSL_KW_local), 6, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwWhile = mSL_KW_while), 7, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwLoop = mSL_KW_loop), 8, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwGmem = mSL_KW_gmem), 9, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwImport = mSL_KW_import), 10, mSL_tyKeywrd, 0);
    mSL_enterGCode((mSL_ckwData = mSL_KW_data), 11, mSL_tyKeywrd, 0);
    //
    //
    pt = 0;
    while (pt < mSL_CGlobCnt) (
        mSL_enterGCode(mSL_CGlobalsN[pt], mSL_CGlobalsL[pt],
                        mSL_CGlobalsT[pt], mSL_CGlobalsV[pt]); pt += 4;
    );
);


function mSL_cleanStructures()
local (pt, cnt)
(
    // Reset all entries before a compilation
    memset(mSL_memCleanStart, 0, mSL_memCleanSize);
    // Clear all "protecting" structures
    mSL_bl_clear(mSL_GC_Protected);
    // These structures are defined in "mSL_make_compiler"
    mSL_ChFree = mSL_nullPtr; // The free list head
    mSL_start = mSL_nullPtr;
    mSL_HEAD = mSL_nullPtr;
    mSL_end = mSL_nullPtr;

    // Clear the main symbol table
    memset(mSL_GCTab, 0, mSL_GCTabSize);
    // Clear the local symbol table
    memset(mSL_LCTab, 0, mSL_LCTabSize);
    // All tables are now set to <0>
    // Clean the mark array
    memset(mSL_CMarkA, -1, mSL_CMarkSiz);
    mSL_pCStack = 0;
    mSL_CG_MainGen = 0;
    mSL_pCCode = 0;
    // mSL_CGlobCnt = 0; // don't change this one !
    mSL_C_cavail = -1;
    mSL_C_numLine = 0;
    mSL_posChar = 0;
    mSL_C_chcurr = 0;
    mSL_F2CPt = 0;
    mSL_errPos = 0;
    mSL_C_chPos = 0;
    mSL_lcod = 0;
    mSL_maxTrace = 0;
    mSL_ICount = 0;
    mSL_TreeMainStruc = 0;
    mSL_initCnt += 1;

    // Reset the allocator to the last static
    mSL_a_cpmem = mSL_lastStatic;
    // what is left free
    mSL_Cfree = mSL_memCpStart - mSL_a_cpmem + mSL_maxCpAddr;
);



// Get the "number" of a tree cell
function mSL_getCellNum(addr)
local (bl, ip, pp)
(
    bl = -1;
    (addr > 0) ? (
        ip = 0; pp = mSL_TreeMainStruc[ip+2];
        while ((pp != 0) && (ip < mSL_TreePgMax)) (
            ((addr >= pp) && (addr < pp+pp[-1])) ? (
                bl = ip * mSL_TreeBlPSize + (0|((addr-pp)/mSL_TreeCellUSize));
                pp = 0; // stop iteration
            ) : (
                ip += 1; pp = mSL_TreeMainStruc[ip+2];
            );
        );
    );
    bl;
);

// Get the "address" of a cell by its number
function mSL_getCellAddr(num)
local (np, nc)
(
    ((num != (0|num)) || (num < 0) || (num >= mSL_TreeBlPSize * mSL_TreePgMax)) ? (num = 0);
    ((mSL_TreeBlPSize > 0) && (mSL_TreeCellUSize > 0) && (mSL_TreeMainStruc > 0)) ? (
        np = 0|(num / mSL_TreeBlPSize);
        nc = num % mSL_TreeBlPSize;
        mSL_TreeMainStruc[np + 2] + mSL_TreeCellUSize * nc;
    ) : (
        0;
    );
);



// Get a chain block
function mSL_getChEnt()
local (ent, ip, pp, num)
(
    ent = mSL_nullPtr;
    (mSL_ChFree === mSL_nullPtr) ? (
        // Should we allocate the whole structure ?
        (mSL_TreeMainStruc === 0) ? (
            mSL_TreeMainStruc = mSL_Dyn_Alloc(mSL_TreePgMax + 2, mSL_KODE_tree, mSL_StM_FlClear);
            (mSL_TreeMainStruc === 0) ? (
                mSL_errC = 1273;
                mSL_malloc_failed |= 1;
            ) : (
                mSL_GC_BProtect(mSL_TreeMainStruc, mSL_GC_Protected);
                // mSL_TreeMainStruc2 = mSL_TreeMainStruc;
                mSL_TreeMainStruc[0] = -1;
                mSL_TreeMainStruc[1] = mSL_TreeBlPSize;
            );
        );
        // find a free slot
        (mSL_errC === 0) ? (
            ip = 2;
            while (mSL_TreeMainStruc[ip] > 0) (
                ip += 1;
            );
            // allocate a new page
            pp = mSL_Dyn_Alloc(mSL_TreeBlPSize * mSL_TreeCellUSize, mSL_KODE_trbl, mSL_StM_FlClear);
            (pp === 0) ? (
                mSL_errC = 1274;
                mSL_malloc_failed |= 1;
            ) : (
                mSL_TreeMainStruc[ip] = pp;
                mSL_TreeLastNewPage = pp;
                mSL_TreeLastNewPosition = ip;
                // Free all entries in the page
                ip = mSL_TreeBlPSize;
                while (ip > 0) (
                    ip -= 1;
                    mSL_freeChEnt(pp + ip * mSL_TreeCellUSize);
                );
            );
        );
    );
    (mSL_errC === 0) ? (
        ent = mSL_ChFree; mSL_ChFree = mSL_rptr[ent];
        mSL_rptr[ent] = mSL_nullPtr;
        num = mSL_getCellNum(ent); // costs a lot !
        (num > mSL_maxTrace) ? (mSL_maxTrace = num);
    );
    ent;
);

function mSL_chainEnt(lft, rgt)
(
    (lft >= 0) ? (
        mSL_rptr[lft] = rgt;
    );
    (rgt >= 0) ? (
        mSL_lptr[rgt] = lft;
    );

);

function mSL_enterHEAD()
local (ent)
(
    ent = mSL_getChEnt();
    (mSL_errC === 0) ? (
        mSL_tyun[ent] = mSL_tyHEAD ; mSL_valu[ent] = 0;
    );
    ent;
);


// enter a value and double chain entries
function mSL_appndU(typ, valu, upos)
local (ne)
(
    ne = mSL_getChEnt();
    (mSL_errC === 0) ? (
        mSL_rptr[ne] = mSL_nullPtr;
        mSL_tyun[ne] = typ; mSL_valu[ne] = valu; mSL_upos[ne] = upos;
        // append
        mSL_lptr[ne] = mSL_end;
        mSL_rptr[mSL_end] = ne; // mSL_end is initially mSL_start, therefore a cell
        mSL_end = ne;
    );
);


function mSL_firstU(typ, ptr)
local (flg)
(
    flg = 1;
    while (flg && (ptr > 0)) (
        (typ === mSL_tyun[ptr]) ? (
            flg = 0;
        ) : (
            ptr = mSL_rptr[ptr];
        );
    );
    ptr;
);


// Remove (and free HEAD and TAIL) of a list
// When flg is 1, REPLACE HEAD with the element count
function mSL_unHEAD(xp, flg)
local (res, p, prv, nxt, cnt)
(
    res = mSL_nullPtr;
    p = xp; prv = mSL_nullPtr;
    (p > 0) ? (
        (mSL_tyun[p] === mSL_tyHEAD) ? (
            res = p = mSL_rptr[p];
            cnt = 0;
            ((flg & 1) === 0) ? (
                mSL_lptr[p] = mSL_nullPtr; //left unchain the HEAD
                mSL_freeChEnt(xp);
            );
            while (p > 0) (
                nxt = mSL_rptr[p];
                cnt += 1;
                (mSL_tyun[p] === mSL_tyTAIL) ? (
                    (prv > 0) ? (
                        mSL_rptr[prv] = mSL_nullPtr; // right unchain the TAIL
                    );
                    mSL_freeChEnt(p);
                    (flg & 1) ? (
                        // change the HEAD to a count
                        res = xp;
                        mSL_tyun[res] = mSL_tyNum;
                        mSL_valu[res] = cnt - 1;
                        (mSL_rptr[res] === p) ? (mSL_rptr[res] = mSL_nullPtr;);
                    );
                );
                prv = p;
                p = nxt;
            );
        );
    );
    res;
);


// Move source to destination, free source
function mSL_mvCell(dst, src)
(
    // mode src to dest
    mSL_tyun[dst] = mSL_tyun[src];
    mSL_valu[dst] = mSL_valu[src];
    mSL_upos[dst] = mSL_upos[src];
    // free source
    mSL_freeChEnt(src);
);


// Clear compiler work areas
function mSL_cleanCPWA()
(
    // The blocks used to contain code
    (mSL_CG_MainGen != 0) ? (
        // may contain some blocks to free
        bl = 0;
        while ((pp = mSL_CG_MainGen[bl]) > 0) (
            mSL_Dyn_Free(pp);
            bl += 1;
        );
        mSL_Dyn_Free(mSL_CG_MainGen);
        mSL_CG_MainGen = 0;
        mSL_pCCode = 0;
    );
    // The tree cells items
    (mSL_TreeMainStruc != 0) ? (
        // Contains blocks to free
        bl = 2;
        while ((pp = mSL_TreeMainStruc[ip]) > 0) (
            mSL_Dyn_Free(pp);
            bl += 1;
        );
        mSL_Dyn_Free(mSL_TreeMainStruc);
        mSL_TreeMainStruc = 0;
        mSL_maxTrace = 0;
    );
    mSL_HEAD = mSL_start = mSL_end = mSL_ChFree = mSL_nullPtr;
);


function mSL_getchar(flg)
local (x, y, z)
(
    x = 1;
    while (x && (mSL_C_cavail === 0))  (
        // read a new line
        ((mSL_C_fH >= 0) && file_avail(mSL_C_fH)) ? (
            mSL_C_cavail = file_string(mSL_C_fH, #mSL_cline);
            x = strlen(#mSL_cline);
            mSL_C_numLine += 1;
            mSL_C_chPos = 0;
        ) : (
            (mSL_C_fH >= 0) ? (file_close(mSL_C_fH); mSL_C_fH = -1;);
            mSL_C_cavail = -1;
        );
    );
    (mSL_C_cavail > 0) ? (
        mSL_C_chcurr = str_getchar(#mSL_cline, mSL_C_chPos, 'cu');
        mSL_C_chPos += 1; mSL_C_cavail -= 1;
    ) : (
        mSL_C_chcurr = -1;
    );
    ((mSL_C_chcurr >= 0x80) && (flg & 1)) ? (
        // Multi byte char - other bytes follow...
        ((mSL_C_chcurr & 0xE0) === 0xC0) ? (
            // a 2 bytes UNICODE char
            x = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            mSL_C_chcurr = ((mSL_C_chcurr & 0x1f) << 6) | (x & 0x3f);
        ) :
        ((mSL_C_chcurr & 0xF0) === 0xE0) ? (
            // a 3 bytes UNICODE char
            x = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            y = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            mSL_C_chcurr = ((mSL_C_chcurr & 0x0F) << 12) | ((x & 0x3F) << 6) | (y & 0x3F);
        ) :
        ((mSL_C_chcurr & 0xF8) === 0xF0) ? (
            // a 4 bytes UNICODE char
            x = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            y = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            z = str_getchar(#mSL_cline, mSL_C_chPos, 'cu'); mSL_C_chPos += 1; mSL_C_cavail -= 1;
            mSL_C_chcurr = ((mSL_C_chcurr & 0x07) << 18) | ((x & 0x3F) << 12) | ((y & 0x3F) << 6) | (z & 0x3F);
        );
    );
    mSL_C_chcurr;
);


function mSL_Node_Trace(ptr)
local (ty, v, nxt, prv, pos, cnt, nat, tn)
(
    sprintf(#sfc, "STRUCT  %d", ptr);
    mSL_log(SysLogBox, #sfc);
    memset(mSL_Flat_List, -1, mSL_Flat_Siz);
    pfl = 0;
    mSL_Flat_List[pfl] = ptr;
    cnt = 1024;
    while ((pfl >= 0) && ((ptr = mSL_Flat_List[pfl]) > 0)) (
        mSL_Flat_List[pfl] = -1;
        pfl -= 1;
        sprintf(#sfc, "Sub STRUCT  %d", ptr);
        mSL_log(SysLogBox, #sfc);
        // make sure we start from the left of the struc.
        while ((ptr > 0) && ((prv = mSL_lptr[ptr]) > 0)) (
            ptr = prv;
        );
        while ((ptr > 0) && (cnt > 0))  (
            ty = mSL_tyun[ptr]; nxt = mSL_rptr[ptr]; prv = mSL_lptr[ptr];
            pos = mSL_upos[ptr]; v = mSL_valu[ptr]; nat = ty & 0x3FF;
            (ty === mSL_tySemiCol) ? (
                tn = ";";
            ) :
            (ty === mSL_opSet) ? (
                tn = "=";
            ) :
            (
                tn = mSL_type_Name(ty);
            );
            sprintf(#sfc, "%d:  %s  [%d  %d]  %x: %s", ptr, tn, prv, nxt, pos, mSL_edit_value(#sfd, v));
            mSL_log(SysLogBox, #sfc);
            ((nat === 10) || (nat === 11)) ? (
                pfl += 1; mSL_Flat_List[pfl] = v;
            );
            ptr = nxt; cnt -= 1;
        );
    );
    mSL_log(SysLogBox, "STRUCT  END");
);


function mSL_flatten_tree(tr)
local (p, hd, tl, ty, ent, rpeat, restart, bz, ll, rl, tyl, tyr, lx, rx, v)
(
    ty = mSL_tyun[tr];
    (mSL_CP_Flags & 16) ? (
        sprintf(#sfc, "Flatten:    %d    %d    %s", tr, mSL_valu[tr],  mSL_type_Name(ty));
        mSL_log(SysLogBox, #sfc);
    );
    (ty === mSL_tySubExp) ? (
        // The object is a sub-exp
        // we are going to flatten it
        // Create the initial chain

        hd = mSL_enterHEAD(); // Create the head
        tl = mSL_getChEnt();  // The tail
        (mSL_errC === 0) ? (
            mSL_tyun[tl] = mSL_tyTAIL ;
        );
        ent = mSL_getChEnt(); // a node to copy ours
        (mSL_errC === 0) ? (
            //mSL_rptr[ent] = mSL_rptr[tr];
            //mSL_lptr[ent] = mSL_lptr[tr];
            mSL_tyun[ent] = mSL_tyun[tr];
            mSL_valu[ent] = mSL_valu[tr];
            mSL_upos[ent] = mSL_upos[tr];
            mSL_flgs[ent] = mSL_flgs[tr];
            mSL_lptr[ent] = hd;
            mSL_rptr[ent] = tl;
            mSL_lptr[hd] = -1;
            mSL_rptr[hd] = ent;
            mSL_lptr[tl] = ent;
            mSL_rptr[tl] = -1;
        );
        // we have now :  hd --> subexp --> tl
        // process lightly
        rpeat = 1; restart = hd;
        while (rpeat && (mSL_errC === 0))   (
            p = restart; rpeat = 0;
            while ((p >= 0) && (mSL_errC === 0))  (
                ty = mSL_tyun[p];
                (mSL_CP_Flags & 16) ? (
                    sprintf(#sfc, "Fl:    %d    %d    %s", p, mSL_valu[p],  mSL_type_Name(ty));
                    mSL_log(SysLogBox, #sfc);
                );
                ((ty === mSL_tyNum) || (ty === mSL_tyIdent)) ? (
                    // OK - skip to next
                    p = mSL_rptr[p];
                ) :
                ((ty === mSL_tyHEAD) || (ty === mSL_tyTAIL)) ? (
                    // OK - skip to next
                    p = mSL_rptr[p];
                ) :
                ((ty === mSL_tyMNeg) || (ty === mSL_tyDMinus) || (ty === mSL_tyDadd) || (ty === mSL_tyDOr) || (ty === mSL_tyDAnd) || (ty === mSL_tyDDiv)) ? (
                    // OK
                    p = mSL_rptr[p];
                ) :
                (ty === mSL_tySubExp) ? (
                    // we have a sub expression
                    // put it in place of the current "p"
                    bz = p; // our base
                    ll = mSL_lptr[bz];
                    rl = mSL_rptr[bz];
                    xp = mSL_valu[bz];
                    lx = mSL_lptr[xp];
                    rx = mSL_rptr[xp];
                    (lx < 0) ? (
                        // no left operand - link the operator
                        mSL_rptr[ll] = xp;
                        mSL_lptr[xp] = ll;
                    ) : (
                        mSL_rptr[ll] = lx;
                        mSL_lptr[lx] = ll;
                    );
                    // link the right operand
                    mSL_rptr[rx] = rl;
                    mSL_lptr[rl] = rx;
                    // Restart analysis
                    rpeat = 1;
                    restart = ll; // from the left
                    // Free the "p" node
                    // mSL_freeChEnt(p);
                    p = -1; // end & restart
                ) :
                (
                    // error for now...
                    (mSL_CP_Flags & 16) ? (
                        mSL_log(SysLogBox, "Unknown type");
                    );
                    mSL_errC = 3415;
                );
            );
        );
        (mSL_errC === 0) ? (
            // Rescan and replace the "-" "numbers"
            p = hd;
            while ((p >= 0) && (mSL_errC === 0))  (
                ty = mSL_tyun[p];
                ((ty === mSL_tyNum) || (ty === mSL_tyIdent)) ? (
                    // OK - skip to next
                    p = mSL_rptr[p];
                ) :
                ((ty === mSL_tyHEAD) || (ty === mSL_tyTAIL)) ? (
                    // OK - skip to next
                    p = mSL_rptr[p];
                ) :
                ((ty === mSL_tyMNeg) || (ty === mSL_tyDMinus)) ? (
                    // we expect a number after that
                    rx = mSL_rptr[p];
                    (mSL_tyun[rx] === mSL_tyNum) ? (
                        mSL_valu[rx] = - mSL_valu[rx];
                        ll = mSL_lptr[p];
                        mSL_rptr[ll] = rx;
                        mSL_lptr[rx] = ll;
                        // mSL_freeChEnt(p);
                        p = rx;
                    ) :
                    (
                        // error for now...
                        (mSL_CP_Flags & 16) ? (
                            mSL_log(SysLogBox, "Unmanaged '-' operand");
                        );
                        mSL_errC = 3416;
                    );
                ) :
                ((ty === mSL_tyDadd) || (ty === mSL_tyDOr) || (ty === mSL_tyDAnd) || (ty === mSL_tyDDiv)) ? (
                    // if next and previous are numbers...
                    bz = p;
                    lx = mSL_lptr[bz];
                    rx = mSL_rptr[bz];
                    tyl = mSL_tyun[lx];
                    tyr = mSL_tyun[rx];
                    ((tyl === mSL_tyNum) && (tyr === mSL_tyNum)) ? (
                        0 ? (
                        sprintf(#sfc, "Fl+l:    %d    %d    %s", lx, mSL_valu[lx],  mSL_type_Name(mSL_tyun[lx]));
                        mSL_log(SysLogBox, #sfc);
                        sprintf(#sfc, "Fl+r:    %d    %d    %s", rx, mSL_valu[rx],  mSL_type_Name(mSL_tyun[rx]));
                        mSL_log(SysLogBox, #sfc);
                        );
                        v = mSL_valu[rx];
                        (ty === mSL_tyDadd) ? (
                            mSL_valu[rx] = mSL_valu[lx] + v;
                        ) :
                        (ty === mSL_tyDOr) ? (
                            mSL_valu[rx] = mSL_valu[lx] | v;
                        ) :
                        (ty === mSL_tyDAnd) ? (
                            mSL_valu[rx] = mSL_valu[lx] & v;
                        ) :
                        (ty === mSL_tyDDiv) ? (
                            v = max(1,min(32,0|v));
                            mSL_valu[rx] = mSL_valu[lx] + (1 << (v-1)) ;
                        ) ;

                        // link to the left
                        ll = mSL_lptr[lx];
                        mSL_rptr[ll] = rx;
                        mSL_lptr[rx] = ll;
                        p = mSL_rptr[p];
                        // mSL_freeChEnt(bz);
                        // mSL_freeChEnt(lx);
                        0 ? (
                        sprintf(#sfc, "Fl+:    %d    %d    %s", rx, mSL_valu[rx],  mSL_type_Name(mSL_tyun[rx]));
                        mSL_log(SysLogBox, #sfc);
                        );
                    ) :
                    (
                        // error for now...
                        (mSL_CP_Flags & 16) ? (
                            mSL_log(SysLogBox, "Unmanaged 'x'  operand");
                        );
                        mSL_errC = 3416;
                    );

                ) :
                (
                    // error for now...
                    (mSL_CP_Flags & 16) ? (
                        mSL_log(SysLogBox, "Unknown type");
                    );
                    mSL_errC = 3417;
                );
            );
        );
        (mSL_errC === 0) ? (
            // Update the initial pointers
            ll = mSL_lptr[tr];
            rl = mSL_rptr[tr];
            mSL_rptr[ll] = p = mSL_rptr[hd];
            mSL_lptr[p] = ll;
            mSL_lptr[rl] = p = mSL_lptr[tl];
            mSL_rptr[p] = rl;
            // we can free "tr"
            // mSL_freeChEnt(tr);
        );
    );
);





// Rewrite a conditional expression "?:"
function mSL_rewConds(ptr, lev)
local (s, eptr, flgRpeat, ty, nxs, prev, next, pprev, nnext, nnnext, nnnnext, newc)
(
    // Go to the left
    eptr = s = ptr;
    while (s > 0) (
        eptr = s; s = mSL_rptr[s];
    );
    flgRpeat = 1;
    while (flgRpeat && (mSL_errC === 0)) (
        flgRpeat = 0;
        s = eptr;
        while (s > 0) (
            ty = mSL_tyun[s]; nxs = mSL_lptr[s];
            // do we have an "?"
            (ty === mSL_tyCondOP) ? (
                // need operands around it
                prev = mSL_lptr[s]; next = mSL_rptr[s];
                ((next > 0) && (mSL_tyun[next] & mSL_tyOperand) && (prev > 0) && (mSL_tyun[prev] & mSL_tyOperand)) ? (
                    pprev = mSL_lptr[prev];
                    // do we have an else part ?
                    (((nnext = mSL_rptr[next]) > 0) && (mSL_tyun[nnext] ===  mSL_tyCondElse)) ? (
                        // expect a right operand
                        (((nnnext = mSL_rptr[nnext]) > 0) && (mSL_tyun[nnnext] & mSL_tyOperand)) ? (
                            // a "correct" X ? Y : Z
                            nnnnext = mSL_rptr[nnnext];
                            newc = mSL_getChEnt();
                            (mSL_errC === 0) ? (
                                mSL_tyun[newc] = mSL_tySubExp;
                                // points to the "?" op
                                mSL_valu[newc] = s; mSL_upos[newc] = mSL_upos[s];
                                // Sets the op as an ?2
                                mSL_tyun[s] = mSL_tyFCond2; mSL_valu[s] = mSL_prCond2;
                                // unlink the left operand
                                mSL_lptr[prev] = mSL_nullPtr;
                                // link the new cell to its left
                                mSL_lptr[newc] = pprev; mSL_rptr[pprev] = newc;
                                // delete the ':' marker
                                mSL_rptr[next] = nnnext; mSL_lptr[nnnext] = next; mSL_freeChEnt(nnext);
                                // unlink the else part
                                mSL_rptr[nnnext] = mSL_nullPtr;
                                // Relink the new created expression in the main part
                                mSL_rptr[newc] = nnnnext;
                                (nnnnext > 0) ? mSL_lptr[nnnnext] = newc;
                                flgRpeat = 1; nxs = pprev;
                            );
                        ) : (
                            mSL_errC = 2207; // a syntax error on this op
                            mSL_errPos = mSL_upos[s];
                        );
                    ) : (
                        // have a "single" X ? Y expression
                        newc = mSL_getChEnt();
                        (mSL_errC === 0) ? (
                            mSL_tyun[newc] = mSL_tySubExp;
                            // points to the "?" op
                            mSL_valu[newc] = s; mSL_upos[newc] = mSL_upos[s];
                            // Sets the op as an ?1
                            mSL_tyun[s] = mSL_tyFCond1; mSL_valu[s] = mSL_prCond1;
                            // unlink the left operand
                            mSL_lptr[prev] = mSL_nullPtr;
                            // link the new cell to its left
                            mSL_lptr[newc] = pprev; mSL_rptr[pprev] = newc;
                            // unlink the right operand
                            mSL_rptr[next] = mSL_nullPtr;
                            // link the new cell to its right
                            mSL_rptr[newc] = nnext; mSL_lptr[nnext] = newc;
                            flgRpeat = 1; nxs = pprev;
                        )
                    );
                ) : (
                    // an error -- signal it
                    mSL_errC = 2206; // a syntax error on this op
                    mSL_errPos = mSL_upos[s];
                );
            );
            s = nxs;
        );
    );
    mSL_errC;
);



// Find nested brackets
function mSL_findBrackets(ptr)
local (s, res, flgCnt, ty, nxs, p, lf, fty, typ, newc, prev, next, z)
(
    // Find the first inner brackets pair in a chained expression
    res = mSL_nullPtr;
    s = ptr;
    flgCnt = 1;
    while (flgCnt && (mSL_errC === 0) && (s > 0)) (
        ty = mSL_tyun[s]; nxs = mSL_rptr[s];
        (ty & mSL_tySep) ? ( AA_typU = ty; );
        AA_lpUnit += 1;
        ((ty === mSL_tyRPar) || (ty === mSL_tyRBrk)) ? (
            (ty === mSL_tyRPar) ? (
                lf = mSL_tyLPar; fty = mSL_tyParExp;
            ) : (
                lf = mSL_tyLBrk; fty = mSL_tyBrkExp;
            );
            p = mSL_lptr[s];
            while (flgCnt && (p > 0)) (
                typ = mSL_tyun[p];
                (typ === lf) ? (
                    // Found the left parenth. or bracket.
                    newc = mSL_getChEnt();
                        (mSL_errC === 0) ? (
                        mSL_tyun[newc] = fty; mSL_valu[newc] = p;
                        // Chain/unchain what is necessary
                        prev = mSL_lptr[p]; // before the left opening
                        next = mSL_rptr[s]; // after the right closing
                        mSL_lptr[newc] = prev; (prev > 0) ? mSL_rptr[prev] = newc;
                        mSL_rptr[newc] = next; (next > 0) ? mSL_lptr[next] = newc;
                        mSL_upos[newc] = mSL_upos[p]; // position = the '[' or '(' item
                        // Unchain left & right separators
                        mSL_lptr[p] = mSL_rptr[s] = mSL_nullPtr;
                        // Change type to HEAD and TAIL
                        mSL_tyun[p] = mSL_tyHEAD; mSL_valu[p] = 0;
                        mSL_tyun[s] = mSL_tyTAIL; mSL_valu[s] = 0;
                        // Check the expression is "bracket clean"
                        res = newc;
                        z = p; // restart from p
                        while (z > 0) (
                            typ = mSL_tyun[z];
                            ((typ === mSL_tyLPar) || (typ === mSL_tyLBrk)) ? (
                                mSL_errC = 2225; // incorrect nesting
                                mSL_errPos = mSL_upos[z];
                            );
                            z = mSL_rptr[z];
                        );
                        flgCnt = 0;
                    );
                );
                p = mSL_lptr[p]; // go left
            );
            // Have we found something ?
            (res === mSL_nullPtr) ? (
                mSL_errC = 2224; // corresponding bracket missing
                mSL_errPos = mSL_upos[s];
            );
        );
        s = nxs;
    );
    res;
);




// Rewrite rule : replace a binary op by a tree struct "subexp", left to right
function mSL_rewL2RRule(ptr, lev)
local (flgRpeat, s, nxs, ty, prev, next, newc, pprev, nnext)
(
    flgRpeat = 1;
    while (flgRpeat && (mSL_errC === 0)) (
        flgRpeat = 0;
        s = ptr;
        while (s > 0) (
            // AA_rewRule += 1;
            ty = mSL_tyun[s]; nxs = mSL_rptr[s];
            (ty & mSL_tyOP) ? AA_LastOP = s; //TRACE
            ((ty & mSL_tyOP) && (((ty >> mSL_prtyShift) & mSL_prtyMask) === lev)) ? (
                //AA_fndOP += 1; //TRACE
                // The current object could become a subtree
                prev = mSL_lptr[s]; next = mSL_rptr[s];
                ((prev > 0) && (next > 0) && (mSL_tyun[prev] & mSL_tyOperand) && (mSL_tyun[next] & mSL_tyOperand)) ? (
                    // Build the structure
                    newc = mSL_getChEnt();
                    (mSL_errC === 0) ? (
                        mSL_tyun[newc] = mSL_tySubExp;
                        AA_newc = newc;
                        mSL_valu[newc] = s; mSL_upos[newc] = mSL_upos[s];
                        pprev = mSL_lptr[prev]; nnext = mSL_rptr[next];
                        (pprev > 0) ? (
                            // Rechain to the new cell
                            mSL_rptr[pprev] = newc; mSL_lptr[newc] = pprev;
                        ) :
                        (prev === ptr) ? (
                            // repoint to the new cell
                            ptr = newc; // all is done
                        ) : (
                            // probably an error
                            mSL_errC = 2221; //
                        );
                        (nnext > 0) ? (
                            // rechain to the next cell
                            mSL_lptr[nnext] = newc; mSL_rptr[newc] = nnext;
                        ) : (
                            // probably have nothing to do
                            mSL_rptr[newc] = mSL_nullPtr;
                        );
                        mSL_lptr[prev] = mSL_nullPtr;
                        mSL_rptr[next] = mSL_nullPtr;
                        flgRpeat = 1;
                        nxs = mSL_rptr[newc]; // next to analyse
                    );
                );
            );
            s = nxs;
        );
    );
);



// Rewrite rule : replace a binary op by a tree structure "subexp", right to left
function mSL_rewR2LRule(ptr, lev, flg)
local (flgRpeat, s, eptr, ty, nxs, prev, next, newc, pprev, nnext, pty, ppty)
(
    // Find end of statement
    eptr = s = ptr;
    while (s > 0) (
        eptr = s; s = mSL_rptr[s];
    );
    flgRpeat = 1;
    while (flgRpeat && (mSL_errC === 0)) (
        flgRpeat = 0;
        s = eptr;
        while (s > 0) (
            ty = mSL_tyun[s]; nxs = mSL_lptr[s];
            ((ty & mSL_tyOP) && (((ty >> mSL_prtyShift) & mSL_prtyMask) === lev)) ? (
                // The current object could become a subtree
                prev = mSL_lptr[s]; next = mSL_rptr[s];
                ((prev > 0) && (next > 0) && (mSL_tyun[prev] & mSL_tyOperand) && (mSL_tyun[next] & mSL_tyOperand)) ? (
                    // Some operations need an identifier as left operand
                    (flg & 1) ? (
                        pty = mSL_tyun[prev];
                        (pty != mSL_tyIdent) ? (
                            (pty === mSL_tySubExp) ? (
                                ppty = mSL_tyun[mSL_valu[prev]];
                                (ppty === mSL_tyBrkInd) ? (
                                    // Change the type of [] op.
                                    mSL_tyun[mSL_valu[prev]] = mSL_tyBrkIndA;
                                ) :
                                (ppty != mSL_tyMgmem) ? (
                                    mSL_errC = 2202;
                                    mSL_errPos = mSL_upos[s];
                                );
                            ) :
                            (
                                AAAA_pty = pty; AAA_prev = mSL_tyun[mSL_valu[prev]];
                                mSL_errC = 2201; // a syntax error on this op
                                mSL_errPos = mSL_upos[s];
                            );
                        ) : (
                            // change the type as mSL_tyIdAddr
                            mSL_tyun[prev] = mSL_tyIdAddr;
                        );
                    );
                    // build the structure
                    newc = mSL_getChEnt();
                    (mSL_errC === 0) ? (
                        mSL_tyun[newc] = mSL_tySubExp; mSL_valu[newc] = s;
                        mSL_upos[newc] = mSL_upos[s];
                        pprev = mSL_lptr[prev]; nnext = mSL_rptr[next];
                        (pprev > 0) ? (
                            // Rechain to the new cell
                            mSL_rptr[pprev] = newc; mSL_lptr[newc] = pprev;
                        ) :
                        (prev === ptr) ? (
                            // repoint to the new cell
                            ptr = newc; // all is done
                        ) : (
                            // probably an error
                            mSL_errC = 2222; //
                        );
                        (nnext > 0) ? (
                            // rechain to the next cell
                            mSL_lptr[nnext] = newc; mSL_rptr[newc] = nnext;
                        ) :
                        (next === eptr) ? (
                            // repoint to the new cell
                            eptr = newc; // all is done
                        ) : (
                            // probably have nothing to do
                            mSL_rptr[newc] = mSL_nullPtr;
                        );
                        mSL_lptr[prev] = mSL_nullPtr;
                        mSL_rptr[next] = mSL_nullPtr;
                        flgRpeat = 1;
                        nxs = mSL_lptr[newc]; // next to analyse
                    );
                ) :
                ((prev > 0) && (next > 0) && (mSL_tyun[next] === mSL_tyTAIL) && (flg & 2)) ? (
                    // suppress last object before the TAIL
                    mSL_rptr[prev] = next; mSL_lptr[next] = prev;
                    mSL_freeChEnt(s); nxs = prev;
                );
            );
            s = nxs;
        );
    );
);



// Detect monadic operators
function mSL_findMonad(ptr)
local (s, ty, nxs, prev, next, newc, nnext)
(
    // Any op preceeded by another one is a monop
    prev = s = ptr;
    while (s > 0) (
        ty = mSL_tyun[s]; nxs = mSL_rptr[s]; prev = s;
        (((ty & mSL_tyOP)||(ty === mSL_tyHEAD)||(ty === mSL_tyLPar)||(ty === mSL_tyLBrk))
            && (nxs > 0) && (mSL_tyun[nxs] & mSL_tyOP)) ? (
            mSL_tyun[nxs] |= mSL_tyOPMon;
        );
        s = nxs;
    );
    // apply Right to left
    s = prev;
    while (s > 0) (
        ty = mSL_tyun[s]; nxs = mSL_lptr[s];
        prev = mSL_lptr[s]; next = mSL_rptr[s];
        ((ty & mSL_tyOPMon) && (next > 0) && (mSL_tyun[next] & mSL_tyOperand)) ? (
            // apply as monadic
            newc = mSL_getChEnt();
            (mSL_errC === 0) ? (
                mSL_tyun[newc] = mSL_tySubExp;
                mSL_valu[newc] = s; mSL_upos[newc] = mSL_upos[s];
                nnext = mSL_rptr[next];
                (prev > 0) ? (
                    // Rechain to the new cell
                    mSL_rptr[prev] = newc; mSL_lptr[newc] = prev;
                ) :
                (s === ptr) ? (
                    // repoint to the new cell
                    ptr = newc; // all is done
                ) : (
                    // probably an error
                    mSL_errC = 2223; //
                );
                (nnext > 0) ? (
                    // rechain to the next cell
                    mSL_lptr[nnext] = newc; mSL_rptr[newc] = nnext;
                ) : (
                    // probably have nothing to do
                    mSL_rptr[newc] = mSL_nullPtr;
                );
                mSL_lptr[s] = mSL_nullPtr;
                mSL_rptr[next] = mSL_nullPtr; // prune it
                nxs = mSL_lptr[newc]; // next to analyse
            );
        );
        s = nxs;
    );
);



// Apply all rules on std expression
function
mSL_doRules(ptr, flg)
(
    mSL_findMonad(ptr); // look for some monadic operators
    mSL_rewL2RRule(ptr, 3); // dyadic "^"
    mSL_rewL2RRule(ptr, 4); // dyadic "*" "/" and "%"
    mSL_rewL2RRule(ptr, 5); // dyadic "-" and "+"
    mSL_rewL2RRule(ptr, 6); // dyadic "<<" and ">>"
    mSL_rewL2RRule(ptr, 7); // dyadic "<" "<=" ">" and ">="
    mSL_rewL2RRule(ptr, 8); // dyadic "=="  "!=" "===" and "!=="
    mSL_rewL2RRule(ptr, 9); // dyadic "&" and "~"
    mSL_rewL2RRule(ptr, 10); // dyadic "|"
    mSL_rewR2LRule(ptr, 11, 0); // dyadic "&&"
    mSL_rewR2LRule(ptr, 12, 0); // dyadic "||"
    mSL_rewConds(ptr, 13); // handle '?' et ':'
    mSL_rewR2LRule(ptr, 14, 1); // dyadic "=" and others
    (flg & 1) ? mSL_rewR2LRule(ptr, 16, 2); // dyadic ";" // separator
);




// Check we have a single value inside a HEAD - TAIL chain
function mSL_checkSingle(xp)
local (res, p, q)
(
    res = mSL_nullPtr;
    ((xp > 0) && (mSL_tyun[xp] === mSL_tyHEAD)) ? (
        p = mSL_rptr[xp]; // next
        ((p > 0) && (mSL_tyun[p] & mSL_tyOperand)) ? (
            // we have an operand
            q = mSL_rptr[p]; // next
            ((q > 0) && (mSL_tyun[q] === mSL_tyTAIL)) ? (
                // Correct - keep only the value
                res = p;
            );
        );
    );
    res;
);



// Check we have a comma-list in that
// returns : 0 to "n" = length of list
// free commas
// -1 = error
function
mSL_checkCList(xp, fl)
local (res, p, state, ty, va, vb, elc, prv, nxt, erf)
(
    (mSL_CP_Flags & 16) ? (
        sprintf(#sfc, "Enter checkCList %d %d", xp, fl);
        mSL_log(SysLogBox, #sfc);
    );
    res = -1;
    state = 1;
    p = xp;
    erf = elc = 0;
    AA_checkCList = 0;
    while (state != 0) (
        AA_elc = elc; //TRACE
        (p > 0) ? (
            ty = mSL_tyun[p];
            va = mSL_valu[p];
            mSL_edit_value(#va, va)
        ) : (
            state = 0; // ends as error
            AA_checkCList = 10; //TRACE
        );
        (state === 1) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 1 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty === mSL_tyHEAD) ? (
                state = 2;
            ) : (
                state = 0; // ends as error
                AA_checkCList = 11; //TRACE
            );
        ) :
        (state === 2) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 2 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty === mSL_tyTAIL) ? (
                // empty list
                state = 0; res = 0; // ok, empty list
            ) :
            (ty & mSL_tyOperand) ? (
                // an operand
                //sprintf(#sfc, "Obj operand %d %s %s", p, #va, mSL_type_Name(ty));
                //mSL_log(SysLogBox, #sfc);
                state = 3; elc += 1;
            ) :
            (ty & mSL_tyPrimFun) ? (
                (mSL_CP_Flags & 128) ? (
                    sprintf(#sfc, "Obj Prim %d %s %s", p, #va, mSL_type_Name(ty));
                    mSL_log(SysLogBox, #sfc);
                );
                state = 6; elc += 1;
            ) :
            (ty & mSL_tyOP) ? (
                (mSL_CP_Flags & 128) ? (
                    sprintf(#sfc, "Obj OP %d %s %s", p, #va, mSL_type_Name(ty));
                    mSL_log(SysLogBox, #sfc);
                );
                state = 5; elc += 1;
            ) : (
                state = 0; // ends as error
                AA_checkCList = 12; //TRACE
            );
        ) :
        (state === 3) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 3 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty === mSL_tyTAIL) ? (
                // ok
                state = 0; res = elc; // return element count
            ) :
            (ty === mSL_tyComma) ? (
                // unchain the comma operation
                prv = mSL_lptr[p]; nxt = mSL_rptr[p];
                (nxt > 0) ? mSL_lptr[nxt] = prv;
                mSL_rptr[prv] = nxt;
                mSL_freeChEnt(p); // free p
                p = prv; // restart in the list
                state = 4;
            ) : (
                (mSL_CP_Flags & 16) ? (
                    sprintf(#sfc, "Obj St3 %d %s %s", p, #va, mSL_type_Name(ty));
                    mSL_log(SysLogBox, #sfc);
                );
                AA_ty = ty;
                (fl) ? (
                    erf = 1; // set erf
                    elc += 1;
                    state = 3;
                ) : (
                    state = 0; // ends as error
                );
                AA_checkCList = 13; //TRACE
            );
        ) :
        (state === 4) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 4 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty & mSL_tyOperand) ? (
                // an operand
                state = 3; elc += 1;
            ) : (
                state = 0; // ends as error
                AA_checkCList = 14; //TRACE
            );
        ) :
        (state === 5) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 5 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty === mSL_tyTAIL) ? (
                // ok
                // res = elc - 16; // return a symbolic element count
                res = -1;
            );
            state = 0;
        ) :
        (state === 6) ? (
            (mSL_CP_Flags & 16) ? (
                sprintf(#sfc, "State 6 %d %s %s", p, #va, mSL_type_Name(ty));
                mSL_log(SysLogBox, #sfc);
            );
            (ty === mSL_tyTAIL) ? (
                // ok
                res = elc - 32; // return a symbolic element count
            );
            state = 0;
        );
        (p > 0) ? p = mSL_rptr[p];
    );
    (mSL_CP_Flags & 16) ? (
        sprintf(#sfc, "End %d/%d %s", res, p, mSL_type_Name(ty));
        mSL_log(SysLogBox, #sfc);
    );
    res;
);



// Next syntactic unit
function
mSL_lex()
local (state, lex, cod, ch, fac, dec, expn, exps, i, s, addr)
(
    state = 1; // init state
    lex = 0;
    cod = 1;
    dec = 1;
    #sid = "";
    while (state > 0) (
        (mSL_C_chcurr === 0) ? (mSL_C_chcurr = mSL_getchar(dec));
        ch = mSL_C_chcurr;

        (state === 1) ? (
            // initial state
            dec = 1;
            mSL_posChar = mSL_C_chPos; // keep initial position
            (ch < 0) ? (
                // end of file
                state = 0;
                cod = lex = -1;
            ) :
            (ch <= 0x20) ? (
                // space or similar
                mSL_C_chcurr = 0; // ignore
            ) :
            (((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')) || (ch === '_')) ? (
                fac = cod = s = 0; state = 2; lex = mSL_tyIdent; // identifier
            ) :
            ((ch >= '1') && (ch <= '9')) ? (
                cod = ch - '0'; mSL_C_chcurr = 0;
                state = 3; lex = mSL_tyNum; // number
            ) :
            (ch === '0') ? (
                cod = 0; mSL_C_chcurr = 0;
                state = 20; lex = mSL_tyNum; // number
            ) :
            (ch === '<') ? (
                state = 5; mSL_C_chcurr = 0;
            ) :
            (ch === '>') ? (
                state = 6; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                state = 7; mSL_C_chcurr = 0;
            ) :
            (ch === '!') ? (
                state = 8; mSL_C_chcurr = 0;
            ) :
            (ch === '&') ? (
                state = 9; mSL_C_chcurr = 0;
            ) :
            (ch === '|') ? (
                state = 10; mSL_C_chcurr = 0;
            ) :
            (ch === '/') ? (
                state = 11; mSL_C_chcurr = 0;
            ) :
            (ch === '*') ? (
                state = 15; mSL_C_chcurr = 0;
            ) :
            (ch === '+') ? (
                state = 16; mSL_C_chcurr = 0;
            ) :
            (ch === '-') ? (
                state = 17; mSL_C_chcurr = 0;
            ) :
            (ch === '%') ? (
                state = 18; mSL_C_chcurr = 0;
            ) :
            (ch === 0x27) ? (  // single quote
                state = 19; dec = cod = 0; lex = mSL_tyNum; mSL_C_chcurr = 0;
            ) :
            (ch === 0x22) ? (  // double quote
                ///AA_lex_state = 1;
                state = 23; dec = cod = 0; i = 0; lex = mSL_tyString; mSL_C_chcurr = 0;
            ) :
            (ch === 96) ? (  // backquote
                state = 30; dec = cod = s = 0; lex = mSL_tyNum; mSL_C_chcurr = 0; fac = 1;
            ) :
            (ch === '$') ? (  // $constant
                state = 2; dec = cod = s = 0; lex = mSL_tyNum; mSL_C_chcurr = 0; fac = 2;
            ) :
            (
                // Simple case : a single operator/separator
                ((ch === ')') || (ch === '(') || (ch === '[') || (ch === ']')) ? (
                    lex = ch | mSL_tySep;
                ) :
                ((ch === '^')) ? (
                    lex = mSL_K_fPow | mSL_tyOP| mSL_prty3;
                ) :
                ((ch === '~')) ? (
                    lex = mSL_K_fXOr | mSL_tyOP| mSL_prty9;
                ) :
                ((ch === '?') || (ch === ':')) ? (
                    lex = ch | mSL_tyOP| mSL_prty13;
                ) :
                ((ch === ',')) ? (
                    lex = ch | mSL_tyOP| mSL_prty15;
                ) :
                ((ch === ';')) ? (
                    lex = mSL_tySemiCol;
                ) :
                (
                    // default ?
                    lex = ch | mSL_tyOP;
                ) ;
                cod = ch;
                state = 0; // done
                mSL_C_chcurr = 0;
            );
        ) :

        (state === 2) ? (
            // coding an identifier - we already have the first char
            // Gather all chars in the string "#sid"
            (((ch >= '0') && (ch <= '9')) || ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z')) || (ch === '_') ) ? (
                // Enter the char in the string
                str_setchar(#sid, s, ch, 'cu'); s += 1; mSL_C_chcurr = 0;
            ) : (
                // The char doesn't belong to the identifier
                (s > 128) ? (
                    // Identifier too long
                    mSL_errC = 2301;
                    state = lex = 0; // error
                ) : (
                    cod = mSL_symbol(#sid);
                    (fac === 0) ? (
                        // check the symbol in the symbol table for a keyword
                        i = mSL_checkGId(cod); // the entry
                        (i >= 0) ? (
                            // give it the type
                            lex = mSL_GCTyp[i];
                        );
                    ) :
                    (fac === 2) ? (
                        // A $ with an identifier
                        // look for the identifier in a constant table
                        (cod === mSL_KW_pi) ? ( cod = $pi; ) : // $pi is correct
                        (cod === mSL_KW_e) ? ( cod = 2.71828182845904523536; ) : // $e was not correct
                        (cod === mSL_KW_endmark) ? ( cod = mSL_End_Mark; ) :
                        (cod === mSL_KW_undef) ? ( cod = Undef; ) :
                        (cod === mSL_KW_usep) ? ( cod = USep; ) :
                        // (cod = mSL_get(mSL_current_constants, cod); );
                        (
                            // Look for the constant in the table
                            addr = mSL_current_constants;
                            s = addr[-1];
                            i = 0;
                            while (i < s) (
                                (addr[i] === cod) ? (
                                    cod = addr[i+1] ; i = s;
                                );
                                i += 2;
                            );
                        );
                    ) ;
                    // otherwise, it is a ` identifier, so just a symbol
                    state = 0; // done
                );
            );
        ) :

        (state === 3) ? (
            // decoding a number
            ((ch >= '0') && (ch <= '9')) ? (
                cod = cod * 10 + ch - '0'; mSL_C_chcurr = 0;
            ) :
            (ch === '.') ? (
                // go decimal
                fac = 1; state = 4; mSL_C_chcurr = 0;
            ) :
            ((ch === 'e') || (ch === 'E')) ? (
                // go exponential
                state = 27; expn = 0; exps = 1; mSL_C_chcurr = 0;
            ) : (
                // done decoding
                state = 0;
            );
        ) :

        (state === 4) ? (
            // gone decimal
            ((ch >= '0') && (ch <= '9')) ? (
                fac = fac * 0.1; cod = cod + fac * (ch - '0'); mSL_C_chcurr = 0;
            ) :
            ((ch === 'e') || (ch === 'E')) ? (
                // go exponential
                state = 27; expn = 0; exps = 1; mSL_C_chcurr = 0;
            ) : (
                // done decoding
                state = 0;
            );
        ) :

        (state === 5) ? (
            // found a "<" - is there something else behind ?
            (ch === '<') ? (
                // got a "<<"
                lex = mSL_K_LShift | mSL_tyOP | mSL_prty6;
                cod = '<<';
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                // got a "<="
                lex = mSL_K_fLTE  | mSL_tyOP | mSL_prty7 ;
                cod = '<=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "<"
                lex = mSL_K_fLT | mSL_tyOP | mSL_prty7 ;
                cod = '<';
                state = 0; // & keep char
            );
        ) :

        (state === 6) ? (
            // found a '>'
            (ch === '>') ? (
                // we got a ">>"
                lex = mSL_K_RShift | mSL_tyOP | mSL_prty6;
                cod = '>>';
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                // got a ">="
                lex = mSL_K_fGTE | mSL_tyOP | mSL_prty7 ;
                cod = '>=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a ">"
                lex = mSL_K_fGT | mSL_tyOP | mSL_prty7 ;
                cod = '>';
                state = 0; // & keep char
            );
        ) :

        (state === 7) ? (
            // found a '='
            (ch === '=') ? (
                // we got a "==" -- check for another "="
                state = 25; mSL_C_chcurr = 0;
            ) : (
                // just a "="
                lex = mSL_opSet ;
                cod = '=';
                state = 0; // & keep char
            );
        ) :

        (state === 8) ? (
            // found a '!'
            (ch === '=') ? (
                // we got a "!=" -- check for another "="
                state = 26; mSL_C_chcurr = 0;
            ) : (
                // just a "!"
                lex = mSL_K_fNot | mSL_tyOP | mSL_prty2 ;
                cod = '!';
                state = 0; // & keep char
            );
        ) :

        (state === 9) ? (
            // found a '&'
            (ch === '&') ? (
                // we got a "&&"
                lex = mSL_tyFLogAnd ;
                cod = '&&';
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                // we got a "&="
                lex = mSL_K_Aff_And | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '&=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "&"
                lex = mSL_K_fAnd | mSL_tyOP | mSL_prty9;
                cod = '&';
                state = 0; // & keep char
            );
        ) :

        (state === 10) ? (
            // found a '|'
            (ch === '|') ? (
                // we got a "||"
                lex = mSL_tyFLogOr ;
                cod = '||';
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                // we got a "|="
                lex = mSL_K_Aff_Or | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '|=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "|"
                lex = mSL_K_fOr | mSL_tyOP | mSL_prty10 ;
                cod = '|';
                state = 0; // & keep char
            );
        ) :

        (state === 11) ? (
            // found a "/" -- is this a comment ?
            (ch === '/') ? (
                state = 12; mSL_C_chcurr = 0;
            ) :
            (ch === '=') ? (
                // we got a "/="
                lex = mSL_K_Aff_Div | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14;
                cod = '/=';
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === '*') ? (
                state = 13; mSL_C_chcurr = 0;
            ) : (
                // just a "/"
                lex = mSL_K_fDiv | mSL_tyOP | mSL_prty4 ;
                cod = '/';
                state = 0; // & keep char
            );
        ) :

        (state === 12) ? (
            // "end of line" comment
            ((ch === 10) || (ch === 13) || (ch === -1)) ? (
                // end of comment -- look for a new unit
                state = 1;
            );
            mSL_C_chcurr = 0; // stay in state - delete char
        ) :

        (state === 13) ? (
            // inside a / * comment
            (ch === '*') ? (
                state = 14;
            );
            mSL_C_chcurr = 0; // stay in state - delete char
        ) :

        (state === 14) ? (
            // found a "*" inside a / * comment
            (ch === '/') ? (
                state = 1; // we are out !
            ) :
            (ch != '*') ? (
                state = 13; // return to the comment
            );
            mSL_C_chcurr = 0; // del. char
        ) :

        (state === 15) ? (
            // found a '*'
            (ch === '=') ? (
                // we got a "*="
                lex = mSL_K_Aff_Times | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '*=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "*"
                lex = mSL_K_fTimes | mSL_tyOP | mSL_prty4 ;
                cod = '*';
                state = 0; // & keep char
            );
        ) :

        (state === 16) ? (
            // found a '+'
            (ch === '=') ? (
                // we got a "+="
                lex = mSL_K_Aff_Plus | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '+=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "+"
                lex = mSL_tyDadd ;
                cod = '+';
                state = 0; // & keep char
            );
        ) :

        (state === 17) ? (
            // found a '-'
            (ch === '=') ? (
                // we got a "-="
                lex = mSL_K_Aff_Minus | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '-=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "-"
                lex = mSL_tyDMinus ;
                cod = '-';
                state = 0; // & keep char
            );
        ) :

        (state === 18) ? (
            // found a '%'
            (ch === '=') ? (
                // we got a "%="
                lex = mSL_K_Aff_Mod | mSL_tyNeedLAddr | mSL_tyOP | mSL_prty14 ;
                cod = '%=';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // just a "%"
                lex = mSL_K_fRes | mSL_tyOP | mSL_prty4 ;
                cod = '%';
                state = 0; // & keep char
            );
        ) :

        (state === 19) ? (
            // found a "'"
            (ch === 0x27) ? (
                // closing quote
                state = 0;
            ) : (
                cod = cod * 256 + ch;
            );
            mSL_C_chcurr = 0;
        ) :

        (state === 20) ? (
            // found a "0" - is there a "x" or "b" behind ?
            ((ch === 'x') || (ch === 'X')) ? (
                // starting an hexadecimal
                state = 21; mSL_C_chcurr = 0;
            ) :
            ((ch === 'b') || (ch === 'B')) ? (
                // starting a binary
                state = 22; mSL_C_chcurr = 0;
            ) :
            ((ch >= '0') && (ch <= '9')) ? (
                cod = ch - '0'; state = 3; mSL_C_chcurr = 0;
            ) :
            (ch === '.') ? (
                // go decimal
                fac = 1; state = 4; mSL_C_chcurr = 0;
            ) :
            ((ch === 'e') || (ch === 'E')) ? (
                // go exponential
                fac = 1; state = 27; expn = 0; exps = 1; mSL_C_chcurr = 0;
            ) : (
                // done decoding
                state = 0;
            );
        ) :

        (state === 21) ? (
            ((ch >= '0') && (ch <= '9')) ? (
                cod = (cod * 16) + ch - '0'; mSL_C_chcurr = 0;
            ) :
            ((ch >= 'A') && (ch <= 'F')) ? (
                cod = (cod * 16) + ch - 'A' + 10; mSL_C_chcurr = 0;
            ) :
            ((ch >= 'a') && (ch <= 'f')) ? (
                cod = (cod  * 16) + ch - 'a' + 10; mSL_C_chcurr = 0;
            ) : (
                // done decoding
                state = 0;
            );
        ) :

        (state === 22) ? (
            ((ch >= '0') && (ch <= '1')) ? (
                cod = (cod * 2) + ch - '0'; mSL_C_chcurr = 0;
            ) : (
                // done decoding
                state = 0;
            );
        ) :

        (state === 23) ? (
            // Inside a string (coded as UTF8)
            ((ch === 0x22) || (ch === 0xA) || (ch === 0xD)) ? (
                // These close the string
                mSL_wSt1[i] = 0;  // close this string
                cod = mSL_mk_string(-1, mSL_wSt1); // returns an actual JSFX string reference
                AA_StrRef = cod;
                // done decoding
                state = 0; mSL_C_chcurr = 0;
            ) :
            (ch === 0x5C) ? (
                // The back-slash escapes something
                state = 24; mSL_C_chcurr = 0;
            ) : (
                // Enter the char in the string
                (i < mSL_CMaxStrSiz) ? (mSL_wSt1[i] = ch; i += 1; );
                mSL_C_chcurr = 0;
            );
        ) :

        (state === 24) ? (
            // a backslash is found in the string
            (ch === 'n') ? ch = 0xA :
            (ch === 'r') ? ch = 0xD :
            (ch === 't') ? ch = 0x9 :
            (ch === 'b') ? ch = 0x8 ;
            // enter ch in the string
            (i < mSL_CMaxStrSiz) ? (mSL_wSt1[i] = ch; i += 1; );
            state = 23; mSL_C_chcurr = 0;
        ) :

        (state === 25) ? (
            // Found an "==" ; is this an "===" ?
            (ch === '=') ? (
                // we got a "==="
                lex = mSL_K_TrEq | mSL_tyOP | mSL_prty8 ;
                cod = '===';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // "just" an "=="
                lex = mSL_K_Eq | mSL_tyOP | mSL_prty8 ;
                cod = '==';
                state = 0; // & keep char
            );
        ) :

        (state === 26) ? (
            // Found an "!=" ; is this an "!==" ?
            (ch === '=') ? (
                // we got a "!=="
                lex = mSL_K_TrNotEq | mSL_tyOP | mSL_prty8 ;
                cod = '!==';
                state = 0; mSL_C_chcurr = 0;
            ) : (
                // "just" an "!="
                lex = mSL_K_NotEq | mSL_tyOP | mSL_prty8 ;
                cod = '!=';
                state = 0; // & keep char
            );
        ) :

        (state === 27) ? (
            // found an "e/E" after a number - look for exponent
            (ch === '-') ? (
                mSL_C_chcurr = 0; exps = -1;
            ) :
            (ch === '+') ? (
                mSL_C_chcurr = 0;
            );
            state = 28;
        ) :

        (state === 28) ? (
            // expect an integer dec. number
            ((ch >= '0') && (ch <= '9')) ? (
                expn = ch - '0'; state = 29; mSL_C_chcurr = 0;
            ) : (
                // no number is following the "e"
                state = 99;
            );
        ) :

        (state === 29) ? (
            // expect an integer dec. number
            ((ch >= '0') && (ch <= '9')) ? (
                expn = expn * 10 + ch - '0'; mSL_C_chcurr = 0;
            ) : (
                // no number is following the expression
                (exps < 0) ? (
                    while (expn >= 10) ? (
                        cod = cod / 10000000000; expn -= 10;
                    );
                    loop (expn, cod = cod / 10; );
                ) : (
                    while (expn >= 10) ? (
                        cod = cod * 10000000000; expn -= 10;
                    );
                    loop (expn, cod = cod * 10; );
                );
                state = 0; // done decoding
            );
        ) :

        (state === 30) ? (
            (ch === 96) ? (  // backquote
                // allow 2 [or more] consecutive backquotes, for syntactic reasons
                mSL_C_chcurr = 0; // suppress it, stay in 30
            ) :
            // is the ` followed by a "(" ?
            (ch === '(') ? (
                // change the "`" to a "data" construct
                i = mSL_checkGId(cod = mSL_ckwData); // the entry
                lex = mSL_GCTyp[i];
                state = 0; // done
            ) : (
                state = 2;
            );
        ) :


        (
            // Unclassified /state
            cod = state;
            state = 0;
            lex = 0; // error
            mSL_errC = 2302;
        );
    );
    mSL_lcod = cod;
    lex;
);



//    Set a compiler for compiling some code

function mSL_set_compiler(cpl)
(
    (cpl != mSL_current_compiler) ? (
        ((cpl === 0) || (cpl[-2] != mSL_CPWA_cpl)) ? (
            mSL_errX = 1983; // invalid compiler
        ) : (
            mSL_current_compiler = cpl;
            // define other globals...
        );
    );
);



//    This create once for all the compiler structures
//    Some remanent arrays are initialized once
//    Other arrays are just "allocated" and will be
//    cleared at any new compilation

function mSL_make_compiler(mem, size)
(
    mSL_new_compiler = mSL_errC = 0;
    mSL_C_fH = -1;
    size = 0|size;
    (size < mSL_minCpSize) ? (
        mSL_errC = 1001; mSL_errPos = 0;
    );

    (mSL_errC === 0) ? (
        mSL_new_compiler = mem + 2;
        mSL_memCpStart = mem + 2;
        mem[0] = mSL_CPWA_cpl; // as "ComPiler Work Area"
        mem[size-2] = mem[1] = mSL_maxCpAddr = size-4;
        mem[size-1] = (mSL_CC_Chksum ~ mem[0]);
        // Build, once for all, all the structures used by the compiler
        // Clean the structure in "cleanStructures"
        memset(mSL_memCpStart, 0, mSL_maxCpAddr);
        mSL_a_cpmem = mSL_memCpStart; // the allocator

        // We expect to have a memory available

        // Define main hash table
        mSL_CGlobalsN = mSL_a_cpmem;
        mSL_a_cpmem += mSL_CGlobSiz; // globals variables
        mSL_CGlobalsL = mSL_CGlobalsN + 1;
        mSL_CGlobalsV = mSL_CGlobalsN + 2;
        mSL_CGlobalsT = mSL_CGlobalsN + 3;

        // Define a temporary work area for flattening a tree
        mSL_Flat_List = mSL_a_cpmem;
        mSL_a_cpmem += mSL_Flat_Siz;

       // Do we already have an array of constants ?
        ((mSL_current_constants != 0) && (mSL_current_constants[-2] === mSL_KODE_constants)) ? (
            // we will use this array
            mSL_CstsSize = mSL_current_constants[-1];
        ) : (
            // otherwise, allocate an array
            mSL_current_constants = 0;
            mSL_make_constants_array(mSL_a_cpmem, (u = min(512, max(64, mSL_CstsSize + 4))));
            mSL_a_cpmem += u;
        );
        // Define, once for all, the names and arities of the op codes
        mSL_op_codes = mSL_a_cpmem; mSL_a_cpmem += 256; // 256 words for the opcodes
        // mSL_op_arities = mSL_a_cpmem; mSL_a_cpmem += 256; // 256 words for the oparities
        // Here is the start of the area that will be cleaned...
        mSL_memCleanStart = mSL_a_cpmem;
        mSL_memCleanSize = mSL_maxCpAddr + mSL_memCpStart - mSL_memCleanStart;
        mSL_fileNames = mSL_a_cpmem; mSL_a_cpmem += 16; // an array of 16 imbricated file names
        mSL_wa1 = mSL_a_cpmem; mSL_a_cpmem += 16; // 16 words work area
        mSL_wa2 = mSL_a_cpmem; mSL_a_cpmem += 16; // 16 words work area
        mSL_wSt1 = mSL_a_cpmem; mSL_a_cpmem += mSL_CMaxStrSiz + 4; // string work area
        mSL_CplStack = mSL_a_cpmem; mSL_a_cpmem += mSL_CpStSiz; // array for the compiler's stack
        mSL_CMarkA = mSL_a_cpmem; mSL_a_cpmem += mSL_CMarkSiz; // mark locations in the Kod
        mSL_F2CList = mSL_a_cpmem; mSL_a_cpmem += mSL_F2CSize; // list of functions to compile
        mSL_F2CCode = mSL_a_cpmem; mSL_a_cpmem += mSL_F2CSize; // codes of functions to compile
        mSL_F2CPt = 0;
        (mSL_GCTab === 0) ? (
            // Choose a prime number for the symbol table
            u = mSL_maxCpAddr / 37;
            mSL_GCSiz =
                (u < 600) ? 587 :
                (u < 700) ? 683 :
                (u < 800) ? 787 :
                (u < 900) ? 887 :
                (u < 1000) ? 997 :
                (u < 1200) ? 1193 :
                (u < 1600) ? 1597 :
                (u < 2000) ? 1999 : 2477;
            // The symbol table -- one entry is 4 words
            mSL_GCTab = mSL_a_cpmem + 1; // first free memory - reserve entry "-1"
            mSL_GCCod = mSL_GCTab + mSL_GCSiz + 1;
            mSL_GCTyp = mSL_GCCod + mSL_GCSiz + 1;
            mSL_GCVal = mSL_GCTyp + mSL_GCSiz + 1;
            mSL_a_cpmem = mSL_GCVal + mSL_GCSiz + 1;  // new free memory
            mSL_GCTabSize = mSL_a_cpmem - mSL_GCTab + 1; // actual memory used
        );

        // construct a "local" symbol table
        (mSL_LCTab === 0) ? (
            mSL_LCSiz = 191; // a fixed size and a prime number
            mSL_LCTab = mSL_a_cpmem + 1; // first free memory - reserve entry "-1"
            mSL_LCCod = mSL_LCTab + mSL_LCSiz + 1;
            mSL_LCTyp = mSL_LCCod + mSL_LCSiz + 1;
            mSL_a_cpmem = mSL_LCTyp + mSL_LCSiz + 1;  // new free memory
            mSL_LCTabSize = mSL_a_cpmem - mSL_LCTab + 1; // actual memory used
        );
        // The chain-list data structure -- one "cell" is 5 words
        // We will use about 98% of the rest of the memory for the cells
        u = 0|(0.98 * (mSL_maxCpAddr - mSL_a_cpmem + mSL_memCpStart) / 5 - 1); // avail
        (u < mSL_intCSiz) ? (mSL_errC = 1003) ;
        mSL_intCSiz = u; // use this anyway

        mSL_lastStatic = mSL_a_cpmem;
        // what is left free
        mSL_Cfree = mSL_memCpStart - mSL_a_cpmem + mSL_maxCpAddr;

        mSL_define_opnames(mSL_op_codes, 256);
        // mSL_define_oparities(mSL_op_arities, 256);
        mSL_define_primitives();
    );

    mSL_checkCLimits();
    mSL_current_compiler === 0 ?
        mSL_current_compiler = mSL_new_compiler;
    mSL_new_compiler;
);



//    Change primitive operations to data
//    when not used as operators

function mSL_mod_primitives(theExp)
local (ptr, ty, nxt)
(
    ptr = theExp;
    while ((ptr > 0) && (mSL_errC === 0))  (
        ty = mSL_tyun[ptr]; nxt = mSL_rptr[ptr];
        (ty === mSL_tyPrimF) ? (
            // Check that the next unit is a '(' (not a ')')...
            ((nxt > 0) && (mSL_tyun[nxt] != mSL_tyLPar)) ? (
                // change the type and the value
                mSL_tyun[ptr] = mSL_tyNum;
                // replace the name by the code, masked
                mSL_valu[ptr] = mSL_Prim_Low + mSL_GCVal[mSL_findGId(mSL_valu[ptr])];
            );
        );
        ptr = nxt;
    );
);



function
mSL_reduceBrackets(theExp)
local (flg, ty, PBExp, lex, ty, xp, xty, r, x, y, z, opt, prev, xprev, xnext, idt, newc)
(
    AA_step = 1; //TRACE
    flg = 1;
    while (flg && (mSL_errC === 0))  (
        flg = (PBExp = mSL_findBrackets(theExp)) > 0;
        (flg && (mSL_errC === 0)) ? (
            //AA_step = max(AA_step, 2); //TRACE
            ty = mSL_tyun[PBExp];


            // A bracket expression -- change it to a "classical" indexing funct. call
            (ty === mSL_tyBrkExp) ? (
                // first, reduce it
                //AA_step = max(AA_step, 3); //TRACE
                mSL_doRules((xp = mSL_valu[PBExp]), 1);
                // We expect now a single value inside a HEAD - TAIL
                ((r = mSL_checkSingle(xp)) > 0) ? (
                    //AA_step = max(AA_step, 4); //TRACE
                    // r is this value
                    xprev = mSL_lptr[r]; xnext = mSL_rptr[r]; // HEAD - TAIL positions
                    // Combine with left operand, id. expected
                    idt = mSL_lptr[PBExp];
                    AA_idt = idt; //TRACE
                    (mSL_tyun[idt] === mSL_tyIdent) ? (
                        //AA_step = max(AA_step, 5); //TRACE
                        // create a new node for the indexation
                        newc = mSL_getChEnt();
                        (mSL_errC === 0) ? (
                            // Set the position of the call to the identifier's
                            mSL_upos[newc] = mSL_upos[idt];
                            mSL_tyun[newc] = mSL_tyBrkInd; mSL_valu[newc] = mSL_prBrkInd;
                            prev = mSL_lptr[idt]; // before the identifier
                            // the left operand is the identifier
                            mSL_lptr[newc] = idt; mSL_rptr[idt] = newc; mSL_lptr[idt] = mSL_nullPtr;
                            // the right operand is the value exp
                            mSL_rptr[newc] = r; mSL_lptr[r] = newc; mSL_rptr[r] = mSL_nullPtr;
                            // Change the PBExp node to a Sub exp one
                            mSL_tyun[PBExp] = mSL_tySubExp; mSL_valu[PBExp] = newc;
                            // This points before the identifier
                            mSL_lptr[PBExp] = prev; mSL_rptr[prev] = PBExp;
                            // PBExp already point correctly to the rest of the expression
                            // we can free xprev and xnext
                            mSL_freeChEnt(xprev); mSL_freeChEnt(xnext);
                        );
                    ) :
                    ((mSL_tyun[idt] === mSL_tyKeywrd) && (mSL_valu[idt] === mSL_ckwGmem)) ? (
                        // This is a "gmem[exp]" construct
                        // Change HEAD to a g[] construct
                        mSL_valu[xprev] = mSL_tyun[xprev] = mSL_tyMgmem;
                        // Free TAIL
                        mSL_rptr[r] = mSL_nullPtr; mSL_freeChEnt(xnext);
                        // Change the type of the brackets
                        mSL_tyun[PBExp] = mSL_tySubExp; mSL_valu[PBExp] = xprev;
                        // Chain to the previous and free "gmem"
                        x = mSL_lptr[idt]; mSL_rptr[x] = PBExp; mSL_lptr[PBExp] = x; mSL_freeChEnt(idt);
                        // mSL_errC = 2334; mSL_errPos = mSL_upos[PBExp];
                    ) : (
                        // we have an error : ident expected before an indexation
                        mSL_errC = 2333; mSL_errPos = mSL_upos[PBExp];
                    );
                ) : (
                    mSL_errC = 2332; mSL_errPos = mSL_upos[PBExp]; // syntax error in bracket
                );
            ) :


            // A parenthesed expression -- change it to a function call, a special form or a simple expression
            (ty === mSL_tyParExp) ? (
                next = mSL_rptr[PBExp];
                AA_nxtnext = next; AA_nxtty = mSL_tyun[next]; //TRACE
                mSL_doRules((xp = mSL_valu[PBExp]), 1);
                // Do we have an identifier, keyword or a special construct at the left ?
                idt = mSL_lptr[PBExp]; xty = mSL_tyun[idt]; x = mSL_valu[idt];  AAA_lastxty = xty;
                z = ((xty === mSL_tyKeywrd) && (x === mSL_ckwData)); // allow special syntax, missing "," etc.
                // AAAAA_T_xty = xty; AAAAA_T_x = x; AAAAA_T_z = z;
                r = mSL_checkCList(xp, z); // get the length of the list
                AAA_lastXP = xp; AAA_lastXPlg = r; AAA_lastXPty = mSL_tyun[xp]; AAA_lastXPval = mSL_valu[xp];
                // mSL_errC = 22222; r = 333; xty = 0;
                ((xty === mSL_tyIdent) || (xty === mSL_tyKeywrd) || (xty === mSL_tyPrimF) ||
                    ((xty === mSL_tySubExp) && ((x = mSL_valu[idt]) > 0) && (mSL_tyun[x] === mSL_tyFSpcF)
                        && ((xty = mSL_tyFSpcF))))? (
                    // This is bound to be a function call or a special form
                    (r >= 0) ? (
                        // create the call
                        (xty === mSL_tyFSpcF) ? (
                            // we are not far from a correct structure
                            // "x" is a special construct ; is this a "while" ?
                            y = mSL_lptr[x];
                            ((y > 0) && (mSL_tyun[y] === mSL_tyKeywrd) && (mSL_valu[y] === mSL_ckwWhile)) ? (
                                // found a while
                                AA_isAWhile = 1; //TRACE
                                y = mSL_rptr[x];
                                ((y <= 0) || (mSL_rptr[y] != mSL_nullPtr)) ? (
                                    // while syntax error
                                    mSL_errC = 2336; mSL_errPos = mSL_upos[PBExp]; // syntax error
                                ) : (
                                    // chain here the contents of parentheses
                                    z = mSL_unHEAD(xp, 0); // get the list without HEAD - TAIL
                                    mSL_rptr[y] = z; mSL_lptr[z] = y;
                                    mSL_rptr[idt] = next; mSL_lptr[next] = idt;  // unlink PBExp
                                    // we don't need the PBExp cell anymore
                                    mSL_freeChEnt(PBExp);
                                );
                            ) : (
                                // consider the parentheses as a simple parent. expression
                                z = mSL_unHEAD(xp, 0); // get the list without HEAD - TAIL
                                (r === 1) ? (
                                    // Move object in situ, then free source
                                    mSL_mvCell(PBExp, z);
                                ) : (
                                    // error
                                    AAAAA_r = r; AAAAA_z = z;
                                    mSL_errC = 2331; mSL_errPos = mSL_upos[PBExp];
                                );
                            );
                        ) : (
                            // a simple call or a keyword followed by parentheses
                            // create a new node for the call
                            newc = mSL_getChEnt();
                            (mSL_errC === 0) ? (
                                // Set the position of the call to the identifier's
                                mSL_upos[newc] = mSL_upos[idt];
                                prev = mSL_lptr[idt]; // before the identifier
                                // the left operand is the identifier
                                mSL_lptr[newc] = idt; mSL_rptr[idt] = newc; mSL_lptr[idt] = mSL_nullPtr;
                                // Change the PBExp node to a Sub exp one
                                mSL_tyun[PBExp] = mSL_tySubExp; mSL_valu[PBExp] = newc;
                                // This points before the identifier
                                mSL_lptr[PBExp] = prev; mSL_rptr[prev] = PBExp;
                                opt = 0;
                                (xty === mSL_tyIdent) ? (
                                    // This is a "standard" function call
                                    mSL_tyun[newc] = mSL_tyFCall; mSL_valu[newc] = mSL_prFCall;
                                    opt = 1; // keep the size as start of list
                                ) :
                                (xty === mSL_tyPrimF) ? (
                                    // This is a "primitive" function call
                                    mSL_tyun[newc] = mSL_tyFCall; mSL_valu[newc] = mSL_prFCall;
                                    opt = 1; // keep the size as start of list
                                ) :
                                (xty === mSL_tyKeywrd) ? (
                                    // This is a "special form"
                                    mSL_tyun[newc] = mSL_tyFSpcF; mSL_valu[newc] = mSL_prSpcF;
                                    opt = 0; // do not need the size of the list
                                );
                                // the right operand is the list
                                z = mSL_unHEAD(xp, opt); // get the list without HEAD - TAIL
                                mSL_rptr[newc] = z; mSL_lptr[z] = newc;
                            );
                        );
                    ) : (
                        AA_E1 = r; //TRACE
                        AA_E2 = xp; //TRACE
                        mSL_errC = 2335; mSL_errPos = mSL_upos[PBExp]; // syntax error in funct. call
                    );
                ) : (
                    // This is a parenthesed expression
                    // r should be 1
                    (r === 1) ? (
                        // OK
                        z = mSL_unHEAD(xp, 0); // get the list without HEAD - TAIL
                        // Move object in situ, then free source
                        mSL_mvCell(PBExp, z);
                    ) :
                    (r === -1) ? (
                        z = mSL_unHEAD(xp, 0); // get the list without HEAD - TAIL
                        // mSL_mvCell(PBExp, z);
                        mSL_tyun[PBExp] = mSL_tyNum;
                        mSL_valu[PBExp] = mSL_tyun[z];
                        mSL_upos[PBExp] = mSL_upos[z];
                        (mSL_CP_Flags & 16) ? (
                            sprintf(#sfc, "Unpar %d/%d %s", r, PBExp, mSL_type_Name(mSL_tyun[PBExp]));
                            mSL_log(SysLogBox, #sfc);
                        );
                    ) : (
                        AAAAA_r = r; AAAAA_z = xp;
                        mSL_errC = 2338; mSL_errPos = mSL_upos[PBExp]; // syntax error in parenthesis exp.
                    );
                );
            ) :

            // Otherwise an error
            (
                mSL_errC = 2341; // unknown unit
                mSL_errPos = mSL_upos[PBExp];
            );
        );
    );

);


// Set a word in the code area
function mSL_setCode(addr, code)
local (bl, bp, ad)
(
    bp = addr & mSL_Code_IMask; // index in the block
    bl = addr >> mSL_Code_IShift; // block number
    ((ad = mSL_CG_MainGen[bl]) === 0) ? (
        // allocate a new bloc
        mSL_CG_MainGen[bl] = ad = mSL_Dyn_Alloc(mSL_Code_ISize, 'ctxn', mSL_StM_FlClear);
        (ad === 0) ? (
            mSL_errC = 1272;
            mSL_malloc_failed |= 1;
        ) : (
            ad[bp] = code;
        );
    ) : (
        ad[bp] = code;
    );
);

// Read a word in the code area
function mSL_getCode(addr)
local (bl, bp, ad)
(
    bp = addr & mSL_Code_IMask; // index in the block
    bl = addr >> mSL_Code_IShift; // block number
    ((ad = mSL_CG_MainGen[bl]) === 0) ? (
        AAAAA_getCodeAddr = addr;
        0;
    ) : (
        ad[bp];
    );
);



// Add a codeop without parameter
function mSL_addCode1(code)
(
    //xxtrace(code, mSL_pCCode);
    mSL_PrK = mSL_CuK; mSL_CuK = code;
    mSL_PrPos = mSL_CuPos; mSL_CuPos = mSL_pCCode;
    mSL_setCode(mSL_pCCode, code);
    mSL_pCCode += 1;
    AA_p1CCode = mSL_pCCode; //TRACE
);


// Add a codeop with one parameter
function mSL_addCode2(code, par)
(
    //xxtrace(code, mSL_pCCode);
    mSL_PrK = mSL_CuK; mSL_CuK = code;
    mSL_PrPos = mSL_CuPos; mSL_CuPos = mSL_pCCode;
    mSL_setCode(mSL_pCCode, code);
    mSL_pCCode += 1;
    mSL_setCode(mSL_pCCode, par);
    mSL_pCCode += 1;
    AA_p2CCode = mSL_pCCode; //TRACE
    //(code === 124) ? (mSL_errC = 9124;);
);


// Push a token in the stack
function mSL_pushToken(tk)
(
    (tk > 0) ? (
        mSL_CplStack[mSL_pCStack] = tk; mSL_pCStack += 1;
        mSL_CplStack[mSL_pCStack] = mSL_upos[tk]; mSL_pCStack += 1;
        mSL_CplStack[mSL_pCStack] = mSL_valu[tk]; mSL_pCStack += 1;
        mSL_CplStack[mSL_pCStack] = mSL_tyun[tk]; mSL_pCStack += 1;
    );
);


// Push a pseudo token in the stack
function mSL_pushPseudo(ty, valu, pos)
(
    mSL_CplStack[mSL_pCStack] = 0; mSL_pCStack += 1;
    mSL_CplStack[mSL_pCStack] = pos; mSL_pCStack += 1;
    mSL_CplStack[mSL_pCStack] = valu; mSL_pCStack += 1;
    mSL_CplStack[mSL_pCStack] = ty; mSL_pCStack += 1;
);






// Code generation
function
mSL_codGen(start, ndgen)
local (ptr, nxp, flg, ty, valu, upos, q, qty, argc, ent, prev, pty, next, nnext, pos, r, rty, s, c, v, mkr, mkr2)
(
    // Allocate an array for the pointers to codes...
    (mSL_errC === 0) ? (
        (mSL_CG_MainGen === 0) ? (
            // mSL_CG_MainGen = mSL_malloc(mSL_Code_MainSize, 'ctab');
            mSL_CG_MainGen = mSL_Dyn_Alloc(mSL_Code_MainSize, 'ctab', mSL_StM_FlClear);
            (mSL_CG_MainGen === 0) ? (
                mSL_errC = 1271;
                mSL_malloc_failed |= 1;
            );
            mSL_GC_BProtect(mSL_CG_MainGen, mSL_GC_Protected);
        );
    );
    (mSL_errC === 0) ? (
        AA_CGen = 1; //TRACE
        mSL_pCStack = 0;
        mSL_pCCode = 0;

        AA_C_start = nxp = start;

        flg = 1;
        while (flg && (mSL_errC === 0)) (

            // get a unit
            (mSL_pCStack > 0) ? (
                mSL_pCStack -= 1; ty = mSL_CplStack[mSL_pCStack];
                mSL_pCStack -= 1; valu = mSL_CplStack[mSL_pCStack];
                mSL_pCStack -= 1; upos = mSL_CplStack[mSL_pCStack];
                mSL_pCStack -= 1; ptr = mSL_CplStack[mSL_pCStack];
            ) :
            (nxp > 0) ? (
                // use current token
                ptr = nxp; nxp = mSL_rptr[ptr];
                ty = mSL_tyun[ptr];
                valu = mSL_valu[ptr];
                upos = mSL_upos[ptr];
            ) : (
                flg = 0;
                ptr = -1;
            );

            mSL_errPos = upos;
            AA_C_Unit = ptr;   //TRACE
            AA_C_ty = ty;      //TRACE
            AA_C_value = valu; //TRACE

            AA_C_ty_5 = AA_C_ty_4;
            AA_C_ty_4 = AA_C_ty_3;
            AA_C_ty_3 = AA_C_ty_2;
            AA_C_ty_2 = AA_C_ty_1;
            AA_C_ty_1 = AA_C_ty;


            flg ? (


                // A number
                (ty === mSL_tyNum) ? (
                    ((valu === (0|valu)) && (valu > -2097152) && (valu < 2097152)) ? (
                        (valu < 0) ? (
                            mSL_addCode1(mSL_K_pushNShort + ((- valu) * mSL_X_OpShDiv));
                        ) : (
                            mSL_addCode1(mSL_K_pushShort + (valu * mSL_X_OpShDiv));
                        );
                    ) : (
                        // generate a "push long" as 2 words
                        mSL_addCode2(mSL_K_pushNum, valu);
                    );
                    AA_CGen |= 4;
                ) :


                // An identifier
                (ty === mSL_tyIdent) ? (
                    // generate a "push ident"
                    (((ent = mSL_checkLId(valu)) >= 0) && ((v = mSL_LCCod[ent]) > 0)) ? (
                        mSL_addCode1(mSL_K_ldLVar + (v * mSL_X_OpShDiv));
                    ) :
                    (((ent = mSL_checkGId(valu)) >= 0) && ((v = mSL_GCCod[ent]) > 0)) ? (
                        ((v & mSL_FlgMask) === 0) ? (
                            mSL_addCode1(mSL_K_ldGVar + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        ((v & mSL_FlgMask) === mSL_OwnFlg) ? (
                            mSL_addCode1(mSL_K_ldOVar + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        ((v & mSL_FlgMask) === mSL_PtrFlg) ? (
                            mSL_addCode1(mSL_K_ldPVar + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        (
                            mSL_errC = 3416; // undeclared identifier
                        );
                    ) :
                    (
                        mSL_errC = 3418; // undeclared identifier
                        sprintf(#dbg_trace2, "Error %d -  Line %d/%d", mSL_errC, mSL_errPos >> 16, mSL_errPos & 0xFFFF);
                    );
                    AA_CGen |= 8;
                ) :

                // An address
                (ty === mSL_tyIdAddr) ? (
                    // generate a "push ident"
                    (((ent = mSL_checkLId(valu)) >= 0) && ((v = mSL_LCCod[ent]) > 0)) ? (
                        mSL_addCode1(mSL_K_ldLAddr + (v * mSL_X_OpShDiv));
                    ) :
                    (((ent = mSL_checkGId(valu)) >= 0) && ((v = mSL_GCCod[ent]) > 0)) ? (
                        ((v & mSL_FlgMask) === 0) ? (
                            mSL_addCode1(mSL_K_ldGAddr + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        ((v & mSL_FlgMask) === mSL_OwnFlg) ? (
                            mSL_addCode1(mSL_K_ldOAddr + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        ((v & mSL_FlgMask) === mSL_PtrFlg) ? (
                            mSL_addCode1(mSL_K_ldPAddr + ((v & 0xffff) * mSL_X_OpShDiv));
                        ) :
                        (
                            mSL_errC = 3417; // undeclared identifier
                        );
                    ) :
                    (
                        mSL_errC = 3419; // undeclared identifier
                        sprintf(#dbg_trace2, "Error %d -  Line %d/%d", mSL_errC, mSL_errPos >> 16, mSL_errPos & 0xFFFF);
                    );
                    AA_CGen |= 8;
                ) :


                // A sub expression
                (ty === mSL_tySubExp) ? (
                    q = valu;
                    // q est une expression
                    (q > 0) ? (
                        qty = mSL_tyun[q];
                    ) : (
                        qty = 0;
                    );
                    (qty & mSL_tyOP) ? (
                        prev = mSL_lptr[q];
                        next = mSL_rptr[q];
                        (prev === mSL_nullPtr) ? (
                            (qty & mSL_tyOPMon) ? (
                                pty = mSL_tyun[next]; v = 0;
                                (qty === mSL_tyMNot) ? (
                                    v = mSL_K_fNot; // ! exp [not]
                                ) :
                                (qty === mSL_tyMNeg) ? (
                                    // is "next" a constant ?
                                    (pty === mSL_tyNum) ? (
                                        mSL_pushPseudo(mSL_tyNum,  - mSL_valu[next], mSL_upos[next]);
                                    ) : (
                                        v = mSL_K_fNeg; // - exp
                                    );
                                ) :
                                (qty === mSL_tyMIdt) ? (
                                    // Consider this as a "do nothing" function
                                    mSL_pushToken(next);
                                ) :
                                (qty === mSL_tyMInt) ? (
                                    v = mSL_K_pInt; // | exp [int]
                                ) :
                                (qty === mSL_tyMBNot) ? (
                                    // is "next" a constant ?
                                    (pty === mSL_tyNum) ? (
                                        mSL_pushPseudo(mSL_tyNum,  - mSL_valu[next] - 1, mSL_upos[next]);
                                    ) : (
                                        v = mSL_K_pBNot; // ~ exp [bit not]
                                    );
                                ) :
                                (qty === mSL_tyMgmem) ? (
                                    v = mSL_K_pgmem; // gmem[exp]
                                ) :
                                (
                                    AAAAA_3403 = qty;
                                    mSL_errC = 3403;
                                );
                                (v > 0) ? (
                                    // opr. monadique
                                    // push the opr
                                    mSL_pushPseudo(mSL_tyOP | v, 0, mSL_upos[q]);
                                    // push the operand
                                    mSL_pushToken(next);
                                );
                            ) : (
                                mSL_errC = 3402;
                            );
                        ) : (
                            (qty === mSL_tySemiCol) ? (
                                // A ";" as statement separator
                                // push right
                                mSL_pushToken(next);
                                mSL_pushPseudo(mSL_ActionSC, 0, mSL_upos[q]);
                                // push left
                                mSL_pushToken(prev);
                            ) :

                            ((qty & mSL_maskSet) === mSL_tySet) ? (
                                pty = mSL_tyun[prev]; AAAA_pty = pty;
                                ((pty === mSL_tySubExp) && ((r = mSL_valu[prev]) > 0) && (mSL_tyun[r] === mSL_tyMgmem)) ? (
                                    // a gmem[x] = y construct -- change to a simpler form
                                    mSL_pushPseudo(mSL_ActionGmem2, 0, mSL_upos[q]);
                                    // push gmem destination
                                    mSL_pushToken(mSL_rptr[r]);
                                    // value
                                    mSL_pushToken(next);
                                ) : (
                                    // A "=" as affectation simple
                                    mSL_pushPseudo(mSL_ActionAff, (qty & 0xff), mSL_upos[q]);
                                    // push left
                                    mSL_pushToken(prev);
                                    // push right
                                    mSL_pushToken(next);
                                );
                            ) :

                            (qty === mSL_tyFSpcF) ? (
                                // a special form
                                ((mSL_tyun[prev] === mSL_tyKeywrd) && (mSL_valu[prev] === mSL_ckwWhile)) ? (
                                    ((nnext = mSL_rptr[next]) > 0) ? (
                                        // a while (cond) (exec) construct
                                        mSL_pushPseudo(mSL_ActionWhil2, mSL_pCCode, 0); // jmp forward
                                        // mSL_pushPseudo(mSL_ActionSC, 0, mSL_upos[q]); // delete TOS
                                        mSL_pushToken(nnext);
                                        mSL_pushPseudo(mSL_ActionWhil3, 0, mSL_upos[q]); // jmp back
                                        mSL_pushToken(next);
                                    ) : (
                                        // try a first type while construct
                                        mSL_pushPseudo(mSL_ActionWhil1, mSL_pCCode, mSL_upos[q]);
                                        // Generate the "right" code
                                        mSL_pushToken(next);
                                    );
                                ) :

                                ((mSL_tyun[prev] === mSL_tyKeywrd) && (mSL_valu[prev] === mSL_ckwLoop)) ? (
                                    // A loop construct
                                    ((nnext = mSL_rptr[next]) > 0) ? (
                                        // a loop (exp, sequence...)
                                        mkr = mSL_getAMarker();
                                        mkr2 = mSL_getAMarker();
                                        // Generate what is needed...
                                        mSL_pushPseudo(mSL_ActionLoop4, mkr2, mSL_upos[q]);
                                        mSL_pushPseudo(mSL_ActionLoop3, mkr, mSL_upos[q]);
                                        mSL_pushToken(nnext);  // The loop body
                                        mSL_pushPseudo(mSL_ActionLoop2, mkr2, mSL_upos[q]);
                                        mSL_pushPseudo(mSL_ActionLoop1, mkr, mSL_upos[q]);
                                        mSL_pushToken(next); // The count
                                    ) : (
                                        mSL_errC = 3411;
                                    );
                                ) :

                                ((mSL_tyun[prev] === mSL_tyKeywrd) && (mSL_valu[prev] === mSL_ckwData)) ? (
                                    // Check that we have only "constants" in the "data"
                                    // an identifier is considered as a symbol : name and `name are equivalent
                                    r = next; c = 0;
                                    while ((r > 0) && (mSL_errC === 0))  (
                                        rty = mSL_tyun[r]; c += 1;
                                        ((rty != mSL_tyNum) && (rty != mSL_tyIdent) && (rty != mSL_tyString)) ? (
                                            (mSL_CP_Flags & 16) ? (
                                                sprintf(#sfc, "Obj Found 3414 %d  %s", r, mSL_type_Name(rty));
                                                mSL_log(SysLogBox, #sfc);
                                            );
                                            bk = mSL_lptr[r];
                                            (rty === mSL_tySubExp) ? (
                                                // The object is a subexpression
                                                // Try to evaluate it
                                                mSL_flatten_tree(r);
                                            ) : (
                                                AAAAA_data_err = rty;
                                                mSL_errC = 3414; mSL_errPos = mSL_upos[r]; r = -1;
                                            );
                                            (mSL_errC === 0) ? (
                                                // relink...
                                                c -= 2;
                                                r = bk;
                                                (mSL_CP_Flags & 16) ? (
                                                    sprintf(#sfc, "Relink at  %d   %s", r, mSL_type_Name(mSL_tyun[r]));
                                                    mSL_log(SysLogBox, #sfc);
                                                );
                                            ) ;
                                        ) : (
                                            r = mSL_rptr[r];
                                        );
                                    );
                                    // we need to create a memory block with these values
                                    r = next;
                                    // s = mSL_malloc(c, mSL_MT_Data);
                                    s = mSL_Dyn_Alloc(c, mSL_MT_Data, mSL_StM_FlClear);
                                    (s === 0) ? (
                                        mSL_errC = 1276;
                                        mSL_malloc_failed |= 1;
                                    ) : (
                                        mSL_GC_BProtect(s, mSL_GC_Protected);
                                        v = 0;
                                        loop(c,
                                            s[v] = mSL_valu[r]; v += 1; r = mSL_rptr[r];
                                        );
                                        // Then push the block address as a constant
                                        mSL_addCode2(mSL_K_pushNum, s);
                                        // mSL_errC = 3412;
                                    );
                                ) :

                                (
                                    mSL_errC = 3413;
                                );
                            ) :

                            (qty === mSL_tyFCall) ? (
                                // function call
                                (mSL_tyun[prev] === mSL_tyPrimF) ? (
                                    // Look for the actual type of the object
                                    ent = mSL_GCVal[mSL_findGId(mSL_valu[prev])];
                                    AAAA_ent = ent;
                                    (ent & mSL_tyPrimFun) ? ( // primitive or predefined operation
                                        // we expect the right to be a list starting with the arg. count
                                        argc = (ent >> 12) & 0xff;
                                        ((mSL_tyun[next] === mSL_tyNum) && (argc < 0xff) & (mSL_valu[next] === argc)) ? (
                                            mSL_pushPseudo(mSL_ActionPrim, ent & 0xfff, mSL_upos[q]); // the call opcode
                                        ) :
                                        ((argc === 0xff) && (mSL_tyun[next] === mSL_tyNum)) ? (
                                            mSL_pushPseudo(mSL_ActionPrim, ent & 0xfff, mSL_upos[q]); // the call opcode
                                            mSL_pushToken(next);
                                        ) : (
                                            mSL_errC = 3556;
                                        );
                                    ) : (
                                        mSL_errC = 3555;
                                    );
                                ) : (
                                    mSL_pushPseudo(mSL_ActionCall, 0, mSL_upos[q]); // the call opcode
                                    mSL_pushToken(prev);
                                    mSL_pushToken(next);
                                );
                                r = s = mSL_rptr[next]; c = 0;
                                while (s > 0) (
                                    r = s;
                                    s = mSL_rptr[s]; c+=1;
                                );
                                while (c > 0) (
                                    mSL_pushToken(r);
                                    r = mSL_lptr[r];
                                    c -= 1;
                                );
                            ) :

                            (qty === mSL_tyFCond1) ? (
                                mkr = mSL_getAMarker();
                                mSL_pushPseudo(mSL_ActionCond1, mkr, mSL_upos[q]);
                                // push the "next" part
                                mSL_pushToken(next);
                                mSL_pushPseudo(mSL_ActionCond2, mkr, mSL_upos[q]);
                                mSL_pushToken(prev);
                            ) :

                            (qty === mSL_tyFCond2) ? (
                                mkr = mSL_getAMarker();
                                mkr2 = mSL_getAMarker();
                                nnext = mSL_rptr[next];
                                // Update "B", free mrk2
                                mSL_pushPseudo(mSL_ActionCond3, mkr2, mSL_upos[q]);
                                // Build the "else" part
                                mSL_pushToken(nnext);
                                // Update the "jump false pop" at "A", free mrk
                                mSL_pushPseudo(mSL_ActionCond4, mkr, mSL_upos[q]);
                                // add a "jump always" to "B", with mkr2
                                mSL_pushPseudo(mSL_ActionCond5, mkr2, mSL_upos[q]);
                                // Generate the "then" part
                                mSL_pushToken(next);
                                // add a "jump on false pop" at "A", keep "A"
                                mSL_pushPseudo(mSL_ActionCond6, mkr, mSL_upos[q]);
                                // Generate the test
                                mSL_pushToken(prev);
                            ) :

                            ((qty === mSL_tyBrkInd) || (qty === mSL_tyBrkIndA)) ? (
                                AAA_qty = qty;
                                // A simple indexing --
                                // push the opr
                                mSL_pushToken(q);
                                // Generate the "index" part
                                mSL_pushToken(next);
                                // The left is supposed to be an identifier
                                AAA_prevty = mSL_tyun[prev];
                                (mSL_tyun[prev] != mSL_tyIdent) ? (
                                    mSL_errC = 3404;
                                );
                                mSL_pushToken(prev);
                            ) :

                            // logical "or"
                            (qty === mSL_tyFLogOr) ? (
                                mkr = mSL_getAMarker();
                                // Generate the "then" part
                                mSL_pushPseudo(mSL_ActionOR1, mkr, mSL_upos[q]);
                                mSL_pushToken(next);
                                mSL_pushPseudo(mSL_ActionOR2, mkr, mSL_upos[q]);
                                mSL_pushToken(prev);
                                // mSL_pushPseudo(mSL_ActionSigErr1, mkr, mSL_upos[q]);
                            ) :

                            // logical "and"
                            (qty === mSL_tyFLogAnd) ? (
                                mkr = mSL_getAMarker();
                                // Generate the "then" part
                                mSL_pushPseudo(mSL_ActionAnd1, mkr, mSL_upos[q]);
                                mSL_pushToken(next);
                                mSL_pushPseudo(mSL_ActionAnd2, mkr, mSL_upos[q]);
                                mSL_pushToken(prev);
                            ) :

                            (
                                // opr. dyadique
                                // push the opr
                                mSL_pushToken(q);
                                // push right
                                mSL_pushToken(next);
                                // push left
                                mSL_pushToken(prev);
                            );
                        );
                    ) : (
                        mSL_errC = 3401;
                    );
                ) :

                // specific case for the ";" actions
                (ty === mSL_ActionSC) ? (
                    mSL_addCode1(mSL_K_Pop);
                ) :

                // specific case for the "=" actions
                (ty === mSL_ActionAff) ? (
                    (valu === 61) ? (valu = mSL_K_Set);
                    mSL_addCode1(valu);
                ) :

                // specific case for the "gmem[x]=" actions
                (ty === mSL_ActionGmem2) ? (
                    mSL_addCode1(mSL_K_pgmem2);
                ) :

                // specific case for while construct
                (ty === mSL_ActionWhil1) ? (
                    mSL_addCode2(mSL_K_jmpOnTruePT, valu);
                ) :

                // specific case for while construct
                (ty === mSL_ActionWhil2) ? (
                    mSL_addCode2(mSL_K_jmpAlwaysPop, valu);
                    mSL_setCode(upos, mSL_pCCode);
                ) :

                // specific case for while construct
                (ty === mSL_ActionWhil3) ? (
                    mSL_addCode2(mSL_K_jmpOnFalsePT, 0);
                    // Check the validity...
                    (mSL_CplStack[mSL_pCStack - 5] === mSL_ActionWhil2) ? (
                        // update the "upos"... with the addr of the value to update
                        mSL_CplStack[mSL_pCStack - 7] = mSL_pCCode -1;
                    ) : (
                        mSL_errC = 2337;
                    );
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond1) ? (
                    // we need to update the "jmpFalse" referenced at "mkr"
                    pos = mSL_CMarkA[valu]; // where to update
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond2) ? (
                    // Generate a jump
                    mSL_addCode2(mSL_K_jmpOnFalsePT, 0);
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond3) ? (
                    // Update the "jmp" at marker
                    pos = mSL_CMarkA[valu]; // where to update
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond4) ? (
                    // Update the "jmp" at marker
                    pos = mSL_CMarkA[valu]; // where to update
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond5) ? (
                    // // Generate a jump
                    mSL_addCode2(mSL_K_jmpAlways, 0);
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update
                ) :

                // specific case for cond construct
                (ty === mSL_ActionCond6) ? (
                    // Generate a jump
                    mSL_addCode2(mSL_K_jmpOnFalsePop, 0);
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update
                ) :

                // indexing
                (ty === mSL_tyBrkInd) ? (
                    mSL_addCode1(mSL_K_indexVal);
                ) :

                // logical "or" - 1
                (ty === mSL_ActionOR1) ? (
                    // Update the Jump op code
                    pos = mSL_CMarkA[valu]; // where to update
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // logical "or" - 2
                (ty === mSL_ActionOR2) ? (
                    // Generate a jump
                    // The marker entry is in "valu"
                    mSL_addCode2(mSL_K_jmpOnTruePopF, 0);
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update
                ) :

                // logical "and" - 1
                (ty === mSL_ActionAnd1) ? (
                    // Update the Jump op code
                    pos = mSL_CMarkA[valu]; // where to update
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // logical "and" - 2
                (ty === mSL_ActionAnd2) ? (
                    // Generate a jump
                    // The marker entry is in "valu"
                    mSL_addCode2(mSL_K_jmpOnFalsePT, 0);
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update
                ) :

                // loop - action 1 - decrement counter
                (ty === mSL_ActionLoop1) ? (
                    // The marker entry is in "valu"
                    mSL_CMarkA[valu] = mSL_pCCode; // 'mrk' : return from bottom of the loop
                    mSL_addCode1(mSL_K_DecrTos); // decrement and test
                ) :

                // loop - action 2 - jump
                (ty === mSL_ActionLoop2) ? (
                    // Generate a jump
                    mSL_addCode2(mSL_K_JNegEP, 0);
                    // The marker entry is in "valu"
                    mSL_CMarkA[valu] = mSL_pCCode - 1; // where to update 'mrk2'
                ) :

                // loop - action 3 - jump
                (ty === mSL_ActionLoop3) ? (
                    // The marker 'mrk' is in value
                    mSL_addCode2(mSL_K_jmpAlwaysPop, mSL_CMarkA[valu]);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ) :

                // loop - action 4 - update the jump
                (ty === mSL_ActionLoop4) ? (
                    pos = mSL_CMarkA[valu]; // where to update 'mrk2'
                    mSL_setCode(pos, mSL_pCCode);
                    // we can free the marker
                    mSL_CMarkA[valu] = -1;
                ):

                // indexing in address mode
                (ty === mSL_tyBrkIndA) ? (
                    mSL_addCode1(mSL_K_indexAdd);
                ) :

                // a function call
                (ty === mSL_ActionCall) ? (
                    mSL_addCode1(mSL_K_fCall);
                ) :

                // a primitive function call
                (ty === mSL_ActionPrim) ? (
                    mSL_addCode1(valu);
                ) :

                // Signal an error (debugging)
                (ty === mSL_ActionSigErr1) ? (
                    mSL_errC = 3334;
                ) :

                // Signal an error (debugging)
                (ty === mSL_ActionSigErr2) ? (
                    mSL_errC = 3335;
                ) :

                // An operator
                (ty & mSL_tyOP) ? (
                    mSL_addCode1(ty & 0xFF);
                ):

                // HEAD - TAIL markers
                ((ty === mSL_tyHEAD) || (ty === mSL_tyTAIL)) ? (
                    // nothing to do
                    AA_CGen |= 2;
                ) :

                (ty === mSL_tyString) ? (
                    ((valu === (0|valu)) && (valu > -2097152) && (valu < 2097152)) ? (
                        mSL_addCode1(mSL_K_pushShort + (valu * mSL_X_OpShDiv));
                    ) : (
                        mSL_addCode2(mSL_K_pushNum, valu);
                    );
                ):

                (
                    mSL_errC = 3303;  // code missing
                );
            );
        );
    );
    (mSL_errC === 0) ? (
        (ndgen === 1) ? mSL_addCode1(mSL_K_stop);
        (ndgen === 2) ? mSL_addCode1(mSL_K_return);
    );

);



// Compile & build a function
// fptr points to the "(_" structure
function
mSL_compileFun(fptr)
local (id, li, ex, wa, idx, ip, c, w, lc, s)
(
    wa = 0;
    mSL_cod = 0;
    (mSL_errC === 0) ? (
        ((fptr <= 0) || (mSL_valu[fptr] != mSL_prFdef)) ? (mSL_errC = 4401);
    );
    (mSL_errC === 0) ? (
        id = mSL_lptr[fptr];
        li = mSL_rptr[fptr];
        ((id <= 0) || (li <= 0) || (mSL_tyun[id] != mSL_tyIdent) || (mSL_tyun[li] != mSL_tyList)) ? (mSL_errC = 4402);
    );
    (mSL_errC === 0) ? (
        ex = mSL_rptr[li];
        (ex <= 0) ? (mSL_errC = 4403);
        s = mSL_tyun[ex];
        ((s != mSL_tySubExp) && (s != mSL_tyIdent) && (s != mSL_tyNum)) ? (mSL_errC = 4404);
    );
    (mSL_errC === 0) ? (
        wa = mSL_a_cpmem + 2;
        wa[mSL_CC_Key] = mSL_CC_KeyCKod;
        wa[mSL_CC_Flags_Idt] = mSL_KW_ccflags;
        wa[mSL_CC_Name_Idt] = mSL_KW_ccname;
        wa[mSL_CC_dpCode_Idt] = mSL_KW_ccode;
        wa[mSL_CC_CodSize_Idt] = mSL_KW_ccodesiz;
        wa[mSL_CC_ParCnt_Idt] = mSL_KW_ccparcnt;
        wa[mSL_CC_LocCnt_Idt] = mSL_KW_ccloccnt;
        wa[mSL_CC_GlbCnt_Idt] = mSL_KW_ccglbcnt;
        wa[mSL_CC_GlbTab_Idt] = mSL_KW_ccglbtbl;
        wa[mSL_CC_OwnTab_Idt] = mSL_KW_ccowntbl;
        wa[mSL_CC_PtrTab_Idt] = mSL_KW_ccptrtbl;
        wa[mSL_CC_last] = mSL_End_Mark;
        wa[mSL_CC_Flags] = 0;
        wa[mSL_CC_GlbTab] = 0;
        wa[mSL_CC_OwnTab] = 0;
        wa[mSL_CC_PtrTab] = 0;
        wa[mSL_CC_Name] = mSL_valu[id]; // name of the function
        w = mSL_valu[li]; // points to the arg. count/list
        c = mSL_valu[w];
        (c === -2) ? (
            c = 2;
            wa[mSL_CC_Flags] = 1;
        ) ;
        wa[mSL_CC_ParCnt] = c;
        mSL_clearLCTab(); // clear the local symbol table
        // Enter the names of the parameters
        idx = mSL_CC_1stId;
        // copy the parameters names
        loop (c,
            w = mSL_rptr[w]; wa[idx] = s = mSL_valu[w];
            mSL_enterLCode(s, 0, mSL_tyIdent);
            idx += 1;
        );
        // Enter the names of the locals
        lc = 0; w = mSL_rptr[w];
        while (w > 0) (
            wa[idx] = s = mSL_valu[w];
            mSL_enterLCode(s, 0, mSL_tyIdent);
            idx += 1; w = mSL_rptr[w]; lc += 1;
        );
        wa[mSL_CC_LocCnt] = lc;
        wa[mSL_CC_dpCode] = idx; // code position
        mSL_codGen(ex, 2); // build the code
        ip = 0;
        loop (mSL_pCCode,
            wa[idx] = mSL_getCode(ip);
            idx += 1; ip += 1;
        );
        wa[mSL_CC_CodSize] = mSL_pCCode;
        //AAAAA_lastidx = idx-1;
        // AAAAA_lastcp = wa[AAAAA_lastidx];
        // wa[idx] = 1; idx += 1;
        // wa[idx] = 0; idx += 1; // "0" as "end code error 1"
        wa[idx] = 0; idx += 1; // will get the size of the block
        wa[idx] = mSL_CC_KeyKEnd; idx += 1;
        wa[idx - 2] = wa[mSL_CC_Size] = idx - 2; // inner size
        mSL_a_cpmem += idx + 2;

        // AAAAA_lastcp2 = wa[AAAAA_lastidx];
        mSL_cod = wa;
    );
);


// Build a code segment
function
mSL_compileBlock(ec)
local (wa, ip, idx)
(
    wa = mSL_a_cpmem + 2;
    mSL_cod = 0;
    wa[mSL_CC_Key] = mSL_CC_KeyCKod;
    wa[mSL_CC_Flags_Idt] = mSL_KW_ccflags;
    wa[mSL_CC_Name_Idt] = mSL_KW_ccname;
    wa[mSL_CC_dpCode_Idt] = mSL_KW_ccode;
    wa[mSL_CC_CodSize_Idt] = mSL_KW_ccodesiz;
    wa[mSL_CC_ParCnt_Idt] = mSL_KW_ccparcnt;
    wa[mSL_CC_LocCnt_Idt] = mSL_KW_ccloccnt;
    wa[mSL_CC_GlbCnt_Idt] = mSL_KW_ccglbcnt;
    wa[mSL_CC_GlbTab_Idt] = mSL_KW_ccglbtbl;
    wa[mSL_CC_OwnTab_Idt] = mSL_KW_ccowntbl;
    wa[mSL_CC_PtrTab_Idt] = mSL_KW_ccptrtbl;
    wa[mSL_CC_last] = mSL_End_Mark;
    wa[mSL_CC_Flags] = 0;
    wa[mSL_CC_GlbTab] = 0;
    wa[mSL_CC_OwnTab] = 0;
    wa[mSL_CC_PtrTab] = 0;
    wa[mSL_CC_Name] = 0; // no code ident
    wa[mSL_CC_ParCnt] = 0; // no parameters
    wa[mSL_CC_LocCnt] = 0; // no locals
    idx = mSL_CC_1stId;
    wa[mSL_CC_dpCode] = idx; // code position
    mSL_clearLCTab(); // clear the local symbol table
    mSL_codGen(mSL_start, ec);
    ip = 0;
    loop (mSL_pCCode,
        wa[idx] = mSL_getCode(ip);
        idx += 1; ip += 1;
    );
    wa[mSL_CC_CodSize] = mSL_pCCode;
    //AAAAA_lastidx = idx-1;
    //AAAAA_lastcp = wa[AAAAA_lastidx];
    //wa[idx] = 0; idx += 1; // "0" as "end code error 1"
    wa[idx] = 0; idx += 1; // will get the size of the block
    wa[idx] = mSL_CC_KeyKEnd; idx += 1;
    wa[idx - 2] = wa[mSL_CC_Size] = idx - 2; // inner size
    mSL_a_cpmem += idx + 2;
    //AAAAA_lastcp2 = wa[AAAAA_lastidx];
    mSL_cod = wa;
);




function mSL_insert_file(fname)
local (flg, p_start, p_end, p_HEAD)
(
    strcpy(#import, #directory);
    strcat(#import, fname);
    (mSL_C_fH >= 0) ? (file_close(mSL_C_fH); mSL_C_fH = -1;);
    AAAA_fname = fname;
    p_start = mSL_start;
    p_end = mSL_end;
    p_HEAD = mSL_HEAD;
    (mSL_errC === 0) ? (
        mSL_C_fH = file_open(#import);
        ((mSL_C_fH >= 0)) ? (
            AAAA_import = 2;
            mSL_end = mSL_start = mSL_HEAD = mSL_enterHEAD();  // Create head
            flg = 1; mSL_C_chcurr = 0;
            mSL_C_cavail = 0;
            mSL_C_numLine = 0;
            mSL_posChar = 0;
            while (flg) (
                AAA_lastlex = lex = mSL_lex();
                AA_tr += 100;
                (lex > 0) ? (
                    mSL_appndU(lex, mSL_lcod, (mSL_C_numLine << 16)+mSL_posChar);
                ) : (
                    flg = 0;
                );
            );
            mSL_appndU(mSL_tyTAIL, 0, 0);
            file_close(mSL_C_fH); mSL_C_fH = -1;
            // We have read a thing
            (mSL_errC === 0) ? (
                AA_tr += 1;
                // adapt some operations to context
                mSL_mod_primitives(mSL_start);

                // Reduce parentheses and brackets
                mSL_reduceBrackets(mSL_start);

                // Apply the basic rules
                mSL_doRules(mSL_start, 0); // keep the ';'

                mSL_newStart = mSL_start;
                mSL_newEnd = mSL_end;


            );
        ) : (
            mSL_errC = 3301;
        );
    );
    mSL_start = p_start;
    mSL_end = p_end;
    mSL_HEAD = p_HEAD;
    mSL_errC;
);




// Examine level zero cell sequence, looking for keywords
// "var" and "function"
function mSL_doSpecials(start)
local (p, q, state, ty, v, vty, i, leftanchor, left, ex1, ex2, ex3, ps, fd, id, li, lp, lok, z)
(
    p = start;
    state = 1;
    leftanchor = -1;
    //AA_CC = 0; AA_CD = 0;
    while ((p > 0) && (mSL_errC === 0))  (
        ty = mSL_tyun[p]; v = mSL_valu[p];
        //AA_CC += 1;
        //AA_09c = AA_09; AA_09 = AA_08c; AA_08c = AA_08; AA_08 = state;

        (state === 1) ? (
            // we expect a "HEAD" unit
            ((ty === mSL_tyHEAD) || (ty === mSL_tySemiCol)) ? (
                leftanchor = p;
                //AA_04 = p; AA_04c = mSL_tyun[p];
                state = 2; p = mSL_rptr[p];
                //AA_05 = p; AA_05c = mSL_tyun[p];
            ) : (
                mSL_errC = 2227; mSL_errPos = mSL_upos[p];
            );
        ) :

        (state === 2) ? (
            //AA_CD += 1;
            //xxtrace(ty, v);
            // do we have a keyword/special construct ?
            // leftanchor = mSL_lptr[p];
            (ty === mSL_tyKeywrd) ? (
                ((v === mSL_ckwVar) || (v === mSL_ckwLoc) || (v === mSL_ckwPtr)) ? (
                    (v === mSL_ckwLoc) ? (vty = mSL_OwnFlg;) :
                    (v === mSL_ckwPtr) ? (vty = mSL_PtrFlg;) :
                    (vty = 0;);
                    q = p; p = mSL_rptr[p]; mSL_freeChEnt(q);
                    // chain to the anchor
                    (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                    (p > 0) ? (mSL_lptr[p] = leftanchor);
                    state = 4;
                ) :
                (v === mSL_ckwFunction) ? (
                    state = 6;
                ) :
                (v === mSL_ckwImport) ? (
                    //AA_03 = p; AA_03c = mSL_tyun[p];
                    state = 7;
                ) : (
                    mSL_errC = 2228; mSL_errPos = mSL_upos[p];
                );
            ) :
            (ty === mSL_tyTAIL) ? (
                (mSL_rptr[p] > 0) ? (
                    mSL_errC = 2229; mSL_errPos = mSL_upos[p];
                );
                p = -1;
            ) : (
                state = 3; // go look for a ";"
            );
        ) :

        // "ordinary" expression
        (state === 3) ? (
            (ty === mSL_tySemiCol) ? (
                state = 1;
            ) :
            (ty === mSL_tyTAIL) ? (
                (mSL_rptr[p] > 0) ? (
                    mSL_errC = 2226; mSL_errPos = mSL_upos[p];
                );
                p = -1;
            ) : (
                p = mSL_rptr[p];
            );
        ) :

        // "var" / "loc" construct
        (state === 4) ? (
            (ty === mSL_tySemiCol) ? (
                state = 2; p = mSL_rptr[p];
                // chain to the anchor
                (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                (p > 0) ? (mSL_lptr[p] = leftanchor);
                leftanchor = p;
            ) :
            (ty === mSL_tyTAIL) ? (
                (mSL_rptr[p] > 0) ? (
                    mSL_errC = 2230; mSL_errPos = mSL_upos[p];
                );
                // chain to the anchor
                (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                (p > 0) ? (mSL_lptr[p] = leftanchor);
                leftanchor = p = -1;
            ) :
            (ty === mSL_tyIdent) ? (
                mSL_enterGCode(v, vty, mSL_tyIdent, 0);
                // we will free the ident and possibly the separator
                q = p; p = mSL_rptr[p]; mSL_freeChEnt(q);
                // chain next item to the anchor
                (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                (p > 0) ? (mSL_lptr[p] = leftanchor);
                // leftanchor = p;
                state = 5;
            ) :
            (ty === mSL_tySubExp) ? (
                // expect a "set" operation
                ((v > 0) && ((mSL_tyun[v] & mSL_maskSet) === mSL_tySet) && ((i = mSL_lptr[v]) > 0) && (mSL_tyun[i] === mSL_tyIdAddr)) ? (
                    mSL_enterGCode(mSL_valu[i], vty, mSL_tyIdent, 0);
                    q = p; p = mSL_rptr[p];
                    // chain this item to the anchor
                    (leftanchor > 0) ? (mSL_rptr[leftanchor] = q);
                    (q > 0) ? (mSL_lptr[q] = leftanchor);
                    // The next item (a ',', or a ';') becomes the new anchor
                    leftanchor = p;
                    state = 5;
                ) : (
                    mSL_errC = 2231; mSL_errPos = mSL_upos[p];
                );
            ) : (
                mSL_errC = 2232; mSL_errPos = mSL_upos[p];
            );
        ) :

        // "var", expecting ','
        (state === 5) ? (
            (ty === mSL_tySemiCol) ? (
                q = p; p = mSL_rptr[p];
                // is this the anchor ?
                (leftanchor != q) ? (
                    // is the left item a ';' or a HEAD ?
                    left = mSL_lptr[q];
                    ((mSL_tyun[left] === mSL_tySemiCol) || (mSL_tyun[left] === mSL_tyHEAD)) ? (
                        // skip this one
                        mSL_rptr[left] = p;
                        (p > 0) ? (mSL_lptr[p] = left);
                        mSL_freeChEnt(q);
                    ) : (
                        // q becomes our new anchor
                        leftanchor = q;
                    );
                );
                state = 2;
            ) :
            (ty === mSL_tyComma) ? (
                // change to a semi-colon, cycle
                mSL_tyun[p] = mSL_tySemiCol; mSL_valu[p] = ';';
                q = p; p = mSL_rptr[p];
                // is this the anchor ?
                (leftanchor != q) ? (
                    // is the left item a ';' or a HEAD ?
                    left = mSL_lptr[q];
                    ((mSL_tyun[left] === mSL_tySemiCol) || (mSL_tyun[left] === mSL_tyHEAD)) ? (
                        // skip this one
                        mSL_rptr[left] = p;
                        (p > 0) ? (mSL_lptr[p] = left);
                        mSL_freeChEnt(q);
                    ) : (
                        // q becomes our new anchor
                        leftanchor = q;
                    );
                );
                state = 4;
            ) :
            (ty === mSL_tyTAIL) ? (
                (mSL_rptr[p] > 0) ? (
                    mSL_errC = 2233; mSL_errPos = mSL_upos[p];
                );
                (leftanchor != p) ? (
                    (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                    (p > 0) ? (mSL_lptr[p] = leftanchor);
                );
                p = -1;
            ) : (
                mSL_errC = 2234; // invalid char in a data
                mSL_errPos = mSL_upos[p];
            );
        ) :


        // "function" construct
        (state === 6) ? (
            // p points to the "function" keyword
            ex1 = mSL_rptr[p]; // this should be an "exp" construc
            // ex1 = 0;
            ((ex1 > 0) && (mSL_tyun[ex1] === mSL_tySubExp)) ? (
                fd = mSL_valu[ex1]; // this should be a "function" construct
                // link this expression to the anchor
                (leftanchor > 0) ? (mSL_rptr[leftanchor] = ex1);
                mSL_lptr[ex1] = leftanchor;
            ) : (
                mSL_errC = 2251; mSL_errPos = mSL_upos[p];
            );

            (mSL_errC === 0) ? (
                ((fd > 0) && (mSL_tyun[fd] === mSL_tyFCall) && ((id = mSL_lptr[fd]) > 0) &&
                        (mSL_tyun[id] === mSL_tyIdent)) ? (
                    // we have a function call - change this to a function def
                    mSL_tyun[fd] = mSL_tyFdef; mSL_valu[fd] = mSL_prFdef;
                    // create a list type from the "p" cell, "function", now unused
                    mSL_valu[p] = lok = z = mSL_rptr[fd]; mSL_lptr[lok] = mSL_nullPtr;
                    mSL_lptr[p] = fd; mSL_rptr[fd] = li = p; mSL_rptr[p] = mSL_nullPtr;
                    mSL_tyun[p] = mSL_tyList;
                    while (z > 0) (
                        lok = z; z = mSL_rptr[z];
                    );
                    // Now, "lok" is the last name in the parameters list
                    AAAAA_lok = mSL_getCellNum(lok); AAAAA_lokty = mSL_tyun[lok];
                    // Is this an expr ?
                    (mSL_tyun[lok] === mSL_tySubExp) ? (
                        mSL_errC = 2255; // error, except for the (argc ; argv) form
                        ex2 = mSL_lptr[lok]; // get previous
                        ((mSL_tyun[ex2] === mSL_tyNum) && (mSL_valu[ex2] === 1)) ? (
                            p = mSL_valu[lok]; // points to the operand
                            AAAAA_lokty2 = mSL_tyun[p];
                            (mSL_tyun[p] === mSL_tySemiCol) ? (
                                ps = mSL_lptr[p]; lp = mSL_rptr[p];
                                // do we have a (idt ; idt) construct ?
                                ((mSL_tyun[ps] === mSL_tyIdent) && (mSL_tyun[lp] === mSL_tyIdent)) ? (
                                    // build a 2 lid rid sequence
                                    mSL_valu[ex2] = -2; // change the count
                                    mSL_rptr[ex2] = ps; mSL_lptr[ps] = ex2;
                                    mSL_rptr[ps] = lp; mSL_lptr[lp] = ps;
                                    mSL_rptr[lp] = -1;
                                    mSL_freeChEnt(lok); // the subExp
                                    mSL_freeChEnt(p); // the ";"
                                    lok = lp;
                                    // mSL_errC = 22223;
                                    mSL_errC = 0;
                                );
                            );
                        );
                    );
                    ex2 = p = mSL_rptr[ex1];
                ) : (
                    mSL_errC = 2252; mSL_errPos = mSL_upos[ex1];
                );
            );
// mSL_errC = 22222;
            (mSL_errC === 0) ? (
                // Manage the "local" keywords
                while ((mSL_errC === 0) && (ex2 > 0) && (mSL_tyun[ex2] === mSL_tySubExp) &&
                      ((ps = mSL_valu[ex2]) > 0) && (mSL_tyun[ps] === mSL_tyFSpcF) &&
                      ((lp = mSL_lptr[ps]) > 0) && (mSL_tyun[lp] === mSL_tyKeywrd) &&
                      (mSL_valu[lp] === mSL_ckwLocal))
                (
                    // chain the list to the lok list
                    z = mSL_rptr[ps];
                    mSL_rptr[lok] = z; mSL_lptr[z] = lok;
                    while (z > 0) (
                        lok = z; z = mSL_rptr[z];
                    );
                    ex3 = ex2; ex2 = mSL_rptr[ex2];
                    // Chain the new expression
                    mSL_rptr[ex1] = ex2; (ex2 > 0) ? (mSL_lptr[ex2] = ex1);
                    // we can free the rest of the structure
                    mSL_freeChEnt(lp); // the keyword
                    mSL_freeChEnt(ps); // the node
                    mSL_freeChEnt(ex3); // the exp
                );
            );

            (mSL_errC === 0) ? (
                // now we expect an expression or equivalent as the function body
                ((ex2 > 0) && (((q = mSL_tyun[ex2]) === mSL_tySubExp) ||
                                (q === mSL_tyIdent) || (q === mSL_tyNum))) ? (
                    ex3 = mSL_rptr[ex2]; mSL_rptr[ex1] = ex3; (ex3 > 0) ? (mSL_lptr[ex3] = ex1);
                    // chain this to the left of the "list"
                    mSL_rptr[li] = ex2; mSL_lptr[ex2] = li; mSL_rptr[ex2] = mSL_nullPtr;
                ) : (
                    mSL_errC = 2253; mSL_errPos = mSL_upos[ex1];
                );
            );

            (mSL_errC === 0) ? (
                // now we expect a ";"
                ((ex3 > 0) && (mSL_tyun[ex3] === mSL_tySemiCol)) ? (
                    // syntax ok -- we define the function name
                    mSL_enterGCode(mSL_valu[id], 0, mSL_tyIdent, 0);
                    // Add this in the list of functions to compile...
                    mSL_F2CList[mSL_F2CPt] = fd; mSL_F2CPt += 1; AAA_toComp = fd;
                    // Now we can suppress the node from the list
                    p = mSL_rptr[ex3];
                    // chain left anchor to the right
                    (p > 0) ?  (mSL_lptr[p] = leftanchor);
                    (leftanchor > 0) ? (mSL_rptr[leftanchor] = p);
                    // free the ';'
                    mSL_freeChEnt(ex3); // the exp
                    state = 2;
                ) : (
                    mSL_errC = 2254; mSL_errPos = mSL_upos[ex1];
                );
            );

        ) :


        (state === 7) ? (
            // Import keyword
            //AA_06 = p; AA_06c = mSL_tyun[p];
            // Check we have a string, then a ";"
            q = p; p = mSL_rptr[p];  z = 0;
            ((p < 0) || (mSL_tyun[p] != mSL_tyString) || ((z = mSL_rptr[p]) < 0) || (mSL_tyun[z] != mSL_tySemiCol)) ? (
                //AA_00 = q; AA_00c = mSL_tyun[q];
                //AA_01 = p; AA_01c = mSL_tyun[p];
                //AA_02 = z; AA_02c = mSL_tyun[z];
                mSL_errC = 2235; mSL_errPos = mSL_upos[q];
            ) : (
                //AA_00 = q; AA_00c = mSL_tyun[q];
                //AA_01 = p; AA_01c = mSL_tyun[p];
                //AA_02 = z; AA_02c = mSL_tyun[z];
                //AA_06 = leftanchor;
                v = mSL_valu[p]; //AA_10 = 9999;
                // Get the string
                mSL_insert_file(v); // mSL_errC = 4444;
                // Free the string
                (mSL_errC === 0) ? (
                    mSL_rptr[leftanchor] = ex1 = mSL_rptr[mSL_newStart]; mSL_lptr[ex1] = leftanchor;
                    ex3 = mSL_rptr[z];
                    mSL_lptr[ex3] = ex2 = mSL_lptr[mSL_newEnd]; mSL_rptr[ex2] = ex3; mSL_freeChEnt(z);
                    //AA_08a = ex1; AA_08b = ex2; AA_09a = ex3;
                    mSL_freeChEnt(q); mSL_freeChEnt(p); mSL_freeChEnt(mSL_newStart); mSL_freeChEnt(mSL_newEnd);
                    p = start; // Restart exploration
                );
                // mSL_errC = 4444;
            );
            state = 1;
        ) :


        (
            mSL_errC = 2220; mSL_errPos = mSL_upos[p];
        )

    );
);






function mSL_checkXLimits()
(
    ((mSL_errX === 0) && (mSL_a_cxcmem >= mSL_memXcStart + mSL_actXcSize)) ? (
        mSL_errX = 4002; mSL_errPos = 0; // out of bounds limits
    );
);




//    Provide some memory for the interpreter to run

function mSL_make_evaluator(mem, size)
local (s, r, u)
(
    mSL_errX = 0;
    size = 0|size;
    (size < mSL_minXcSize) ? (
        mSL_errX = 4001; mSL_errPos = 0; // too small area
    );

    (mSL_errX === 0) ? (
        mSL_new_evaluator = mem + 2; // The returned object
        mSL_actXecBSize = size; /// trace
        memset(mem, 0, size);
        // Mark the area
        mem[0] = mSL_KODE_evl; // as "eXeCute Work Area"
        mem[size-2] = mem[1] = mSL_maxCpAddr = size-4;
        mem[size-1] = (mSL_CC_Chksum ~ mem[0]);
        // Put an end marker at the end of the list
        mSL_new_evaluator[mSL_EV_last] = mSL_End_Mark;
        // keep some area for structure referencing
        mSL_memXcEnd = mem + size - 3; // last "Start_End"
        mSL_a_cxcmem = mSL_new_evaluator + mSL_EV_last +1;
        // Compute available space (for proportions)
        mSL_actXcSize = mSL_memXcEnd - mSL_a_cxcmem;

        // Provide some internal work memory [currently not used]
        mSL_baseXSMSize = min(mSL_baseMemMax, max(mSL_baseMemMin, 0|(mSL_actXcSize*mSL_baseMemPc)));
        mSL_baseXSMem = mSL_a_cxcmem; mSL_a_cxcmem += mSL_baseXSMSize;
        // Start of allocated area
        mSL_memXcStart = mSL_a_cxcmem;

        mSL_new_evaluator[mSL_EV_var] = mSL_KW_globals;
        mSL_new_evaluator[mSL_EV_varAddr] = mSL_baseAVars;

        mSL_new_evaluator[mSL_EV_loc] = mSL_KW_locals;
        mSL_new_evaluator[mSL_EV_locAddr] = mSL_baseOVars;

        mSL_new_evaluator[mSL_EV_ext] = mSL_KW_pointers;
        mSL_new_evaluator[mSL_EV_extAddr] = mSL_basePVars;



        // Allocatable memory area
        mSL_XlastStatic = mSL_a_cxcmem;
        // Start of free area
        ((mSL_current_memory != 0) && (mSL_current_memory[mSL_BLOCK_Key] === mSL_KODE_memory)) ? (
            // we will use this array
            mSL_xFree = mSL_memXcEnd - mSL_a_cxcmem;
        ) : (
            // Build a memory bloc with the rest of available memory
            mSL_current_memory = mSL_new_memory = 0; s = mSL_memXcEnd - mSL_a_cxcmem;
            //  mSL_make_memory(mSL_a_cxcmem, s);
            mSL_errX = 4003; // no virtual memory provided
            mSL_a_cxcmem += s; mSL_xFree = 0;
        );
        mSL_new_evaluator[mSL_EV_mem] = mSL_KW_memory;
        mSL_new_evaluator[mSL_EV_memAddr] = mSL_current_memory;


    );

    mSL_checkXLimits();
    mSL_current_evaluator === 0 ?
        mSL_current_evaluator = mSL_new_evaluator;
    mSL_new_evaluator;
);

// Check if the parameter is the address of an object
function
mSL_isObject(obj)
local (addr, size, key)
(
    (((addr = obj - 2) > 0)
        && (addr < mSL_lastmemory) && (addr === (0|addr))
        && ((size = addr[1]) >= 0) && (addr+size < mSL_lastmemory) && (addr[size+2] === size)
        && ((key = addr[0]) > mSL_MKey_min) && (addr[size+3] === (key ~ mSL_CC_Chksum)));
);

// Check if the parameter is the address of an object allocated in dynamic memory
// This restricts its address to [mSL_current_memory[mSL_MM_LowAd] .. mSL_current_memory[mSL_MM_HighAd]]
function
mSL_isMemObject(obj)
local (addr, size, key)
(
    (((addr = obj - 2) > 0)
        && (addr > mSL_current_memory[mSL_MM_LowAd]) && (addr === (0|addr))
        && ((size = addr[1]) >= 0) && (addr+size+4 < mSL_current_memory[mSL_MM_HighAd])
        && (addr[size+2] === size) && ((key = addr[0]) > mSL_MKey_min)
        && (addr[size+3] === (key ~ mSL_CC_Chksum)));
);


// Set value of a global variable
function mSL_Set_G_Value(id, value)
(
    ((id != 0) && ((fent = mSL_checkGId(id)) >= 0)) ? (
        mSL_GCVal[fent] = value;
    );
);


// Copy an object to interpreter memory
function mSL_CpyObj2Mem(obj)
local (addr, ty, siz)
(
    ty = obj[-2]; siz = obj[-1]; // Size
    //addr = mSL_malloc(siz, ty);
    addr = mSL_Dyn_Alloc(siz, ty, mSL_StM_FlClear);
    (addr === 0) ? (
        mSL_errC = 1277;
        mSL_malloc_failed |= 1;
    ) : (
        mSL_GC_BProtect(addr, mSL_GC_Protected);
        memcpy(addr,obj,siz); // copy the inner part
    );
    addr;
);

// Free (delayed) as much as we can of compiler structures
function mSL_CP_Free_Structs()
(
    (mSL_TreeMainStruc != 0) ? (
        ic = 2; loop(mSL_TreePgMax,
            ent = mSL_TreeMainStruc[ic]; ic += 1;
            (ent > 0) ? mSL_Dyn_Recycle(ent);
        );
        mSL_Dyn_Recycle(mSL_TreeMainStruc);
        mSL_TreeMainStruc = 0;
        mSL_maxTrace = 0;
    );
    (mSL_CG_MainGen != 0) ? (
        ic = 0; loop(mSL_Code_MainSize,
            ent = mSL_CG_MainGen[ic]; ic += 1;
            (ent > 0) ? mSL_Dyn_Recycle(ent);
        );
        mSL_Dyn_Recycle(mSL_CG_MainGen);
        mSL_CG_MainGen = 0;
        mSL_pCCode = 0;
    );
    mSL_HEAD = mSL_start = mSL_end = mSL_ChFree = mSL_nullPtr;
);


//   Main entry -- compile the source code provided as an open file

function
mSL_compile(fHandle, fname, srcstr, cpflgs)
local (flg, lex, endgen, fptr, fp, fn, fent, sz, loc_baseAVars, loc_baseOVars, loc_basePVars, p)
(
    (mSL_C_fH >= 0) ? (file_close(mSL_C_fH); mSL_C_fH = -1;);
    //AA_tr = 0;
    (mSL_errC === 0) ? (
        // reset all the work structures ?
        mSL_cleanStructures();
        mSL_clearGCTab(); // init the global Symbol table
        mSL_clearLCTab(); // and the semi-local
        (cpflgs & 2) ? (
            // update globals from external exec.
            mSL_updateGlobals(mSL_baseAVars, mSL_GlbFlg);
            mSL_updateGlobals(mSL_baseOVars, mSL_OwnFlg);
            mSL_updateGlobals(mSL_basePVars, mSL_PtrFlg);
        ) : (
            mSL_baseAVars = 0;
            mSL_baseOVars = 0;
            mSL_basePVars = 0;
        );

        // Type of code : "program" or "function"
        ((cpflgs & 1) === 0) ? (
            endgen = 1; // end with "exit"
        ) : (
            endgen = 2; // end with "return"
        );
        //AA_tr = 1;
    );

    mSL_checkCLimits();

    (mSL_errC === 0) ? (
        //AA_tr = 2;
        mSL_C_fH = fHandle;
        ((mSL_C_fH < 0) && (fname > 0)) ? (
            // Try to open "fname"
            mSL_C_fH = file_open(fname);
        );
        (mSL_C_fH >= 0) ? (
            AA_tr = 3;
            mSL_C_cavail = 0;
        ) :
        (srcstr > 0) ? (
            // Use "srcstr" as the input text
            strcpy(#mSL_cline, srcstr);
            mSL_C_cavail = strlen(#mSL_cline);
            mSL_C_chcurr = 0;
            mSL_C_numLine = 1;
            mSL_C_chPos = 0;
        ) :
        (
            mSL_errC = 2404; // can't open the file
            mSL_errPos = 0;
        );
    );



    (mSL_errC === 0) ? (
        //AA_tr = 4;
        // Create the initial Structure as a HEAD/TAIL sequence
        mSL_end = mSL_start = mSL_HEAD = mSL_enterHEAD();  // Create head
        flg = 1;
        while (flg && (mSL_errC === 0)) (
            lex = mSL_lex();
            //AA_tr += 100;
            (lex > 0) ? (
                mSL_appndU(lex, mSL_lcod, (mSL_C_numLine << 16)+mSL_posChar);
            ) : (
                flg = 0;
            );
        );
        mSL_appndU(mSL_tyTAIL, 0, 0);
        (mSL_CP_Flags & 256) ? mSL_Node_Trace(mSL_HEAD);
    );
    //AA_lpUnit = 0;
    mSL_F2CPt = 0;


    (mSL_errC === 0) ? (
        //AA_tr += 1;
        // adapt some operations to context
        mSL_mod_primitives(mSL_start);

        // Reduce parentheses and brackets
        mSL_reduceBrackets(mSL_start);

        // Apply the basic rules
        mSL_doRules(mSL_start, 0); // keep the ';'

        // We can now detect the level zero special constructs
        mSL_doSpecials(mSL_start);

        // Finish the whole thing
        mSL_rewR2LRule(mSL_start, 16, 2); // dyadic ";" // separator

        (mSL_CP_Flags & 256) ? mSL_Node_Trace(mSL_HEAD);
    );

    mSL_main_cod = 0;

    (mSL_errC === 0) ? (

        mSL_Last_CF = fptr = 0;
        while ((mSL_errC === 0) && (mSL_F2CPt > fptr)) (
            // Compile next function in the list
            mSL_compileFun(mSL_F2CList[fptr]);
            (mSL_cod[-2] === mSL_CC_KeyCKod) ? (
                mSL_F2CCode[fptr] = mSL_fun = mSL_CpyObj2Mem(mSL_cod);
                fn = mSL_fun[mSL_CC_Name];
                (fn != 0) ? (mSL_Set_G_Value(fn, mSL_fun); mSL_Last_CF = mSL_fun; );
            );
            fptr += 1;
        );


        mSL_compileBlock(endgen);
        (mSL_cod[-2] === mSL_CC_KeyCKod) ? (
            mSL_main_cod = mSL_CpyObj2Mem(mSL_cod);
            fn = mSL_main_cod[mSL_CC_Name];
            (fn != 0) ? mSL_Set_G_Value(fn, mSL_main_cod);
        );

        // Let's create appropriate vars tables
        sz = (mSL_gvar+1) & mSL_NumMask;
        // loc_baseAVars = ((sz === 0) && (mSL_EmptyAVars != 0)) ? mSL_EmptyAVars : mSL_malloc(sz+8, mSL_KODE_gvars);
        //loc_baseAVars = mSL_malloc(sz+8, mSL_KODE_gvars);
        loc_baseAVars = mSL_Dyn_Alloc(sz+8, mSL_KODE_gvars, mSL_StM_FlClear);
        mSL_GC_BProtect(loc_baseAVars, mSL_GC_Protected);
        sz = (mSL_ovar+1) & mSL_NumMask;
        // loc_baseOVars = ((sz === 0) && (mSL_EmptyOVars != 0)) ? mSL_EmptyOVars : mSL_malloc(sz+8, mSL_KODE_locals);
        //loc_baseOVars = mSL_malloc(sz+8, mSL_KODE_locals);
        loc_baseOVars = mSL_Dyn_Alloc(sz+8, mSL_KODE_locals, mSL_StM_FlClear);
        mSL_GC_BProtect(loc_baseOVars, mSL_GC_Protected);
        sz = (mSL_pvar+1) & mSL_NumMask;
        // loc_basePVars = ((sz === 0) && (mSL_EmptyPVars != 0)) ? mSL_EmptyPVars : mSL_malloc(sz+8, mSL_KODE_pointers);
        //loc_basePVars = mSL_malloc(sz+8, mSL_KODE_pointers);
        loc_basePVars = mSL_Dyn_Alloc(sz+8, mSL_KODE_pointers, mSL_StM_FlClear);
        mSL_GC_BProtect(loc_basePVars, mSL_GC_Protected);
        ((loc_baseAVars === 0) || (loc_baseOVars === 0) || (loc_basePVars === 0)) ? (
            mSL_errC = 1275;
        );

        (mSL_errC === 0) ? (
            mSL_clean_vtabs(loc_baseAVars, loc_baseOVars, loc_basePVars);
            mSL_retrieveGlobals(loc_baseAVars, loc_baseOVars, loc_basePVars);

            (cpflgs & 2) ? (
                // Are these identical to our original tables ?
                mSL_same_entries(mSL_baseAVars, loc_baseAVars)  ? (
                    loc_baseAVars = mSL_baseAVars;
                    (mSL_CP_Flags & 8) ? (
                        sprintf(#sfc, "Re-using vars %d", loc_baseAVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                ) : (
                    mSL_fwdChain(mSL_baseAVars, loc_baseAVars); // forward chain
                );
                mSL_same_entries(mSL_baseOVars, loc_baseOVars)  ? (
                    loc_baseOVars = mSL_baseOVars;
                    (mSL_CP_Flags & 8) ? (
                        sprintf(#sfc, "Re-using locs %d", loc_baseOVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                ) : (
                    mSL_fwdChain(mSL_baseOVars, loc_baseOVars); // forward chain
                );
                mSL_same_entries(mSL_basePVars, loc_basePVars)  ? (
                    loc_basePVars = mSL_basePVars;
                    (mSL_CP_Flags & 8) ? (
                        sprintf(#sfc, "Re-using ptrs %d", loc_basePVars);
                        mSL_log(SysLogBox, #sfc);
                    );
                ) : (
                    mSL_fwdChain(mSL_basePVars, loc_basePVars); // forward chain
                );
            );

            // Let's populate the various structures: main code and functions
            mSL_main_cod[mSL_CC_GlbTab] = loc_baseAVars;
            mSL_main_cod[mSL_CC_OwnTab] = loc_baseOVars;
            mSL_main_cod[mSL_CC_PtrTab] = loc_basePVars;

            fptr = 0;
            while (mSL_F2CPt > fptr) (
                mSL_fun = mSL_F2CCode[fptr];
                mSL_fun[mSL_CC_GlbTab] = loc_baseAVars;
                mSL_fun[mSL_CC_OwnTab] = loc_baseOVars;
                mSL_fun[mSL_CC_PtrTab] = loc_basePVars;
                fptr += 1;
            );
        );

    );

    // mSL_bl_clear(mSL_GC_Protected); // free compiler's structures

    (mSL_errC != 0) ? (
        sprintf(#dbg_trace2, "Error %d -  Line %d/%d", mSL_errC, mSL_errPos >> 16, mSL_errPos & 0xFFFF);
    );

    mSL_CP_Free_Structs();
    mSL_errC;
);







//    Make a new thread
//    Use a mSL allocated bloc

function mSL_make_thread()
local (s, bl, stak)
(
    mSL_new_thread = 0;
    //bl = mSL_malloc(mSL_THR_Z, mSL_THR_KeyStrt); // create thread
    bl = mSL_Dyn_Alloc(mSL_THR_Z, mSL_THR_KeyStrt, mSL_StM_FlClear); // create thread
    //stak = mSL_malloc(mSL_baseStkMax, mSL_KODE_stack); // create stack
    stak = mSL_Dyn_Alloc(mSL_baseStkMax, mSL_KODE_stack, mSL_StM_FlClear); // create stack
    ((bl === 0) || (stak === 0)) ? (
        // allocation failed
        bl ? mSL_Dyn_Free(bl);
        stak ? mSL_Dyn_Free(stak);
        mSL_errX = 1016; mSL_errPos = 0; // no space
        mSL_malloc_failed |= 1;
    ) : (
        // internal clear
        // memset(bl, 0, s); // all reset - done in malloc
        bl[mSL_THR_State_Idt] = 'stat'; // State of the thread
        bl[mSL_THR_UTId_Idt] = 'utid'; // Unique Id for the thread
        bl[mSL_THR_SchedEnt_Idt] = 'sche'; // scheduler entry
        bl[mSL_THR_baseAVars_Idt] = 'gitb'; // Global var. table
        bl[mSL_THR_baseLocals_Idt] = 'litb'; // Local var. table
        bl[mSL_THR_baseOVars_Idt] = 'oitb'; // semilocal var. table
        bl[mSL_THR_basePVars_Idt] = 'pitb'; // pointers var. table
        bl[mSL_THR_basePhStack_Idt] = 'stkp'; //  start of the physical stack
        bl[mSL_THR_baseTOS_Idt] = 'stka'; //  start of the logical stack
        bl[mSL_THR_StackSize_Idt] = 'stks'; // size of the stack
        bl[mSL_THR_baseAddStack_Idt] = 'stkb'; // base of the stack
        bl[mSL_THR_baseHighStack_Idt] = 'stkh'; // top of the stack
        bl[mSL_THR_StackCurr_Idt] = 'stkc'; // current stack
        bl[mSL_THR_TOS_Idt] = 'ctos'; // current top of stack
        bl[mSL_THR_baseCode_Idt] = 'codb'; // start of the code
        bl[mSL_THR_CodeSize_Idt] = 'cods'; // size of the code
        bl[mSL_THR_CodeCurr_Idt] = 'codc'; // current code address
        bl[mSL_THR_CodePtr_Idt] = 'codp'; // pointer in code
        bl[mSL_THR_NxtOp_Idt] = 'nxop'; // next operation
        bl[mSL_THR_rtrnVal_Idt] = 'rval'; // return value
        bl[mSL_THR_errX_Idt] = 'errx'; // Error code (if any)
        bl[mSL_THR_PCode_Idt] = 'errp'; // Error location
        bl[mSL_THR_ICount_Idt] = 'icnt'; // Instruction count
        bl[mSL_THR_MxStk_Idt] = 'stmx'; // Stack max size
        bl[mSL_THR_Evnt_Idt] = 'evnt'; // event location
        // Enter stack address
        bl[mSL_THR_basePhStack] = stak;
        mSL_new_thread = bl;
    );
    (mSL_current_thread === 0) ? (
        mSL_current_thread = mSL_new_thread;
    );
    mSL_new_thread;
);




//   "Clean" a thread

function mSL_clean_thread(thrd)
local (stk)
(
    (thrd[-2] === mSL_THR_KeyStrt) ? ( // half verification
        stk = thrd[mSL_THR_basePhStack];
        thrd[mSL_THR_State] = 0;
        thrd[mSL_THR_UTId] = 0;
        // mSL_THR_SchedEnt -- updated outside
        thrd[mSL_THR_baseAVars] = 0;
        thrd[mSL_THR_baseLocals] = 0;
        thrd[mSL_THR_baseOVars] = 0;
        thrd[mSL_THR_basePVars] = 0;
        thrd[mSL_THR_baseCode] = 0;
        thrd[mSL_THR_CodePtr] = 0;
        thrd[mSL_THR_NxtOp] = 0;
        thrd[mSL_THR_PCode] = 0;
        thrd[mSL_THR_ICount] = 0;
        thrd[mSL_THR_MxStk] = 0;
        thrd[mSL_THR_TOS] = 0;
        thrd[mSL_THR_rtrnVal] = 0;
        thrd[mSL_THR_baseAddStack] = 0;
        thrd[mSL_THR_baseTOS] = 0;
        thrd[mSL_THR_baseTOS] = 0;
        thrd[mSL_THR_baseHighStack] = 0;
        thrd[mSL_THR_errX] = 0;
        thrd[mSL_THR_Evnt] = 0;
        mSL_bl_clear(stk); // keep the stack, but clear it
        thrd[mSL_THR_StackSize] = stk[-1]; // by definition
    );
);


//   Save thread informations after an execution

function mSL_save_thread(thrd)
(
    (thrd[-2] === mSL_THR_KeyStrt) ? (  // half verification
        thrd[mSL_THR_State] |= 4;
        while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link) (
            mSL_baseAVars = mSL_baseAVars[mSL_baseAVars[-1]-1];
            (mSL_CP_Flags & 8) ? (
                sprintf(#sfc, "SvA.Forwarding to %d", mSL_baseAVars);
                mSL_log(SysLogBox, #sfc);
            );
        thrd[mSL_THR_baseAVars] = mSL_baseAVars;
        );
        while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link) (
            mSL_baseOVars = mSL_baseOVars[mSL_baseOVars[-1]-1];
            (mSL_CP_Flags & 8) ? (
                sprintf(#sfc, "SvO.Forwarding to %d", mSL_baseOVars);
                mSL_log(SysLogBox, #sfc);
            );
        );
        while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link) (
            mSL_basePVars = mSL_basePVars[mSL_basePVars[-1]-1];
            (mSL_CP_Flags & 8) ? (
                sprintf(#sfc, "SvP.Forwarding to %d", mSL_basePVars);
                mSL_log(SysLogBox, #sfc);
            );
        );
        thrd[mSL_THR_baseOVars] = mSL_baseOVars;
        thrd[mSL_THR_basePVars] = mSL_basePVars;
        thrd[mSL_THR_baseLocals] = mSL_baseLocals;
        thrd[mSL_THR_baseCode] = mSL_baseCode;
        thrd[mSL_THR_CodePtr] = mSL_CodePtr;
        thrd[mSL_THR_NxtOp] = mSL_NxtOp;
        thrd[mSL_THR_PCode] = mSL_PCode;
        thrd[mSL_THR_ICount] = mSL_ICount;
        thrd[mSL_THR_MxStk] = mSL_High_Stack;
        thrd[mSL_THR_TOS] = mSL_TOS;
        thrd[mSL_THR_rtrnVal] = mSL_TOS[0];
        thrd[mSL_THR_baseAddStack] = mSL_baseAddStack;
        thrd[mSL_THR_baseTOS] = mSL_baseTOS;
        thrd[mSL_THR_baseHighStack] = mSL_baseHighStack;
        thrd[mSL_THR_errX] = mSL_errX;
    ) : (
        mSL_errX = 9603;
    );
);



//    Load thread information before an execution

function mSL_load_thread(thrd)
(
    // Define Global variables from a thread
    (mSL_errX === 0) ? (
        (thrd[-2] === mSL_THR_KeyStrt) ? (
            mSL_current_thread = thrd;
            // Is there a forward link in mSL_baseAVars ?
            mSL_baseAVars = thrd[mSL_THR_baseAVars];
            while (mSL_baseAVars[mSL_baseAVars[-1]-2] === mSL_Fwrd_Link)  (
                mSL_baseAVars = thrd[mSL_THR_baseAVars] = mSL_baseAVars[mSL_baseAVars[-1]-1];
                (mSL_CP_Flags & 8) ? (
                    sprintf(#sfc, "Ld.Forwarding to %d", mSL_baseAVars);
                    mSL_log(SysLogBox, #sfc);
                );
            );
            mSL_baseOVars = thrd[mSL_THR_baseOVars];
            while (mSL_baseOVars[mSL_baseOVars[-1]-2] === mSL_Fwrd_Link)  (
                mSL_baseOVars = thrd[mSL_THR_baseOVars] = mSL_baseOVars[mSL_baseOVars[-1]-1];
                (mSL_CP_Flags & 8) ? (
                    sprintf(#sfc, "Ld.Forwarding to %d", mSL_baseOVars);
                    mSL_log(SysLogBox, #sfc);
                );
            );
            mSL_basePVars = thrd[mSL_THR_basePVars];
            while (mSL_basePVars[mSL_basePVars[-1]-2] === mSL_Fwrd_Link)  (
                mSL_basePVars = thrd[mSL_THR_basePVars] = mSL_basePVars[mSL_basePVars[-1]-1];
                (mSL_CP_Flags & 8) ? (
                    sprintf(#sfc, "Ld.Forwarding to %d", mSL_basePVars);
                    mSL_log(SysLogBox, #sfc);
                );
            );
            mSL_baseLocals = thrd[mSL_THR_baseLocals];
            mSL_baseCode = thrd[mSL_THR_baseCode];
            mSL_CodePtr = thrd[mSL_THR_CodePtr];
            mSL_NxtOp = thrd[mSL_THR_NxtOp];
            mSL_PCode = thrd[mSL_THR_PCode];
            mSL_ICount = thrd[mSL_THR_ICount];
            mSL_High_Stack = thrd[mSL_THR_MxStk];
            mSL_TOS = thrd[mSL_THR_TOS];
            mSL_baseAddStack = thrd[mSL_THR_baseAddStack];
            mSL_baseTOS = thrd[mSL_THR_baseTOS];
            mSL_baseHighStack = thrd[mSL_THR_baseHighStack];
            mSL_errX = thrd[mSL_THR_errX];
            mSL_CodeStop = 0;
            thrd[mSL_THR_State] |= 2;
        ) : (
            mSL_errX = 9602;
        );
    );
);



//   Populate a thread structure after a compilation

function mSL_init_thread(ent)
local (w, xcode, bcode, thrd, stk, ssiz)
(
    (mSL_errX === 0) ? (
        ((ent < SchedFirstEnt) || (ent > SchedLastEnt)) ? (
            mSL_errX = 2412; // incorrect scheduler entry
        );
    );
    (mSL_errX === 0) ? (
        xcode = SchedPar1[ent]; // aka mSL_main_cod after a compilation
        ((xcode === 0) || (xcode[-2] != mSL_CC_KeyCKod)) ? (
            mSL_errX = 2413; // incorrect code
        );
    );
    (mSL_errX === 0) ? (
        thrd = SchedThrdPt[ent];
        ((thrd === 0) || (thrd[-2] != mSL_THR_KeyStrt)) ? (
            mSL_errX = 2414; // incorrect thread
            AAAAC_thrdERR = thrd;
        );
    );
    (mSL_errX === 0) ? (
        stk = thrd[mSL_THR_basePhStack];
        ((stk === 0) || (stk[-2] != mSL_KODE_stack) || ((ssiz=stk[-1]) < mSL_baseStkMin)) ? (
            mSL_errX = 2417; // no defined stack
        );
    );
    (mSL_errX === 0) ? (
        // Start populating the thread AREA
        // thrd[mSL_THR_SchedEnt] = ent; // the scheduler entry
        // The always available global variables
        (thrd[mSL_THR_baseAVars] === 0) ? (
            (w = xcode[mSL_CC_GlbTab]) ? (
                thrd[mSL_THR_baseAVars] = w;
            ) : (
                mSL_errX = 2418; // no defined global table
            );
        );
    );
    (mSL_errX === 0) ? (
        (thrd[mSL_THR_baseOVars] === 0) ? (
            (w = xcode[mSL_CC_OwnTab]) ? (
                thrd[mSL_THR_baseOVars] = w;
            ) : (
                mSL_errX = 2420; // no defined own table
            );
        );
    );
    (mSL_errX === 0) ? (
        (thrd[mSL_THR_basePVars] === 0) ? (
            (w = xcode[mSL_CC_PtrTab]) ? (
                thrd[mSL_THR_basePVars] = w;
            ) : (
                mSL_errX = 2419; // no defined pointer table
            );
        );
    );
    (mSL_errX === 0) ? (
        // code and associated values
        thrd[mSL_THR_CodeCurr] = xcode;
        bcode = xcode + xcode[mSL_CC_dpCode];
        thrd[mSL_THR_baseCode] = bcode;  // aka mSL_baseCode
        thrd[mSL_THR_CodePtr] = 0;
        thrd[mSL_THR_PCode] = 0;
        thrd[mSL_THR_ICount] = 0;
        thrd[mSL_THR_MxStk] = 0;
        thrd[mSL_THR_State] = 1;
        thrd[mSL_THR_errX] = 0;
        thrd[mSL_THR_rtrnVal] = 0;
        // stack mSL_current_stack === stk
        // thrd[mSL_THR_basePhStack] = stk; // keep the provided stak
        memset(stk,0,ssiz); // reset stack to zeroes
        stk[0] = mSL_K_stop; // Put a "stop lock" instruction
        // Add some stack end markers
        // Help check stack overflow conditions
        stk[ssiz-65] = stk[ssiz-33] = stk[ssiz-1] = mSL_End_Mark;
        thrd[mSL_THR_baseHighStack] = stk + ssiz - 65;
        thrd[mSL_THR_baseAddStack] = stkb = stk + 1; // initial base stack
        // The "context"
        stkb[0] = stkb; // loop on last stack [[mSL_baseAddStack]]
        stkb[1] =       // [[mSL_baseLocals]]
        stkb[2] =       // [[mSL_baseTOS]]
                    thrd[mSL_THR_baseTOS] = thrd[mSL_THR_baseLocals] = thrd[mSL_THR_TOS] = stkb + mSL_STK_DSiz - 1;
        stkb[3] = stk;  // [[mSL_baseCode]] - a code with the single instruction "0" ==> error
        stkb[4] = 0;    // [[mSL_CodePtr]]
        stkb[5] = thrd[mSL_THR_baseAVars];  // [[mSL_baseAVars]]
        stkb[6] = thrd[mSL_THR_baseOVars];  // [[mSL_baseOVars]]
        stkb[7] = thrd[mSL_THR_basePVars];  // [[mSL_basePVars]]
        // Set the needed values
        thrd[mSL_THR_NxtOp] = w = bcode[0];
        mSL_CodeStop = 0;
        (w === 0) ? (
            mSL_errX = 2416;
        );
    );
    ent;
);


// Look for the memory address of an ident in a thread
function mSL_idt_addr(thrd, idt)
local (res, chk, locv, glov, i, j)
(
    res = mmmDefLoc; // we can read/write here with no consequences
    // First, quick check that this is a thread.
    chk = ((thrd[-2] === mSL_THR_KeyStrt));
    chk ? (
        res = mmmDefLoc-1;
        locv = thrd[mSL_THR_baseOVars];
        glov = thrd[mSL_THR_baseAVars];
        chk = (locv[-2] === mSL_KODE_locals) && (glov[-2] === mSL_KODE_gvars);
    );
    chk ? (
        res = mmmDefLoc-2;
        i = 0; j = locv[-1];
        while ((i < j) && (res <= mmmDefLoc)) (
            (locv[i] === idt) ? (res = locv + i + 1);
            i += 2;
        );
        i = 0; j = glov[-1];
        while ((i < j) && (res <= mmmDefLoc)) (
            (glov[i] === idt) ? (res = glov + i + 1);
            i += 2;
        );
    );
    res; // the address
);


function mSL_prim_Sum(n, p)
local (sum, ip)
(
    sum = 0;
    ip = 0;
    loop(n, sum += p[ip]; ip += 1;);
    sum;
);




// UTilities for programs
function mSL_num2str(num)
local (anum, a, b, c, d)
(
    anum = abs(num);
    (num === floor(num)) ? (
        (num === mSL_End_Mark) ? (
            strcpy(#mSL_wS2, "======");
        ) :
        ((num >= mSL_MKey_min) && (num <= mSL_MKey_max)) ? (
            a = (num >> 24) & 0xff; b = (num >> 16) & 0xff;
            c = (num >> 8) & 0xff ; d = num & 0xff;
            ((a > 0x20) && (a < 0x7F) && (b > 0x20) && (b < 0x7F) && (c > 0x20) && (c < 0x7F)
            && (d > 0x20) && (d < 0x7F)) ? (
                sprintf(#mSL_wS2, "'%c%c%c%c'/%.0f", a, b, c, d, num);
            ) : (
                sprintf(#mSL_wS2, "%.0f", num);
            );
        ) :
        ((num > mSL_Sym_Low) && (num < mSL_Sym_High)) ? (
            mSL_id2Str(num);
            strcpy(#mSL_wS2, "`");
            strcat(#mSL_wS2, #mSL_wS1);
        ) :
        (
            sprintf(#mSL_wS2, "%.0f", num);
        );
    ) : (
        sprintf(#mSL_wS2, "%g", num);
    );
    #mSL_wS2; // return the string
);



//    Set an evaluator for interpreting some code

function mSL_set_evaluator(evl)
local ()
(
    ((evl === 0) || (evl != mSL_current_evaluator)) ? (
        (evl[-2] != mSL_KODE_evl) ? (
            mSL_errX = 1980; // invalid evaluator
        ) : (
            // set "evl" as "our" evaluator
            mSL_current_evaluator = evl;
        );
    );
);

function mSL_define_constant(name, value)
(
    mSL_current_constants[mSL_CstsPtc] = mSL_symbol(name);
    mSL_current_constants[mSL_CstsPtc + 1] = value ;
    mSL_CstsPtc = min(mSL_CstsPtc + 2, mSL_CstsSize - 2);
);

function mSL_define_opcode(name, code)
(
    code = min(255, max(128, 0|code));
    mSL_op_codes[code] = name;
    mSL_defGlobal(name, mSL_GlbFlg, mSL_tyPrimF, mSL_tyPrimFun | (0xff << 12) | code);
);

function mSL_define_global(name, value)
(
    mSL_defGlobal(name, mSL_GlbFlg, mSL_tyIdent, value);
);

function mSL_define_pointer(name, value)
(
    mSL_defGlobal(name, mSL_PtrFlg, mSL_tyIdent, value);
);

// Some run-time operations for user extensions (128)
// They can be redefined in mSL_Extend.jsfx-inc to provide more useful operations...
function mSL_255(c,v) (c); function mSL_254(c,v) (c); function mSL_253(c,v) (c); function mSL_252(c,v) (c);
function mSL_251(c,v) (c); function mSL_250(c,v) (c); function mSL_249(c,v) (c); function mSL_248(c,v) (c);
function mSL_247(c,v) (c); function mSL_246(c,v) (c); function mSL_245(c,v) (c); function mSL_244(c,v) (c);
function mSL_243(c,v) (c); function mSL_242(c,v) (c); function mSL_241(c,v) (c); function mSL_240(c,v) (c);
function mSL_239(c,v) (c); function mSL_238(c,v) (c); function mSL_237(c,v) (c); function mSL_236(c,v) (c);
function mSL_235(c,v) (c); function mSL_234(c,v) (c); function mSL_233(c,v) (c); function mSL_232(c,v) (c);
function mSL_231(c,v) (c); function mSL_230(c,v) (c); function mSL_229(c,v) (c); function mSL_228(c,v) (c);
function mSL_227(c,v) (c); function mSL_226(c,v) (c); function mSL_225(c,v) (c); function mSL_224(c,v) (c);
function mSL_223(c,v) (c); function mSL_222(c,v) (c); function mSL_221(c,v) (c); function mSL_220(c,v) (c);
function mSL_219(c,v) (c); function mSL_218(c,v) (c); function mSL_217(c,v) (c); function mSL_216(c,v) (c);
function mSL_215(c,v) (c); function mSL_214(c,v) (c); function mSL_213(c,v) (c); function mSL_212(c,v) (c);
function mSL_211(c,v) (c); function mSL_210(c,v) (c); function mSL_209(c,v) (c); function mSL_208(c,v) (c);
function mSL_207(c,v) (c); function mSL_206(c,v) (c); function mSL_205(c,v) (c); function mSL_204(c,v) (c);
function mSL_203(c,v) (c); function mSL_202(c,v) (c); function mSL_201(c,v) (c); function mSL_200(c,v) (c);
function mSL_199(c,v) (c); function mSL_198(c,v) (c); function mSL_197(c,v) (c); function mSL_196(c,v) (c);
function mSL_195(c,v) (c); function mSL_194(c,v) (c); function mSL_193(c,v) (c); function mSL_192(c,v) (c);
function mSL_191(c,v) (c); function mSL_190(c,v) (c); function mSL_189(c,v) (c); function mSL_188(c,v) (c);
function mSL_187(c,v) (c); function mSL_186(c,v) (c); function mSL_185(c,v) (c); function mSL_184(c,v) (c);
function mSL_183(c,v) (c); function mSL_182(c,v) (c); function mSL_181(c,v) (c); function mSL_180(c,v) (c);
function mSL_179(c,v) (c); function mSL_178(c,v) (c); function mSL_177(c,v) (c); function mSL_176(c,v) (c);
function mSL_175(c,v) (c); function mSL_174(c,v) (c); function mSL_173(c,v) (c); function mSL_172(c,v) (c);
function mSL_171(c,v) (c); function mSL_170(c,v) (c); function mSL_169(c,v) (c); function mSL_168(c,v) (c);
function mSL_167(c,v) (c); function mSL_166(c,v) (c); function mSL_165(c,v) (c); function mSL_164(c,v) (c);
function mSL_163(c,v) (c); function mSL_162(c,v) (c); function mSL_161(c,v) (c); function mSL_160(c,v) (c);
function mSL_159(c,v) (c); function mSL_158(c,v) (c); function mSL_157(c,v) (c); function mSL_156(c,v) (c);
function mSL_155(c,v) (c); function mSL_154(c,v) (c); function mSL_153(c,v) (c); function mSL_152(c,v) (c);
function mSL_151(c,v) (c); function mSL_150(c,v) (c); function mSL_149(c,v) (c); function mSL_148(c,v) (c);
function mSL_147(c,v) (c); function mSL_146(c,v) (c); function mSL_145(c,v) (c); function mSL_144(c,v) (c);
function mSL_143(c,v) (c); function mSL_142(c,v) (c); function mSL_141(c,v) (c); function mSL_140(c,v) (c);
function mSL_139(c,v) (c); function mSL_138(c,v) (c); function mSL_137(c,v) (c); function mSL_136(c,v) (c);
function mSL_135(c,v) (c); function mSL_134(c,v) (c); function mSL_133(c,v) (c); function mSL_132(c,v) (c);
function mSL_131(c,v) (c); function mSL_130(c,v) (c); function mSL_129(c,v) (c); function mSL_128(c,v) (c);




// */

Comp_lib_End = -1;
