/*
    The GAME MASTER main procedures
    (c)Jean-Jacques Girardot
    2018-2023
*/



@init


//    What do you see here ? =>      ⌘ ⌥ ⇧
// GetProjectPath(#pp); // This would be so nice !
GameMasterVersion = ui_version(1,7,6);
#CreationDate = "Mai 31, 2024";
the_host = mSL_KW_GameMaster;

// Evaluate an approximation of time_precise vs time
tSUnix = time(); tPLoc = time_precise(); timeD = tSUnix - tPLoc;
tSUnix = time(); tPLoc = time_precise(); timeD += tSUnix - tPLoc;
tSUnix = time(); tPLoc = time_precise(); timeD += tSUnix - tPLoc;
tUnix = tSUnix = time(); tPLoc = time_precise(); timeD += tSUnix - tPLoc;
timeD = timeD/4;

pTimePrevious = pTBlockStart = tPLoc + timeD;

current_Memory_Mode = 0; // no memory allocation allowed for now
mSL_Dyn_RecycleF = 1;
mSL_Dyn_Tr = 0; // 0xffff;
mm_show_ratio = 1;
fdi = gInit(); // global shared memory reset
gmem[timeDelta] = timeD;

// handle time
locT.DTG_init(1);  // 2 corresponding to summer time, 1 to winter time ?
tA = tStart = tReset = tUnix;
locT.DTG_update(tUnix); // update with time
timeGMemUpdate(); // accurate day


Rndm_n = 1 + tStart % 1000000007; // the random seed of the moment...
T0 = T1 = S0 = S1 = 0;
T_div = 1 / T_fact; // 2^-48 Exact value
currSmpl = 0; // current sample
iKPar = 0; // current displayed parameter

XDcount = 1; // 10;
cmdCap = 0x4 | 0x20; // On Mac: allow "cmd" or "ctrl" as "alternate" modifiers
altCap = 0x10 ; // on Mac : "alt"


GMI('Game', 'Mast', 'er--'); // init memory


//AGMW000 = AGMW010 = AGMW020 = AGMW030 = AGMW040 = AGMW050 = AGMW060 = AGMW070 = AGMW080 = AGMW090 = -1;
//AGMW100 = AGMW110 = AGMW120 = AGMW130 = AGMW140 = AGMW150 = AGMW160 = AGMW170 = AGMW180 = AGMW190 = -1;
//AGMW200 = AGMW210 = AGMW220 = AGMW230 = AGMW240 = AGMW250 = AGMW260 = AGMW270 = AGMW280 = AGMW290 = -1;
//AGMW300 = AGMW310 = AGMW320 = AGMW330 = AGMW340 = AGMW350 = AGMW360 = AGMW370 = AGMW380 = AGMW390 = -1;
//AGMW400 = AGMW410 = AGMW420 = AGMW430 = AGMW440 = AGMW450 = AGMW460 = AGMW470 = AGMW480 = AGMW490 = -1;
//AGMW500 = AGMW510 = AGMW520 = AGMW530 = AGMW540 = AGMW550 = AGMW560 = AGMW570 = AGMW580 = AGMW590 = -1;

// About string use
string_cst_first = 10000;
string_tmp_first = 190000;
string_var_first = 90000;
string_cst_last = 90000;
string_tmp_last = 290000;
string_var_last = 190000;



XV = 1;

gmem[versionGMaster] = GameMasterVersion;
presetVersionCurrent = ui_version(1,4,5);
presetVersionLoaded = 0;
presetVersionMask = 0xffff00;
presetLoadError = 0;
presetCheckValue = 0x27A65; // some arbitrary check value
presetCheckLoaded = 0;
mSL_loc_tim = 4;
mSL_xop_cnt = 0;
mSL_loc_tadd = 1;
mSL_Script_Tgl = 0;

#dbg_trace0 = "";
#dbg_trace1 = "";
#dbg_trace2 = "";
#dbg_trace3 = "";
#dbg_trace4 = "";
#dbg_trace5 = "";
#dbg_trace6 = "";
#dbg_trace7 = "";

#gstring = "";
gvar = #gstring;
// The Directory default location for files
#Def_GL_Directory = #D_GL_Directory = "GM-Libs/";
// The Directory default location for scripts
// #Def_GM_Scripts = #D_GM_Scripts = "Scripts/";
#Def_GM_Scripts = #D_GM_Scripts = "Scripts/";
// #Def_GM_Scripts = #D_GM_Scripts = "../Scripts/";
// The name of the Game Player mSL ini file
#Def_GM_mSL_set = #D_GM_mSL_set = "GM_mSL_scripts.txt"; // The list of available scripts files
#Def_GM_txt_set = #D_GM_txt_set = "GM_txt_configs.txt"; // The list of available configurations files
#Def_Script_Name = #D_Script_Name = "GenPlayScript.txt"; // Not used anymode
#Def_GM_mSL_ini = #D_GM_mSL_ini = "GM_mSL_ini.mSL"; // Main mSL script
#Def_InSens_Name = #D_InSens_Name = "config-Sensors.mSL"; // sensors / configurations & actions
#Def_ClipsModifiers = #D_ClipsModifiers = "config-Clips.mSL";
#Def_PlayModes = #D_PlayModes = "config-PModes.mSL";
#Def_SpaceModes = #D_SpaceModes = "config-SModes.mSL";
#Def_HPConfigs = #D_HPConfigs = "config-HP.mSL";
#Def_ClipSetConf = #D_ClipSetConf  = "config-ClSets.mSL";
#Def_BanksDefs = #D_BanksDefs = "config-Banks.mSL";
#Def_clDirectory = #D_clDirectory = "WAVES";
#Def_AudioDir = #D_GM_audioDir = "Audio";
#D_GM_Project_Path = ""; // unknown for now
#D_GM_Project_Name = ""; // unknown for now
#D_GM_Project_Path_FX = ""; // unknown for now
#D_GM_Project_Path_WAV = ""; // unknown for now
#D_GM_Project_Path_SCR = ""; // unknown for now
#D_GM_Project_Path_SNDS = ""; // unknown for now
#D_GM_Project_Path_GLib = ""; // unknown for now
#D_GM_Alt_Path = ""; // unknown for now
#Def_clEdFormat = #D_clEdFormat = "clip1%04d.%s";
strcpy(#D_clNameFormat, #D_clDirectory);
strcat(#D_clNameFormat, "/");
strcat(#D_clNameFormat, #D_clEdFormat);
GM_Project_Path = idx = 0;
GM_Project_Path_FX = (idx += 1);
GM_Project_Path_WAV = (idx += 1);
GM_Project_Path_SCR = (idx += 1);
GM_audioDir = (idx += 1);


flag_ld_HPC = 1; // should we load HP configuration ?
flag_ld_PlMd = 2; // should we load the play modes definition file ?
flag_ld_SpMd = 4; // should we load the space modes definition file ?
flag_ld_Bnks = 8; // should we load the banks definition file ?
flag_ld_Clips= 0x10; // should we load the clips definition file ?
flag_ld_Sensrs= 0x20; // should we load the sensors definition file ?
flag_ld_ClSets= 0x40; // should we load the clipsets definition file ?
flag_ld_Profile = 0x1000; // should we load the profile ?

flagHPCRload = 1;
flagPMRload = 1;
flagSPRload = 1;
flagBKRload = 1;
flagClVRload = 1;
flagClSetload = 1;
flagSnsrRload = 1;
flagGM_mSL_ini = 1;
flagDoLoadScripts = 1;
flagStdRload = 1;


// Proportion of the max allowed execution time of a block
// we decide to use for this plug-in
BlDurationProp = 0.16; // 16%

// (minima) number of mSL instructions we can execute in a second
// This is of course depending of the CPU !
// Here for my iMac, 3.5 GHz, Intel Core i7
// mSL_insts_per_s = 18000000;
// mSL_insts_per_s = 14000000; // Mac Book Pro
mSL_insts_per_s = 32000000; // Mac Studio Pro





EnterSens = 16;
currSens = 0;
currcell = 0;
currUpdt = 0;
currCpMode = 0;
currplayer = 0;
currUAdd = 0;
currclip = -1;
currclcnt = 0;
currclprv = 999;
currxcnt = 0;
currxAdd = 0;
currpmode = 0;
currDPars = 0;
currclipPrev = 0;
currpmodePrev = 0;
currclcntPrev = 0;
currUAddPrev = 0;
currDParsPrev = 0;
currplayerPrev = 0;
currpad = 0;
currLastSet = 0;
currLastDate = -1;
cpsrc = p_Interact;
interMod = 0;
interType = 1;
inter1 = inter2 = 0;
inter1pa = inter2pa = 0;
cellAlt = -1;
cellClip = -1;
clpn = 0;
TRC = 0;
STBerr = 0;
PMAddr = SMAddr = 0;
xNum = zNum = xCnt = 0;
showClNbrs = 0;
showStates = 4;

#efs = "";

// some globals "little" variables
dpa = dpi = efs = afs = efi = idx = gerr = kerr = 0;
delayLoad = 2;
delayLdInt = 0.5;
flagShowMemory = 1;
TabAddrMax = TabAddrMin = 0;
// Global infos, used in the "notify" primitive.
curr_Proc_PID = 0; // current process number
curr_Proc_Name = 0; // name of current process
LockSet = 0; // player global lock status

GClipSeq = 0; // global clip sequence - a unique number associated to every clip played

// These must be defined here
padSScriptsNL = 4;
padSScriptsNC = 4;
K_padSScriptsSiz = padSScriptsNL * padSScriptsNC;
//sprintf(#dbg_trace0,"L00230:  %d  %d  %d", padSScriptsNL, padSScriptsNC, K_padSScriptsSiz);

// All "reselect" variables
reSelectRate = reSelectVolume = reSelectGrFades = reSelectPartial = reSelectPmod =
reSelectDuration = reSelectSpaceMode = reSelectPlayMode = reSelectHpFlgs =
reSelectFadeOut = reSelectFadeIn =
reSelectHpSet = reSelectHpSet2 = reSelectHpent = reSelectHpent2 = reSelectHpcnt = Undef;

//====== Memory Initializations ======

//====== Init Private Game Player Shared Memory [currently not used]
SharedLowMemory = 0;
SharedLowMemorySize = 1024;
// 0 to 127 reserved
wa128 = 128; // a 128 words work area
wa256 = 256; // a 256 words work area
wa512 = 512; // a (surprise !) 512 words work area

SharedHighMemory = 0; // will be updated later
SharedHighMemorySize = 0; // yet unknown


//====== PRESETS ======
//====== Reserve some memory to read/write presets
idx = SharedLowMemory + SharedLowMemorySize;
serialSize = 12288; // size of a preset
serialBlock = idx; // +++ 1024
idx += serialSize;
K_savedStringsCnt = 192; // can save up to preset strings.
savedStrings = idx; // +++ 13312
idx += K_savedStringsCnt; // +++ 13504
memset(serialBlock, 0, idx - serialBlock);

//====== Reserve some memory for some algorithms that do not need memory management
clipsWorkAreaSize = clTSize; // 10000
clipsWorkArea = idx; // +++ 13504
idx += clipsWorkAreaSize;
smallPrimeSize = 128;
smallPrimeList = s = idx; // +++ 23504
idx += smallPrimeSize; //
smallPrimePtr = irand(smallPrimeSize);
U = -1;
s[U+=1] = 10211; s[U+=1] = 10267; s[U+=1] = 10289; s[U+=1] = 10301;
s[U+=1] = 10321; s[U+=1] = 10429; s[U+=1] = 10477; s[U+=1] = 10501;
s[U+=1] = 11551; s[U+=1] = 11743; s[U+=1] = 10141; s[U+=1] = 10169;
s[U+=1] = 11617; s[U+=1] = 11789; s[U+=1] = 11969; s[U+=1] = 11801;
s[U+=1] = 12113; s[U+=1] = 12197; s[U+=1] = 12373; s[U+=1] = 14561;
s[U+=1] = 12641; s[U+=1] = 10667; s[U+=1] = 10711; s[U+=1] = 10861;
s[U+=1] = 13291; s[U+=1] = 13421; s[U+=1] = 13591; s[U+=1] = 14173;
s[U+=1] = 13451; s[U+=1] = 13759; s[U+=1] = 13907; s[U+=1] = 11821;

s[U+=1] = 14207; s[U+=1] = 12143; s[U+=1] = 13103; s[U+=1] = 12037;
s[U+=1] = 15307; s[U+=1] = 15551; s[U+=1] = 16361; s[U+=1] = 16747;
s[U+=1] = 17183; s[U+=1] = 17317; s[U+=1] = 17333; s[U+=1] = 18451;
s[U+=1] = 18701; s[U+=1] = 19079; s[U+=1] = 19207; s[U+=1] = 19249;
s[U+=1] = 19531; s[U+=1] = 19571; s[U+=1] = 19597; s[U+=1] = 19609;
s[U+=1] = 19681; s[U+=1] = 19697; s[U+=1] = 19793; s[U+=1] = 19913;
s[U+=1] = 20393; s[U+=1] = 20411; s[U+=1] = 20441; s[U+=1] = 20477;
s[U+=1] = 20479; s[U+=1] = 20483; s[U+=1] = 20639; s[U+=1] = 20641;

s[U+=1] = 10739; s[U+=1] = 11059; s[U+=1] = 11443; s[U+=1] = 10601;
s[U+=1] = 10613; s[U+=1] = 11171; s[U+=1] = 10883; s[U+=1] = 10711;
s[U+=1] = 11423; s[U+=1] = 11503; s[U+=1] = 11329; s[U+=1] = 11369;
s[U+=1] = 11489; s[U+=1] = 11597; s[U+=1] = 11491; s[U+=1] = 10151;
s[U+=1] = 11813; s[U+=1] = 12373; s[U+=1] = 12907; s[U+=1] = 13681;
s[U+=1] = 11719; s[U+=1] = 12269; s[U+=1] = 13093; s[U+=1] = 13931;
s[U+=1] = 11731; s[U+=1] = 12101; s[U+=1] = 13001; s[U+=1] = 13477;
s[U+=1] = 11633; s[U+=1] = 12007; s[U+=1] = 12637; s[U+=1] = 13003;

s[U+=1] = 11777; s[U+=1] = 11059; s[U+=1] = 11443; s[U+=1] = 10601;
s[U+=1] = 12109; s[U+=1] = 12211; s[U+=1] = 12401; s[U+=1] = 12739;
s[U+=1] = 12829; s[U+=1] = 12923; s[U+=1] = 13007; s[U+=1] = 13109;
s[U+=1] = 13309; s[U+=1] = 13499; s[U+=1] = 13697; s[U+=1] = 13879;
s[U+=1] = 14081; s[U+=1] = 14197; s[U+=1] = 14323; s[U+=1] = 11677;
s[U+=1] = 10613; s[U+=1] = 11171; s[U+=1] = 10883; s[U+=1] = 11839;
s[U+=1] = 11939; s[U+=1] = 12113; s[U+=1] = 12227; s[U+=1] = 12569;
s[U+=1] = 12841; s[U+=1] = 12941; s[U+=1] = 13313; s[U+=1] = 13323;
smallWA1Size = 128;  // a little  work area
smallWA1 = idx;  // +++ 23632
idx += smallWA1Size;


/*
=== STATIC MEMORY ===
*/
//AGMW010 = GMW();
static_Mem = idx; // +++ 23760
// Static memory management : starts after the serial block
mSL_StM_Init(idx); // init static memory
current_Memory_Mode = mSL_MMd_Static; // starting now, allow use of "make_array"
//AGMW020 = GMW();
mSL_Str_Init(#strFirst, #strLast); // allocate strings for strings allocator
//AGMW030 = GMW();
mSL_Str_TInit(#wstrFirst, #wstrLast); // allocate strings for temporary strings
//AGMW040 = GMW();
mSL_Str_PInit(#xstrFirst, #xstrLast); // allocate strings for permanent strings
mSL_Str_GCPRinit(2000); // GC protected remanent strings
//AGMW050 = GMW();
//====== GLOBALS ======
init_idents();
mSL_Init_Keywords();
mSL_Init_long_Keywords();
init_log_boxes();

function init_paths_strings()
local ()
(
    PathsStrings = make_array(32);
    PathsStrings[GM_Project_Path] = #D_GM_Project_Path;
    PathsStrings[GM_Project_Path_FX] = #D_GM_Project_Path_FX;
    PathsStrings[GM_Project_Path_WAV] = #D_GM_Project_Path_WAV;
    PathsStrings[GM_Project_Path_SCR] = #D_GM_Project_Path_SCR;
    PathsStrings[GM_audioDir] = #D_GM_audioDir;
);

// Starting now, "idx" is a relative index in the preset area.
// Reserve some strings for the presets
ii = 0; loop(K_savedStringsCnt, savedStrings[ii] = mSL_Str_Perm(); ii+=1;);
// 0 to 15 are for tabulations names (if any)
idx = 16;
Pr7_Date = idx; // save date of the preset
Pr7_PlayModes = (idx += 1);
Pr7_SpaceModes = (idx += 1);
Pr7_BanksDefs = (idx += 1);
Pr7_HPConfigs = (idx += 1);
Pr7_ClipsModifiers = (idx += 1);
Pr7_InSens_Name = (idx += 1);
Pr7_GM_mSL_ini = (idx += 1);
Pr7_Script_Name = (idx += 1);
Pr7_clDirectory = (idx += 1);
Pr7_ClipsSets = (idx += 1);
Pr7_Project_Path = (idx += 1);
Pr7_Project_Name = (idx += 1);
Pr7_Project_SCR = (idx += 1);
Pr7_Project_WAV = (idx += 1);
Pr7_Project_SNDS = (idx += 1);
Pr7_Project_FX = (idx += 1);
Pr7_Project_GLib = (idx += 1);
idx = 48;
// 48 to 64 are for scripts names in settings
namScriptfiles = savedStrings + idx;
idx += K_padSScriptsSiz;
K_fileAliases = idx; // strings for files aliases
idx += 64; // should we need more ?
// Check we don't overflow the string array
// 48 used on the strings provided
(idx >= K_savedStringsCnt) ? err_sys_ini = 9927; // preset string array overflow
//====== work area for "ui-lib-JJ.jsfx-inc" ======
//AGMW060 = GMW();
ui_lib_start = mSL_StM_BlockStart('ulib');
//AGMW070 = GMW();
// Graphic set-up
// starting at +X protects location "0" from program errors...
ui_lib_end = ui_setup(ui_lib_start);
//AGMW080 = GMW();
mSL_StM_BlockEnd(ui_lib_end); // stop temporary
//AGMW090 = GMW();
//====== Init "ui-lib-JJ.jsfx-inc" ======
gfxInit();
//AGMW100 = GMW();
//====== Init "ui-lib-JJ-GUI.jsfx-inc" ======
studPrefDispPanes = 2;
studPrefDispSize = 1;
ui_MinSize1Pane = 312;
ui_MinSize4Panes = 4 * ui_MinSize1Pane;
ui_MinSize3Panes = 3 * ui_MinSize1Pane;
ui_MinSize2Panes = 2 * ui_MinSize1Pane; // min size for 2 panes
ui_MaxSize1Pane = 16 * ui_MinSize1Pane; // max size for 1 pane
ui_BestSize1Pane = 0|(16 * ui_MinSize1Pane); // best size for 1 pane
ui_MinSubColSize = 0|(ui_MinSize1Pane/2.5);
ui_lib_JJ_GUI_init(studPrefDispSize);
//AGMW110 = GMW();




//======= Test Operations - stuctures used later
HSZ_Siz = 1431;  //  1033; // 2999;
H_Table = make_array(HSZ_Siz); // Set to zero
memset(H_Table, -1, HSZ_Siz);
H_Codes = make_array(HSZ_Siz); // Set to zero
H_Dupl = make_array(HSZ_Siz); // Set to zero
H_Colls = 0;
H_Tsts = 0;



/*
=== STRUCTURES ===
*/
//-------------
// Play Mode
PMEsize = 36; //  size of a playmode entry
idx_Pm_PmdN = 0; // Play mode number
idx_Pm_Kmd = 1;  // Commande des players,
idx_Pm_FLM1 = 2;  // flags de modification de la commande des players
idx_Pm_FLM2 = 3; //  "
idx_Pm_Speed1 = 4; // vitesse de lecture - min, max, inversion
idx_Pm_Speed2 = 5; // "
idx_Pm_Speed3 = 6; // "
idx_Pm_GDepth1 = 7; // superposition des voix - min, max
idx_Pm_GDepth2 = 8; // "
idx_Pm_PVol1 = 9; // volume - min, max
idx_Pm_PVol2 = 10; // "
idx_Pm_PDur1 = 11; // play duration - min, max
idx_Pm_PDur2 = 12; // "
idx_Pm_Gsize1 = 13; // grain size in seconds, min, max
idx_Pm_Gsize2 = 14; // "
idx_Pm_FX1 = 15; // Effect 1
idx_Pm_FX1_2 = 16; // "
idx_Pm_FX2 = 17; // Effect 2
idx_Pm_FX2_2 = 18; // "
idx_Pm_PFdIn1 = 19; // Play Fade-in
idx_Pm_PFdIn2 = 20; // Play Fade-in2
idx_Pm_PFdOut1 = 21; // Play Fade-out
idx_Pm_PFdOut2 = 22; // Play Fade-out2
idx_Pm_GPFdIn1 = 23; // Grain Fade-in
idx_Pm_GPFdIn2 = 24; // Grain Fade-in2
idx_Pm_GPFdOut1 = 25; // Grain Fade-out
idx_Pm_GPFdOut2 = 26; // Grain Fade-out2
idx_Pm_GPFdTy = 27; // Grain Fade Type
idx_Pm_ChCnt1 = 28; // Gen Channel Count
idx_Pm_ChCnt2 = 29; // Gen Channel Count
idx_Pm_Spec0 = 30; // Special modifieurs
//-------------
// Space Mode
SMESize = 20; // size of a spacemode entry
idx_Sm_sMnum = 0; // SpaceMode/number of the space mode
idx_Sm_HPSet1 = 1; // Number of the first HP set
idx_Sm_HPSet2 = 2; // Number of the second HP set
idx_Sm_HPSet3 = 3; // Number of the third HP set
idx_Sm_HPSet4 = 4; // Number of the fourth HP set
idx_Sm_HPCnt1 = 5; // Min and max count
idx_Sm_HPCnt2 = 6; // should be consecutive
idx_Sm_HPFlags = 7;
idx_Sm_Algo = 8; // Space algorithm
idx_Sm_Aux = 9; // 1 value
idx_Sm_HPEv = 10; // up to 4 values
idx_Sm_Pars = 14; // up to 6 values
//-------------
// Partial
BKEsize = 12; // size of a bank entry
idx_Pa_Grp = 0; // group number
idx_Pa_Bnk = 1; // bank number
idx_Pa_Clps = 2; // Clps
idx_Pa_Clps2 = 3; // Clps + 1
idx_Pa_PlM = 4; // Playmode
idx_Pa_SpM = 5; // Spacemode
idx_Pa_prVol = 6; // Vol. correction
idx_Pa_prVol2 = 7; // Vol. correction
idx_Pa_PWeight = 8; // weight of clips
idx_Pa_PClass = 9; // class of the partiel
idx_Pa_PBFlgs = 10; // Flags
idx_Pa_PNumb = 11; // internal number

// Some play commands
idx = 0;
pACinP = (idx -= 1); // Play any clip in the current Partial // -1
pACinG = (idx -= 1); // Play any clip in the group of the current Partial // -2
pACinB = (idx -= 1); // Play any clip in the group & bank of the current Partial // -3
pACinWwP = (idx -= 1); // Play any clip in the whole system, with parameters from the current Partial // -4
pACinSwP = (idx -= 1); // Play any clip in the selection, with parameters from the current Partial // -5
pACinRP = (idx -= 1); // Play any clip in a random Partial // -6

//----
//  Module/box flags
ubx_inited = 1;
ubx_modified = 2;
ubx_final = 0x100; // contains final items
ubx_recurs = 0x200; // contains other boxes
//  User inner box description
ubx_psize = idx = -1;
//----
ubx_ty = (idx += 1);    // Type of the box
ubx_flgs = (idx += 1); // associated flags
ubx_mref = (idx += 1);  // dynamic memory reference
ubx_anc = (idx += 1);  // ancestor (relative)
ubx_name = ubx_anc; // name of module as a string
//----
ubx_lcnt = (idx += 1);  // Number of direct descendants
ubx_icnt = (idx += 1); // number of direct items
ubx_1st = (idx += 1);  // 1st descendant (relative)
ubx_tcnt = (idx += 1);  // total Number of descendants
//----
ubx_l  = (idx += 1); // left position
ubx_t  = (idx += 1); // top position
ubx_w  = (idx += 1);  // width
ubx_h  = (idx += 1);  // height
//----
ubx_minw  = (idx += 1);  // min width
ubx_maxw  = (idx += 1);  // max width
ubx_thread = (idx += 1);  // thread base
ubx_thrdid = (idx += 1);  // thread base idt
//----
ubx_isiz = (idx += 1); // size of a box
//----
idx = 0; // tos
stk_btyp = idx;  // current bloc type
stk_cbx = (idx -= 1);  // current box [relative]
stk_rtsk = (idx -= 1); // return stack
stk_rtst = (idx -= 1); // return state
stk_mode = (idx -= 1); // work mode
stk_h = (idx -= 1); // computed height
stk_w = (idx -= 1); // computed width
stk_t = (idx -= 1); // computed top
stk_l = (idx -= 1); // computed left
stk_i = (idx -= 1); // index in boxes
stk_b = (idx -= 1); // base of boxes sequence
stk_isiz = 1 - idx;
// adjusts
ubx_sbox_more = 4;
//====== GRAPHICS-INIT ======

<? include("GM-Libs/mSL_Colors.jsfx-inc"); ?>


U4_2 = ui_pcolor_derived(U4_0, 2);
U4_4 = ui_pcolor_derived(U4_0, 4);
U4_6 = ui_pcolor_derived(U4_0, 6);
U4_8 = ui_pcolor_derived(U4_0, 8);
U4_16 = ui_pcolor_derived(U4_0, 16);


U5_2 = ui_pcolor_derived(U5_0, 2);
U5_4 = ui_pcolor_derived(U5_0, 4);
U5_6 = ui_pcolor_derived(U5_0, 6);
U5_8 = ui_pcolor_derived(U5_0, 8);
U5_16 = ui_pcolor_derived(U5_0, 16); // was 16+2


// The "theme" menu
uix_jtheme_menu = make_jmenu(
    ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel |
    //
    ui_jmenu_opt_rclick |
    //  ui_jmenu_opt_alclick |
    // ui_jmenu_opt_alclick |
    ui_jmenu_opt_notitle,
    "Theme",
    // "&1 Default|&1 Black|&1 Tron|&1 Light Cyan|&1 Orange|&1 Blue|&1 Dark Cyan||&2 Small|&2 Large|| &3 1 pane|&3 2 panes|&3 3 panes|&3 4 panes"
    "!&1 Default|&1 Black|&1 Tron|&1 Light Cyan|&1 Orange|&1 Blue|&1 Dark Cyan"
    );
uix_jtheme_rtc_max = 7;  // 7 entries in the menu
// Correct a few things...
ui_jcolor_inactive_grey = Color_Dark_Gray;
ui_jGUI_prev = 0;
studDispPPrev = -1;
studDispPCnt = 0;
prev_gfx_w = 0;
ui_GFXReason = 0;
ui_GFXCount = 0;
serial_counter = 0;
ubMeanT = ubXcnt = ubXdur = ubXmax = 0;



altTabsNames = savedStrings; // use first saved strings to save alternate tabsnames


// Global objects
menu_uix_jlog = make_jmenu(
    ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "Log Layout", "!&X1 column|&X2 columns|&X3 columns|&X4 columns||&/height +|&/height -|&/blank|&/clear");


// paramCount = 256; // The count of master/looper/players adjustable parameters - now defined in clip_lib
ULocPrime = 113;
waitAfterMod = 8; // seconds, wait-time after a value modification or error
Kbtp = -1; // A play command
PlayRelay = -1; // another play command
PlayCell = 0; // PlayRelay parameter
min_Generators = 0.5; // Nombre min de generateurs en aléatoire
max_Generators = 20; // Nombre max de generateurs en aléatoire

ClCheckFlag = 1;
ClCheckNum = 0;
ClCheckCnt = 0;
ClCheckForce = 1;
ClCheckView = 1;

// Some actions flags
flagKillAllThreads = 0;
ActFlg1 = 0x100;
ActFlg2 = 0x200;
ActFlg3 = 0x400;
ActFlg4 = 0x800;

// Copies of System Variables
sysTempo = tempo;
sysPlayState = play_state;
sysPlayPosition = play_position;
sysBeatPosition = beat_position;

// Graphics
colMouseWasIn = 0;
Kmouse_cap = Keyed = KeyedT = AAAA_lastKeyedT = 0;

// Time Events
timeEvent0 = timeEvent1 = timeEvent2 = timeEvent3 = pTimePrevious - 50;

timeFlag0 = timeFlag1 = timeFlag2 = timeFlag3 = timeFlagT = 0;
timeFlag2Cnt = 0;

err_sys = 0; // generic error system
err_sys_ini = 0; // generic initialization error system
err_sys_rtm = 0; // generic run-time error system
err_sys_gfx = 0; // generic graphic error system
err_fclp = 0; // error when reading clips description file
err_fplm = 0; // error in play modes description file
err_fhpc = 0; // error in HP configuration description file
err_fspm = 0; // error in space modes description file
err_fbnk = 0; // error in partials/banks description file
err_sdfr = 0; // error in sensors def reader

SchedActive = 1; // scheduler activity
SensorsActive = 0; // sensors activity
SysLinksActive = 0; // System Link Activity
SysLinkFlag = 0;
SysLinkType = 0;
SysLinkTime = 0;
SysLinkKod = 0;
SysLinkUsed = -1;
SysSourceType = 0;
SysSourceKod = 0;
SysSourceUsed = -1;
Evnt_Current = 0;
MIDILogActive = 0; // MIDI Log Activity
//GvAutoMd = 0; // Global Auto Mode / auto mode activity
GvPlayOnce = 0; // Play Once mode
GvPlayTyp = 0; // Auto play type
GvPlayGrp = 0;
GvPlayBnk = 0;
GvPlayPart = 0;
GvPlayPartEnt = 0;
GvPlayPM = 0;
GvPlaySM = 0;
GvPlayCl0 = 0;
GvPlayCl1 = 0;
GvPlayCl2 = 9999;
GvPlayCl3 = 0;
GvpM = 0;
GvsM = 0;
GvErrP1 = GvErrP2 = GvErrP3 = GvErrP4 = GvErrP5 = GvErr = 0;
GvEps = 0.00005; // for rounding
GvPlFlTemp = GvPlFlDefault = 1+4+32+64;
BankLink = 0;
// Statistic
Bcpy = Beop = Bflg = BPlc = BLpc = 0;
BPlSig4 = BPlSig16 = BPlSig64 = BPlSig256 = BPlSig1024 = 0;
BLpSig4 = BLpSig16 = BLpSig64 = BLpSig256 = BLpSig1024 = 0;
BPlTresh4 = BPlTresh16 = BPlTresh64 = BPlTresh256 = BPlTresh1024 = 0;
BLpTresh4 = BLpTresh16 = BLpTresh64 = BLpTresh256 = BLpTresh1024 = 0;
BPlBuf4 = make_array(4); BLpBuf4 = make_array(4);
BPlBuf16 = make_array(16); BLpBuf16 = make_array(16);
BPlBuf64 = make_array(64); BLpBuf64 = make_array(64);
BPlBuf256 = make_array(256); BLpBuf256 = make_array(256);
BPlBuf1024 = make_array(1024); BLpBuf1024 = make_array(1024);
BPlPtr4 = BPlPtr16 = BPlPtr64 = BPlPtr256 = BPlPtr1024 = 0;
BLpPtr4 = BLpPtr16 = BLpPtr64 = BLpPtr256 = BLpPtr1024 = 0;
BPLCTAbase = BPLCTime = 0;
// BPLCTbase = 2;
// BPLCTlimit = 4;
BPLCTlimit = 2 * (BPLCTbase = 1024);
BPlDoPlay = BLpDoPlay = 0;
BPlRat = 1;
BPlAdjF = 1.01;
GvAutoNxt = Undef;
do_gfx_init = 1;
sysSamplesBlock = sysGSamplesBlock = 0;
Curr_Block_Max_Delay = 0;
PlayModesVersion = 0; // version/identification of the play modes file
SpaceModesVersion = 0; // version/identification of the space modes file
BanksDefsVersion = 0; // version/identification of the banks file
HPConfigVersion = 0; // version/identification of the HP configuration file
ClipConfigVersion = 0; // version/identification of the clips configuration file
SensorsCfVersion = 0; // version/identification of the sensors configuration file



lastTime = 0; // last "known" Unix time
lastTick = lastGTick = 0;
lastErrSignal = 0;
lastDraw = 0;
lastMn = gfxMn = gfxMcnt = -1;
lastHr = -1;
lastGMn = 0;
lastGHr = 0;
noInterrupt = 0;

tickShift = 4;
player = 0;
readerCount = 0;
stat10m = 0;
flagStopOne = 0;
UFirst = UNext = ULast = 0;
Kselect = 0;
Kpart = 0;
KpFlags = 0;
Kmnd_Pl = 0;
KSource = 0;
GPlUnit = UGDummy; // The (global) player unit we have just sent a command...
Uxa = 0;
UXstat = 0;
GMTrack = 0;

// playLogSize = 1 * 1024 * 1024;
// playMem = 0; // set later
// various counters and gizmos
gmaxd = gstrt = 0;
lmaxd = lstrt = 0;
ClMEntries = ClLEntry = 0;
blockCntr = 0;
blockTickCntr = 0;
blockMaxCntr = 0;
blockMinCntr = 999999;
//============== dbg infos & modes
dbg_mem_add = 0;
dbg_mem_def_add = 0;
dbg_mem_dec = 0;
dbg_curr_sel = 0;
dbg_mode = 0;
dbg_fpr = 0;
dbg_show_height = 256;
dbg_line_height = 19;
dbg_u_zm = 0;
dbg_u_za = 0;
dbg_u_ms_x = 0;
dbg_u_ms_y = 0;
dbg_u_zmc = 0;
u_prev_zmc = 0;

MIDI_Flgs = 0; // MIDI flags for trace
AllowedPlA = 0; // allowed to play
AllowedLpA = 0; // allowed to loop
AllowedPlR = 0; // allowed to play
AllowedLpR = 0; // allowed to loop



//Few checks for the clip library
// Check Global Param Use
(UCBparCnt > UCBparHCnt) ? err_sys_ini = 9905; // UCB parameters overflow
//(bcbSpl0 > BCBsize-64) ? err_sys_ini = 9906;  // UCB base overflow
make_bit_arrays(); // we will need uix_bit_set


PrintFormats = make_array(32);
i = 0; loop(32, PrintFormats[i] = "%d"; i+= 1; );
PrintFormats[1] = "%f";
PrintFormats[2] = "%s";
PrintFormats[3] = "%03d";
PrintFormats[4] = "%04d";
PrintFormats[5] = "%08d";
PrintFormats[6] = "%02X";
PrintFormats[7] = "%08X";
PrintFormats[8] = "%.1f";
PrintFormats[9] = "%.2f";
PrintFormats[10] = "%.3f";
PrintFormats[11] = "%.4f";
PrintFormats[12] = "%.1f s";
PrintFormats[13] = "%d ms";
PrintFormats[14] = "%.1f ms";
PrintFormats[15] = "%d %%";
PrintFormats[16] = "%.2f s";
PrintFormats[17] = "%d kHz";
PrintFormats[18] = "%.3f %%";
PrintFormats[19] = "%.1f dB";
PrintFormats[20] = "%i";
PrintFormats[21] = "%.2e";
PrintFormats[22] = "%.3f s";
PrintFormats[23] = "%d Hz";
PrintFormats[24] = "%.5f";
PrintFormats[25] = "%04X";
PrintFormats[28] = " ➤ %d";
PrintFormats[29] = " ✔︎ %d";
PrintFormats[30] = "%d:%d";
PrintFormats[31] = "%d/%d";

// Work area for HP settings
HP_Set_Used = HP_Set_Total = 128;
HP_Cost = 15;
HP_Set_Cntr = make_array(HP_Set_Total);
HP_uDelta = 2; // Increase every 2 seconds
HP_uTime = pTBlockStart; // time to work on HP_usage (size HP_uSize)

//====== Utilities procedures ======
// Find a value in a list, return its position
function getpos(list, value, default)
local (pos)
(
    pos = 0;
    while ((list[pos] != value) && (pos < default)) (
        pos += 1;
    );
    pos;
);


// Get a random element in a list of size "siz"
function getrandelt(list, siz)
(
    siz <= 1 ? list[0] : list[irand(siz)];
);

function
updatePaths()
(
    (strlen(#D_GM_Project_Path_SCR) > 15) ? (
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_PlayModes); strcpy(#D_PlayModes, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_SpaceModes); strcpy(#D_SpaceModes, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_HPConfigs); strcpy(#D_HPConfigs, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_GM_mSL_ini); strcpy(#D_GM_mSL_ini, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_ClipsModifiers); strcpy(#D_ClipsModifiers, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_InSens_Name); strcpy(#D_InSens_Name, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_ClipSetConf); strcpy(#D_ClipSetConf, #WS);
        strcpy(#WS, #D_GM_Project_Path_SCR); strcat(#WS, #Def_BanksDefs); strcpy(#D_BanksDefs, #WS);
        strcpy(#WS, #D_GM_Project_Path_WAV); strcat(#WS, #Def_clEdFormat); strcpy(#D_clNameFormat, #WS);
        strcpy(#WS, #D_GM_Project_Path_FX); strcat(#WS, #Def_GL_Directory); strcpy(#D_GL_Directory, #WS);
        strcpy(#WS, #D_GM_Project_Path_FX); strcat(#WS, #Def_GL_Directory); strcpy(#D_GM_Project_Path_GLib, #WS);
    );
);


function
SetNewProjectPath (pth)
(
    // Is the path ending in ".RPP" ?
    match("%{gvar}s/*.RPP", pth) ? (
        strcpy(#D_GM_Project_Name, pth);
        strcpy(#D_GM_Project_Path, gvar);
        strcat(#D_GM_Project_Path, "/");
        strcpy(#D_GM_Project_Path_FX, #D_GM_Project_Path); strcat(#D_GM_Project_Path_FX, "Effects/");
        strcpy(#D_GM_Project_Path_SCR, #D_GM_Project_Path); strcat(#D_GM_Project_Path_SCR,"Data/Scripts/");
        strcpy(#D_GM_Project_Path_WAV, #D_GM_Project_Path); strcat(#D_GM_Project_Path_WAV,"Data/WAVES/");
        strcpy(#D_GM_Project_Path_SNDS, #D_GM_Project_Path); strcat(#D_GM_Project_Path_SNDS,"Data/Sounds/");
        mSL_log(SysLogBox, #D_GM_Project_Path);
        //mSL_log(SysLogBox, #D_GM_Project_Path_FX);
        updatePaths();
    );
);

// Try to open a file somewhere
function GM_file_open(fname, flgs)
local (fhd)
(
    strcpy(#tmpFname, fname);
    0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
    fhd = file_open(#tmpFname);
    (fhd < 0) ? (
        // is the file in current directory ?
        strcpy(#tmpFname, #D_GL_Directory); strcat(#tmpFname, fname);
        0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
        fhd = file_open(#tmpFname);
        (fhd < 0) ? (
            // is the file in the script directory ?
            strcpy(#tmpFname, #D_GM_Scripts); strcat(#tmpFname, fname);
            0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
            fhd = file_open(#tmpFname);
            (fhd < 0) ? (
                strcpy(#tmpFname, #D_GL_Directory); strcat(#tmpFname, #D_GM_Scripts); strcat(#tmpFname, fname);
                0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
                // is the file is Libs/Scripts
                fhd = file_open(#tmpFname);
                (fhd < 0) ? (
                    strcpy(#tmpFname, #D_GM_Project_Path); strcat(#tmpFname, #D_GM_Scripts); strcat(#tmpFname, fname);
                    0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
                    fhd = file_open(#tmpFname);
                );
            );
        );
    );
    fhd;
);


//====== PLAY LOG MANAGEMENT ======

padPlayLogNL = 1;
padPlayLogNC = 8;
padPlayLogSiz = padPlayLogNL * padPlayLogNC;
padPlayLogp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padPlayLogNL, padPlayLogNC, padPlayLogSiz);
padPlayLogLabs = padPlayLogp + padPlayLogp[ui_jpad_labs]; // addresses of labels
padPlayLogColrs = padPlayLogp + padPlayLogp[ui_jpad_clrs]; // addresses of colors
padPlayLogCells = padPlayLogp + padPlayLogp[ui_jpad_cells]; // addresses of cells desc.
padPlayLogVals = padPlayLogp + padPlayLogp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padPlayLogSiz,
            padPlayLogColrs[ii] = Col_Inactive;
            padPlayLogLabs[ii] = "";
            ii+=1;
);

plgRecNames = make_array(12);
idx = -1;
plgRecNames[idx += 1] = "&/ Stop           H";
plgRecNames[idx += 1] = "&/ Record       R";
plgRecNames[idx += 1] = "&/ Pause         R";
plgRecNames[idx += 1] = "";
plgRecNames[idx += 1] = "> Options";
plgRecNames[plgRecLOnPause = (idx += 1)] =  "&+ Lock sounds on pause        O";       // recOptLockSnds
plgRecNames[plgRecRecReplay = (idx += 1)] = "&+< Record replayed sounds     T";       // recOptRecReplay
plgRecLastId = idx+1;

menu_plrec = make_jmenu(
    ui_jmenu_typ_opt | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "recModes", plgRecLastId, plgRecNames);


plgReplNames = make_array(20);
// WARNING: spaces before keyboard shortcuts reminders are adjusted so the shortcuts almost seem to be aligned...
idx = -1;
plgReplNames[idx += 1] = "&/ Stop           H";
plgReplNames[idx += 1] = "&/ Replay        P";
plgReplNames[idx += 1] = "&/ Pause         P";
plgReplNames[idx += 1] = "&/ Rewind";
plgReplNames[idx += 1] = "";
plgReplNames[idx += 1] = "> Options";
plgReplNames[plgReplAStop = (idx += 1)] =   "&+ Auto Stop";                                                 // playAutoStop
plgReplNames[plgReplLPause = (idx += 1)] =  "&+ Pause after each sound";                                    // playAndStop
plgReplNames[plgReplPLock = (idx += 1)] =   "&+ Lock replayed sounds                        K";             // playAndLock
plgReplNames[plgReplPUnLock = (idx += 1)] = "&+ Unlock replayed sounds                    U";             // playAndUnLock
plgReplNames[plgReplMute = (idx += 1)] =    "&+ Mute replayed sounds                       M";              // replayUnMute
plgReplNames[plgReplMIRC = (idx += 1)] =    "&+ Markers include replayed sounds     G";                     // recOptMarkReplay
plgReplNames[plgReplStep = (idx += 1)] =    "&+ Step Mode                                           S";     // playModeStep
plgReplNames[plgJmpLoop = (idx += 1)] =     "&+ Immediate jump into Loop                 J";                // playJmpLoop
plgReplNames[plgSkipSlnc = (idx += 1)] =    "&+ Skip long silences                               E";        // playSkipSlnc
plgReplNames[plgRepLoop = (idx += 1)] =     "&+< Repeat Mode                                       L";      // playRepeatMd
plgReplLastId = idx+1;

menu_plrepl = make_jmenu(
    ui_jmenu_typ_opt | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "repModes", plgReplLastId, plgReplNames);


markersWA = make_array(128);
playSpeedVals = make_array(11);
playSpeedPtr = 0;
playSpeedVals[0] =  1;  playSpeedVals[1] =  1.5;
playSpeedVals[2] =  2;  playSpeedVals[3] =  2.5;
playSpeedVals[4] =  -2.5;  playSpeedVals[5] =  -2;
playSpeedVals[6] =  -1.5;  playSpeedVals[7] =  -1;
playSpeedVals[8] =  -0.5;  playSpeedVals[9] =  0;
playSpeedVals[10] =  0.5;

//====== PLAY STORE MANAGEMENT ======

// First : all related variables
pPlayTimeCurrent = pRecTimeCurrent = 0;
playersCount = 0;

recModeOff = 0; // recorder stopped
recModePause = 2; // pausing while Recording
recModeOn = 3; // recording

recOptLockSnds = 0;
recOptRecReplay = 0;
recOptMarkReplay = 1;

replayModeOff = 0; // replaying off
replayModePause = 1;  // pausing while replaying
replayModeOn = 2; // replaying
playRModeNow = 8; // now

pRecCount = 0;
pMAltOff = recModeOff;
pMAltOn = playRModeNow;

recordMode = recModeOn; // mode
replayMode = replayModeOff;
replayEntry = 0;
replayUnMute = 1;


pTDelta = 0;
pTDispF = 0;
pTEpsilon = 0.001; // temporal epsilon
playModeSpeed = 1;
playFward = 1;
playModeRVolume = 1;
playLastTime = -1;  // last date a player was playing & recorded
playLastAlloc = -1; // last anchor recorded
playTime2Next = 0;
playTimeMax = 0;
playReeval = 1;
playSkipDur = 30; // duration for "playSkipSlnc" option
// Various options for play mode
playFlags = 0;
playGoNext = 0;
playAndStop = 0;
playAutoStop = 0;
playModeStep = 0;
playAndLock = 0;
playAndUnLock = 0;
playRepeatMd = 0;
playSkipSlnc = 0;
playEpilog = 10;
playAllow = 0;
playJmpLoop = 0;
playMarkCopy = 0;
playMarkDelete = 0;
playItemsFlags = 0;

// ??
playpttbsSize = 100;
playTimes = make_array(playpttbsSize+2); memset(playTimes, 0, playpttbsSize+2);
playEntries = make_array(playpttbsSize+2); memset(playEntries, -2, playpttbsSize+2);
playTimes[playpttbsSize] = playStep = 1;


padPlayStoreNL = 10; // 8;
padPlayStoreNC = 10; // 8;
padPlayStoreSiz = padPlayStoreNL * padPlayStoreNC;
padPlayStorep = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padPlayStoreNL, padPlayStoreNC, padPlayStoreSiz);
padPlayStoreLabs = padPlayStorep + padPlayStorep[ui_jpad_labs]; // addresses of labels
padPlayStoreColrs = padPlayStorep + padPlayStorep[ui_jpad_clrs]; // addresses of colors
padPlayStoreCells = padPlayStorep + padPlayStorep[ui_jpad_cells]; // addresses of cells desc.
padPlayStoreVals = padPlayStorep + padPlayStorep[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padPlayStoreSiz,
            padPlayStoreColrs[ii] = Col_Inactive;
            padPlayStoreLabs[ii] = "";
            ii+=1;
);

padPlayStoreMod = -1; // last cell modified
padPlayStoreMDate = 0;

GXUnit = UGAddr; // default GXUnit
psKPlaySiz = 128;
clESize = padPlayStoreSiz ; //
psKPlaying = make_array(2 * psKPlaySiz + 2 * clESize); // This keep an instantaneous set of all players # currently playing
memset(psKPlaying, -1, 2 * psKPlaySiz + clESize);
psKReplaying = psKPlaying + psKPlaySiz;
clTabE = psKReplaying + psKPlaySiz; // Entries of the play pad
clTabFl = clTabE + clESize; // various infos about the play pad
pKP = 0;
// Structure of a log play pad entry
// 0 to 3 : list management
lppEType = 4; // Type of the entry
lppEFlgs = 5; // various flags
lppEElct = 6; // Item count
lppECurItem = 7; // current selected item
lppEItmIncr = 8; // item increment
lppED1st = 9; // recorded Date of first sound
lppEDate = 10; // Marking date
lppEDurat = 11; // total duration
lppESpeed = 12; // replay speed
lppEWait = 13; // time to wait
lppETpCnt = 14; // Total number of sounds to play
lppEMetro = 15; // Metronome reference
lppEPsnd = 16; // Position of first item

lppLoop1 = -1;
lppLoop2 = -1;
lppLoopMd = 0;
lppRepDate = 0;
lppRepNum = 0;
lppEFlgInact = 0x10;

// Play Store Menu Management
psmMSiz = 64;
psmMNames = make_array(psmMSiz);
itdsp = 0;
psmMNames[itdsp] = ">Type";
psmMNames[psmMEnt0 = (itdsp += 1)] = "&1Inactive";
psmMNames[(itdsp += 1)] = "&1Mark point";
//psmMNames[psmMLP1 = (itdsp += 1)] = "&1Loop point 1";
//psmMNames[psmMLP2 = (itdsp += 1)] = "&1Loop point 2";
psmMNames[psmPosSS = (itdsp += 1)] = "&1Single sound";
psmMNames[(itdsp += 1)] = "&1Random sound";
psmMNames[(itdsp += 1)] = "&1Round Robin";
psmMNames[(itdsp += 1)] = "&1Ensemble";
psmMNames[(itdsp += 1)] = "&1Sequence";
psmMenuTypeEnd = itdsp + 1 ;
psmMNames[(itdsp += 1)] = "&1<Change Type          Y";

//psmMNames[(itdsp += 1)] = "";
psmMNames[(itdsp += 1)] = ">Date";
psmMNames[psmMMarker = (itdsp += 1)] = "&2Mark date";
psmMNames[(itdsp += 1)] = "&2First item";
psmMNames[(itdsp += 1)] = "&2Last item";
psmMNames[(itdsp += 1)] = "&2<Sequence end";
psmMenuMarkerEnd = itdsp + 1 ;

// Precise sunchro on beat and metronome not yet ready...
//psmMNames[(itdsp += 1)] = "";
//psmMNames[(itdsp += 1)] = ">Sync";
//psmMNames[(itdsp += 1)] = "&3None";
psmMSyncNo = itdsp;
//psmMNames[(itdsp += 1)] = "&3Auto";
//psmMNames[(itdsp += 1)] = "&3Metro 1";
//psmMNames[(itdsp += 1)] = "&3Metro 2";
//psmMNames[(itdsp += 1)] = "&3Metro 3";
//psmMNames[(itdsp += 1)] = "&3<Metro 4";
psmMenuSynchroEnd = itdsp + 1 ;


//psmMNames[(itdsp += 1)] = "";
psmMNames[(itdsp += 1)] = ">Lay out";
psmMNames[psmMMVLeft = (itdsp += 1)] = "&/Move left";
psmMNames[psmMMVRight = (itdsp += 1)] = "&/Move right";
psmMNames[psmMMVUp = (itdsp += 1)] = "&/Move up";
psmMNames[psmMMVDown = (itdsp += 1)] = "&/Move down";
psmMNames[psmMPshLeft = (itdsp += 1)] = "&/Push left";
psmMNames[psmMPshRight = (itdsp += 1)] = "&/Push right";
psmMNames[psmLODup = (itdsp += 1)] = "&/Duplicate                   D";
psmMNames[psmLOCut = (itdsp += 1)] = "&/Cut                             X";
psmMNames[psmLOCpy = (itdsp += 1)] = "&/Copy                          C";
psmMNames[psmLOPst = (itdsp += 1)] = "&/<Paste                         V";


//psmMNames[(itdsp += 1)] = "";
psmMNames[(itdsp += 1)] = ">Options";
psmMNames[psmOptInact = (itdsp += 1)] = "&+Toggle inactive          N";
psmMNames[psmOptLppnt = (itdsp += 1)] = "&+<Toggle loop point      F";


//psmMNames[(itdsp += 1)] = "";
psmMNames[(itdsp += 1)] = ">Edit";
psmMNames[psmEdit0 = (itdsp += 1)] = "&/Add 1 ms              ⌥⌘▶︎";
psmMNames[psmEdit1 = (itdsp += 1)] = "&/Add 10 ms               ⌥▶︎";
psmMNames[psmEdit2 = (itdsp += 1)] = "&/Add 100 ms             ⌘▶︎";
psmMNames[psmEdit3 = (itdsp += 1)] = "&/Add 1 s                        ▶︎";
psmMNames[psmEdit4 = (itdsp += 1)] = "&/Add 10 s                     ▲";
psmMNames[psmEdit5 = (itdsp += 1)] = "&/Add 1'                      ⌘▲";
psmMNames[psmEdit6 = (itdsp += 1)] = "&/Add 5'                     ⌥▲";
psmMNames[psmEdit7 = (itdsp += 1)] = "&/Add 30'                ⌥⌘▲";
psmMNames[psmEdit8 = (itdsp += 1)] = "&/Sub 1 ms              ⌥⌘◀︎";
psmMNames[psmEdit9 = (itdsp += 1)] = "&/Sub 10 ms               ⌥◀︎";
psmMNames[psmEdit10 = (itdsp += 1)] = "&/Sub 100 ms             ⌘◀︎";
psmMNames[psmEdit11 = (itdsp += 1)] = "&/Sub 1 s                        ◀︎";
psmMNames[psmEdit12 = (itdsp += 1)] = "&/Sub 10 s                      ▼";
psmMNames[psmEdit13 = (itdsp += 1)] = "&/Sub 1'                       ⌘▼";
psmMNames[psmEdit14 = (itdsp += 1)] = "&/Sub 5'                      ⌥▼";
psmMNames[psmEdit15 = (itdsp += 1)] = "&/Sub 30'                 ⌥⌘▼";
psmMNames[psmEdit16 = (itdsp += 1)] = "&/Round to 1 ms      ⌥⌘=";
psmMNames[psmEdit17 = (itdsp += 1)] = "&/Round to 10 ms       ⌥=";
psmMNames[psmEdit18 = (itdsp += 1)] = "&/Round to 100 ms     ⌘=";
psmMNames[psmEdit19 = (itdsp += 1)] = "&/Round to 1 s                =";
psmMNames[psmEdit20 = (itdsp += 1)] = "&/Round to 10 s              :";
psmMNames[psmEdit21 = (itdsp += 1)] = "&/Round to 1'               ⌘:";
psmMNames[psmEdit22 = (itdsp += 1)] = "&/Round to 5'              ⌥:";
psmMNames[psmEdit23 = (itdsp += 1)] = "&/Round to 30'         ⌥⌘:";
psmMenuITC = itdsp + 1 ;

menu_Pad_psm = make_jmenu(ui_jmenu_typ_opt | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "Play pad menu", psmMenuITC, psmMNames);

menu_Pad_clrs = make_array(16);
itdsp = -1;
menu_Pad_clrs[itdsp += 1] = Color_Cadet_Blue_A; // inactive
menu_Pad_clrs[itdsp += 1] = Color_Light_Green; // marker
//menu_Pad_clrs[itdsp += 1] = Color_Dark_Olive_Green; // loop point 1
//menu_Pad_clrs[itdsp += 1] = Color_Forest_Green; // loop point 2
menu_Pad_clrs[itdsp += 1] = Color_Light_Blue; // single sound
menu_Pad_clrs[itdsp += 1] = Color_Std_Blue; // random sound
menu_Pad_clrs[itdsp += 1] = Color_Cerulean_Blue; // RR sound
menu_Pad_clrs[itdsp += 1] = Color_Brilliant_Yellow; // Chord
menu_Pad_clrs[itdsp += 1] = Color_Goldenrod; // sequence
menu_Pad_clrs[itdsp += 1] = Color_Yellow_Green;
menu_Pad_clrs[itdsp += 1] = Color_Purple;
menu_Pad_clrs[itdsp += 1] = Color_Blue_Violet;
menu_Pad_clrs[itdsp += 1] = Color_Dark_Olive_Green;
menu_Pad_clrs[itdsp += 1] = Color_Persian_Indigo;

//====== PRESETS MANAGEMENT ======


padPresetsNL = 1;
padPresetsNC = 8;
padPresetsSiz = padPresetsNL * padPresetsNC;
padPresetsp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padPresetsNL, padPresetsNC, padPresetsSiz);
padPresetsLabs = padPresetsp + padPresetsp[ui_jpad_labs]; // addresses of labels
padPresetsColrs = padPresetsp + padPresetsp[ui_jpad_clrs]; // addresses of colors
padPresetsCells = padPresetsp + padPresetsp[ui_jpad_cells]; // addresses of cells desc.
padPresetsVals = padPresetsp + padPresetsp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padPresetsSiz,
            padPresetsColrs[ii] = Col_Inactive;
            padPresetsLabs[ii] = "";
            ii+=1;
);


/*
=== Preset description ===
*/
// Presets start at 1024 up to 13312
BCtrlInfoSize = 128;
serialDelta = serialBlock; // current position in preset
serialHead = 8; // 1st 8 words describe the kind of preset loaded
serialLoad = serialSize - serialHead; // 12288 - 8 = 12280
serialBlockV = serialBlock + serialHead;

// serialBlock + 0
// Subblock 1 - individual variables - @0, Size 128
Pr7_pr_vers = 0;
Pr7_pr_check = 1;
Pr7_pr_aux1 = 2;
Pr7_pr_aux2 = 3;
//
Pr7_PlayGrp = 8;
Pr7_PlayBnk = 9;
Pr7_PlayPart = 10;
Pr7_PlayPM = 11;
Pr7_PlaySM = 12;
Pr7_PlayCl0 = 13;
Pr7_PlayCl1 = 14;
Pr7_PlayCl2 = 15;
Pr7_BKV0 = 16;
Pr7_SMV0 = 17;
Pr7_PMV0 = 18;
Pr7_PlayTyp = 19;
Pr7_PrefDPanes = 20;
Pr7_PrefDSize = 21;
Pr7_UplayControl = 22;
Pr7_SensorSize = 23;
Pr7_SensorNum = 24;
Pr7_FStrAliasesNum = 25;
Pr7_FStrAliasesCnt = 26;
Pr7_Partial0 = 32; // size: BKEsize = 12 values

BKEsize = 12; // size of a bank entry
Pr7_StudConf = Pr7_Partial0 + BKEsize;  // up to 8 panes
Pr7_StudRat = Pr7_StudConf + 8;  // size : 8 * 4
Pr7_Free = Pr7_StudRat + 8 * 4;


// Initialize studio configuration
p = serialBlock + Pr7_StudConf;
ii = 0; loop(8, p[ii] = 1; ii+= 1;);
p = serialBlock + Pr7_StudRat;
ii = 0; loop(8*4, p[ii] = 600; ii+= 1;);
// Subblock 2 - Packed strings -

// Subblock 3 - Play pad - @512,  a total of 4*padStTotSiz= 512
Pr7_PadStval = 512;

// serialBlock + 1024
// we sometimes use directly locations in the serialBlock
SlidersBlockA = serialBlock+1024; // uses actually (BCtrlInfoSize = 128) * 8 words
SlidersBlockB = SlidersBlockA+BCtrlInfoSize;
SlidersBlockC = SlidersBlockB+BCtrlInfoSize;
SlidersBlockD = SlidersBlockC+BCtrlInfoSize;
SlidersBlockE = SlidersBlockD+BCtrlInfoSize;
SlidersBlockF = SlidersBlockE+BCtrlInfoSize;
SlidersBlockG = SlidersBlockF+BCtrlInfoSize;
SlidersBlockH = SlidersBlockG+BCtrlInfoSize;


//
// use an array for various parameters
// serialBlock + 2048
// paramCount is defined as 256 in clip-lib
paramValues = serialDelta = serialBlock+2048;  // The address of all parameters values
serialDelta += paramCount;
paramStatus = serialDelta;  // The address of all parameters status
serialDelta += paramCount;
//

// serialBlock + 3072
// Defining displayable control blocks
dcbBlocksAll = serialDelta = serialBlock+3072; //  at least 2048

// serialBlock + 5120
serialDelta = serialBlock + 5120; //
// Players displaying 6*128 = 768
BplayerInfoCount = 4;
BplayerInfoReserve = 2;
Bplayers = serialDelta;
BplayerA = Bplayers;
BplayerB = BplayerA + BCtrlInfoSize;
BplayerC = BplayerB + BCtrlInfoSize;
BplayerD = BplayerC + BCtrlInfoSize;
// Reserve
BplayerE = BplayerD + BCtrlInfoSize;
BplayerF = BplayerE + BCtrlInfoSize;

serialDelta += BCtrlInfoSize * (BplayerInfoCount + BplayerInfoReserve);

//
serialDelta = serialBlock + 6144; //
Pr7_SysLinks = serialDelta; // keep up to 256 MIDI links


serialDelta = serialBlock + 7200; // free area
FlagsTbSiz = 32;
FlagsTbVals = serialDelta - FlagsTbSiz;
/// Actual use
serialUse = serialDelta - serialBlock;
// Check de non débordement
(serialUse > serialSize) ? err_sys_ini = 9925; // serialBlock overflow error

//====== PRESET BLOCK END ======



//====== DISPLAYERS ARRAY ======
DispCnt = 9;
DispFmt = make_array(DispCnt); // formats
DispHdr = make_array(DispCnt); // headers labels
DispVa1 = make_array(DispCnt); // value 1
DispVa2 = make_array(DispCnt); // value 2
DispIds = make_array(DispCnt); // numeric identifiers
DispUseNow = DispCnt-1;
ii=0; loop(DispCnt,
    DispFmt[ii] = "%s%s";
    DispHdr[ii] = "";
    DispVa1[ii] = DispVa2[ii] = "";
    DispIds[ii] = 0;
    ii+= 1;
);


//====== MIDI BUFFER ======
MIDImsgSize = 4; // Size of a MIDI message
MIDImsgNum = 128; // number of messages kept
MIDISensMinWRep = 5; // Midi Sensors Minimum Wait before Reapeat
MIDISensDefTout = 4; //default Time-out by item for MIDI Seq. recognition
MIDIbfSize = MIDImsgSize * MIDImsgNum;
MIDIMsgB = make_array(MIDIbfSize);
MIDIIdx = 0;
MIDI_Curr = 0;
MIDI_Flag = 0;
MIDI_Sens_mode = 0;
MIDILastSeq = make_array(8);
MIDIDates = make_array(16);

MIDISeqSiz = 32 * 256;
// MIDISeqCnt = 256;
MIDISeqncs = make_array(MIDISeqSiz);
MIDISeqPtr = 0;
// Maybe unused now ?
kmdlsize = 126;
kmdlist = make_array(kmdlsize+2);

// Last MIDI command received
MIDIlastcmd = make_array(8);

MIDI_msg1 = 0;
MIDI_msg2 = 0;
MIDI_msg3 = 0;
MIDI_pack = 0;
MIDI_msgTim = 0;

MIDI_LinkTY_CC = 0x11000;
MIDI_LinkTY_SV = 0x21000;
MIDI_LinkTY_Slid = 0x31000;
MIDI_LinkTY_Act = 0x22000;
MIDI_LinkMask = 0xFF000;
MIDI_LinkOper = 0x3FFF;
MIDI_LinkPar = 0xFFF;
Link_Type = 0;
Slider_Source_Ty = 0x1000;

sysKode = sysAct = sysPar1 = sysPar2 = sysVal = 0;

// Links table message => action
Links_TSiz = 1999; // a prime
Links_HTab = make_array(Links_TSiz);
Links_Actn = make_array(Links_TSiz);
Links_Par1 = make_array(Links_TSiz);
Links_Par2 = make_array(Links_TSiz);

// Waiting actions
W_Actions_Siz = 1024;
W_Actions_Ptr = 0;
W_Actions_Last = 0;
W_Actions_Flg = 1;
W_Actions_Ent = make_array(W_Actions_Siz);
W_Actions_Par = make_array(W_Actions_Siz);


function clearLinksTables()
(
    memset(W_Actions_Ent, -1, W_Actions_Siz);
    memset(Links_HTab, 0, Links_TSiz);
    memset(Links_Actn, 0, Links_TSiz);
    memset(Links_Par1, 0, Links_TSiz);
    memset(Links_Par2, 0, Links_TSiz);
);
clearLinksTables();


uix_MIDI_menu = make_jmenu(
    ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "MIDI", "clear all links");

function enterLink(ctl, act, val, ext)
local (h, xpos)
(
    h = ctl % Links_TSiz;
    xpos = -1;
    while ((Links_HTab[h] != 0) && (Links_HTab[h] != ctl))  (
        ((Links_HTab[h] === -1) && (xpos === -1)) ? xpos = h;
        h = (h + 113) % Links_TSiz;
    );
    (Links_HTab[h] != ctl) ? (
        (xpos >= 0) ? (h = xpos);
    );
    Links_HTab[h] = ctl;
    Links_Actn[h] = act;
    Links_Par1[h] = val;
    Links_Par2[h] = ext;
    MIDILogActive ? (
        sprintf(#s, "LINK %X%02X %X %g %g", 0|(ctl/256), ctl & 0xff, act, val, ext);
        mSL_log(SysLogBox, #s);
    );
);

function removeLink(ctl)
local(h)
(
    h = ctl % Links_TSiz;
    while ((Links_HTab[h] != 0) && (Links_HTab[h] != ctl))  (
        h = (h + 113) % Links_TSiz;
    );
    (Links_HTab[h] === ctl) ? (
        MIDILogActive ? (
            sprintf(#s, "REMOVE LINK %X%02X %X", 0|(ctl/256), ctl & 0xff, Links_Actn[h]);
            mSL_log(SysLogBox, #s);
        );
        Links_HTab[h] = -1;
        Links_Actn[h] = 0;
        Links_Par1[h] = 0;
        Links_Par2[h] = 0;
    );
);


function getLinkEntry(ctl)
local (h, act)
(
    h = ctl % Links_TSiz;
    act = -1;
    while ((act === -1) && (Links_HTab[h] != 0)) (
        (Links_HTab[h] === ctl) ? (
            act = h;
        );
        h = (h + 113) % Links_TSiz;
    );
    act;
);

// Find the "next" entry in the link table
lkpos = 0;
function findLink(kod)
local (res, cnt, kod)
(
    res = -1;
    kod &= MIDI_LinkOper; // the kod we are looking for
    cnt = Links_TSiz;
    while ((res === -1) && (cnt >= 0)) (
        (kod === (Links_Actn[lkpos] & MIDI_LinkOper)) ? (
            res = lkpos;
        );
        cnt -= 1; lkpos = (lkpos + 1) % Links_TSiz;
    );
    res;
);

function linkType(ctl)
(
    ctl & 0x80 ? 0x4000 : ctl & 0xF000;
);

// Look for a MIDI sequence
function findMIDIseq(ptr, dur2, dur3, dur4, dur5)
local (pMs, found, seqCnt, ssz, dur, cc, xcc, ps, i, flg)
(
    // Explore all sequences
    pMs = MIDISeqncs; seqCnt = MIDISeqSiz - 32; // allow 32 unused
    found = 0;
    AAAAAA_flg = -1;
    AAAAAA_dur2 =  dur2 ;
    AAAAAA_dur3 =  dur3 ;
    AAAAAA_dur4 =  dur4 ;
    AAAAAA_dur5 =  dur5 ;
    while ((found === 0) && ((ssz = pMS[0]) > 0) && ((cc = pMs[3]) > 0) && (seqCnt > 0)) (
        dur = pMs[2]; xcc = cc; // keep cc cnt
        (cc === 4) ? (flg = (dur4 <= dur);) :
        (cc === 3) ? (flg = (dur3 <= dur);) :
        (cc === 2) ? (flg = (dur2 <= dur);) :
        (flg = 1;);
        AAAAAA_flg = flg = flg & (pMs[1] === MIDI_Sens_mode);
        flg ? (
            AAAAAA_cc = cc;
            // zerr1 & zerr2 used as traces
            zerr1=dur3; zerr2=pMs[1];
            ps = pMs+4; // Points to capt. seq.
            i = 0;
            while (flg && (cc > 0)) (
                (ps[i] != ptr[i]) ? (flg = 0; zerr1=ps[i]; zerr2=ptr[i];) ;
                i += 1; cc -= 1;
            );
        );
        flg ? (
            found = pMs + xcc + 4; // return 1st kmd
            currSens = pMs[xcc+3]; // last sensor number
        );
        pMs += ssz;
        seqCnt -= 1;
    );
    AAAAAA_found = found;
);



// Create MIDI States colors
MIDI_Colors_Siz = 16;
MIDI_Colors_Base = make_array(MIDI_Colors_Siz);
MIDI_Colors_Base[0] = Color_Std_Green;
MIDI_Colors_Base[1] = Color_Std_Yellow;
MIDI_Colors_Base[2] = Color_Std_Blue;
MIDI_Colors_Base[3] = Color_Std_Orange;
MIDI_Colors_Base[4] = Color_Std_Cyan;
MIDI_Colors_Base[5] = Color_Std_Red;
MIDI_Colors_Base[6] = Color_Std_Magenta;
MIDI_Colors_Base[7] = Color_Std_Brown;
MIDI_Colors_Base[8] = Color_Barley_White;
MIDI_Colors_Base[9] = Color_Bisque_A;
MIDI_Colors_Base[10] = Color_Blizzard_Blue;
MIDI_Colors_Base[11] = Color_Cafe_Royale;
MIDI_Colors_Base[12] = Color_Dark_Pink;
MIDI_Colors_Base[13] = Color_Medium_Spring_Green;
MIDI_Colors_Base[14] = Color_Dark_Violet;
MIDI_Colors_Base[15] = Color_Persian_Indigo;


MIDI_Sensors_Max = 16; // Max number of connected sensors
MIDI_States_siz = 32;  //  MIDI States count
MIDI_States_Max_siz = 32;  //  MIDI States count
InSensColorSize = 36;  // Each with this number of colors

MIDI_Colors_Set = make_array(MIDI_States_Max_siz);

ii = 0; loop(MIDI_States_Max_siz,
    MIDI_Colors_Set[ii] = make_array(InSensColorSize);
    set_pcolors_array(MIDI_Colors_Set[ii], InSensColorSize,
        MIDI_Colors_Base[ii % MIDI_Colors_Siz], Color_Dark_Gray,
        0.5, -1);
    ii += 1;
);




/*
=== Flags/Indicators sets ===
*/
//  FlagsTbSiz is 32
//  FlagsTbVals = of size FlagsTbSiz
Max_Flags = 0x80000000; // max "integer" value in a 32 bits float
FlagsTbNames = make_array(FlagsTbSiz);
FlagsTbNums = make_array(FlagsTbSiz);
// FlagsTbVals = make_array(FlagsTbSiz); // Now defined and saved in presets
idx = 0;
Flgs_mSLScr0 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "mSL Scripts 0"; idx += 1;
Flgs_mSLScr1 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "mSL Scripts 1"; idx += 1;
Flgs_mSLScr2 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "mSL Scripts 2"; idx += 1;
Flgs_mSLScr3 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "mSL Scripts 3"; idx += 1;
Flgs_Set_Pr = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Table Trace"; idx += 1;
Flgs_GC = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "GC Flags"; idx += 1;
Flgs_Scripts = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Scripts Flags"; idx += 1;
Flgs_Sys = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "System Flags"; idx += 1;
Flgs_Cplr = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Compiler Flags"; idx += 1;
Flgs_Plyers = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Players Flags"; idx += 1;
Flgs_Acts = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Actions Flags"; idx += 1;
Flgs_MIDI = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "MIDI Flags"; idx += 1;
Flgs_Play = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Play Flags"; idx += 1;
Flgs_Thrds = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Threads dbg"; idx += 1;
Flgs_PrOps = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "mSL Primit."; idx += 1;
Flgs_ConfLd = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Conf. Load"; idx += 1;
Flgs_TblUpd = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Table Updt."; idx += 1;
Flgs_Logs = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Log Flags"; idx += 1;
Flgs_AuxS = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Aux command"; idx += 1;
Flgs_AuxP1 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Aux par 1"; idx += 1;
Flgs_AuxP2 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Aux par 2"; idx += 1;
Flgs_AuxP3 = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Aux par 3"; idx += 1;
Flgs_Pdbg = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Play dbg"; idx += 1;
Flgs_Evnts = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Events dbg"; idx += 1;
Flgs_GFXTrcs = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "GFX Trace"; idx += 1;
Flgs_Umods = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "User Modules"; idx += 1;
Flgs_Inits = idx; FlagsTbVals[idx] = 0; FlagsTbNums[idx] = idx; FlagsTbNames[idx] = "Init/Load"; idx += 1;
FlagsCount = idx;
// Just check we are not adding too many items
(FlagsCount > FlagsTbSiz) ? err_sys_ini = 9926; // serialBlock error
// Sort Actions Menu
mSL_Sort_Strings(FlagsCount, 0, FlagsTbNames, FlagsTbNums, 0, 0);



//====== Macro Management ======

// work area to copy
Mac_WA_TSiz = 0x20000;  // reservation for macro expensions
Mac_WA_Temp = make_array(Mac_WA_TSiz); // texts of expensions
Mac_WA_Tptr = 1; // Preserve space for siez
Mac_WA_Siz = 0x10000; // reservation for macro texts
Mac_WA_HSiz = 1999;
Mac_WA_Dec = 17;
Mac_WA_Tab = make_array(Mac_WA_Siz); // texts of macros
Mac_WA_Hash = make_array(Mac_WA_HSiz);
Mac_WA_HPts = make_array(Mac_WA_HSiz);
Mac_WA_Ptmc = 1;
Mac_WA_ESiz = 50;
Mac_WA_Errs = make_array(Mac_WA_ESiz * 4);
Mac_WA_Pterr = 0;

Mac_WA_TSiz = 20;
Mac_WA_Tcrs = make_array(Mac_WA_TSiz * 4);
Mac_WA_Ptrcs = 0;

TabAddrMax = TabAddrMin = mSL_StM_FreePt; // min. address recognized for an array

// Note an error
function doESignal(Err, EP1, EP2, EP3)
local (p)
(
    p = Mac_WA_Errs + 4 * Mac_WA_Pterr;
    p[0] = Err; p[1] = EP1; p[2] = EP2; p[3] = EP3;
    Mac_WA_Pterr = (Mac_WA_Pterr + 1) % Mac_WA_ESiz;
    p = Mac_WA_Errs + 4 * Mac_WA_Pterr;
    p[0] = p[1] = p[2] = p[3] = mSL_Separator; // signal "last"
);


// Note a trace
function doTSignal(TR0, TR1, TR2, TR3)
local (p)
(
    p = Mac_WA_Tcrs + 4 * Mac_WA_Ptrcs;
    p[0] = TR0; p[1] = TR1; p[2] = TR2; p[3] = ETR3P3;
    Mac_WA_Ptrcs = (Mac_WA_Ptrcs + 1) % Mac_WA_TSiz;
    p = Mac_WA_Tcrs + 4 * Mac_WA_Ptrcs;
    p[0] = p[1] = p[2] = p[3] = 0; // signal "last"
);

// find a macrodefinition
function mac_pos(mname)
local (ent, cnt, alt, k)
(
    ent = mname % Mac_WA_HSiz;
    cnt = Mac_WA_HSiz;
    alt = -1;
    while (((k = Mac_WA_Hash[ent]) != mname) && (k != 0) && (cnt > 0))   (
        cnt -= 1;
        ((k === -1) && (alt === -1)) ? alt = ent;
        ent = (ent + Mac_WA_Dec) % Mac_WA_HSiz;
    );
    ((k != mname) && (k != 0)) ? (
        ent = -1;
        (alt >= 0) ? ent = alt;
    );
    ent;
);

// Enter a macrodefinition
function mac_enter(maddr, size)
local (mname, ent)
(
    mname =  maddr[0];
    ent = mac_pos(mname);
    (ent >= 0) ? (
        // Is there room left ?
        (Mac_WA_Ptmc + size + 3 < Mac_WA_Siz) ? (
            // save the macro
            Mac_WA_Hash[ent] = mname; // name of the macro
            Mac_WA_HPts[ent] = Mac_WA_Tab + Mac_WA_Ptmc; // mem. addr of the macro
            Mac_WA_Tab[Mac_WA_Ptmc] = mname; Mac_WA_Ptmc+=1;
            Mac_WA_Tab[Mac_WA_Ptmc] = size; Mac_WA_Ptmc+=1;
            loop(size, maddr += 1; Mac_WA_Tab[Mac_WA_Ptmc] = maddr[0]; Mac_WA_Ptmc+=1;);
            Mac_WA_Tab[0] = Mac_WA_Ptmc; // trace position
        ) : (
            ent = -1; // can't save
        );
    );
    ent;
);


//====== Actions Sets - simple ======
ActionTbSiz = 1024; // Nb total d'actions
ActionHsSiz = 1999;
ActionHsDec = 17;
ActionTbNames = make_array(ActionTbSiz); // full name
ActionShNames = make_array(ActionTbSiz); // short name
ActionTbNums = make_array(ActionTbSiz);
ActionTbFlgs = make_array(ActionTbSiz);
ActionHsTab = make_array(ActionHsSiz);
ActionHsNums = make_array(ActionHsSiz);
#ActionNeutral = "~~~~~~~~";
ActionReparse = 255;

// find an action
function act_pos(mname)
local (ent, cnt, alt, k)
(
    ent = mname % ActionHsSiz;
    cnt = ActionHsSiz;
    alt = -1;
    while (((k = ActionHsTab[ent]) != mname) && (k != 0) && (cnt > 0))   (
        cnt -= 1;
        ((k === -1) && (alt === -1)) ? alt = ent;
        ent = (ent + ActionHsDec) % ActionHsSiz;
    );
    ((k != mname) && (k != 0)) ? (
        ent = -1;
        (alt >= 0) ? ent = alt;
    );
    ent;
);

// ================== ACTIONS DEF ===================
idx = 0; loop (ActionTbSiz, ActionTbNames[idx] = #ActionNeutral; ActionShNames[idx] = 0;
               ActionTbNums[idx] = idx; idx += 1; );

idx = 255; ActionTbFlgs[idx] = 0x8000; // Not named "move" action
idx = 0; ActionTbNums[idx] = 0; ActionTbNames[idx] = "None"; ActionShNames[idx] = "None";
idx = 1; ActionTbNums[idx] = 300; ActionTbNames[idx] = "Auto Play off"; ActionShNames[idx] = "AutoOff";
idx = 2; ActionTbNums[idx] = 301; ActionTbNames[idx] = "Auto Play on"; ActionShNames[idx] = "AutoOn";
idx = 3; ActionTbNums[idx] = 302; ActionTbNames[idx] = "Auto Play on/off"; ActionShNames[idx] = "AutoTgl";
idx = 4; ActionTbNums[idx] = 303; ActionTbNames[idx] = "Stop all Players"; ActionShNames[idx] = "PlayStop";
idx = 5; ActionTbNums[idx] = 304; ActionTbNames[idx] = "Stop and Release"; ActionShNames[idx] = "PlStopR";
idx = 6; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Display pad #"; ActionShNames[idx] = "ShowPad";
idx = 7; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select Group"; ActionShNames[idx] = "SelGrp";
idx = 8; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Next Group"; ActionShNames[idx] = "NextGrp";
idx = 9; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Temp Play Flags"; ActionShNames[idx] = "TmpPlFlg";
idx = 10; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Default Play Flags"; ActionShNames[idx] = "DefPlFlg";
idx = 11; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 0"; ActionShNames[idx] = "SelPad0";
idx = 12; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 1"; ActionShNames[idx] = "SelPad1";
idx = 13; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 2"; ActionShNames[idx] = "SelPad2";
idx = 14; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 3"; ActionShNames[idx] = "SelPad3";
idx = 15; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 4"; ActionShNames[idx] = "SelPad4";
idx = 16; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 5"; ActionShNames[idx] = "SelPad5";
idx = 17; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 6"; ActionShNames[idx] = "SelPad6";
idx = 18; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad 7"; ActionShNames[idx] = "SelPad7";
idx = 19; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad next"; ActionShNames[idx] = "SelNxPad";
idx = 20; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad previous"; ActionShNames[idx] = "SelPrPad";
idx = 21; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Play clip of group"; ActionShNames[idx] = "PlayGrp";
idx = 22; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select SM [tmp] (_)";  ActionShNames[idx] = "TempSMd";ActionTbFlgs[idx] = 1;
idx = 23; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select PM [tmp] (_)";  ActionShNames[idx] = "TempPMd"; ActionTbFlgs[idx] = 1;
idx = 24; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select SM (p0) (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "SetSMd";
idx = 25; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select PM (p0) (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "SetPMd";
idx = 26; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select HPset [tmp] (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "TempHPs";
idx = 27; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select Bank [tmp] (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "TempBnk";
idx = 28; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select Duration [tmp] (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "TempDur";
idx = 29; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select Volume [tmp] (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "TempVol";
idx = 30; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Interrupt Cl. off";  ActionShNames[idx] = "NoInterr";
idx = 31; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Select Gr.Fades [tmp] (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "TmGraFd";
idx = 32; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Set Max Players (_)"; ActionTbFlgs[idx] = 1; ActionShNames[idx] = "SetMaxP";
idx = 33; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Rand. Event (...)"; ActionShNames[idx] = "RndEvnt"; ActionTbFlgs[idx] = 0x100; // variable, stop at "-1"
idx = 34; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Set Param (_,_)"; ActionShNames[idx] = "SetParam"; ActionTbFlgs[idx] = 0x2;
idx = 35; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Wait (_,0)"; ActionShNames[idx] = "Wait"; ActionTbFlgs[idx] = 2;
idx = 36; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Cond. exec (_)"; ActionShNames[idx] = "CondExec"; ActionTbFlgs[idx] = 1;
idx = 37; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Log Message"; ActionShNames[idx] = "LogMess"; ActionTbFlgs[idx] = 1;
idx = 38; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor Set lock (_,_)"; ActionShNames[idx] = "SensLokS"; ActionTbFlgs[idx] = 2;
idx = 39; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Copy Partiel _"; ActionShNames[idx] = "CopyPart"; ActionTbFlgs[idx] = 1;
idx = 40; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor Set Unlock"; ActionShNames[idx] = "SensULkS"; ActionTbFlgs[idx] = 1;
idx = 41; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Stop and Clear"; ActionShNames[idx] = "PlStopC";
idx = 42; ActionTbNums[idx] = idx+299; ActionTbNames[idx] = "Sensor pad #(_)"; ActionShNames[idx] = "SensPadX"; ActionTbFlgs[idx] = 1;
idx = 43; ActionTbNums[idx] = 342; ActionTbNames[idx] = "Sensor lock (_,_)"; ActionShNames[idx] = "SensLok2"; ActionTbFlgs[idx] = 2;
idx = 44; ActionTbNums[idx] = 343; ActionTbNames[idx] = "MIDI Add Dummy"; ActionShNames[idx] = "MIDAddDu";
idx = 45; ActionTbNums[idx] = 344; ActionTbNames[idx] = "Sensors release"; ActionShNames[idx] = "SensRel";
idx = 46; ActionTbNums[idx] = 345; ActionTbNames[idx] = "MIDI Add evnt (_,_)"; ActionShNames[idx] = "MIDAddEv"; ActionTbFlgs[idx] = 2;
idx = 47; ActionTbNums[idx] = 346; ActionTbNames[idx] = "Set vol. bias (_)"; ActionShNames[idx] = "SetVBias"; ActionTbFlgs[idx] = 1;
idx = 48; ActionTbNums[idx] = 347; ActionTbNames[idx] = "Set volume (_)"; ActionShNames[idx] = "SetVol"; ActionTbFlgs[idx] = 1;
idx = 49; ActionTbNums[idx] = 348; ActionTbNames[idx] = "Sensor lock (_)";  ActionShNames[idx] = "SensLok1"; ActionTbFlgs[idx] = 1;
idx = 50; ActionTbNums[idx] = 349; ActionTbNames[idx] = "Play clip (_)"; ActionShNames[idx] = "PlayClip"; ActionTbFlgs[idx] = 1;
idx = 51; ActionTbNums[idx] = 350; ActionTbNames[idx] = "Play cl. unmod. (_)"; ActionShNames[idx] = "PlayUnmd"; ActionTbFlgs[idx] = 1;
idx = 52; ActionTbNums[idx] = 351; ActionTbNames[idx] = "Play Rand. Cl. (...)"; ActionShNames[idx] = "PlayRnd"; ActionTbFlgs[idx] = 0x100; // variable, stop at "-1"
idx = 53; ActionTbNums[idx] = 352; ActionTbNames[idx] = "Play clip (_,Fl)"; ActionShNames[idx] = "PlayFlg"; ActionTbFlgs[idx] = 2;
idx = 54; ActionTbNums[idx] = 353; ActionTbNames[idx] = "Play RR. Cl. (0,...)"; ActionShNames[idx] = "PlayRndN"; ActionTbFlgs[idx] = 0x301; // variable, stop at "-1"
idx = 55; ActionTbNums[idx] = 354; ActionTbNames[idx] = "Play Seq. Cl. (0,...)"; ActionShNames[idx] = "PlaySeq"; ActionTbFlgs[idx] = 0x301; // variable, stop at "-1"
idx = 56; ActionTbNums[idx] = 355; ActionTbNames[idx] = "Play Ex. Cl. (0,...)"; ActionShNames[idx] = "PlayExh"; ActionTbFlgs[idx] = 0x301; // variable, stop at "-1"
idx = 57; ActionTbNums[idx] = 356; ActionTbNames[idx] = "Play 0,{clips}"; ActionShNames[idx] = "PlaySet"; ActionTbFlgs[idx] = 0x601; // variable, stop at "-111"
idx = 58; ActionTbNums[idx] = 357; ActionTbNames[idx] = "Play clip from Set"; ActionShNames[idx] = "PlFrSet"; ActionTbFlgs[idx] = 1;
idx = 59; ActionTbNums[idx] = 358; ActionTbNames[idx] = "Play clip from Set Limited"; ActionShNames[idx] = "PlFrSetL"; ActionTbFlgs[idx] = 1;
idx = 60; ActionTbNums[idx] = 359; ActionTbNames[idx] = "Notify process"; ActionShNames[idx] = "Notify"; ActionTbFlgs[idx] = 8;

idx = 101; ActionTbNames[idx] = "Aux. Script Version"; ActionShNames[idx] = "ASVers";  //
idx = 102; ActionTbNames[idx] = "Aux. Script Flags"; ActionShNames[idx] = "ASFlgs"; //
idx = 103; ActionTbNames[idx] = "Aux. Script Res X"; ActionShNames[idx] = "ASRetX"; ActionTbFlgs[idx] = 1; //
idx = 104; ActionTbNames[idx] = "Aux. Script Res"; ActionShNames[idx] = "ASRet";  //
idx = 105; ActionTbNames[idx] = "Aux. Script Done"; ActionShNames[idx] = "ASWDone";  //
idx = 106; ActionTbNames[idx] = "Aux. Script Busy"; ActionShNames[idx] = "ASWBusy";  //
idx = 107; ActionTbNames[idx] = "Value: Unavail"; ActionShNames[idx] = "Unavail";  //


idx = 111; ActionTbNames[idx] = "Aux. Script Set Fl."; ActionShNames[idx] = "ASSetTr"; ActionTbFlgs[idx] = 1; //
idx = 112; ActionTbNames[idx] = "Go nth. Marker"; ActionShNames[idx] = "GoNtMark"; ActionTbFlgs[idx] = 1; //
idx = 113; ActionTbNames[idx] = "Go Marker M"; ActionShNames[idx] = "GoMark"; ActionTbFlgs[idx] = 1; //
idx = 114; ActionTbNames[idx] = "Start playing"; ActionShNames[idx] = "StrtRead";  //
idx = 115; ActionTbNames[idx] = "Stop playing"; ActionShNames[idx] = "StopRead";  //
idx = 116; ActionTbNames[idx] = "Pause playing"; ActionShNames[idx] = "PauzRead";  //
idx = 117; ActionTbNames[idx] = "Get Play position"; ActionShNames[idx] = "GetPPos";  //
idx = 118; ActionTbNames[idx] = "Get Play position 2"; ActionShNames[idx] = "GetPPos2";  //
idx = 119; ActionTbNames[idx] = "Get Play Status"; ActionShNames[idx] = "GetPStat";  //
idx = 120; ActionTbNames[idx] = "Get Edit position"; ActionShNames[idx] = "EdtCurP";  //
idx = 121; ActionTbNames[idx] = "Move Edit position"; ActionShNames[idx] = "MvEdPos"; ActionTbFlgs[idx] = 1; //
idx = 122; ActionTbNames[idx] = "Move Edit position 2"; ActionShNames[idx] = "MvEdPos2"; ActionTbFlgs[idx] = 1; //
idx = 123; ActionTbNames[idx] = "Move to start"; ActionShNames[idx] = "MvEdStrt";  //
idx = 124; ActionTbNames[idx] = "Get Play Rate"; ActionShNames[idx] = "ProjPRat";  //
idx = 125; ActionTbNames[idx] = "Execute REAPER Action"; ActionShNames[idx] = "ReAct"; ActionTbFlgs[idx] = 1; //

idx = 128; ActionTbNames[idx] = "Stop Script"; ActionShNames[idx] = "ASStop";  //


ActionCount = idx + 1;

// Give a short/long name to any action
idx = 0; loop (ActionTbSiz, (ActionShNames[idx] === 0) ? ActionShNames[idx] = ActionTbNames[idx];
                            (ActionTbNames[idx] === 0) ? ActionTbNames[idx] = ActionShNames[idx];   idx += 1; );
// Enter short actions names in the hash table
idx = 0; loop (ActionTbSiz,
    (strcmp(ActionShNames[idx], #ActionNeutral) != 0) ? (
        // enter action name in hash table
        aname = mSL_symbol(ActionShNames[idx]);
        ent = act_pos(aname);
        (ent >= 0) ? (
            ActionHsTab[ent] = aname;
            ActionHsNums[ent] = ActionTbNums[idx];
            (FlagsTbVals[Flgs_Acts] & 16) ? (
                sprintf(#s, "—>   Action  '%s'  /  %d  =>  %d", mSL_edit_value(#u, aname), ActionHsNums[ent], ent);
                mSL_log(SysLogBox, #s);
            );
        );
    );
    idx += 1;
);

action_num = 0;
action_ent = 0;

mSL_Sort_Strings(ActionCount, 0, ActionTbNames, ActionShNames, ActionTbNums, 0);

while (strcmp(ActionTbNames[ActionCount-1], #ActionNeutral) === 0) ( ActionCount -= 1; );

menu_Actions = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "actions", ActionCount, ActionTbNames);




menu_Flags = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "flags", FlagsCount, FlagsTbNames);
Settings_F_Sel = 0;

// Two more players control blocks, to exchange with...
//  BCtrlInfoSize = 128
BplayerG = make_array(BCtrlInfoSize);
BplayerH = make_array(BCtrlInfoSize);
// Addresses of all these blocks
bplMenuAddrs = make_array(8);


//====== Special LEDS and RANDOMSTATES ======
parLedA = make_jled(ui_jled_mk_interact|ui_jled_mk_actOnSel, 0.9, -1, Color_Bright_Green);
parLedA[ui_jled_r] = 0.4;
parLedB = make_jled(ui_jled_mk_interact|ui_jled_mk_actOnSel, 0.9, -1, Color_Bright_Green);
parLedB[ui_jled_r] = 0.4;


ledR1 = make_jled(ui_jled_mk_interact, 0.9, -1, Color_Std_Red);
ledR1[ui_jled_r] = 0.4;
ledR1[ui_jled_status]=1;
ledR1[ui_jled_menu1]=1; // use left clic to invert

// The random color menu
iledColMenu = make_jmenu(ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "cols", "1-Red|2-Orange|3-Yellow|4-Green|5-Cyan|6-Blue|7-Magenta|8-Pink");
parLedA[ui_jled_menu2]=iledColMenu;
parLedA[ui_jled_menu1]=1; // use left clic to invert
parLedB[ui_jled_menu2]=iledColMenu;
parLedB[ui_jled_menu1]=1; // use left clic to invert

//====== PARAMETERS MANAGEMENT ======
/*
    Most is done in "GP_Parameters.jsfx-inc"
*/

// paramCount is 256   ; paramEntSize = 20
(pp_EntSize > paramEntSize) ? err_sys_ini = 9936; // paramEntSize error
(p_ActSize > paramCount) ? err_sys_ini = 9937; // paramCount error

paramBlock = make_array(paramCount * paramEntSize);
paramFlags = make_array(paramCount);
paramPrevValues = make_array(paramCount);
param_last_touched = 1;
param_current = -1;
param_last_current = -2;
param_touch_count = 0;
param_touch_last = -1;
param_current_min = 0;
param_current_max = 0;
param_current_min_m = 0;
param_current_max_m = 0;
key_strike_count = 0;
key_strike_last = -1;
key_last_in = '?';
paramDynCnt = 0; // actually used
// The reference pad
padDynPrstNL = 4;
padDynPrstNC = 16;
padDynPrstSiz = padDynPrstNL * padDynPrstNC;
padDynPrstSizT = padDynPrstSiz + 5;
// Array of parameters values : (64+5) * 28
arrDyns = make_array(paramDynSiz * padDynPrstSizT);
// paramType defined as paramDynSiz - 1;

paramDynCopy65 = arrDyns + paramDynSiz * padDynPrstSiz; // "copy" of the values
paramDynamic66 = paramDynCopy65 + paramDynSiz; // dynamic copy of active parameters
paramDynamic67 = paramDynamic66 + paramDynSiz; // dynamic copy of active parameters
paramDynDefault68 = paramDynamic67 + paramDynSiz; // default values
paramDyn = paramDynDefault68 + paramDynSiz; // list of the parameters
paramDynIds = make_array(32); // list of the parameters ids
paramDynNums = make_array(32); // list of the parameters numbers
paramDynBstMin = make_array(32); // "appropriate" minimum values for parameters
paramDynBstMax = make_array(32); // "appropriate" maximum values for parameters
#parId = "-";

// Hash table for parameters coded names
//paramHashIds = make_array(paramHSiz);
//paramHashNbs = make_array(paramHSiz);
paramHashTbl = mSL_makeHT(paramHSiz, paramHStep);
paramHStep = paramHashTbl[-1]; // in case the func updated the step

//  Hash table for JSFX vars access
jvarsHashTbl = mSL_makeHT(128 + 0|(1.35*mSL_JSFX_var_count), 6121);
jvarsHStep = jvarsHashTbl[-1];
jvarsHSize = jvarsHashTbl[-2];

// Create the entries
mSL_dcl_JSFX_vars();

// Table of Sound Units by Track number
SUTrASize = 16 + uCnt;
SUTrAddr = make_array(SUTrASize);

// Menus for main sliders controls
paramMSLMenuNames = make_array(paramCount+1);
paramMSLMenuNums = make_array(paramCount+1);
menu_Param_mSL = 0;
paramMSLMenuSize = 0;

// Menus for players sliders controls
paramUBSLMenuNames = make_array(paramCount+1);
paramUBSLMenuNums = make_array(paramCount+1);
menu_Param_UBS = 0;
paramUBSLMenuSize = 0;

// Menus for players display controls
displayAdd = 128;
paramUBDsMenuNames = make_array(paramCount+displayAdd+1);
paramUBDsMenuNums = make_array(paramCount+displayAdd+1);
menu_Param_UBD = 0;
paramUBDsMenuSize = 0;

// Sliders Menu
GUI_Sliders_Menu_Block = mSL_StM_Alloc(ui_jmenu_items+paramCount+1, 'Menu', mSL_StM_FlClear);
// Parameters Menu
GUI_Parameters_Menu_Block = mSL_StM_Alloc(ui_jmenu_items+paramCount+1, 'Menu', mSL_StM_FlClear);
// Parameters/Indicators Menu
GUI_ParDisp_Menu_Block = mSL_StM_Alloc(ui_jmenu_items+paramCount+displayAdd+1, 'Menu', mSL_StM_FlClear);

// Menus for players buffers control...
bplMenuNames = make_array(64);
idx = -1;
bplMenuNames[idx += 1] = "Lock";
bplLock = idx+1; // actual menu nums are NOT name indices !
bplMenuNames[idx += 1] = "Stop";
bplStop = idx+1; // actual menu nums are NOT name indices !
bplMenuNames[idx += 1] = "Duplicate";
bplDuplicate = idx+1; // actual menu nums are NOT name indices !
bplMenuNames[idx += 1] = "Restart as player";
bplRestartPlay = idx+1;
bplMenuNames[idx += 1] = "Restart as looper";
bplRestartLoop = idx+1;
bplMenuNames[idx += 1] = "Play new clip";
bplNewPlay = idx+1;
bplMenuNames[idx += 1] = "Loop new clip";
bplNewLoop = idx+1;
bplMenuNames[idx += 1] = "Update HP conf";
bplHPConf = idx+1;
bplMenuNames[idx += 1] = ">Layout change";
bplCopy = idx + 1;
bplMenuNames[idx += 1] = "copy A => E"; bplMenuNames[idx += 1] = "copy A => F";
bplMenuNames[idx += 1] = "copy A => G"; bplMenuNames[idx += 1] = "copy A => H";
bplMenuNames[idx += 1] = "copy B => E"; bplMenuNames[idx += 1] = "copy B => F";
bplMenuNames[idx += 1] = "copy B => G"; bplMenuNames[idx += 1] = "copy B => H";
bplMenuNames[idx += 1] = "copy C => E"; bplMenuNames[idx += 1] = "copy C => F";
bplMenuNames[idx += 1] = "copy C => G"; bplMenuNames[idx += 1] = "copy C => H";
bplMenuNames[idx += 1] = "copy D => E"; bplMenuNames[idx += 1] = "copy D => F";
bplMenuNames[idx += 1] = "copy D => G"; bplMenuNames[idx += 1] = "copy D => H";
//
bplMenuNames[idx += 1] = "copy E => A"; bplMenuNames[idx += 1] = "copy E => B";
bplMenuNames[idx += 1] = "copy E => C"; bplMenuNames[idx += 1] = "copy E => D";
bplMenuNames[idx += 1] = "copy F => A"; bplMenuNames[idx += 1] = "copy F => B";
bplMenuNames[idx += 1] = "copy F => C"; bplMenuNames[idx += 1] = "copy F => D";
bplMenuNames[idx += 1] = "copy G => A"; bplMenuNames[idx += 1] = "copy G => B";
bplMenuNames[idx += 1] = "copy G => C"; bplMenuNames[idx += 1] = "copy G => D";
bplMenuNames[idx += 1] = "copy H => A"; bplMenuNames[idx += 1] = "copy H => B";
bplMenuNames[idx += 1] = "copy H => C"; bplMenuNames[idx += 1] = "<copy H => D";
bplCopyLast = idx;

// bplMenuNames[idx += 1] = "";

bplMenuNames[idx += 1] = ">Controls layout";
bplMenuNames[idx += 1] = "1 column";
bplMenuNames[idx += 1] = "<2 columns";
idx += 1; // Menu item count

// Menus
bplSLMenu = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "Moves", idx, bplMenuNames);

/*
    Displaying a parameter in a box
*/

function parShow(xpnum)
local (pp)
(
    ((xpnum > 0) && (xpnum < paramCount) && (xpnum == (0|xpnum))) ? (
        pp = paramBlock + xpnum * paramEntSize;
        (pp[pp_Name] != 0) ? (
            ui_show(pp[pp_Name], paramValues[xpnum], pp[pp_SFmt]);
        );
    ) : (
        ui_show(0);
    );
);



// All the actions definitions
Act_Play = 1;
Act_AutoSwitch = 2;
Act_ParSet = 3;
Act_GrpSwitch = 4;
Act_CtrlPlay = 5;
Act_RandPlay = 6;
Act_RevPlay = 7;
Act_StopPlay = 8;
Act_RandGen = 9;
// 10 : run an mSL thread +10+

//====== Audio=Clips=Formats ======

fFormats = make_array(16);
setFileFormats(fFormats);


//====== GRAPHICS ======
menu_bar_item_width = 88;
uix_doubleclicktime = 0.55;
ui_Xtime_period = 1; // refresh screen every Second
uix_jtheme_known = -1; // keep info about the theme




// Update clip info area
// ii = 0; loop (clTSize, gmem[clInfStart+ii] = 0; ii+= 1;);



// this, non zero, to indicate initialization complete
gmem[timeStartUp] = tUnix;

gmem[timeDay] = -1; // force recomputation
locT.DTG_update(tUnix); // unnecessary ?
timeGMemUpdate(); // may update winter time
timeGMemUpdate(); // now is probably good


// Edit the plug-in version
#GMversion = "";
sprintf(#GMversion, "GAME PLAYER ——— Version %d.%d.%d ——— %s", (GameMasterVersion >> 16),
         (GameMasterVersion >> 8) & 0xff, GameMasterVersion & 0xff, #CreationDate);
// Edit the start up time
#started = "";
sprintf(#started, "Start: %02d/%02d/%02d ", gmem[timeDay], gmem[timeMonth], gmem[timeYear]);
edTime(gmem[timeSecOfDay]);
strcat(#started, #edt);



function nowTime()
(
    sprintf(#nowis, "Now: %02d/%02d/%02d ", gmem[timeDay], gmem[timeMonth], gmem[timeYear]);
    edTimeL(gmem[timeSecOfDay]);
    strcat(#nowis, #edt);
);

nowTime();

function nowIs()
local(str)
(
    str = #;
    sprintf(str, "%02d/%02d/%04d ", gmem[timeDay], gmem[timeMonth], gmem[timeYear]);
    edTimeL(gmem[timeSecOfDay]);
    strcat(str, #edt);
);



//###### ALL INIT DONE, READY TO WORK
gmem[flagIDate] = tStart;
gmem[flagInited] = 1;




// Statistics handling
cbsecsize = 60; // 60 of them
cbuffsecs = make_array(cbsecsize); // buffer des secondes - also set to zero
cbsptr = 0;

cbminsize = 60;
cbuffmin = make_array(cbminsize);
cbmptr = 0;

cbhoursize = 24;
cbuffhours = make_array(cbhoursize);
cbhptr = 0;

statmin = 0;
stathour = 0;
statday = 0;

blStatSiz = 300; // duration in seconds - so, 5 minute memory
blStatThis = 0; blStatPrev = -1;
blStatXecCnt = make_array(blStatSiz);
blStatCPUUse = make_array(blStatSiz);
blStatCPUMax = make_array(blStatSiz);
blStatGFXUse = make_array(blStatSiz);
blStatGFXMax = make_array(blStatSiz);
// initialize all this
ii=0; loop(blStatSiz,
    blStatXecCnt[ii] = 45; // default to 45 block exec/second as a guess start
    blStatCPUUse[ii] = 0.001; // default to 1 ms of exec time each second, as a guess start
    blStatCPUMax[ii] = 0.00001; // max default time
    blStatGFXUse[ii] = 0.0125; // default to 12.5 seconds of exec time each second, as a guess start
    ii += 1;
);

tdMin = 0.35;
tdMax = 1.40;
tdRel = 0.25;

// Define here most default values for the various settings
gmem[speedBase] = 1;
clipLow = gmem[cmClipLow] = 0;
clipHigh = gmem[cmClipHigh] = 9999;


function ADump(inp)
(
    A99Addr = inp;
        A00 = inp[0];
        A01 = inp[1];
        A02 = inp[2];
        A03 = inp[3];
        A04 = inp[4];
        A05 = inp[5];
        A06 = inp[6];
        A07 = inp[7];
        A08 = inp[8];
        A09 = inp[9];
        A10 = inp[10];
        A11 = inp[11];
        A12 = inp[12];
        A13 = inp[13];
        A14 = inp[14];
        A15 = inp[15];
        A16 = inp[16];
        A17 = inp[17];
        A18 = inp[18];
        A19 = inp[19];
        A20 = inp[20];
        A21 = inp[21];
        A22 = inp[22];
        A23 = inp[23];
        A24 = inp[24];
        A25 = inp[25];
        A26 = inp[26];
        A27 = inp[27];
        A28 = inp[28];
        A29 = inp[29];
        A30 = inp[30];
        A31 = inp[31];
        A32 = inp[32];
        A33 = inp[33];
        A34 = inp[34];
        A35 = inp[35];
        A36 = inp[36];
        A37 = inp[37];
        A38 = inp[38];
        A39 = inp[39];
);

// Play color arrays
displayColorsSiz = 41;
displayColorsA = make_array(displayColorsSiz);
set_pcolors_array(displayColorsA, displayColorsSiz,
    Color_Blue_Green, Color_Goldenrod,
    0.4, -1);

// ADump(displayColorsA);
//

menu_Play_Mode = make_jmenu(
        ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel |
        //
        ui_jmenu_opt_rclick |
         ui_jmenu_opt_notitle,
        "Mode", "Plain|Play|Loop");

//====== Players displaying ======
//BCtrlInfoSize = 128;
//BplayerInfoCount = 4;
//
BplayerA = Bplayers;
BplayerB = BplayerA + BCtrlInfoSize;
BplayerC = BplayerB + BCtrlInfoSize;
BplayerD = BplayerC + BCtrlInfoSize;
// Reserve
BplayerE = BplayerD + BCtrlInfoSize;
BplayerF = BplayerE + BCtrlInfoSize;
// Keep addresses
bplMenuAddrs[0] = BplayerA; bplMenuAddrs[1] = BplayerB;
bplMenuAddrs[2] = BplayerC; bplMenuAddrs[3] = BplayerD;
bplMenuAddrs[4] = BplayerE; bplMenuAddrs[5] = BplayerF;
bplMenuAddrs[6] = BplayerG; bplMenuAddrs[7] = BplayerH;
// Structure description
//   0 = display type : Locked / Last / selected
BplEdit = 3; // edit mode
//   1 = unit [in 0 .. 63]

//   2 =
Bpl_SlCnt = 3; // displayed slider count
Bpl_ShCnt = 4; // displayed info controls
Bpl_CCSlCnt = 5; // column count for sliders
Bpl_CCCtCnt = 6; // column count for controls
Bpl_Sl1 = 16; // first slider to display
Bpl_Sh1 = 64; // first info to display
Bpl_SlLast = Bpl_Sh1 - 1; // last slider to display
Bpl_ShLast = BCtrlInfoSize - 1; // last info to display

padBplayer = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        1, 6, 6);
padBplLabs = padBplayer + padBplayer[ui_jpad_labs]; // addresses of labels
padBplColrs = padBplayer + padBplayer[ui_jpad_clrs]; // addresses of colors
padBplCells = padBplayer + padBplayer[ui_jpad_cells]; // addresses of cells desc.
padBplVals =  padBplayer + padBplayer[ui_jpad_values]; // addresses of values
//
ii = 0; loop(6,
             padBplColrs[ii] = Col_Inactive;
             padBplLabs[ii] = " ";
             ii+=1; );
//
//
//====== DISPLAYABLES ======
// Defining displayables
//
//
// Update the default menu screen
uix_jG_menuscr[ii=0] = "Main";
uix_jG_menuscr[ii+=1] = "Studio A";
uix_jG_menuscr[ii+=1] = "Studio B";
uix_jG_menuscr[ii+=1] = "Studio C";
uix_jG_menuscr[ii+=1] = "Studio D";
uix_jG_menuscr[ii+=1] = "Studio E";
uix_jG_menuscr[ii+=1] = "Live 1";
uix_jG_menuscr[ii+=1] = "Live 2";
uix_jG_menuscr[ii+=1] = -1;
//——————————————
dcbTabsCount = ii; // menu bar max -- number of tabs
uix_jmbsel = 0;
uix_jmbprv = 0;
uix_switch = 0;
uix_jG_menuscrSz = dcbTabsCount + 2; // add some size to display sound indicator

dcbPannelsMax = 4; // up to 4 pannels in each tabulation
dcbMSize = 32; // max number of different displayable modules in each pane
dcbMax = dcbMSize - 1;
dcbMCount = dcbTabsCount * dcbPannelsMax; // number of different modules sets - used for main, studios A, B , etc.
// we currently use 64 * 2 words, so 128 for each menu
dcbWSize = dcbMSize * 2;
dcbBSize = dcbWSize * dcbMCount;
(dcbBSize > 2048) ? err_sys_ini = 9924; // serialBlock error

/*
=== MODULES ===
*/

// The GM Main menu
dcbNamesCnt = 128; // up to 128 strings in the dcb Menu - 79+32 used
// memory block for the menu
GUI_Main_Menu_Block = mSL_StM_Alloc(ui_jmenu_items+dcbNamesCnt, 'Menu', mSL_StM_FlClear);

blockDispNames = make_array(dcbNamesCnt);
blockDispIdts = make_array(dcbNamesCnt);
blockDispInverts = make_array(dcbNamesCnt);

// User modules
dcbUModsSiz = 32;
dcbUModsCnt = 0;
blockUsrNames = make_array(dcbUModsSiz);
blockUsrIds = make_array(dcbUModsSiz);
blockUsrNum = make_array(dcbUModsSiz);
blockUsrRefs = make_array(dcbUModsSiz);
blockUsrChecks = make_array(dcbUModsSiz);

dcbUXRefsSiz = 64;
blockUsrCode = make_array(dcbUXRefsSiz);
blockUsrDesc = make_array(dcbUXRefsSiz);

function
checkUsrMods()
local (blu, i, k)
(
    dcbUModsCnt = i = 0;
    loop (dcbUModsSiz,
        k = (blockUsrNames[i] != 0) && ((blu = blockUsrRefs[i]) > 0) && (mSL_bl_check(blu, 'umod'));
        blockUsrChecks[i] = k;
        dcbUModsCnt += k;
        i += 1;
    );
);

function
deleteUsrMods()
local (blu, i, k)
(
    memset(blockUsrNames, 0, dcbUModsSiz);
    memset(blockUsrIds, 0, dcbUModsSiz);
    memset(blockUsrNum, 0, dcbUModsSiz);
    memset(blockUsrRefs, 0, dcbUModsSiz);
    memset(blockUsrChecks, 0, dcbUModsSiz);
    memset(blockUsrCode, 0, dcbUXRefsSiz);
    memset(blockUsrDesc, 0, dcbUXRefsSiz);
);

function
mkModuleMenu()
local (i, tmp, bln, blu)
(

    i = 0; loop(dcbNamesCnt,
        blockDispNames[i] = "";
        blockDispIdts[i] = i;
        blockDispInverts[i] = i;
        i+=1;
    ); // unused entries set to ""

    // - the numbers                                // xx Returned from menu
    blockCurrMod = itdsp = 0;
    blockDispNames[blockCurrMod] = "&/Current";    // 1
    blockModules = (itdsp += 1);
    blockDispNames[blockModules] = ">Modules";    // not counted
    blockFirst = itdsp + 1;
    blockMainInfos = (itdsp += 1);
    blockDispNames[blockMainInfos] = "Main Infos"; // 2
    blockPlayPad = (itdsp += 1);
    blockDispNames[blockPlayPad] = "Studio Play Pad"; // 3
    blockPlayControls = (itdsp += 1);
    blockDispNames[blockPlayControls] = "Play Control"; // 4
    blockSlidersA = (itdsp += 1);
    blockDispNames[blockSlidersA] = "Parameters A"; // 5
    blockSlidersB = (itdsp += 1);
    blockDispNames[blockSlidersB] = "Parameters B"; // 6
    blockSlidersC = (itdsp += 1);
    blockDispNames[blockSlidersC] = "Parameters C"; // 7
    blockSlidersD = (itdsp += 1);
    blockDispNames[blockSlidersD] = "Parameters D"; // 8
    blockSlidersE = (itdsp += 1);
    blockDispNames[blockSlidersE] = "Parameters E"; // 9
    blockSlidersF = (itdsp += 1);
    blockDispNames[blockSlidersF] = "Parameters F"; // 10
    blockSlidersG = (itdsp += 1);
    blockDispNames[blockSlidersG] = "Parameters G"; // 11
    blockSlidersH = (itdsp += 1);
    blockDispNames[blockSlidersH] = "Parameters H"; // 12
    blockBanksDef = (itdsp += 1);
    blockDispNames[blockBanksDef] = "Banks Definition"; // 13
    blockRandStates = (itdsp += 1);
    blockDispNames[blockRandStates] = "Random States"; // 14
    blockUnits = (itdsp += 1);
    blockDispNames[blockUnits] = "Sound Units"; // 15
    blockClips = (itdsp += 1);
    blockDispNames[blockClips] = "Clips Selection"; // 16
    blockScheduler = (itdsp += 1);
    blockDispNames[blockScheduler] = "Scheduler"; // 17
    blockHPConfig = (itdsp += 1);
    blockDispNames[blockHPConfig] = "HP Configuration"; // 18
    blockPlayModes = (itdsp += 1);
    blockDispNames[blockPlayModes] = "Play Modes"; // 19
    blockSpaceModes = (itdsp += 1);
    blockDispNames[blockSpaceModes] = "Space Modes"; // 20
    blockClipsSettings = (itdsp += 1);
    blockDispNames[blockClipsSettings] = "Clips Settings"; // 21
    blockSensors = (itdsp += 1);
    blockDispNames[blockSensors] = "Sensors"; // 22
    blockDisplayerA = (itdsp += 1);
    blockDispNames[blockDisplayerA] = "Displayer A";  // 23
    blockDisplayerB = (itdsp += 1);
    blockDispNames[blockDisplayerB] = "Displayer B"; // 24
    blockDisplayerC = (itdsp += 1);
    blockDispNames[blockDisplayerC] = "Displayer C"; // 25
    blockDisplayerD = (itdsp += 1);
    blockDispNames[blockDisplayerD] = "Displayer D"; // 26
    blockSysLinks = (itdsp += 1);
    blockDispNames[blockSysLinks] = "Links Manager"; // 27
    blockScripts = (itdsp += 1);
    blockDispNames[blockScripts] = "Scripts Settings"; // 28
    blockProcessesMgr = (itdsp += 1);
    blockDispNames[blockProcessesMgr] = "Processes Manager"; // 29
    blockMemory1 = (itdsp += 1);
    MM1 = blockDispNames[blockMemory1] = "Memory 1"; // 30
    blockPreset = (itdsp += 1);
    blockDispNames[blockPreset] = "Presets Manager"; // 31
    blockPlayLog = (itdsp += 1);
    blockDispNames[blockPlayLog] = "Play Log"; // 32
    blockSysLog = (itdsp += 1);
    blockDispNames[blockSysLog] = "System Log"; // 33
    blockUsrLog = (itdsp += 1);
    blockDispNames[blockUsrLog] = "User Log"; // 34
    blockMemory2 = (itdsp += 1);
    MM2 = blockDispNames[blockMemory2] = "Memory 2"; // 35
    blockDynPars = (itdsp += 1);
    blockDispNames[blockDynPars] = "Dynamic Play Parameters"; // 36

    blockUsrFirst = itdsp+1;
    // Add users modules
    memset(blockUsrNum, 0, dcbUModsSiz);
    i=j=0; loop (dcbUModsSiz,
        (blockUsrChecks[i]) ? (
            blockUsrIds[i] = (itdsp += 1);
            blockUsrNum[j] = i; j += 1;
            blockDispNames[itdsp] = blockUsrNames[i];
        );
        i += 1;
    );
    blockUsrLast = itdsp;
    //
    blockDispITC = itdsp+1; // item count
    // for the menu
    blockStrSpace = (itdsp += 1);
    blockDispNames[(itdsp += 1)] = ">Modules Disposition";
    blockStrMvUp = (itdsp += 1);
    blockDispNames[blockStrMvUp] = "&/Move up";
    blockStrMvDwn = (itdsp += 1);
    blockDispNames[blockStrMvDwn] = "&/Move down";
    blockStrMvTop = (itdsp += 1);
    blockDispNames[blockStrMvTop] = "&/Move top";
    blockStrMvBottom = (itdsp += 1);
    blockDispNames[blockStrMvBottom] = "&/Move Bottom";
    blockStrMvLeft = (itdsp += 1);
    blockDispNames[blockStrMvLeft] = "&/Move left";
    blockStrMvRight = (itdsp += 1);
    blockDispNames[blockStrMvRight] = "&/Move right";
    blockCopyModule = (itdsp += 1);
    blockDispNames[blockCopyModule] = "&/Copy module";
    blockPasteModule = (itdsp += 1);
    blockDispNames[blockPasteModule] = "&/<Paste module";
    //
    (itdsp += 1); // separator
    blockDispNames[(itdsp += 1)] = ">Panes Arrangement";
    blockPaneMvLeft = (itdsp += 1);
    blockDispNames[blockPaneMvLeft] = "&/Move pane left";
    blockPaneMvRight = (itdsp += 1);
    blockDispNames[blockPaneMvRight] = "&/Move pane right";
    blockPaneShftLeft = (itdsp += 1);
    blockDispNames[blockPaneShftLeft] = "&/Shift panes left";
    blockPaneShftRight = (itdsp += 1);
    blockDispNames[blockPaneShftRight] = "&/Shift panes right";
    blockCpyPane = (itdsp += 1);
    blockDispNames[blockCpyPane] = "&/Copy pane";
    blockPstPane = (itdsp += 1);
    blockDispNames[blockPstPane] = "&/Paste pane";
    (itdsp += 1); // separator
    block1Pane = (itdsp += 1);
    blockDispNames[block1Pane] = "&P1 pane";
    block2Pane = (itdsp += 1);
    blockDispNames[block2Pane] = "&P2 panes";
    block3Pane = (itdsp += 1);
    blockDispNames[block3Pane] = "&P3 panes";
    block4Pane = (itdsp += 1);
    blockDispNames[block4Pane] = "&P4 panes";
    blockReset = (itdsp += 1);
    blockDispNames[blockReset] = "&/Reset Sizes";
    (itdsp += 1); // separator
    blockPaneClear = (itdsp += 1);
    blockDispNames[blockPaneClear] = "&/Clear Pane";
    blockAllPaneClear = (itdsp += 1);
    blockDispNames[blockAllPaneClear] = "&/<Clear all panes";
    //
    (itdsp += 1); // separator
    blockDispNames[(itdsp += 1)] = ">Tabs Management";
    blockDispNames[itdsp += 1] = "&~ignored";
    blockTabShftLeft = (itdsp += 1);
    blockDispNames[blockTabShftLeft] = "&/Shift tabs left"; //
    blockTabShftRight = (itdsp += 1);
    blockDispNames[blockTabShftRight] = "&/Shift tabs right"; //
    blockTabRename = (itdsp += 1);
    blockDispNames[blockTabRename] = "&/<Rename tab..."; //
    //
    (itdsp += 1); // separator
    blockDispNames[(itdsp += 1)] = ">Theme";
    blockThemeDefault = (itdsp += 1);
    blockDispNames[blockThemeDefault] = "!&1Default"; //
    blockThemeBlack = (itdsp += 1);
    blockDispNames[blockThemeBlack] = "!&1 Black"; //
    blockThemeTron = (itdsp += 1);
    blockDispNames[blockThemeTron] = "!&1 Tron"; //
    blockThemeLightCyan = (itdsp += 1);
    blockDispNames[blockThemeLightCyan] = "!&1 Light Cyan"; //
    blockThemeOrange = (itdsp += 1);
    blockDispNames[blockThemeOrange] = "!&1 Orange"; //
    blockThemeBlue = (itdsp += 1);
    blockDispNames[blockThemeBlue] = "!&1 Blue"; //
    blockThemeDarkCyan = (itdsp += 1);
    blockDispNames[blockThemeDarkCyan] = "!&1< Dark Cyan"; //
    //
    //
    blockMenuITC = itdsp + 1 ;
    // ======
    // Alphabetical sort of modules

    // Alphabetically sort modules names - insure future compatibility by keeping same number for previous modules
    mSL_Sort_Strings(blockDispITC, blockFirst, blockDispNames, blockDispIdts, 0, 0);
    // build invert table
    i = blockFirst; while(i<blockDispITC) (
        blockDispInverts[blockDispIdts[i]] = i; i += 1;
    );

    // provide a block for the menu
    ui_jmenu_provided_block = GUI_Main_Menu_Block ;
    menu_Stud_Mod = make_jmenu(
        ui_jmenu_typ_opt | ui_jmenu_opt_rndrect | ui_jmenu_opt_shrclick | ui_jmenu_opt_notitle,
            "Studio", blockMenuITC, blockDispNames);
    // Set the "<" in last module item
    tmp  = menu_Stud_Mod[ui_jmenu_items + blockDispITC - 1];
    str_setchar(tmp, 5, '<');
    //ADump(menu_Stud_Mod-2);
    0 ? (
        sprintf(#zz, "Creating Sudio: %d", menu_Stud_Mod);
        mSL_log(SysLogBox, #zz);
        sprintf(#zz, "Stud:A %s", menu_Stud_Mod[ui_jmenu_items]);
        mSL_log(SysLogBox, #zz);
        sprintf(#zz, "Stud:Z %s", menu_Stud_Mod[ui_jmenu_items + blockMenuITC - 1]);
        mSL_log(SysLogBox, #zz);
    );

);

mkModuleMenu();

// ======
dcbStudSet = make_array(dcbMCount);
memset(dcbBlocksAll, 0, dcbBSize);
i = 0; loop(dcbMCount, dcbStudSet[i] = dcbBlocksAll + i*dcbWSize; i+= 1;);

scbTempCopy = make_array(dcbWSize);

// ======

// Global variables
blockDesc = 0;  // description of the current block
blockMouseWasIn = 0; //  in which block was the mouse ?
cModule = 0; // "current" module
copiedMod = 0; // "copied" module

TabIdt = 0;
PanIdt = 0;


/*
     Perform a GUI operation
        opr: operation class: 0, 1, 2, 3...
        bNumb: the pannel (0 to 31) on which the operation will apply
        module= a "module" number
        kit = the suboperation number
*/
function
mSL_GUI_Generic(opr, bNumb, module, kit)
local (i, j, u, v, flg, tbN, mblk, a, k)
(
    flg = 1;
    tbN = -1; // Tabulation number (in 0 .. 7)
    mblk = 0; // Current block address
    // Check we have a correct blockDesc
    ((bNumb >= 0) && (bNumb < dcbMCount)) ? (
        mblk = dcbBlocksAll + bNumb * dcbWSize;
        tbN = bNumb >> 2;
    ) :
    ((blockDesc >= dcbBlocksAll) && (blockDesc < (dcbBlocksAll + dcbMCount * dcbWSize))) ? (
        bNumb = 0|((blockDesc - dcbBlocksAll)/dcbWSize);
        mblk = dcbBlocksAll + bNumb * dcbWSize;
        tbN = bNumb >> 2;
    ) : (
        flg = 0;
    );

    ((module < blockFirst) || (module >= blockDispITC)) ? (module = 0; );


    flg ? (
        (module === 0) ? (module = mblk[dcbWSize - 1];);
        (opr === 1) ? (
            // add module "module" to the current block
            i = 0; while ((mblk[i] != 0) && (mblk[i] != module)) ( i+= 1;);
            mblk[i] = module;
        ) :
        (opr === 2) ? (
            // remove module "module" from the current block
            i = j = 0;
            while ((j < dcbMax) && ((u = mblk[j]) !== 0)) (
                (module === u) ? ( j+= 1; );
                mblk[i] = mblk[j];
                i += 1 ; j += 1;
            );
            (module > 0) ? copiedMod
        ) :
        (opr === 3) ? (
            // perform action "kit"
            (kit === blockStrMvUp) ? (
                // move up current module
                (module > 0) ? (
                    i = 0; while (i < dcbMax) (
                        u = mblk[i]; v = mblk[i+1];
                        (v === module) ? (
                            mblk[i] = v; mblk[i+1] = u; i = dcbMax;
                        );
                        i += 1;
                    );
                );
            ) :
            (kit === blockStrMvDwn) ? (
                // move down current module
                (module > 0) ? (
                    i = 0; while (i < dcbMax) (
                        u = mblk[i]; v = mblk[i+1];
                        ((u === module) && (v !== 0)) ? (
                            mblk[i] = v; mblk[i+1] = u; i = dcbMax;
                        );
                        i += 1;
                    );
                );
            ) :
            (kit === blockStrMvTop) ? (
                // move top current module
                (module > 0) ? (
                    i = dcbMax-1; while (i >= 0) (
                        u = mblk[i]; v = mblk[i+1];
                        (v === module) ? (
                            mblk[i] = v; mblk[i+1] = u;
                        );
                        i -= 1;
                    );
                );
            ) :
            (kit === blockStrMvBottom) ? (
                // move bottom current module
                (module > 0) ? (
                    i = 0; while (i < dcbMax) (
                        u = mblk[i]; v = mblk[i+1];
                        ((u === module) && (v !== 0))  ? (
                            mblk[i] = v; mblk[i+1] = u;
                        );
                        i += 1;
                    );
                );
            ) :
            (kit === blockStrMvLeft) ? (
                // move left current module
                (module > 0) ? (
                    // Remove module from current pane
                    i = j = 0;
                    while (i < dcbMax) (
                        (module === mblk[j]) ? (  j+= 1; );
                        mblk[i] = mblk[j];
                        i += 1 ; j += 1;
                    );
                    // Add module to right pane
                    v = tbN * 4 + ((bNumb - tbN * 4 + 3) % 4); // pane at the right
                    u = dcbBlocksAll + v * dcbWSize; // its description
                    i = 0; while ((u[i] != 0) && (u[i] != module))  ( i+= 1;);
                    u[i] = module;
                    0 ? (
                        sprintf(#dbg_trace1, "+MVLM+ %d : %d (%d) [%d,%d,%d,%d] => %d (%d) @ %d   [%d,%d, %d, %d]", module, bNumb,
                                        mblk, mblk[0], mblk[1], mblk[2], mblk[3], v, u, i,
                                        u[0], u[1], u[2], u[3]);
                        mSL_log(SysLogBox, #dbg_trace1);
                    )
                );
            ) :
            (kit === blockStrMvRight) ? (
                // move right current module
                (module > 0) ? (
                    // Remove module from current pane
                    i = j = 0;
                    while (i < dcbMax) (
                        (module === mblk[j]) ? (  j+= 1; );
                        mblk[i] = mblk[j];
                        i += 1 ; j += 1;
                    );
                    // Add module to right pane
                    v = tbN * 4 + ((bNumb - tbN * 4 + 1) % 4); // pane at the right
                    u = dcbBlocksAll + v * dcbWSize; // its description
                    i = 0; while ((u[i] != 0) && (u[i] != module))  ( i+= 1;);
                    u[i] = module;
                    0 ? (
                        sprintf(#dbg_trace1, "+MVRM+ %d : %d (%d) [%d,%d,%d,%d] => %d (%d) @ %d  [%d,%d, %d, %d]", module, bNumb,
                                        mblk, mblk[0], mblk[1], mblk[2], mblk[3], v, u, i,
                                        u[0], u[1], u[2], u[3]);
                        mSL_log(SysLogBox, #dbg_trace1);
                    );
                );
            ) :
            (kit === blockCopyModule) ? (
                (module > 0) ? (
                    copiedMod = module;
                );
            ) :
            (kit === blockPasteModule) ? (
                (copiedMod > 0) ? (
                    // add module "copiedMod" to the current block
                    i = 0; while ((mblk[i] != 0) && (mblk[i] != copiedMod)) ( i+= 1;);
                    mblk[i] = copiedMod;
                );
            ) :
            (kit === blockPaneClear) ? (
                memset(mblk, 0, dcbWSize);
            ) :
            (kit === blockAllPaneClear) ? (
                memset(dcbBlocksAll, 0, dcbBSize);
            ) :
            (kit === blockCpyPane) ? (
                memcpy(scbTempCopy, mblk, dcbWSize);
            ) :
            (kit === blockPstPane) ? (
                memcpy(mblk, scbTempCopy, dcbWSize);
            ) :
            (kit === block1Pane) ? (
                serialBlock[Pr7_StudConf+tbN] = 1;
            ) :
            (kit === block2Pane) ? (
                serialBlock[Pr7_StudConf+tbN] = 2;
            ) :
            (kit === block3Pane) ? (
                serialBlock[Pr7_StudConf+tbN] = 3;
                /*
                ffff2 = 1;
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                sprintf(#sx, "%d => 3 Panes: %d  %d  %d  --- %f  %f  %f ", tbN, p[0], p[1], p[2],
                    max(1, p[0])/max(1, p[0] + p[1] + p[2]),
                    max(1, p[1])/max(1, p[1] + p[2]), 1);
                mSL_log(SysLogBox, #sx);
                */
            ) :
            (kit === block4Pane) ? (
                serialBlock[Pr7_StudConf+tbN] = 4;
            ) :
            (kit === blockReset) ? (
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                p[0] = p[1] = p[2] = p[3] = 600;
            ) ;
            (kit === blockPaneMvLeft) ? (
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                v = tbN * 4 + (a = (bNumb - tbN * 4 + 3) % 4); // pane at the left
                // exchange sizes
                k = p[a]; p[a] = p[bNumb]; p[bNumb] = k;
                // exchange contents
                u = dcbBlocksAll + v * dcbWSize;
                memcpy(scbTempCopy, mblk, dcbWSize);
                memcpy(mblk, u, dcbWSize);
                memcpy(u, scbTempCopy, dcbWSize);
            ) :
            (kit === blockPaneMvRight) ? (
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                v = tbN * 4 + (a = (bNumb - tbN * 4 + 1) % 4); // pane at the right
                // exchange sizes
                k = p[a]; p[a] = p[bNumb]; p[bNumb] = k;
                // exchange contents
                u = dcbBlocksAll + v * dcbWSize;
                memcpy(scbTempCopy, mblk, dcbWSize);
                memcpy(mblk, u, dcbWSize);
                memcpy(u, scbTempCopy, dcbWSize);
            ) :
            (kit === blockPaneShftLeft) ? (
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                k = p[0]; p[0] = p[1]; p[1] = p[2]; p[2] = p[3]; p[3] = k;
                u = dcbBlocksAll + tbN * 4 * dcbWSize; // left pane
                memcpy(scbTempCopy, u, dcbWSize);
                memcpy(u, u+dcbWSize, dcbWSize);
                memcpy(u+dcbWSize, u+2*dcbWSize, dcbWSize);
                memcpy(u+2*dcbWSize, u+3*dcbWSize, dcbWSize);
                memcpy(u+3*dcbWSize, scbTempCopy, dcbWSize);
            ) :
            (kit === blockPaneShftRight) ? (
                p = serialBlock + Pr7_StudRat + 4 * tbN;
                k = p[3]; p[3] = p[2]; p[2] = p[1]; p[1] = p[0]; p[0] = k;
                u = dcbBlocksAll + (tbN * 4 + 3) * dcbWSize; // right pane
                memcpy(scbTempCopy, u, dcbWSize);
                memcpy(u, u-dcbWSize, dcbWSize);
                memcpy(u-dcbWSize, u-2*dcbWSize, dcbWSize);
                memcpy(u-2*dcbWSize, u-3*dcbWSize, dcbWSize);
                memcpy(u-3*dcbWSize, scbTempCopy, dcbWSize);
            ) :
            (kit === blockTabShftLeft) ? (
                // Shift content left
                i=0; loop(4,
                    u = dcbBlocksAll + i * dcbWSize;
                    p = serialBlock + Pr7_StudRat + i;
                    k = p[0];
                    memcpy(scbTempCopy, u, dcbWSize);
                    loop(dcbTabsCount-1,
                        memcpy(u, u + 4 * dcbWSize, dcbWSize);
                        u += 4 * dcbWSize;
                        p[0] = p[4]; p += 4;
                    );
                    p[0] = k;
                    memcpy(u, scbTempCopy, dcbWSize);
                    i += 1;
                );
                // Shift panes count and names
                k = serialBlock[Pr7_StudConf]; u = altTabsNames[0];
                i=0; loop(dcbTabsCount-1,
                    serialBlock[Pr7_StudConf+i] = serialBlock[Pr7_StudConf+i+1];
                    altTabsNames[i] = altTabsNames[i+1];
                    i += 1;
                );
                serialBlock[Pr7_StudConf+i] = k;
                altTabsNames[i] = u;
            ) :
            (kit === blockTabShftRight) ? (
                // Shift content right
                i=0; loop(4,
                    u = dcbBlocksAll + ((dcbTabsCount-1) * 4 + i) * dcbWSize;
                    p = serialBlock + Pr7_StudRat + (dcbTabsCount-1) * 4 + i;
                    k = p[0];
                    memcpy(scbTempCopy, u, dcbWSize);
                    loop(dcbTabsCount-1,
                        memcpy(u, u - 4 * dcbWSize, dcbWSize);
                        u -= 4 * dcbWSize;
                        p[0] = p[-4]; p -= 4;
                    );
                    p[0] = k;
                    memcpy(u, scbTempCopy, dcbWSize);
                    i += 1;
                );
                // Shift panes count and names
                k = serialBlock[Pr7_StudConf + dcbTabsCount-1]; u = altTabsNames[dcbTabsCount-1];
                i=dcbTabsCount-1; loop(dcbTabsCount-1,
                    serialBlock[Pr7_StudConf+i] = serialBlock[Pr7_StudConf+i-1];
                    altTabsNames[i] = altTabsNames[i-1];
                    i -= 1;
                );
                serialBlock[Pr7_StudConf] = k;
                altTabsNames[0] = u;
            ) ;
        ) :
        (opr === 4) ? (
            // various GUI related operations
            ((kit >=0) && (kit < dcbTabsCount)) ? (
                // switch to screen "kit"
                ui_screen_switch(uix_jG_switchr[kit]);
            );

        );
    );

);







//====== VARIOUS ======





// Random State initialisation

initRandomStates();

// Define first entry as "black"
gmem[idx = RandomSColors] = 0; // black
// Define the colors for referencing the random generators

gmem[idx += 1] = uix_pack_color(178,37,25);
// gmem[idx += 1] = uix_pack_color(180,70,25);
gmem[idx += 1] = uix_pack_color(193,122,25);
gmem[idx += 1] = uix_pack_color(190,169,25);
// gmem[idx += 1] = uix_pack_color(145,183,24);
gmem[idx += 1] = uix_pack_color(26,188,21);
// gmem[idx += 1] = uix_pack_color(25,185,110);
gmem[idx += 1] = uix_pack_color(28,180,186);
gmem[idx += 1] = uix_pack_color(28,95,188);
gmem[idx += 1] = uix_pack_color(127,25,188);
// gmem[idx += 1] = uix_pack_color(181,26,180);
gmem[idx += 1] = uix_pack_color(176,23,122);

gmem[idx += 1] = Color_Std_Red;
gmem[idx += 1] = Color_Std_Orange;
gmem[idx += 1] = Color_Std_Yellow;
gmem[idx += 1] = Color_Std_Green;
gmem[idx += 1] = Color_Std_Cyan;
gmem[idx += 1] = Color_Std_Blue;
gmem[idx += 1] = Color_Std_Magenta;
gmem[idx += 1] = Color_Std_Brown;
// And then some more
gmem[idx += 1] = Color_Azure;
gmem[idx += 1] = Color_Bronze;
gmem[idx += 1] = Color_Deep_Red;
gmem[idx += 1] = Color_Fern_Green;
//
gmem[idx += 1] = Color_Blaze_Orange;
gmem[idx += 1] = Color_Grayish_Brown;
gmem[idx += 1] = Color_Dark_Aqua;
gmem[idx += 1] = Color_Bright_Turquoise;
gmem[idx += 1] = Color_Deep_Cadmium_Red;
gmem[idx += 1] = Color_Asparagus;
gmem[idx += 1] = Color_Peach_Yellow;
/*
gmem[idx += 1] = Color_Blue_Haze;
gmem[idx += 1] = Color_Deep_Reddish_Orange;
gmem[idx += 1] = Color_Heliotrope;
gmem[idx += 1] = Color_Dark_Olive_Green;
gmem[idx += 1] = Color_Chartreuse_Yellow;
gmem[idx += 1] = Color_Blue_Bell;
gmem[idx += 1] = Color_Dark_Sea_Green;
gmem[idx += 1] = Color_Light_Brownish_Gray;
gmem[idx += 1] = Color_Chartreuse_Yellow;
gmem[idx += 1] = Color_Forest_Green;
gmem[idx += 1] = Color_Blue_Violet;
gmem[idx += 1] = Color_Clear_Yellow;
*/
(idx-RandomSColors >= RandomSColorsCnt) ? err_sys_ini = 9922; // to many colours...




//====== PLAY STATS and BALANCE ======
function BPLSTClear()
local (i)
(
    BPlSig4 = BPlSig16 = BPlSig64 = BPlSig256 = BPlSig1024 = 0;
    BLpSig4 = BLpSig16 = BLpSig64 = BLpSig256 = BLpSig1024 = 0;
    BPlTresh4 = BPlTresh16 = BPlTresh64 = BPlTresh256 = BPlTresh1024 = 0;
    BLpTresh4 = BLpTresh16 = BLpTresh64 = BLpTresh256 = BLpTresh1024 = 0;
    i = 0; loop(4, BPlBuf4[i] = BLpBuf4[i] = 0; i += 1;);
    i = 0; loop(16, BPlBuf16[i] = BLpBuf16[i] = 0; i += 1;);
    i = 0; loop(64, BPlBuf64[i] = BLpBuf64[i] = 0; i += 1;);
    i = 0; loop(256, BPlBuf256[i] = BLpBuf256[i] = 0; i += 1;);
    i = 0; loop(1024, BPlBuf1024[i] = BLpBuf1024[i] = 0; i += 1;);
    BPlDoPlay = BLpDoPlay = BPLCTAbase = BPLCTime = 0;
);

//====== CLIPS ======
slBankset = 0;
slGroupNum= 0;
aclnBused = make_array(clNBanks);  // [100]
aclnBunav = make_array(clNBanks);
aclnBplyd = make_array(clNBanks);
cBk1 = 0; // current bank for loop1
cBk2 = 0; // current bank for loop2
cBk3 = 0; // current bank for loop3
cBk4 = 0; // current bank for loop4

K_aclnAliasesCnt = 256; // # of dropped in sets
aclnAliases = make_array(K_aclnAliasesCnt);
newAliases = make_array(K_aclnAliasesCnt);
aliasesStrCount = 0;
aliasesCount = 0;
padclips = make_jpad(
           ui_jpad_ty_act | ui_jpad_mk_colors |  ui_jpad_mk_altcolors
           | ui_jpad_mk_values,
           10, 10, clInBank);

padXclrs = padclips + padclips[ui_jpad_clrs]; // addresses of colors
padclips[ui_jpad_coff] = 0;
padValues = padclips + padclips[ui_jpad_values];
padVCells = padclips + padclips[ui_jpad_cells]; // addresses of cells desc.
padclips[ui_jpad_fmts] = "%d";

padbanks = make_jpad(
           ui_jpad_ty_act | ui_jpad_mk_colors |
           // ui_jpad_mk_rrcells | ui_jpad_mk_rcells |
           ui_jpad_mk_values,
           1, 10, clBSSize);

padBCells = padbanks + padbanks[ui_jpad_cells]; // addresses of cells desc.
padBclrs = padbanks + padbanks[ui_jpad_clrs]; // addresses of colors
padBvals = padbanks + padbanks[ui_jpad_values];
padbanks[ui_jpad_fmts] = "%d";
padBCells[slGroupNum] |= ui_jpad_ct_selec;


VlCnumLastM = 0; VlCnumUnchkd  = 1;
// The pad relative to the Clips Volumes
padVlNC = 8; // number of columns
padVlClips = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        1, padVlNC, padVlNC);
padVlClips[ui_jpad_fmts] = "%04d";
padVlclrs = padVlClips + padVlClips[ui_jpad_clrs]; // addresses of colors
padVllabs = padVlClips + padVlClips[ui_jpad_labs]; // addresses of labels
padVlcVals = padVlClips + padVlClips[ui_jpad_values]; // addresses of values
padVlCells = padVlClips + padVlClips[ui_jpad_cells]; // addresses of cells desc.
ii = 0; loop(padVlNC,
             padVlclrs[ii] = Col_Inactive;
             padVllabs[ii] = " ";
             ii+=1; );
VlpVer = padVlNC - 3;
VlpMsg = padVlNC - 2;
VlpRld = padVlNC - 1;
padVlclrs[0] = Col_ClVCl ;
padVlCells[0] = ui_jpad_ct_showval;
padVlcVals[0] = 0; // default
padVlclrs[1] = Col_ClVCl ;
padVlclrs[VlpMsg] = Col_InfoC;
padVlclrs[VlpRld] = Col_InfoC;
padVllabs[VlpRld] = "Reload";


function updClBk(u)
local(ix, cused, cunav, cplyd, z)
(
    ((u >= 0) && (u < clNBanks)) ? (
        cused = cunav = cplyd = 0;
        ix = u * clInBank;
        loop (clInBank,
            z = gmem[clInfStart + ix];
            (z < 0) ? (cunav += 1;) :
            ((z > 0) || ((z === 0) && (gmem[clClInfos + ix] > 0))) ? (cused += 1; cplyd += z;);
            ix += 1;
        );
        aclnBused[u] = cused;
        aclnBunav[u] = cunav;
        aclnBplyd[u] = cplyd;
    );
);

function updClSel(offset, count)
local (ix, iy, z)
(
    ix = offset; iy = offset + count;
    clipsUsed = clipsUnAvail = clipsPlyd = 0;
    while ((ix >=0) && (ix < iy) && (ix < clTSize))   (
        z = gmem[clInfStart + ix];
        (z < 0) ? ( clipsUnAvail += 1; ) :
        (z > 0) ? ( clipsUsed += 1; clipsPlyd += z; );
        ix += 1;
    );
);


function
getClipName(clNum, strset)
local (als, str, strsize, pts, ch, lge, fFo)
(
    #fname = "";
    ((clNum >= 0) && (clNum < clTSize) && (strset != 0)) ? (
        // Is this an "alias" ?
        ((als = gmem[clClAlias+clNum]) != 0) ? (
            str = strset[als >> 16]; // string holding the alias
            strsiz = strlen(str);
            pts = als & 0xffff; // pointer in the string
            // Decode the string segment : "    lng    name    "
            ch = ' ';
            while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                ch = str_getchar(str, pts, 'cu'); pts += 1;
            );
            // decode length
            lge = 0;
            while ((pts < strsiz) && (ch >= '0') && (ch <= '9')) (
                lge = lge * 10 + ch - '0'; ch = str_getchar(str, pts, 'cu'); pts += 1;
            );
            // skip spaces
            while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                ch = str_getchar(str, pts, 'cu'); pts += 1;
            );
            // get actual name
            strcpy_substr(#fname, str, pts - 1, lge);
        ) : (
            // It's a simple clip
            // Do we already know the file format ?
            fFo = (gmem[clClInfos+clNum] >> 8) & 0xf;
            (fFo != 0) ? (
                sprintf(#fname, #D_clNameFormat, clNum, fFormats[fFo]);
            );
        );
    );
    #fname;
);


function
enterClipName(name, clNum, strset)
local (namlg, id, cn, idlg, bc, cs, l, clId, acnt)
(
    // First, build the description
    namlg = strlen(name);
    id = #; sprintf(id, "%d ", clNum); idlg = strlen(id);
    cn = #; sprintf(cn, "%d %s ", namlg, name);
    strcat(id, cn); nlg = strlen(id);
    // Look for a string
    clId = cs = 0; bc = 1;
    acnt = 0;
    while (bc) (
        cs = strset[acnt];
        (cs === 0) ? (strset[acnt] = cs = mSL_Str_Alloc(""); );
        (((l = strlen(cs)) + nlg) >= 16380) ? (
            acnt += 1; // skip to next
        ) : (
            clId = (acnt << 16) + l + idlg;
            strcat(cs, id);
            bc = 0;
            (TRC & 0x1000) ? (
                sprintf(#s, "[%06x <<<< %s", clId, name); mSL_log(SysLogBox, #s);
            );
            (TRC & 0x2000) ? (
                sprintf(#s, "[%06x <<<< %s", clId, strset[aliasesStrCount]); mSL_log(SysLogBox, #s);
            );
        );
    );
    aliasesStrCount = max(aliasesStrCount, acnt);
    clId;
);

// Explore all aliases to recreate their codification
// This cleans the representation
function
recreateAliases()
local(ii, clNum, nc, s)
(
    aliasesStrCount = aliasesCount = clNum = 0;
    // First, clean newAliases if necessary
    ii = 0; loop (K_aclnAliasesCnt,
        ((s = newAliases[ii]) != 0) ? (mSL_Str_Free(s));
        ii += 1;
    );
    loop (clTSize,
        (gmem[clClAlias + clNum] != 0) ? (
            // this is an alias
            getClipName(clNum, aclnAliases);
            (strlen(#fname) != 0) ? (
                // save the name in new string set
                nc = enterClipName(#fname, clNum, newAliases);
                // update the reference
                gmem[clClAlias + clNum] = nc;
                // Force to recheck this clip
                gmem[clInfStart+clnb] = 0;
                gmem[clClSizes+clnb] = 0;
                gmem[clClInfos+clnb] = 0;
                gmem[clClVolumes+clnb] = clVolumeBias;
                gmem[clClDurations+clnb] = 0;
                aliasesCount += 1;
            ) : (
                sprintf(#s, "Can't find an ident for %04d : %06X", clNum, gmem[clClAlias + clNum]);
                mSL_log(SysLogBox, #s);
            )
        );
        clNum += 1;
    );
    // release previous strings
    ii = 0; loop (K_aclnAliasesCnt,
        ((s = aclnAliases[ii]) != 0) ? (mSL_Str_Free(s));
        aclnAliases[ii] = newAliases[ii];
        newAliases[ii] = 0;
        ii += 1;
    );
    // ((aliasesCount === 0) && (aclnAliases[0] === 0)) ? (aclnAliases[0] = mSL_Str_Alloc(""));
);

function
removeAliases()
local(ii, s)
(
    ii = 0; loop (clTSize, gmem[clClAlias + ii] = 0; ii += 1;);
    ii = 0; loop (K_aclnAliasesCnt,
        ((s = aclnAliases[ii]) != 0) ? (mSL_Str_Free(s));
        ii += 1;
    );
    aliasesStrCount = aliasesCount = 0;
);


//  After a load preset, reinstall all aliases in clClAlias
function
rebuildAllaliases()
local(ii, strsrc, pts, strsiz, ch, clNum, lge, namepos, x)
(
    aliasesStrCount = aliasesCount = 0;
    ii = 0; loop (clTSize, gmem[clClAlias + ii] = 0; ii += 1;);
    ii = 0; loop (K_aclnAliasesCnt,
        ((strsrc = aclnAliases[ii]) != 0) ? (
            aliasesStrCount += 1;
            pts = 0; strsiz = strlen(strsrc);
            ch = ' ';
            while ((pts < strsiz) && (clNum <= clTSize))  (
                // skip spaces
                while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                    ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                );
                // decode clip number
                clNum = 0;
                while ((pts < strsiz) && (ch >= '0') && (ch <= '9')) (
                    clNum = clNum * 10 + ch - '0'; ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                );
                // skip spaces
                while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                    ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                );
                lge = 0; namepos = pts - 1;
                // decode length
                while ((pts < strsiz) && (ch >= '0') && (ch <= '9')) (
                    lge = lge * 10 + ch - '0'; ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                );
                // skip spaces
                while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                    ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                );
                // get string
                (lge > 0) ? (
                    pts = pts - 1 + lge;
                    ch = ' ';
                    // skip end spaces
                    while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                        ch = str_getchar(strsrc, pts, 'cu'); pts += 1;
                    );
                    // build the alias
                    gmem[clClAlias+clNum] = x = (ii << 16) + namepos;
                    aliasesCount += 1;
                    // Force to recheck this clip
                    gmem[clInfStart+clNum] = 0;
                    gmem[clClSizes+clNum] = 0;
                    gmem[clClInfos+clNum] = 0;
                    gmem[clClVolumes+clNum] = clVolumeBias;
                    gmem[clClDurations+clNum] = 0;
                    (TRC & 0x1000) ? (
                        sprintf(#s, "[< Clip(%d) => %06x  %d", clNum, x, lge); mSL_log(SysLogBox, #s);
                    );
                );
            );
        );
        ii += 1;
    );
);


function
checkClip(clNum, flg)
local (fH, ip, err, nch, ch, frate, fsize, als, str, pts, lge)
(
    ((clNum >= 0) && (clNum < clTSize)) ? (
        fH = -1;
        (((gmem[clClInfos+clNum] === 0) && (gmem[clInfStart+clNum] === 0)) || (flg)) ? (
            err = ip = 0;
            als = gmem[clClAlias+clNum];
            getClipName(clNum, aclnAliases);
            (strlen(#fname) != 0) ? (
                // Open file
                fH = file_open(#fname);
                (TRC & 0x400) ? (
                    sprintf(#s, "   check file %06X  \"%s\"  => %d", als, #fname, fH);
                    mSL_log(SysLogBox, #s);
                );
            ) : (
                while ((fH < 0) && (ip < 15) && (fFormats[ip+1] != 0)) (
                    ip += 1;
                    sprintf(#fname, #D_clNameFormat, clNum, fFormats[ip]);
                    fH = file_open(#fname);
                );
            );
            (fH < 0) ? (
                // file not found [probably]
                err = -0404;
            ) : (
                file_riff(fH, nch, frate);
                (nch < 1) ? (
                    err = -0421; // not supported
                ) :
                (nch > 48) ? (
                    err = -0448; // not supported
                ) :
                ((frate < 1000) || (frate > 400000)) ? (
                    err = -0496; // not supported
                ) :
                (
                    fsize = file_avail(fH);
                    (fsize <= 48) ? (
                         err = -0468; // too short
                    );
                );
            );
            (err != 0) ? (
                gmem[clClDurations+clNum] = 0;
                gmem[clInfStart+clNum] = err;
                gmem[clClInfos+clNum] = gmem[clClSizes+clNum] = 0;
                (gmem[clClDurations+clNum] === 0) ? (
                    (TRC & 0x400) ? (
                        sprintf(#s, "   checkClip(%d) => %d   [%d]", clNum, gmem[clClDurations+clNum], err);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                gmem[clClInfos+clNum] = nch + (ip << 8) + (frate << 12);
                gmem[clClSizes+clNum] = fsize;
                gmem[clClDurations+clNum] = fsize / (frate * nch) ; // std. duration
                (flg) ? (
                    gmem[clInfStart+clNum] = 0; // reset counting
                );
                (gmem[clClDurations+clNum] === 0) ? (
                    (TRC & 0x400) ? (
                        sprintf(#s, "   checkClip(%d) => %d   [%d / %d * %d]", clNum, gmem[clClDurations+clNum], fsize, frate, nch);
                        mSL_log(SysLogBox, #s);
                    );
                );
            );
        );
        (fH >= 0) ? file_close(fH);
    );

);



function clearClipsCharacteristics()
local (ii)
(
    ClipConfigVersion = ClMEntries = ClLEntry = 0;
    ii = 0; loop(clTSize, gmem[clClVolumes+ii]=clVolumeBias; ii+=1;); // reset all to 0dB
);


function installClipSet(clNum, strFList)
local (pts, aln, strsiz, ch, clnb, lge, namepos, newstr, x)
(
    // Instal all the entries of strFList in the clClAlias table.
    // Format is "cc lll NNNNNNNNNNNNN ccc lll NNNNNNNN ccc lll NNNNNNNNNNN .... ccc lll NNNNNNNN "
    // with "cccc" 1st clip number or 10000, "lll" length of name, "NNNN..." name of the file
    // each Alias entry points to a lllNNNNNNN
    //(aclnAliases[aliasesStrCount] != 0) ? (aliasesStrCount += 1;);
    // aclnAliases[aliasesStrCount] = newstr = mSL_Str_Alloc("");

    pts = 0; strsiz = strlen(strFList); clNum = 0 | max(clNum, 0);
    ch = ' ';
    while ((pts < strsiz) && (clNum < clTSize))  (
        // skip spaces
        while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
            ch = str_getchar(strFList, pts, 'cu'); pts += 1;
        );
        // decode clip number
        clnb = 0;
        while ((pts < strsiz) && (ch >= '0') && (ch <= '9')) (
            clnb = clnb * 10 + ch - '0'; ch = str_getchar(strFList, pts, 'cu'); pts += 1;
        );
        // skip spaces
        while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
            ch = str_getchar(strFList, pts, 'cu'); pts += 1;
        );
        lge = 0; namepos = pts - 1;
        // decode length
        while ((pts < strsiz) && (ch >= '0') && (ch <= '9')) (
            lge = lge * 10 + ch - '0'; ch = str_getchar(strFList, pts, 'cu'); pts += 1;
        );
        // skip spaces
        while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
            ch = str_getchar(strFList, pts, 'cu'); pts += 1;
        );
        // get string
        (lge > 0) ? (
            ptname = pts - 1;
            pts = ptname + lge;
            ch = ' ';
            // skip end spaces
            while ((pts < strsiz) && ((ch === ' ') || (ch === '\n') || (ch === '\r') || (ch === '\t'))) (
                ch = str_getchar(strFList, pts, 'cu'); pts += 1;
            );
            // what should we do ?
            (clnb >= clTSize) ? (clnb = clNum; clNum += 1;); // actual clip number
            strcpy_substr(#y, strFList, ptname, lge);
            gmem[clClAlias+clnb] = x = enterClipName(#y, clnb, aclnAliases);
            // keep name in newstr
            // first the clip number
            //sprintf(#ws, "%d ", clnb); strcat(newstr, #ws); namepos = strlen(newstr);
            // define the alias
            //gmem[clClAlias+clnb] = x = (aln << 16) + namepos;
            // Enter length and name
            //sprintf(#ws, "%d ", lge); strcat(newstr, #ws); pz = strlen(newstr);
            // strcat(newstr, #y);
            // Force to recheck this clip
            gmem[clInfStart+clnb] = 0;
            gmem[clClSizes+clnb] = 0;
            gmem[clClInfos+clnb] = 0;
            gmem[clClVolumes+clnb] = clVolumeBias;
            gmem[clClDurations+clnb] = 0;
            aliasesCount += 1;
            (TRC & 0x800) ? (
                sprintf(#s, " Clip(%d) => %06x  %d %s  [%d]", clnb, x, lge, #y, newstr); mSL_log(SysLogBox, #s);
            );
            checkClip(clnb, 1);
        );
     );

);

//====== UNITS ======
paduNl = 0|(uCnt/8);
padcNl_Units = 1; // Currently used number of lines in Units pad
padunits =  make_jpad(
       //  ui_jpad_mk_rcells |
        // ui_jpad_mk_rrcells |
        // ui_jpad_ty_opt
         ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values | ui_jpad_mk_altcolors,
         paduNl, 8, uCnt);

padUlabs = padunits + padunits[ui_jpad_labs]; // addresses of labels
padUclrs = padunits + padunits[ui_jpad_clrs]; // addresses of colors
padUAclrs = padunits + padunits[ui_jpad_altclrs]; // addresses of alt colors
padUNAddr = padunits + padunits[ui_jpad_values]; // addresses of values
padUCells = padunits + padunits[ui_jpad_cells]; // addresses of cells

//———————————————————————-



/*
=== PLAY MODES ===
*/
PMnumLastM = 0; PMnumUnchkd  = 1;
padPMNL = 1;
padPMNC = 8;
padPMSiz = padPMNL * padPMNC;
padPModes = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        padPMNL, padPMNC, padPMSiz);
padPModes[ui_jpad_fmts] = "%03d";
//
padPMLabs = padPModes + padPModes[ui_jpad_labs]; // addresses of labels
padPMColrs = padPModes + padPModes[ui_jpad_clrs]; // addresses of colors
padPMCells = padPModes + padPModes[ui_jpad_cells]; // addresses of cells desc.
padPMVals =  padPModes + padPModes[ui_jpad_values];
ii = 0; loop(padPMSiz,
             padPMColrs[ii] = Col_Inactive;
             padPMLabs[ii] = " ";
             padPMVals[ii] = 0;
             ii+=1; );
PMpVer=padPMNC-3;
PMpMsg=padPMNC-2;
PMpRld=padPMNC-1;
padPMColrs[0] = Col_PlMode;
padPMCells[0] = ui_jpad_ct_showval;
padPMVals[0] = 0; // default play mode

padPMColrs[PMpVer] = Col_InfoC;
padPMColrs[PMpMsg] = Col_InfoC;
padPMColrs[PMpRld] = Col_InfoC;
padPMLabs[PMpRld] = "Reload";

//————————————————————————-
// PMEsize = already defined; // size of a playmode entry
PMEcnt = 1000; // playmode entry count
PMTab = make_array(PMEsize*PMEcnt);
PMDEcnt = 0; // defined entry count
// idx_Pm_PmdN = PMEsize-1;

APtcnt = 0; // input count
PEntry = -1; // last entry defined
APEPos = -1;
APEEnt = -1;
ABval = 0;



//————————————————————————

function copyPMEntry(dst, src)
local(a)
(
    a = 0;
    (dst >= 0 && dst <PMEcnt && src>= 0 && src < PMEcnt && src != dst) ? (
        memcpy((a = PMTab+PMEsize*dst), PMTab+PMEsize*src, PMEsize);
    );
    a;
);



function
defPMEntryInit()
local (PMe)
(
    memset(PMTab, Undef, PMEsize * PMEcnt); // the whole array is set to "Undef"
    // define entry 0
    memset(PMTab, 0, PMEsize); // set to 0 entry 0
    // define some specific values for Play mode "0"
    PMTab[idx_Pm_Kmd] = KmdPlay; // default command : play
    PMTab[idx_Pm_FLM1] = mSL_Dyn_Flg1_def;   // all flags
    PMTab[idx_Pm_FLM1+1] = mSL_Dyn_Flg2_def;   // all flags
    PMTab[idx_Pm_Speed1] = 1; // min speed 1
    PMTab[idx_Pm_Speed1+1] = 1; // max speed 1
    PMTab[idx_Pm_Speed1+2] = 0; // play forward
    PMTab[idx_Pm_GDepth1] = 1;  // min voice polyphony 1
    PMTab[idx_Pm_GDepth1+1] = 1;  // max voice polyphony 1
    PMTab[idx_Pm_PVol1] = 0;  // min vol 0dB
    PMTab[idx_Pm_PVol1+1] = 0;  // max vol 0dB
    PMTab[idx_Pm_FX1] = -120;  // min send to FX1 -120dB === no send
    PMTab[idx_Pm_FX1+1] = -120;  // max send to FX1 -120dB === no send
    PMTab[idx_Pm_FX2] = -120;  // min send to FX2 -120dB === no send
    PMTab[idx_Pm_FX2+1] = -120;  // max send to FX2 -120dB === no send
    PMTab[idx_Pm_PDur1] = 5;  // min play duration /seconds
    PMTab[idx_Pm_PDur1+1] = 120;  // max play duration /seconds
    PMTab[idx_Pm_Gsize1] = 2;  // min grain size /seconds
    PMTab[idx_Pm_Gsize1+1] = 5;  // max grain size /seconds
    PMTab[idx_Pm_PmdN] = 0;
    // Duplicate 0 in 1 and 2
    PMe = copyPMEntry(1, 0);
    PMe[idx_Pm_Kmd] = KmdLoop; //  command : loop
    copyPMEntry(2, 0);
);


/*
    Check all entries - also set default values
*/
function
updPMEntries()
local(ix, PMe, v1, v2)
(
    PMDEcnt = 0;
    ix=0; loop(PMEcnt,
        PMe = PMTab + ix * PMEsize;
        (PMe[idx_Pm_Kmd] != Undef) ? (
            PMDEcnt += 1;
            // Flags
            // (PMe[idx_Pm_FLM1] === Undef) ?  PMe[idx_Pm_FLM1] = mSL_Dyn_Flg1_def;
            // (PMe[idx_Pm_FLM1+1] === Undef) ?  PMe[idx_Pm_FLM1+1] = PMe[idx_Pm_FLM1];
            // Speed - order them
            //v1 = PMe[idx_Pm_Speed1]; (v1 === Undef) ?  v1 = 1;
            //v2 = PMe[idx_Pm_Speed1+1]; (v2 === Undef) ?  v2 = v1;
            //PMe[idx_Pm_Speed1] = min(v1, v2);
            //PMe[idx_Pm_Speed1+1] = max(v1, v2);
            //(PMe[idx_Pm_Speed1+2] === Undef) ?  PMe[idx_Pm_Speed1+2] = 0;
            // Voix
            //(PMe[idx_Pm_GDepth1] === Undef) ?  PMe[idx_Pm_GDepth1] = 1;
            //(PMe[idx_Pm_GDepth1+1] === Undef) ?  PMe[idx_Pm_GDepth1+1] = PMe[idx_Pm_GDepth1];
            // Volume
            //(PMe[idx_Pm_PVol1] === Undef) ?  PMe[idx_Pm_PVol1] = 0;
            //(PMe[idx_Pm_PVol1+1] === Undef) ?  PMe[idx_Pm_PVol1+1] = PMe[idx_Pm_PVol1];
            // Durée
            //(PMe[idx_Pm_PDur1] === Undef) ?  PMe[idx_Pm_PDur1] = 5;
            //(PMe[idx_Pm_PDur1+1] === Undef) ?  PMe[idx_Pm_PDur1+1] = 2 * PMe[idx_Pm_PDur1] + 30;
            // Grains
            //(PMe[idx_Pm_Gsize1] === Undef) ?  PMe[idx_Pm_Gsize1] = 3;
            //(PMe[idx_Pm_Gsize1+1] === Undef) ?  PMe[idx_Pm_Gsize1+1] = PMe[idx_Pm_Gsize1];
            // Effet 1
            //(PMe[idx_Pm_FX1] === Undef) ?  PMe[idx_Pm_FX1] = -120;
            //(PMe[idx_Pm_FX1+1] === Undef) ?  PMe[idx_Pm_FX1+1] = PMe[idx_Pm_FX1];
            // Effet 2
            //(PMe[idx_Pm_FX2] === Undef) ?  PMe[idx_Pm_FX2] = -120;
            //(PMe[idx_Pm_FX2+1] === Undef) ?  PMe[idx_Pm_FX2+1] = PMe[idx_Pm_FX2];
            PMe[idx_Pm_PmdN] = ix;
        );
        ix += 1;
    );
);




/*
=== HP CONFIGURATIONS ===
*/
HPnumLastM = 0; HPnumUnchkd  = 1;
HPDispMode = 0;
HPInstCnt=0; // count of HP in the install...
HPInstMax=128; // the install should have less than X HP
HPCurrCDef=0;
padHPNL = 1;
padHPNC = 8;
padHPSiz = padHPNL * padHPNC;
padHPModes = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors  | ui_jpad_mk_values,
        padHPNL, padHPNC, padHPSiz);
padHPModes[ui_jpad_fmts] = "%04d";
//
padHPLabs = padHPModes + padHPModes[ui_jpad_labs]; // addresses of labels
padHPColrs = padHPModes + padHPModes[ui_jpad_clrs]; // addresses of colors
padHPCells = padHPModes + padHPModes[ui_jpad_cells]; // addresses of cells desc.
padHPVals = padHPModes + padHPModes[ui_jpad_values];// addresses of cells values
ii = 0; loop(padHPSiz,
             padHPColrs[ii] = Col_Inactive;
             padHPLabs[ii] = " ";
             ii+=1; );
//
HPpVer=padHPNC-3;
HPpMsg=padHPNC-2;
HPpRld=padHPNC-1;
//
padHPColrs[0] = Col_HPSel ;
padHPCells[0] |= ui_jpad_ct_showval;
padHPVals[0] = 1; // default HP conf.
//
padHPColrs[1] = Col_InfoC;
padHPLabs[1] = "Sequence";
//
padHPColrs[HPpMsg] = Col_InfoC;
padHPColrs[HPpRld] = Col_InfoC;
padHPLabs[HPpRld] = "Reload";

// HP SET
HPCDown = Color_Blaze_Orange; // HP du bas
HPCMidd = Color_Blue_Bell; // HP du milieu
HPCUp   = Color_Bright_Green; // HP du haut
padHPSNl = 8;
padHPSNc = 16;
padHPSSiz = padHPSNl * padHPSNc;
padHPSets = make_jpad( ui_jpad_ty_act | ui_jpad_mk_colors | ui_jpad_mk_values, padHPSNl, padHPSNc, padHPSSiz);
padHPSets[ui_jpad_fmts] = "%d";
//
padHPSColrs = padHPSets + padHPSets[ui_jpad_clrs]; // addresses of colors
padHPSCells = padHPSets + padHPSets[ui_jpad_cells]; // addresses of cells desc.
padHPSVals = padHPSets + padHPSets[ui_jpad_values];// addresses of cells values
ii = 0; loop(padHPSSiz,
            padHPSColrs[ii] = Col_Inactive;
            ii+=1; );
//—————————-
// Une entrée est:  <num. conf> <nb. de HP>  <HP.1>  <HP.2> ... <HP.N> <0>
// une configuration pointe sur <nb. de HP>
//HPASize = 0x8000; // 32768 entries
//HPPSize = 4000; // configurations
// HPGlTabSiz = HPASize + HPPSize + 4096;
HPGlTab = make_array(HPGlTabSiz);
// HPATab = make_array(HPASize);
// HPPTab = make_array(HPPSize);
pdx = HPGlTab;
pdx[0] = mSL_KW_HPATab;
pdx[1] = HPASize;
HPATab = pdx + 2; pdx += HPASize + 2;
pdx[0] = mSL_KW_HPPTab;
pdx[1] = HPPSize;
HPPTab = pdx + 2; pdx += HPPSize + 2;
pdx[0] = -1;
pdx[1] = -1;

HPApt = 0;
HPCntDef=0;


HP_use_siz = 129;
HP_use_wa = make_array(HP_use_siz);
HP_info_siz = 12;
HP_info_wa = make_array(HP_info_siz);
HP_info_flgs = 0;
HP_info_defent = 1;
HP_info_minch = 2;
HP_info_maxch = 3;
HP_info_miss = 4;
HP_info_rtc1 = 5;
HP_info_rtc2 = 6;
HP_Spec_siz = 256;
HP_Spec_set = make_array(HP_Spec_siz);
HP_Spec_setNd = HP_Spec_set + HP_Spec_siz;

// Config GL 2022
HPlev0 = 999;
HPlev1 = 999;


function HPConf2gmem()
local (ii, ptin, cf, ct)
(
    // End of loading - duplicate in gmem so that players can use it
    ii = 0; loop(HPASize, gmem[gHPATab+ii] = HPATab[ii]; ii += 1; );
    ii = 0; loop(HPPSize, gmem[gHPPTab+ii] = 0; ii += 1; );
    gmem[gHPApt] = HPApt; gmem[gHPCntDef] = HPCntDef;
    // Recreate appropriate pointer table for gmem
    ptin = ii = 0;
    (HPATab[0] === mSL_KW_FIdent) ? ( ptin = 2; );
    while (ptin < HPApt) (
        cf = abs(HPATab[ptin]); // conf number
        ptin += 1;  // skip conf number
        gmem[gHPPTab+cf] = gHPATab + ptin;
        ct = HPATab[ptin]; // conf size
        ptin += ct + 2;  // skip conf size
    );
);


function HPConfInit()
(
    HPApt = 0; // reset free pointer to 0
    memset(HPATab, 0, HPASize);
    memset(HPPTab, 0, HPPSize);
    HPInstCnt=0;
    err_fhpc = 0;
    HPCurrCDef=0;
    HPCntDef=0;
    HPConfigVersion = 0; // Means table empty
);

/* Manually build a default HP Conf table, for a single stereo pair */
function HPConfDefBuild()
local (idx)
(
    memset(HPATab, 0, HPASize);
    memset(HPPTab, 0, HPPSize);
    err_fhpc = 0;
    HPCurrCDef=0;
    HPCntDef=0;
    HPConfigVersion = 1; // means "default"
    HPApt = 0; // reset free pointer to 0
    HPATab[HPApt] = mSL_KW_FIdent; HPApt += 1;
    HPATab[HPApt] = HPConfigVersion; HPApt += 1;

    // First conf: empty
    HPATab[HPApt] = 1; HPApt += 1; // configuration "1"
    HPPTab[0] = HPATab + HPApt;
    HPPTab[1] = HPATab + HPApt;
    HPATab[HPApt] = 0 ; HPApt += 1; // size 0
    HPATab[HPApt] = 0 ; HPApt += 1; // ends with zero
    //
    // Mono, left channel
    HPATab[HPApt] = 11; HPApt += 1; // configuration "11"
    HPPTab[11] = HPATab + HPApt;
    HPATab[HPApt] = 1 ; HPApt += 1; // size 1
    HPATab[HPApt] = 1 ; HPApt += 1; // uses HP n° 1
    HPATab[HPApt] = 0 ; HPApt += 1; // ends with zero
    //
    // Mono, right channel
    HPATab[HPApt] = 12; HPApt += 1; // configuration "12"
    HPPTab[12] = HPATab + HPApt;
    HPATab[HPApt] = 1 ; HPApt += 1; // size 1
    HPATab[HPApt] = 2 ; HPApt += 1; // uses HP n° 2
    HPATab[HPApt] = 0 ; HPApt += 1; // ends with zero
    //
    // Stereo std.
    HPATab[HPApt] = 21; HPApt += 1; // configuration "21"
    HPPTab[21] = HPATab + HPApt;
    HPATab[HPApt] = 2 ; HPApt += 1; // size 2
    HPATab[HPApt] = 1 ; HPApt += 1; // uses HP n° 1
    HPATab[HPApt] = 2 ; HPApt += 1; // uses HP n° 2
    HPATab[HPApt] = 0 ; HPApt += 1; // ends with zero
    //
    // Stereo inverted
    HPATab[HPApt] = 22; HPApt += 1; // configuration "22"
    HPPTab[22] = HPATab + HPApt;
    HPATab[HPApt] = 2 ; HPApt += 1; // size 2
    HPATab[HPApt] = 2 ; HPApt += 1; // uses HP n° 2
    HPATab[HPApt] = 1 ; HPApt += 1; // uses HP n° 1
    HPATab[HPApt] = 0 ; HPApt += 1; // ends with zero
    //
    AHPmax = HPCurrCDef = 22; // this is current conf
    HPInstCnt = 2; // uses 2 HP.
    HPCntDef = 5; // 5 configurations are defined.
    padHPVals[0] = HPCurrCDef;
    HPConf2gmem();
);

function HPConfBuild()
local(ptc, ptin, val, state, ucnt)
(
    ptc = ptin = 0;
    state = 0;
    ucnt = 0;
    memset(HPPTab, 0, HPPSize);
    HPInstCnt=0;
    AHPmax = 0;
    // Is there a config identification ?
    (HPATab[0] === mSL_KW_FIdent) ? (
        val = HPATab[1];
        ((val < mSL_Max_Flgs) && (val > 0) && (val == (0|val))) ? (
            HPConfigVersion = val;
        ) : (
            err_fhpc = 0313; // Invalid configuration identification
        );
        ptin += 2;
    );
    HPPTab[0] = HPATab + ptin + 1;
    while ((ptin < HPASize) && (err_fhpc === 0)) (
        val = HPATab[ptin];
        (state === 0) ? (
            (val > 0) ? (
                // looking for a conf #
                (val < HPPSize) ? (
                    (val > AHPmax) ? AHPmax = val;
                    (HPPTab[val] != 0) ? (
                        err_fhpc = 0317; // configuration already defined
                    );
                    HPPTab[val] = HPATab + ptin +1;
                    HPCurrCDef=val; // current definition
                    HPCntDef +=1; // def. count
                ) : (
                    err_fhpc = 0311; // conf. number too high
                );
                state = 1;
            );
            // in state 0, any number <=0 is eliminated
        ) :
        (state === 1) ? (
            // Check HP count
            ((val > 0) && (val <= HPInstMax)) ? (
                ucnt = val;
            ) : (
                err_fhpc = 0312; // incorrect HP count in conf.
            );
            state = 2;
        ) :
        (state === 2) ? (
            (ucnt > 0) ? (
                // expect a HP number
                ((val > 0) && (val <= HPInstMax)) ? (
                    ucnt -= 1;
                    (val > HPInstCnt) ? HPInstCnt = val; // keep max. HP number
                ) : (
                    err_fhpc = 0315; // HP num invalid
                );
            ) :
            (
                // we expect a final "0"
                (val === 0) ? (
                    state = 0;
                ) : (
                    err_fhpc = 0316; // final "0" expected
                );
            );
        );
        ptin += 1;
    );
);


function HPConfCheck()
local (ptin, cf, ct, val)
(
    ptin = ct = 0;
    HPInstCnt = HPCntDef = 0;
    // Is there a config identification ?
    (HPATab[0] === mSL_KW_FIdent) ? (
        val = HPATab[1];
        ((val < mSL_Max_Flgs) && (val > 0) && (val == (0|val))) ? (
            HPConfigVersion = val;
        ) : (
            err_fhpc = 0314; // Invalid configuration identification
        );
        ptin = 2;
    );
    while (ptin < HPApt) (
        cf = HPATab[ptin]; // conf number
        ptin += 1;  // skip conf number
        ct = HPATab[ptin]; // conf size
        ptin += 1;  // skip conf size
        (cf > 0) ? (
            loop (ct,
                val = HPATab[ptin];
                (val > HPInstCnt) ? HPInstCnt = val; // keep max. HP number
                ptin += 1;
            );
        ) : (
            loop (ct,
                val = HPATab[ptin]; // should be a conf number
                ((val <= 0) || (val >= HPPSize)) ? (STBerr = 0731;) :
                (((pt = HPPTab[val]) <= HPATab) || (pt >= HPATab + HPASize)) ? (STBerr = 0732;) :
                ((pt[-1]!= val)) ? ( STBerr = 0733;);
                ptin += 1;
            );
        );
        ptin += 1; // skip final 0
    );
    // count, independently, configurations
    ptin = 0; loop(HPPSize,
        (HPPTab[ptin] != 0) ? HPCntDef +=1; // conf count
        ptin += 1;
    );

    HPConf2gmem();
);



/*
=== CLIPSETS ===
*/
// clipsWorkArea [already declared] is a clipsWorkAreaSize (10000) words work area
ClSetPSize = 2048;
ClSetPtr = make_array(ClSetPSize);
ClSetDSize = 8192; // contents for clipsets definitions
ClSetTab = make_array(ClSetDSize+128);
ClSetTAPtr = 0;
ClSet_ErrRe  = 0;
ClSetAAloc = ClSetPSize - 1;
convertClipRanges= 1; // as a test
// Description of an entry
ClSet_num = 0; // Set number
ClSet_cnt = 1; // actual count of clips
ClSet_MinL = 2; // minimum length requested
ClSet_MaxL = 3; // maximum length requested
ClSet_Algo = 4; // algo flags
ClSet_Rnd = 5; // a random number
ClSet_Start = 6; // exploration start position
ClSet_Lst = 7; // last chosen entry
ClSet_Genc = 8; // total count generated clips
ClSet_UCLA = 9; // if Unique CLip Available
ClSet_lastclp = 10; // last clip
ClSet_lastcnt = 11; // current set size
ClSet_1stC = 12; // 1st precomputed clip
ClSet_lCl = 62; // up to (ClSet_lCl - ClSet_1stC) pre-results


function
clearClipSets()
(
    memset(ClSetPtr, -1, ClSetPSize);
    memset(ClSetTab, -1, ClSetDSize);
    ClSetAAloc = ClSetPSize - 1;
    ClSetTAPtr = 0;
    delayLoad += 2;
);
clearClipSets();


function
closeClipSet()
local (ps, n)
(
    ps = ClSetTab + ClSetTAPtr; // current set
    (((n = ps[0]) >= 0) && (n < ClSetPSize) && (ClSetPtr[n] === -1)) ? (
        ClSetPtr[n] = ps;
        //ps[ClSet_mclu] = 99999; // Min clip limit
        pts = ps + ClSet_lCl;
        // explore clip workarea
        cw = clipsWorkArea; cp = 0; sc = lc = cc = -1;
        while (cp < clipsWorkAreaSize) (
            cc = clipsWorkArea[cp];
            (cc >= 0) ? (
                (sc < 0) ? (
                    // keep start clip
                    sc = cc;
                );
                lc = cc;
            ) :
            (sc >= 0) ? (
                // keep sequence
                pts[0] = sc * clipsWorkAreaSize + lc; pts += 1;
                0 ? (sprintf(#s, "   Seq: %d -> %d", sc, lc); mSL_log(SysLogBox, #s););
                sc = lc = -1;
            );
            cp += 1;
        );

        (sc >= 0) ? (
            // keep sequence
            pts[0] = sc * clipsWorkAreaSize + lc; pts += 1;
            0 ? (sprintf(#s, "   Seq: %d -> %d", sc, lc); mSL_log(SysLogBox, #s););
            sc = lc = -1;
        );
        pts[0] = -1; pts += 1;
        ClSetTAPtr += pts - ps;
    );
);


function
resetClipSet(csn)
local(lstcs, i)
(
    (csn < 0) ? (csn = 0; lstcs=ClSetPSize-1;) : (lstcs = csn;);
    while (csn <= lstcs) (
        ps = ClSetPtr[csn];
        ((ps > 0) && (ps[0] == csn)) ? (
            ps[ClSet_cnt] = 0;
            i = ClSet_1stC; while (i < ClSet_lCl) (ps[i] = -2; i+= 1;);
        );
        csn += 1;
    );
);



function
clipFromSet(set)
local (cl, ps, i, j, k, l, f, flgs, g, pp, cnt, cp, c1, c2, r, p, a, mclu, lprtr)
(
    cl = -2; ClSet_ErrRe = 0;
    ((set >= 0) && (set < ClSetPSize) && (set === (0|set)) && ((ps = ClSetPtr[set]) >= ClSetTab) && (set === ps[ClSet_num])) ? (
        // Do we already have some clip number computed ?
        cl = ps[ClSet_UCLA]; // Unique Clip Left Available case

        i = ClSet_1stC; while ((cl < 0) && (i < ClSet_lCl)) (
            ((cl = ps[i]) >= 0) ? ps[i] = -2;
            i += 1;
        );

        (cl < 0) ? (
            // no saved clip found
            flgs = ps[ClSet_Algo];
            f = flgs & 0x100; // PLUC flag
            r = ps[ClSet_Rnd]; // the random
            // Should we Play Less Used Clips (PLUC) ?
            (f = (flgs & 0x100)) ? (



                // PLUC flag set
                lprtr = 2;
                while ((cl === -2) && (lprtr > 0))
                (
                    lprtr -= 1;
                    // explore the set and create entries
                    // First, build the whole conf in clipsWorkArea
                    pp = ps + ClSet_lCl;
                    // mclu = K = ps[ClSet_mclu];
                    mclu = 999999999;
                    cnt = 0; g = 1; clipsWorkArea[0] = -1;  // set might be empty
                    while ((cp = pp[0]) >= 0) (
                        c1 = 0|(cp / clipsWorkAreaSize); c2 = cp % clipsWorkAreaSize;
                        while (c1 <= c2) (
                            //is c1 an acceptable clip ?
                            i = gmem[clClDurations+c1]; j = gmem[clInfStart+c1];
                            // nb: j is < 0 if the clip has been locked or is in error
                            ((j >= 0) && (i >= ps[ClSet_MinL]) && (i <= ps[ClSet_MaxL])) ? (
                                // size correct
                                (j <= mclu) ? (
                                    // clip could be selected
                                    (mclu > j) ? (
                                        mclu = j; cnt = 0;
                                    );
                                    clipsWorkArea[cnt] = c1;
                                    cnt += 1;
                                );
                            /*
                            ) :
                            (((i === 0) || (j === 0)) && (g === 1)) ? (
                                // do 1 exploration of a clip
                                gmem[clClInfos+c1] = gmem[clInfStart+c1] = 0; // will force recheck the clip
                                (gmem[clClDurations+c1] === 0) ? gmem[clClDurations+c1] = -1; // eliminate the clip for now
                                //checkClip(c1, 1); g = 0; // but force recheck
                                //ClCheckFlag = 1; // ask for clips rechecking
                                //ClCheckView = 1; cBk4 = 0;
                            */
                            );
                            c1 += 1;
                        );
                        pp += 1;
                    );
                    ps[ClSet_cnt] = max(ps[ClSet_cnt], cnt); // keep count of clips
                    clipsWorkArea[cnt] = -1; ps[ClSet_lastcnt] = cnt;
                    (cnt > 0) ? (
                        (cnt <= 1) ? (
                            // just one clip in the set. Simplify the rest
                            p = 0;
                            cl = clipsWorkArea[0];
                        ) : (
                            // more than 1 clip in the set - try to keep a few
                            a = ((flgs & 0xFF) === 2);
                            // a = ((flgs & 1) === 0);
                            // Provide a first random clip as immediate result
                            ((p = ps[ClSet_Lst] % cnt) === (ps[ClSet_Start] % cnt)) ? (
                                (flgs & 1) ? (
                                    // restart at zero
                                    (r > 0) ? (
                                        ps[ClSet_Start] = 0;
                                    ) : (
                                        ps[ClSet_Start] = cnt - 1;
                                    );
                                ) :
                                ((flgs & 1) === 0) ? (
                                    // Change random prime
                                    ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
                                    ps[ClSet_Start] = (smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];) % cnt;
                                );
                                p = ps[ClSet_Start];
                            );
                            //
                            r = (r + cnt + cnt) % cnt;
                            cl = clipsWorkArea[p]; // this result
                            ps[ClSet_UCLA] = -2; // no shortcut
                            p = (a ? (irand(cnt)) : ((p + r) % cnt);); // the next result
                            // Save some more in the structure if clip reading is completed
                            g ? (
                                i = ClSet_1stC; j = cnt;
                                while ((i < ClSet_lCl) && (p != (ps[ClSet_Start] % cnt)) && (j > 0)) (
                                    ps[i] = clipsWorkArea[p]; i += 1; j -= 1;
                                    p = (a ? (irand(cnt)) : ((p + r) % cnt);); // next
                                );
                            );
                        );
                        ps[ClSet_Lst] = p; // save next entry for future use
                    ) : (
                        // Current selection is empty. Try again
                        ClSet_ErrRe += 1; // set is empty
                        (flgs & 1) ? (
                            ps[ClSet_Start] = ps[ClSet_Lst] = 0; // always restart from first selected
                        );
                    );
                );



            ) : (



                // Just explore the set
                while ((cl === -2))  (
                    // explore the set and create entries
                    // First, build the whole conf in clipsWorkArea
                    lprtr -= 1;
                    //mclu = K = ps[ClSet_mclu];
                    cnt = 0; g = 1; clipsWorkArea[0] = -1;  // set might be empty
                    pp = ps + ClSet_lCl;
                    while ((cp = pp[0]) >= 0) (
                        c1 = 0|(cp / clipsWorkAreaSize); c2 = cp % clipsWorkAreaSize;
                        while (c1 <= c2) (
                            //is c1 an acceptable clip ?
                            i = gmem[clClDurations+c1]; j = gmem[clInfStart+c1];
                            // nb: j is < 0 if the clip has been locked or is in error
                            ((j >= 0) && (i >= ps[ClSet_MinL]) && (i <= ps[ClSet_MaxL])) ? (
                                    clipsWorkArea[cnt] = c1;
                                    cnt += 1;
                            /*
                            ) :
                            (((i === 0) || (j === 0)) && (g === 1)) ? (
                                // do 1 exploration of a clip
                                gmem[clClInfos+c1] = gmem[clInfStart+c1] = 0; // will force recheck the clip
                                (gmem[clClDurations+c1] === 0) ? gmem[clClDurations+c1] = -1; // eliminate the clip for now
                                //checkClip(c1, 1); g = 0; // but force recheck
                                //ClCheckFlag = 1; // ask for clips rechecking
                                //ClCheckView = 1; cBk4 = 0;
                            */
                            );
                            c1 += 1;
                        );
                        pp += 1;
                    );
                    ps[ClSet_cnt] = max(ps[ClSet_cnt], cnt); // keep count of clips
                    clipsWorkArea[cnt] = -1; ps[ClSet_lastcnt] = cnt;
                    (cnt > 0) ? (
                        (cnt <= 1) ? (
                            // just one clip in the set. Simplify the rest
                            p = 0; cl = clipsWorkArea[0];
                            ((ps[ClSet_cnt] == 1) && (ps[ClSet_Genc] > 10)) ? (
                                // try to keep the clip for future use
                                ps[ClSet_UCLA] = cl;
                            );
                        ) : (
                            // more than 1 clip in the set - try to keep a few
                            a = ((flgs & 0xFF) === 2);
                            // Provide a first random clip as immediate result
                            ((p = ps[ClSet_Lst] % cnt) === (ps[ClSet_Start] % cnt)) ? (
                                (flgs & 1) ? (
                                    // restart at zero
                                    (r > 0) ? (
                                        ps[ClSet_Start] = 0;
                                    ) : (
                                        ps[ClSet_Start] = cnt - 1;
                                    );
                                ) :
                                ((flgs & 1) === 0) ? (
                                    // Change random prime
                                    ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
                                    ps[ClSet_Start] = (smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];) % cnt;
                                );
                                p = ps[ClSet_Start];
                            );
                            //
                            cl = clipsWorkArea[p]; // this result
                            ps[ClSet_UCLA] = -2; // no shortcut
                            p = (a ? (irand(cnt)) : ((p + r + cnt) % cnt);); // the next result
                            // Save some more in the structure if clip reading is completed
                            g ? (
                                i = ClSet_1stC; while ((i < ClSet_lCl) && (p != (ps[ClSet_Start] % cnt))) (
                                    ps[i] = clipsWorkArea[p]; i += 1;
                                    p = (a ? (irand(cnt)) : ((p + r + cnt) % cnt););
                                );
                            );
                        );
                        ps[ClSet_Lst] = p; // save next entry to use
                    ) : (
                        cl = -1;
                    );
                );
            );

        );

        ps[ClSet_Genc] += 1;
        ps[ClSet_lastclp] = cl;

    ) : (
        ClSet_ErrRe = 8; // set undefined
    );

    (cl >= 0) ? cl : -1; // return a clip # or -1

);



/*
=== SPACE MODES ===
*/
SMnumLastM = 0; SMnumUnchkd  = 1;
padSMNL = 1;
padSMNC = 8;
padSMSiz = padSMNL * padSMNC;
padSModes = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        padSMNL, padSMNC, padSMSiz);
padSModes[ui_jpad_fmts] = "%03d";
//
padSMLabs = padSModes + padSModes[ui_jpad_labs]; // addresses of labels
padSMColrs = padSModes + padSModes[ui_jpad_clrs]; // addresses of colors
padSMCells = padSModes + padSModes[ui_jpad_cells]; // addresses of cells desc.
padSMVals =  padSModes + padSModes[ui_jpad_values];
ii = 0; loop(padSMSiz,
             padSMColrs[ii] = Col_Inactive;
             padSMLabs[ii] = " ";
             ii+=1; );
//
SMpVer=padSMNC-3;
SMpMsg=padSMNC-2;
SMpRld=padSMNC-1;
padSMColrs[0] = Col_SpMode ;
padSMCells[0] = ui_jpad_ct_showval;

padSMColrs[SMpVer] = Col_InfoC;
padSMColrs[SMpMsg] = Col_InfoC;
padSMColrs[SMpRld] = Col_InfoC;
padSMLabs[SMpRld] = "Reload";
// ————————————————————-
SMESize = 12; // size of a spacemode entry
SMEcnt = 1000; // Spacemode entry count
SMTab = make_array(SMESize*SMEcnt);
SMDEcnt = 0;

ASErrCfr = 0;
ASErrSensr = 0;
SEntry = -1; // Last entry defined
ASEPos = -1;
ASEEnt = -1;


function defSMEntryDefault()
local(SMe)
(
    memset(SMTab, Undef, SMESize * SMEcnt);
    // define Entries 0 and 1
    memset(SMTab, 0, SMESize); // set to 0 all entries
    SMe = SMTab;
    SMe[idx_Sm_sMnum] = 0;
    SMe[idx_Sm_HPSet1] = 201; // use HP Set 201
    SMe[idx_Sm_HPCnt1] = 2;
    SMe[idx_Sm_HPCnt2] = 2;
    SMe += SMESize;
    memcpy(SMe, SMTab, SMESize);
    SMe[idx_Sm_sMnum] = 1;
    SMe += SMESize;
    memcpy(SMe, SMTab, SMESize);
    SMe[idx_Sm_sMnum] = 2;
);

function
updSMEntries()
local(ix, k, SMe)
(
    SMDEcnt = 0;
    ix=0; loop(SMEcnt,
        SMe = SMTab + ix * SMESize;
        (SMe[idx_Sm_HPSet1] != Undef) ? (
            SMDEcnt += 1;
            SMe[idx_Sm_sMnum] = ix;
            SMe[idx_Sm_Algo] === Undef ? SMe[idx_Sm_Algo] = 0;
            SMe[idx_Sm_HPCnt2] === Undef ? SMe[idx_Sm_HPCnt2] = SMe[idx_Sm_HPCnt1];
            // SMe[idx_Sm_HPSet2] === Undef ? SMe[idx_Sm_HPSet2] = SMe[idx_Sm_HPSet1];
            // other undefined values are set to 0
            k = 0; loop(SMESize,
                SMe[k] === Undef ? SMe[k] = 0;
                k += 1;
            );
        );
        ix += 1;
    );
);



/*
=== BANKS DEFINITIONS ===
*/
BKnumLastM = 0; BKnumUnchkd  = 1;
padBKNL = 2;
padBKNC = 8;
padBKSiz = padBKNL * padBKNC;
padBKSets = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        padBKNL, padBKNC, padBKSiz);
padBKSets[ui_jpad_fmts] = "%04d";
//
padBKLabs = padBKSets + padBKSets[ui_jpad_labs]; // addresses of labels
padBKColrs = padBKSets + padBKSets[ui_jpad_clrs]; // addresses of colors
padBKCells = padBKSets + padBKSets[ui_jpad_cells]; // addresses of cells desc.
padBKVals = padBKSets + padBKSets[ui_jpad_values]; // addresses of pad values
//
ii = 0; loop(padBKSiz,
             padBKColrs[ii] = Col_Inactive;
             padBKLabs[ii] = " ";
             ii+=1; );
//
BKpVer=padBKNC-3;
BKpMsg=padBKNC-2;
BKpRld=padBKNC-1;
padBKColrs[0] = Col_Partial ;
padBKVals[0] = 0; // default displayed entry
padBKVals[1] = 0; // default displayed entry
padBKVals[2] = 0; // default displayed entry
padBKVals[3] = 0; // default displayed entry
//
padBKColrs[BKpVer] = Col_InfoC;
padBKColrs[BKpMsg] = Col_InfoC;
padBKColrs[BKpRld] = Col_InfoC;
padBKLabs[PMpRld] = "Reload";
//
// ————————————————————-
BKEsize = 12; // size of a bank entry
BKEcnt=5000;  // number of partials
Part1st = BKTab = make_array(BKEsize*BKEcnt);
BKDEcnt=0; // defined entry count
BKDESpEnt = -1;
BKFrst = 0; // Première entrée utilisée
curPartial = make_array(BKEsize);
BgrpCurr = 0;  // current group
BGrpLow = 0;  // group low limit
BGrpHigh = BKEcnt-1; // group high limit
BGrpSelect = 0;  // lock indicator for group when searching partial

// Allow up to 1000 partials for a group
BKPtSiz = 1000; // selected entries
BKPtCnt = 0;
BKPtTab = make_array(BKPtSiz); // Pointers to BKTab
BKPtMass = make_array(BKPtSiz); // Cumulative masses
BKCurrGrp = -2;
BKCurrBnk = -2;
BKCumSum = 0;

BKMxGrpn = 0;
BKMxBnkn = 0;

BShowEntry = 0;
BNumEntry = 0;


// Allow up to 2000 groups
GRPtSiz = 2000;
GRPtTab = make_array(GRPtSiz);
// Current values
Grp_nb = Bnk_nb = PlM_nb = SpM_nb = 0;
bankCheckbfnd = bankCheckcfnd = 0;

// Check that the current bank is valid...
function BankCheckEntry()
local (cl, v, bn)
(
    // It should have at least a clip number
    ((cl = curPartial[idx_Pa_Clps]) != Undef) ? (
        ((cl >= 0) && (cl <= 9999)) ? (
            curPartial[idx_Pa_Clps+1] === Undef ? curPartial[idx_Pa_Clps+1] = curPartial[idx_Pa_Clps];
            cl = curPartial[idx_Pa_Clps+1];
            ((cl < 0) || (cl > 9999)) ? err_fbnk = 0340; // invalid clip number
            (cl < curPartial[idx_Pa_Clps]) ? ( // xchange both values
                curPartial[idx_Pa_Clps+1] = curPartial[idx_Pa_Clps]; curPartial[idx_Pa_Clps] = cl;
            );
        ) : (
            (cl === -1) ? (
                // a Set number
                cl = curPartial[idx_Pa_Clps+1];
                ((cl < 0) || (cl > 999)) ? err_fbnk = 0341;
            ) : (
                err_fbnk = 0342; // incorrect clip number
            );
        );
        (err_fbnk === 0) ? (
            // build a new entry
            curPartial[idx_Pa_Grp] === Undef ? curPartial[idx_Pa_Grp] = Grp_nb;
            v = curPartial[idx_Pa_Grp];
            ((v < 0) || (v >= GRPtSiz)) ? err_fbnk = 0344; // invalid group number
            v > BKMxGrpn ? BKMxGrpn = v;
            curPartial[idx_Pa_Bnk] === Undef ? curPartial[idx_Pa_Bnk] = Bnk_nb;
            bn = curPartial[idx_Pa_Bnk]; // bank number
            ((bn < 0) || (bn >= 65536)) ? err_fbnk = 0345; // invalid bank number
            bn > BKMxBnkn ? BKMxBnkn = bn;
            curPartial[idx_Pa_PlM] === Undef ? curPartial[idx_Pa_PlM] = PlM_nb;
            v = curPartial[idx_Pa_PlM];
            ((v < 0) || (v >= PMEcnt)) ? err_fbnk = 0348; // invalid play mode
            curPartial[idx_Pa_SpM] === Undef ? curPartial[idx_Pa_SpM] = SpM_nb;
            v = curPartial[idx_Pa_SpM];
            ((v < 0) || (v >= SMEcnt)) ? err_fbnk = 0349; // invalid space mode
            curPartial[idx_Pa_prVol] === Undef ? curPartial[idx_Pa_prVol] = 0;
            v = curPartial[idx_Pa_prVol];
            ((v < -120) || (v > 24)) ? err_fbnk = 0350; // invalid min vol
            curPartial[idx_Pa_prVol+1] === Undef ? curPartial[idx_Pa_prVol+1] = curPartial[idx_Pa_prVol];
            v = curPartial[idx_Pa_prVol+1];
            ((v < -120) || (v > 24)) ? err_fbnk = 0351; // invalid max vol
            curPartial[idx_Pa_PWeight] === Undef ? curPartial[idx_Pa_PWeight] = 1;
            v = curPartial[idx_Pa_PWeight];
            ((v < 0.01) || (v > 32767)) ? err_fbnk = 0352; // invalid partial weight
            curPartial[idx_Pa_PClass] === Undef ? curPartial[idx_Pa_PClass] = 0;
            curPartial[idx_Pa_PBFlgs] === Undef ? curPartial[idx_Pa_PBFlgs] = 0;
            v = curPartial[idx_Pa_PBFlgs];
            ((v < 0) || (v > mSL_Max_Flgs)) ? err_fbnk = 0353; // invalid Flags value
            curPartial[idx_Pa_PNumb] = 0; // will be updated later
            // keep entry
            (BKDESpEnt >= 0) ? (
                memcpy(BKTab + BKDESpEnt*BKEsize, curPartial, BKEsize); BKDESpEnt = -1;
            ) :
            (BKDEcnt < BKEcnt) ? (
                memcpy(BKTab + BKDEcnt*BKEsize, curPartial, BKEsize); BKDEcnt += 1;
            ) : (
                err_fbnk = 0354;  // partial table full
            );
            memset(curPartial, Undef, BKEsize); //
        );
        bankCheckbfnd = bankCheckcfnd = 0;
    );
);




function defBankInit()
local (b, P0)
(
    // Create a default entry 0.
    memset(BKTab, Undef, BKEsize*BKEcnt);
    err_fbnk = 0;
    memset(curPartial, Undef, BKEsize); // a working partiel
    memset(BKPtTab, Undef, BKPtSiz);    // up to BKPtSiz = 1000 partiels/group
    memset(GRPtTab, Undef, GRPtSiz);    // up to GRPtSiz = 2000 groups
    BKMxGrpn = BKMxBnkn = Grp_nb = Bnk_nb = PlM_nb = SpM_nb = 0;
    BKFrst = BKDEcnt = 64; // some partials reserved, no entry defined so far
    Part1st = BKTab + BKEsize * BKFrst;
    memset(BKTab, 0, BKEsize); BKTab[idx_Pa_Clps2] = 9999; // Partial 0
    // Reset some variables
    GvPlayTyp = GvPlayTypGroup; // default select group
    GvPlayGrp = 0;
    GvPlayBnk = 0;
    GvPlayPart = 0;
    GvPlayPartent = BKTab;
    GvPlayPM = 0;
    GvPlaySM = 0;
    GvPlayCl0 = 0;
    GvPlayCl1 = 0;
    GvPlayCl2 = 9999;
    GvPlayCl3 = 0;
    0 ? (
        b = BKTab;
        sprintf(#s2, "**P0  %d %d %d %d --- %d %d %d %d", b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
        mSL_log(SysLogBox, #s2);
    );
    0 ? mSL_log(SysLogBox, "Banks Cleared.");
);


// Select some partials according to a criteria
function
BKSelectParts(grpn, bnkn, sflgs)
local(ii, pt, iTab, cummass, pkm, r)
(

    ii = BKFrst; // do not check reserved partials
    pt = 0;
    iTab = BKEsize * BKFrst;

    ((BKCurrGrp != grpn) || (BKCurrBnk != bnkn) || (sflgs != 0)) ? (
        // compute the new set
        cummass = 0; // cumulative mass
        while ((ii < BKDEcnt) && (pt < BKPtSiz)) (
            ((BKTab[iTab+idx_Pa_Grp] === grpn) &&
            ((bnkn === -1) || (bnkn === BKTab[iTab+idx_Pa_Bnk]))) ? (
                // Get the playmode command
                pkm = PMTab[PMEsize*BKTab[iTab+idx_Pa_PlM]+idx_Pm_Kmd];
                (((sflgs & MskForcePlay) === 0)
                || ((sflgs & FLdoForceRead) && (pkm === KmdPlay))
                || ((sflgs & FLdoForceLoop) && (pkm === KmdLoop))) ? (
                    // keep the information
                    BKPtTab[pt] = ii;
                    BKPtMass[pt] = cummass = cummass + BKTab[iTab+idx_Pa_PWeight];
                    pt += 1;
                );
            );
            ii += 1;
            iTab += BKEsize;
        );
        BKPtCnt = pt;
        BKCurrGrp = grpn;
        BKCurrBnk = bnkn;
        BKCumSum = cummass;
    );

    (BKPtCnt > 0) ? (
        // choose a random entry corresponding to a partial
        cummass = BKPtMass[BKPtCnt-1];
        r = cummass * frand();
        ii = 0;
        while ((ii < BKPtCnt-1) && (r > BKPtMass[ii])) (
            ii += 1;
        );
        BKPtTab[ii]; // return the partial number
    ) : (
        -1;
    );
);




// Convert the partial clip entry into a Set
function
autoConvertClRange(xpart)
local(klc, khc, set, ps, x)
(
    klc = xpart[idx_Pa_Clps];
    khc = xpart[idx_Pa_Clps+1]; // low & high clips numbers
    (klc > khc) ? (x = klc; klc = khc; khc = x;);

    ((klc >= 0) && (ClSetTAPtr < ClSetDSize)) ? (
        ps = ClSetTab + ClSetTAPtr; // for now keep info in this area
        memset(ps, -2, ClSet_lCl + 2);
        ClSetTAPtr += ClSet_lCl + 2; // always this size
        ps[ClSet_cnt] = -1; // actual count of clips updated later;
        ps[ClSet_Algo] = 0; // default algorithm type;
        ps[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
        ps[ClSet_MinL] = 0.001; // default min length : 0.001 seconds;
        ps[ClSet_MaxL] = 3600; // default max length : 1 hour;
        ps[ClSet_Lst] = ps[ClSet_Start] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize]; // last entry used;
        ps[ClSet_Genc] = 0; // number of clip generated;
        //ps[ClSet_mclu] = 99999; // Min clip limit
        memset(clipsWorkArea, -1, clipsWorkAreaSize); // clear work area
        // Allocate a set number
        set = ClSetAAloc;
        while ((set > 0) && (ClSetPtr[set] != -1)) (set -= 1; );
        ClSetAAloc = set; // as a default, use set "0"
        (ClSetPtr[set] != -1) ? err_fbnk = 0771;
        ClSetPtr[set] = ps;
        // Create the list
        ps[ClSet_lCl] = klc *  clipsWorkAreaSize + khc; // next one is already -1
        ps[ClSet_num] = set;
        // Update the partial
        xpart[idx_Pa_Clps] = -1;
        xpart[idx_Pa_Clps+1] = set;
        0 ? (sprintf(#s, "**  autoConvertClRange(%d / %d) [%d %d => %d]", xpart, 0|((xpart - BKTab)/BKEsize), klc, khc, set); mSL_log(SysLogBox, #s);
        );
    );


);



/*
=== STUDIO PLAY PAD ===
*/
StdnumLastM = 0; StdnumUnchkd  = 1;


//
padStNL = 8; padStvNL = 8;
padStNC = 8;
padStSiz = padStvNL * padStNC;
padKnt = 2; // we define 2 pads
padStTotSiz = padStSiz * padKnt;  // 128
cmdPadBase = 16; // command pad base
cmdClMdBase = max(512, cmdPadBase + padStTotSiz); // global offset for a clip mode command: 512
cmdStdBase = max(1024, 256+cmdClMdBase); // other command: 1024
padStGFact = 4; // pad studio grow factor

padStudio = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_rrcells,
        padStNL, padStNC, padStSiz);
padStudio[ui_jpad_fmts] = "%04d";
padStudio[ui_jpad_gloff] = 0;
//
padStLabs = padStudio + padStudio[ui_jpad_labs]; // addresses of labels
padStColrs = padStudio + padStudio[ui_jpad_clrs]; // addresses of colors
padStCells = padStudio + padStudio[ui_jpad_cells]; // addresses of cells desc.

padStPVals = make_array(padStTotSiz); // all partials values
padStFlags = make_array(padStTotSiz); // addt. flags
padStClipsL = make_array(padStTotSiz); // low clip number
padStClipsH = make_array(padStTotSiz); // low clip number
padStErrors = make_array(padStTotSiz); // errors codes
//

/*
padStFlDspM = 0x7; // display type mask
padStFlErrbit = 0x8; // error flag
padStFlDisp = padStFlDspM | padStFlErrbit;
padStFlMsk  = 0xfffffff0; // keeping the cell flags
padStFlMsk7 = padStFlMsk | padStFlDspM; // keeping the flags except error
*/

padStFlDspM = 0xf; // display type mask
padStFlErrbit = 0x10; // error flag
padStFlDisp = padStFlDspM | padStFlErrbit;
padStFlMsk  = 0xffffffe0; // keeping the cell flags
padStFlMsk7 = padStFlMsk | padStFlDspM; // keeping the flags except error


padStOffset = 0; // offset  in values
padStDeltaOffset = 16;
padStMaxOffset = padStTotSiz - padStSiz + padStDeltaOffset;

padStDispNone = 0;
padStDispPar = 1;
padStDispGrp = 2;
padStDispGBk = 3;
padStDispRng = 4;
padStDispClip = 5;
padStDispAct = 6;
padStDispSpec = 7;

padStDispErr = 8;
//
ii = 0; loop(padStSiz,
             padStColrs[ii] = Col_Inactive;
             padStLabs[ii] = " ";
        ii+=1; );
ii = 0; loop(padStTotSiz,
             padStFlags[ii] = 1; // default display mode
             padStPVals[ii] = 0; // display partial 0 by default
             padStClipsL[ii] = -1; // low clip #
             padStClipsH[ii] = -1; // high clip #
             padStErrors[ii] = 0; // no error yet
        ii+=1; );
//

menu_Stud_Pad = make_jmenu(
        ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
        "Mode", "None|Partial|Group|Group + Bank|Clips range|Clip select|Action|Special|Err show");
menuStudPDM = 9; // nb. de display modes


//====== Actions ======
StdActLastM = 0; StdActUnchkd  = 1;
padAcNl = 2;
padAcNc = 8;
padAcSiz = padAcNl * padAcNc;
padcNl_PCtrl = 2; // Currently used number of lines in Units play control
padActions = make_jpad(
        ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
        padAcNl, padAcNc, padAcSiz);
//
padAcLabs = padActions + padActions[ui_jpad_labs]; // addresses of labels
padAcColrs = padActions + padActions[ui_jpad_clrs]; // addresses of colors
padAcCells = padActions + padActions[ui_jpad_cells]; // addresses of cells desc.
padAcVals =  padActions + padActions[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padAcSiz,
             padAcColrs[ii] = Col_Inactive;
             padAcLabs[ii] = " ";
             ii+=1; );
//

menu_Act_Mode = make_jmenu(
        ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
        "Mode", "!Studio Pad|Group|Bank|Partial|Clip|Range|Any Clip|Any Bank");
menuActModeCnt = 8; // nb. of display modes

// #dbg_trace2 = menu_Act_Mode[ui_jmenu_items];
//
// Pad colors, depending on GvPlayTyp
GvPlayTypGroup = 1;
GvPlayTypBank = 2;
GvPlayTypPartial = 3;
GvPlayTypClip = 4;
GvPlayTypRange = 5;
GvPlayTypAnyClip = 6;
GvPlayTypAnyBank = 7;
// flag : the cell has been clicked
GvPlayClipClicked = 8;
// Specific commands
GvPlayTypGrPlay = 15;
GvPlayTypGrLoop = 14;
// Pad "Group" - active for Group, Bank, Partial
PadTypGroup = uix_bit_set[GvPlayTypGroup] | uix_bit_set[GvPlayTypBank] ;
// Pad "Bank" - active for Bank
PadTypBank = uix_bit_set[GvPlayTypBank];
// Pad "Partial"
PadTypPartial = uix_bit_set[GvPlayTypPartial] | uix_bit_set[GvPlayTypAnyClip]
              | uix_bit_set[GvPlayTypClip] | uix_bit_set[GvPlayTypRange] ;
// Pad "play mode"
PadTypPM = 0;
// Pad "Space Mode"
PadTypSM = 0;
// Pad "Clip"
PadTypCl0 =  uix_bit_set[GvPlayTypClip] ;
// Pad "Clip low"
PadTypCl1 =  uix_bit_set[GvPlayTypRange] ;
// Pad "Clip high"
PadTypCl2 =  uix_bit_set[GvPlayTypRange] ;


//====== Scheduler Tasks ======
padSchNL = 2;
padSchNC = 8;
padSchSiz = padSchNL * padSchNC;
padSched = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padSchNL, padSchNC, padSchSiz);
//
padSchLabs = padSched + padSched[ui_jpad_labs]; // addresses of labels
padSchColrs = padSched + padSched[ui_jpad_clrs]; // addresses of colors
padSchCells = padSched + padSched[ui_jpad_cells]; // addresses of cells desc.
padSchVals = padSched + padSched[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padSchSiz,
            padSchColrs[ii] = Col_Inactive;
            padSchLabs[ii] = "";
            ii+=1;
);

SchedActv = make_array(padSchSiz);
KRun_mSL_Thread = 10;

//====== Sensors Management ======
padSensNL = 3;
padSensNC = 3;
padSensSiz = padSensNL * padSensNC;
padSensrs = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padSensNL, padSensNC, padSensSiz);
padSensLabs = padSensrs + padSensrs[ui_jpad_labs]; // addresses of labels
padSensColrs = padSensrs + padSensrs[ui_jpad_clrs]; // addresses of colors
padSensCells = padSensrs + padSensrs[ui_jpad_cells]; // addresses of cells desc.
padSensVals = padSensrs + padSensrs[ui_jpad_values]; // addresses of values
padSensMaxSiz =  32;
padSensShowSiz = 3;
padSensInhib = make_array(padSensMaxSiz);
//
ii = 0; loop(padSensSiz,
            padSensColrs[ii] = Col_Inactive;
            padSensLabs[ii] = "";
            padSensInhib[ii] = 0;
            ii+=1;
);

function setSensorSize(n)
(
    ((n === '2') || (n === 2))? (
        padSensShowSiz = 2;
    ) :
    ((n === '3') || (n === 3)) ? (
        padSensShowSiz = 3;
    );
    ((padSensShowSiz != 2) && (padSensShowSiz != 3)) ? (
        padSensShowSiz = 3;
    );
    padSensrs[ui_jpad_nli] = padSensShowSiz;
    padSensrs[ui_jpad_nco] = padSensShowSiz;
    padSensrs[ui_jpad_linc] = padSensShowSiz;
    padSensrs[ui_jpad_cinc] = 1;
);

function releaseSensors(n)
local (i)
(
    /*
    ((n >= 1) && (n <= padSensSiz)) ? (
        padSensInhib[n - 1] = 0;
    ) : (
        i=0; loop(padSensMaxSiz, padSensInhib[i] = 0; i += 1; );
    );
    */
    i=0; loop(padSensMaxSiz,
        (n & 1) ? padSensInhib[i] = 0;
        i += 1; n = n >> 1;
    );
);


// The sensors control PAD
padSnsKNL = 3;
padSnsKNC = 2;
padSnsKSiz = padSnsKNL * padSnsKNC;
padSnsKmd = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padSnsKNL, padSnsKNC, padSnsKSiz);
padSnsKLabs = padSnsKmd + padSnsKmd[ui_jpad_labs]; // addresses of labels
padSnsKColrs = padSnsKmd + padSnsKmd[ui_jpad_clrs]; // addresses of colors
padSnsKCells = padSnsKmd + padSnsKmd[ui_jpad_cells]; // addresses of cells desc.
padSnsKVals = padSnsKmd + padSnsKmd[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padSnsKSiz,
            padSnsKColrs[ii] = Col_Inactive;
            padSnsKLabs[ii] = "";
            ii+=1;
);


//AGMW120 = GMW();

//================ Settings MANAGEMENT ==================

padSettingsNL = 1;
padSettingsNC = 8;
padSettingC7fmt = 0; // input format for cell. 7
padSettingsSiz = padSettingsNL * padSettingsNC;
padSettingsp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padSettingsNL, padSettingsNC, padSettingsSiz);

padSettingsLabs = padSettingsp + padSettingsp[ui_jpad_labs]; // addresses of labels
padSettingsColrs = padSettingsp + padSettingsp[ui_jpad_clrs]; // addresses of colors
padSettingsCells = padSettingsp + padSettingsp[ui_jpad_cells]; // addresses of cells desc.
padSettingsVals = padSettingsp + padSettingsp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padSettingsSiz,
            padSettingsColrs[ii] = Col_Inactive;
            padSettingsLabs[ii] = "";
            ii+=1;
);

// padSScriptsNL = 4;  // already defined before
// padSScriptsNC = 4;  // already defined before
// K_padSScriptsSiz = padSScriptsNL * padSScriptsNC;  // already defined before
// namScriptfiles : string array of size K_padSScriptsSiz
// sprintf(#dbg_trace1,"L03970:  %d  %d  %d", padSScriptsNL, padSScriptsNC, K_padSScriptsSiz);
padSScriptsp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padSScriptsNL, padSScriptsNC, K_padSScriptsSiz);
padSScriptsLabs = padSScriptsp + padSScriptsp[ui_jpad_labs]; // addresses of labels
padSScriptsColrs = padSScriptsp + padSScriptsp[ui_jpad_clrs]; // addresses of colors
padSScriptsCells = padSScriptsp + padSScriptsp[ui_jpad_cells]; // addresses of cells desc.
padSScriptsVals = padSScriptsp + padSScriptsp[ui_jpad_values]; // addresses of values
//
shortScriptfiles  = make_array(K_padSScriptsSiz);
ii = 0; loop(K_padSScriptsSiz, shortScriptfiles[ii] = mSL_Str_RAlloc(""); ii += 1;);
updScriptfiles = 1;

//AGMW121 = GMW();
//================ System Sliders [JSFX Sliders] MANAGEMENT ==================
padJSFXSlNL = 2;
padJSFXSlNC = 8;
padJSFXSlSiz = padJSFXSlNL * padJSFXSlNC;
padJSFXSlp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padJSFXSlNL, padJSFXSlNC, padJSFXSlSiz);

padJSFXSlLabs = padJSFXSlp + padJSFXSlp[ui_jpad_labs]; // addresses of labels
padJSFXSlColrs = padJSFXSlp + padJSFXSlp[ui_jpad_clrs]; // addresses of colors
padJSFXSlCells = padJSFXSlp + padJSFXSlp[ui_jpad_cells]; // addresses of cells desc.
padJSFXSlVals = padJSFXSlp + padJSFXSlp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padJSFXSlSiz,
            padJSFXSlColrs[ii] = Col_Inactive;
            padJSFXSlLabs[ii] = "";
            ii+=1;
);

JSFXSlNb = 0;
JSFXSlShow = 0;
JSFXSlCnt = 65;

// Sliders management
sliders_current = make_array(JSFXSlCnt); //  0 unused, 1 to 64 are sliders values
sliders_Min = make_array(JSFXSlCnt);
sliders_Max = make_array(JSFXSlCnt);
sliders_par_Min = make_array(JSFXSlCnt);
sliders_par_Max = make_array(JSFXSlCnt);
sliders_flags = make_array(JSFXSlCnt);
ii = 0; loop(JSFXSlCnt,
    sliders_current[ii] = Undef;
    sliders_flags[ii] = Undef;
    sliders_Min[ii] = 1000000000.0;
    sliders_Max[ii] = -1000000000.0;
    ii+=1;
);



/*
=== Dynamic Parameters Management ===
*/
// The command Pad
padDynParNL = 1;
padDynParNC = 8;
padDynParSiz = padDynParNL * padDynParNC;
padDynParW = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDynParNL, padDynParNC, padDynParW);

padDynParLabs = padDynParW + padDynParW[ui_jpad_labs]; // addresses of labels
padDynParColrs = padDynParW + padDynParW[ui_jpad_clrs]; // addresses of colors
padDynParCells = padDynParW + padDynParW[ui_jpad_cells]; // addresses of cells desc.
padDynParVals = padDynParW + padDynParW[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDynParSiz,
            padDynParColrs[ii] = Col_Inactive;
            padDynParLabs[ii] = "";
            ii +=1;
);

padDynParCells[7] |= ui_jpad_ct_altcol;

//padDynParW[ui_jpad_color1] = Color_Bright_Green ;
//padDynParW[ui_jpad_color2] = Color_Brownish_Orange ;
// padDynParW[ui_jpad_color3] = Color_Blue_Violet ;
// padDynParW[ui_jpad_color4] = Color_Gold ;


// The Flags pad
padDynFlgNL = 1;
padDynFlgNC = 28;
padDynFlgSiz = padDynFlgNL * padDynFlgNC;
padDynFlgW = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values
    //
    | ui_jpad_mk_rcells
    // | ui_jpad_mk_rrcells
    //| ui_jpad_mk_cclear
    , padDynFlgNL, padDynFlgNC, padDynFlgW);

padDynFlgLabs = padDynFlgW + padDynFlgW[ui_jpad_labs]; // addresses of labels
padDynFlgColrs = padDynFlgW + padDynFlgW[ui_jpad_clrs]; // addresses of colors
padDynFlgCells = padDynFlgW + padDynFlgW[ui_jpad_cells]; // addresses of cells desc.
padDynFlgVals = padDynFlgW + padDynFlgW[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDynFlgSiz,
            padDynFlgColrs[ii] = Col_Inactive;
            padDynFlgLabs[ii] = "";
            (ii & 0x4) ? padDynFlgCells[ii] |= ui_jpad_ct_altcol;
            ii +=1;
);

padDynFlgW[ui_jpad_color1] = Color_Bright_Green ;
padDynFlgW[ui_jpad_color2] = Color_Brownish_Orange ;
padDynFlgW[ui_jpad_color3] = Color_Blue_Violet ;
padDynFlgW[ui_jpad_color4] = Color_Gold ;


xtval = 0;
dyn_And_Mask = mSL_Dyn_Mask_def;
dyn_Or_Mask = 0;
ffmode = 0;
ffdisp = 0;


padDynPrstW = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDynPrstNL, padDynPrstNC, padDynPrstW);

padDynPrstLabs = padDynPrstW + padDynPrstW[ui_jpad_labs]; // addresses of labels
padDynPrstColrs = padDynPrstW + padDynPrstW[ui_jpad_clrs]; // addresses of colors
padDynPrstCells = padDynPrstW + padDynPrstW[ui_jpad_cells]; // addresses of cells desc.
padDynPrstVals = padDynPrstW + padDynPrstW[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDynPrstSiz,
            padDynPrstColrs[ii] = Col_Inactive;
            padDynPrstLabs[ii] = "";
            ii +=1;
);


//================ Scripts MANAGEMENT ==================
padScriptsNL = 2;
padScriptsNC = 8;
padScriptsSiz = padScriptsNL * padScriptsNC;
padScriptsp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padScriptsNL, padScriptsNC, padScriptsSiz);

padScriptsLabs = padScriptsp + padScriptsp[ui_jpad_labs]; // addresses of labels
padScriptsColrs = padScriptsp + padScriptsp[ui_jpad_clrs]; // addresses of colors
padScriptsCells = padScriptsp + padScriptsp[ui_jpad_cells]; // addresses of cells desc.
padScriptsVals = padScriptsp + padScriptsp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padScriptsSiz,
            padScriptsColrs[ii] = Col_Inactive;
            padScriptsLabs[ii] = "";
            ii+=1;
);
showThrdent = 0;
showThrdType = 0;
showThrdTypeCnt = 6;
showThrdTypeNms = make_array(showThrdTypeCnt);
showThrdTypeNms[0] = "All";
showThrdTypeNms[1] = "Active";
showThrdTypeNms[2] = "Working";
showThrdTypeNms[3] = "Waiting";
showThrdTypeNms[4] = "Locked";
showThrdTypeNms[5] = "Free";

uuuMslFn = 0;
uuuMslFname = 0;
uuuMslFent = 0;
uuuMslTSiz = 64;
uuuMslTabs = make_array(uuuMslTSiz); // an array of names of files to compile
uuuMslTPt =  0; // index in this table
uuuMslCSiz = 128;
uuuMslCTab = make_array(uuuMslCSiz); // an array of names of compileds files to execute
uuuMslCPt = 0; // index in this table

/* Add a file name to the compiler list */
function doMslCompile(fname)
(
    // Do not accept empty strings
    (strlen(fname) != 0) ? (
        0 ? (sprintf(#s, "::About to doMslCompile: \"%s\"", fname); mSL_log(SysLogBox, #s););
        atomic_set(mSL_Lock, max(1,atomic_get(mSL_Lock)));
        uuuMslTabs[uuuMslTPt] = fname; uuuMslTPt = (uuuMslTPt + 1) % uuuMslTSiz;
        atomic_add(mSL_loc_tim,mSL_loc_tadd);
        uuuMslFn = 1; // set flag
    )
);

//================ Debugging ===================
// Memory display boxes
memoryBoxSize = 24;
memoryBox1  = make_array(memoryBoxSize);
memoryBox2  = make_array(memoryBoxSize);

// Pad debug
padDebugNL = 1;
padDebugNC = 8;
padDebugSiz = padDebugNL * padDebugNC;
padDebug1p = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDebugNL, padDebugNC, padDebugSiz);

padDebug1Labs = padDebug1p + padDebug1p[ui_jpad_labs]; // addresses of labels
padDebug1Colrs = padDebug1p + padDebug1p[ui_jpad_clrs]; // addresses of colors
padDebug1Cells = padDebug1p + padDebug1p[ui_jpad_cells]; // addresses of cells desc.
padDebug1Vals = padDebug1p + padDebug1p[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDebugSiz,
            padDebug1Colrs[ii] = Col_Inactive;
            padDebug1Labs[ii] = "";
            ii+=1;
);

padDebug2p = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDebugNL, padDebugNC, padDebugSiz);

padDebug2Labs = padDebug2p + padDebug2p[ui_jpad_labs]; // addresses of labels
padDebug2Colrs = padDebug2p + padDebug2p[ui_jpad_clrs]; // addresses of colors
padDebug2Cells = padDebug2p + padDebug2p[ui_jpad_cells]; // addresses of cells desc.
padDebug2Vals = padDebug2p + padDebug2p[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDebugSiz,
            padDebug2Colrs[ii] = Col_Inactive;
            padDebug2Labs[ii] = "";
            ii+=1;
);

memoryBoxAdd = 0; // shared address between boxes

memoryBox1[0] = padDebug1p;
memoryBox1[1] = padDebug1Labs;
memoryBox1[2] = padDebug1Colrs;
memoryBox1[3] = padDebug1Cells;
memoryBox1[4] = padDebug1Vals;
memoryBox1[5] = MM1;
// 6
memoryBox1[17] = 96;
memoryBox1[18] = 19;
memoryBox1[19] = blockMemory1;
memoryBox1[20] = 1;


memoryBox2[0] = padDebug2p;
memoryBox2[1] = padDebug2Labs;
memoryBox2[2] = padDebug2Colrs;
memoryBox2[3] = padDebug2Cells;
memoryBox2[4] = padDebug2Vals;
memoryBox2[5] = MM2;
// 6
memoryBox2[17] = 96;
memoryBox2[18] = 19;
memoryBox2[19] = blockMemory2;
memoryBox2[20] = 1;

// The debug menu ActionTbSiz
DebugTbSize = 64;
DebugTbNames = make_array(DebugTbSize);
DebugTbTyps = make_array(DebugTbSize);
DebugTbAdds = make_array(DebugTbSize);
DebugTbDecs = make_array(DebugTbSize);

dbg_u_za = 0;

//================ Show Config ==================
function
ShowConfig()
local (v)
(
    mSL_log(SysLogBox, "");
    ((v = gmem[versionGMScript]) != 0) ? (
        sprintf(#s, "Auxiliary Script ——— Version %d.%d.%d", (v >> 16), (v >> 8) & 0xff, v & 0xff); mSL_log(SysLogBox, #s);
    ) : (
        mSL_log(SysLogBox, "No auxiliary script active.");
    );
    sprintf(#s, "Project name:    \"%s\"", #D_GM_Project_Name);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Project path:    \"%s\"", #D_GM_Project_Path);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Libs directory:    \"%s\"", #D_GL_Directory);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Sounds directory:    \"%s\"", #D_GM_Project_Path_SNDS);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Scripts directory:    \"%s\"", #D_GM_Project_Path_SCR);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Clips directory:    \"%s\"", #D_GM_Project_Path_WAV);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Clips names:    \"%s\"", #D_clNameFormat);   mSL_log(SysLogBox, #s);
    sprintf(#s, "HP Config:    \"%s\"", #D_HPConfigs);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Space Modes:    \"%s\"", #D_SpaceModes);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Play Modes:    \"%s\"", #D_PlayModes);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Clips modifiers:    \"%s\"", #D_ClipsModifiers);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Clips sets:    \"%s\"", #D_ClipSetConf);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Banks:    \"%s\"", #D_BanksDefs);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Sensors:    \"%s\"", #D_InSens_Name);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Files list:    \"%s\"", #D_GM_txt_set);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Scripts list:    \"%s\"", #D_GM_mSL_set);   mSL_log(SysLogBox, #s);
    sprintf(#s, "Profile:    \"%s\"", #D_GM_mSL_ini);   mSL_log(SysLogBox, #s);
    mSL_log(SysLogBox, "System Files:");
    mSL_log(SysLogBox, #GMversion);
);

//================ Links MANAGEMENT ==================

padLinksNL = 2;
padLinksNC = 8;
padLinksSiz = padLinksNL * padLinksNC;
padLinksp = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padLinksNL, padLinksNC, padLinksSiz);

padLinksLabs = padLinksp + padLinksp[ui_jpad_labs]; // addresses of labels
padLinksColrs = padLinksp + padLinksp[ui_jpad_clrs]; // addresses of colors
padLinksCells = padLinksp + padLinksp[ui_jpad_cells]; // addresses of cells desc.
padLinksVals = padLinksp + padLinksp[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padLinksSiz,
            padLinksColrs[ii] = Col_Inactive;
            padLinksLabs[ii] = "";
            ii+=1;
);
//
// Enter a MIDI Note in the MIDI List
function SensMIDIIn()
(
    SensorsActive ? (
        MIDI_Curr = MIDIIdx;
        ((MIDI_msg2 >= 1) && (MIDI_msg2 <= 16) && (padSensInhib[MIDI_msg2-1] === 0)) ? (
            MIDIMsgB[MIDIIdx] = MIDI_msg1;
            MIDIMsgB[MIDIIdx+1] = MIDI_msg2; // Add 1
            MIDIMsgB[MIDIIdx+2] = MIDI_msg3;
            MIDIMsgB[MIDIIdx+3] = MIDI_msgTim;

            ((MIDI_msg2 != prevmsg2) || ((MIDI_msgTim - prevmsgTim) > MIDISensMinWRep)) ? (
                prevmsg2 = MIDI_msg2; prevmsgTim = MIDI_msgTim;
                MIDIIdx = (MIDIIdx + 4) % MIDIbfSize; // next in
                MIDI_Flag = 1;
                zm8=zm7; zm7=zm6; zm6=zm5; zm5=zm4;
                zm4=zm3; zm3=zm2; zm2=zm1; zm1=MIDI_msg2; // just for trace
                (MIDI_msg2 <= 16) ? (MIDIDates[MIDI_msg2-1] = MIDI_msgTim; ui_GFXdoNow |= 1;);
                gmem[sensorsPadState] = MIDI_msg2 + 0x10;
            );
        );
    );
);

function AddDummyMIDIImm(n)
(
    MIDI_msg1 = 0x90; // dummy
    MIDI_msg2 = n;
    MIDI_msg3 = 64;
    MIDI_msgTim = time_precise() + timeD;
    prevmsgTim = MIDI_msgTim - MIDISensMinWRep - 2;
    SensMIDIIn();
);

function AddDummyMIDIIn(n)
(
    MIDIMsgB[MIDIIdx] = 0x90; // dummy
    MIDIMsgB[MIDIIdx+1] = n;
    MIDIMsgB[MIDIIdx+2] = 64;
    MIDIMsgB[MIDIIdx+3] = MIDI_msgTim;
    MIDIIdx = (MIDIIdx + 4) % MIDIbfSize;
);

// get a "pushed" MIDI event
function localMIDIget()
(
    res = 0;
    (tmpMIDIptr != tmpMIDIptw) ? (
        res = tmpMIDIbuff + tmpMIDIptr; tmpMIDIptr = (tmpMIDIptr + 4) % tmpMIDIsiz;
    );
    res;
);

// Enter a dummy MIDI in event - to be "received" later
function localMIDIpush(M1, M2, M3)
(
    gmem[tmpMIDIbuff+tmpMIDIptw] = M1;
    gmem[tmpMIDIbuff+tmpMIDIptw+1] = M2;
    gmem[tmpMIDIbuff+tmpMIDIptw+2] = M3;
    gmem[tmpMIDIbuff+tmpMIDIptw+3] = time_precise() + timeD;
    tmpMIDIptw = (tmpMIDIptr + 4) % tmpMIDIsiz;
);

//AGMW130 = GMW();

SA_Valid = 0x10000;
SA_workarea = make_array(4);
SA_workarea[0] = SA_Valid + 1;
ACPTrSiz = 2048;
ACPTrTAB = make_array(ACPTrSiz);
ACPTrPt = 0;

function Expand_Action_List(list)
local (ccnt, xp, zz, u, v, f, g, lg, p, src, err, redir, ent, lsiz, pm, ps, pd, madd, mr, msz, flgs, wc)
(
    flgs = FlagsTbVals[Flgs_Acts]; // trace flags
    src = list;
    err = 0; redir = -1; mr = 32; // number of macro replacements allowed
    (flgs & 0x10) ? (
        sprintf(#s, "Parse start @: %d   [%d   %d   %d  ...]", list, list[0], list[1], list[2]);
        mSL_log(SysLogBox, #s);
    );
    lsiz = ccnt = list[0];
    // lsiz += 1;  // add the size word
    zz = list + 1; // include xp as first elt
    xp = zz[0];
    (ccnt < 1024) ? (
        while ((ccnt > 0) && (err === 0)) (
            while (((xp = zz[0]) >= mSL_Sym_Low) && (xp <= mSL_Sym_High) && (err === 0) && (mr > 0))  (
                // Is this a defined action ?
                (((ent = act_pos(xp)) >= 0) && (ActionHsTab[ent] === xp)) ? (
                    // just replace it by its value
                    (flgs & 0x10) ? (
                        sprintf(#s, "    Action  '%s'  =>  %d ", mSL_edit_value(#u, xp), ActionHsNums[ent]);
                        mSL_log(SysLogBox, #s);
                    );
                    zz[0] = xp = ActionHsNums[ent];
                ) :
                // Is this a macro ?
                (((ent = mac_pos(xp)) >= 0) && (Mac_WA_Hash[ent] === xp)) ? (
                    madd = Mac_WA_HPts[ent]; // La macro: <name> <size> <body>
                    pm = zz - src; // position of the macro
                    msz = madd[1]; // size to be inserted
                    (flgs & 0x10) ? (
                        sprintf(#s, "    Macro  '%s'  pos:  %d  siz: %d ", mSL_edit_value(#u, xp), madd, madd[1]);
                        mSL_log(SysLogBox, #s);
                    );
                    ((redir < 0) && (msz > 1)) ? (
                        // we copy here the whole entry
                        (Mac_WA_Tptr + madd[1] + lsiz + 6 >= Mac_WA_TSiz) ? Mac_WA_Tptr = 1; // restart at 1
                        (Mac_WA_Tptr + madd[1] + lsiz + 6 >= Mac_WA_TSiz) ? (
                            // error - things are getting too large !
                            ccnt = 0; err = 0260; xp = 0;
                        ) :
                        (
                            memcpy(Mac_WA_Temp + Mac_WA_Tptr, src, lsiz+1); // copy whole entry
                            redir = Mac_WA_Tptr; // position in Mac_WA_Temp
                            src = Mac_WA_Temp + Mac_WA_Tptr; // new [definitive] source
                            zz = src + pm; // restart analysis at the first word of the expansion
                            (flgs & 0x20) ? (
                                sprintf(#s, "    Source copied  siz: %d  from: %d  to: %d", lsiz+1, list, src);
                                mSL_log(SysLogBox, #s);
                            );
                            Mac_WA_Tptr += lsiz+1;
                            // The list has been moved
                            pm = zz - src; // relative position of the macro
                        );
                    );
                    (err === 0) ? (
                        // move the "rest" of the command
                        wc = lsiz - pm ; // size to move
                        (msz < 1) ? (
                            // Empty macro
                            // mode back the queue
                            ps = zz + 1;
                            pd = zz;
                            (flgs & 0x20) ? (
                                sprintf(#s, "    Tail advance  siz: %d  from: %d  to: %d", wc, ps, pd);
                                mSL_log(SysLogBox, #s);
                            );
                            loop(wc, pd[0] = ps[0]; ps += 1; pd +=1; ); pd[0] = 0; // and clear last
                        ) :
                        (msz === 1) ? (
                            // is this a "single word" macro ?
                            // quite easy...
                            zz[0] = madd[2]; // and we can restart the analysis
                            (flgs & 0x20) ? (
                                sprintf(#s, "    Macro  siz: 1  value: %s", mSL_edit_value(#u, zz[0]));
                                mSL_log(SysLogBox, #s);
                            );
                        ) : (
                            ps = zz + wc + 1; // last world to be moved
                            pd = zz + msz + wc; // last position to go, +1
                            Mac_WA_Tptr = pd - Mac_WA_Temp;
                            loop(wc, ps -= 1; pd -=1; pd[0] = ps[0]; );
                            (flgs & 0x20) ? (
                                sprintf(#s, "    Tail moved  siz: %d  from: %d  to: %d", wc, zz + 1, zz + msz);
                                mSL_log(SysLogBox, #s);
                            );
                            // now insert the macro body
                            memcpy(zz, madd+2, msz);
                            (flgs & 0x20) ? (
                                sprintf(#s, "    Macro  siz: %d  from: %d  to: %d", msz, madd+2, zz);
                                mSL_log(SysLogBox, #s);
                            );
                        );
                        // Analysis can restart at "zz"
                        ccnt += msz - 1; // after adding the macro size
                        src[0] += msz - 1; // update size
                        Mac_WA_Temp[0] = Mac_WA_Tptr;
                    );
                    mr -= 1;
                ) :
                (
                    // symbol not found
                    (flgs & 0x10) ? (
                        sprintf(#s, "    Symbol  '%s'  not found ", mSL_edit_value(#u, xp));
                        mSL_log(SysLogBox, #s);
                    );
                    err = 0262;
                );
            );

            u = xp;
            ((xp >= 300 && xp < 400)) ? (
                xp = xp - 299;
            ) :
            ((xp < 0) || (xp > 255)) ? (
                xp = 0;
            );
            // Size of the entry
            f = ActionTbFlgs[xp];
            (f & 0xFF00) ? (
                // special case
                g = f & 0xFF00;
                (g & 0x100) ? (
                    // length depending on "-1"
                    lg = 1+getpos(zz, -1, 128); // find -1 in "zz"
                ) :
                (g & 0x400) ? (
                    lg = 1+getpos(zz, -111, 128); // find -111 in "zz"
                ) :
                (
                    lg = 1;
                );
                (g & 0x200) ? (
                    // change to pointers...
                    v = zz[1];
                    (v < ACPTrTAB) ? (
                        p = ACPTrTAB + ACPTrPt;
                        p[0] = v; zz[1] = p;
                        (flgs & 4) ? (
                            sprintf(#s, "*   Make pointer at: %d   to: %d,  %d/%d ", zz+1, v, zz[1], ACPTrPt);
                            mSL_log(SysLogBox, #s);
                        );
                        ACPTrPt = (ACPTrPt + 1) % ACPTrSiz;
                    );
                );
                (g & 0x8000) ? (
                    // The "forward case...
                    p = zz[1];
                    (p === 0) ? (
                        lg = 2;
                    ) :
                    (p === -1) ? (
                        lg = 2;
                    ) :
                    (p === src) ? (
                        lg = 2;
                    ) :
                    (
                        // redirect
                        lg = zz - src;
                        src = p; // new. Rexplore
                        zz = src + lg;
                        lg = 2;
                    );
                );
            ) : (
                lg = f + 1;
            );
            (flgs & 0x20) ? (
                sprintf(#s, "Parse code %s   %d   Siz: %d - Err: %d", mSL_edit_value(#u, u), xp, lg, err);
                mSL_log(SysLogBox, #s);
            );
            zz = zz + lg;
            ccnt -= lg;
        );
    );
    (err === 0) ? src : - err;
);

function SensorsClear()
(
    MIDISeqPtr = 0;
    SensorsDef = 1;
    memset(MIDISeqncs, 0, MIDISeqSiz);
);


//====== READER CONTROL BLOCKS ======
UplayControl = 0;



randBSize = 256;
randBuff = make_array(randBSize);
randVals = make_array(randBSize);
clRandCB2 = 0;
clOffset = 0;
clSetSize = 0;
searchCnt = 0;
searchMod = 4;


//====== PLAY LOG MANAGEMENT ======
// Structure of a Sequence descriptor

// Create all "playLogEcnt" entries in the free entry list
function
PlayLogSetUp()
local (gm, ent, gent)
(
    gm = playLogStrt;
    loop (playLogEcnt,
        ent = SchBlcksStart; gent = gm;
        SchedInsertTail(PlLogFree, ent, 0);
        ent[plLEntGRef] = -gent;
        ent[SchevEvntName] = gmem[gent + RCB_FSND] = plIDNT;
        gmem[gent + RCB_RefCnt] = 1;
        gmem[gent + RCB_Random_seed] = -1; // not defined yet
        SchBlcksStart += 8; gm += playLogESize;
    );
);

function getGmFSA()
local (ent)
(
    !(ent = SchedDetachHead(PlLogFree)) ? (
        ent = SchedDetachHead(PlRecCurrent);
    );
    ent;
);

function
getTmpEnt()
local (ent)
(
    !(ent = SchedDetachHead(PlLogFree)) ? (
        ent = SchedDetachHead(PlRecCurrent);
    );
    SchedInsertTail(PlLogFree, ent, 0);
    4 - ent[plLEntGRef]; // return an address in gmem
);

// Keep a mark in the playlog
function setPlayMark(ent, plist, qlist, flgs)
local (pp, pq, ii, ij, is, it, da, elc, td, dl, nd)
(
    da = elc = 0;
    // Use record date in record mode active, otherwise play date
    it = nd = ((recordMode == recModeOff) || (flgs & 1)) ? pPlayTimeCurrent : pRecTimeCurrent;
    // Count items
    (plist > 0) ? (
        ii = 0; while ((is = plist[ii]) >= 0) (
            (is[plLEntRcrd] < it) ? it = is[plLEntRcrd];
            markersWA[elc] = is;
            elc += 1; ii += 1;
        );
    );
    (qlist > 0) ? (
        ii = 0; while ((is = qlist[ii]) >= 0) (
            (is[plLEntRcrd] < it) ? it = is[plLEntRcrd];
            markersWA[elc] = is;
            elc += 1; ii += 1;
        );
    );
    ((ent < 0) || (ent >= clESize)) ? (
        ent = -1;
        ii = 0; while ((ii < clESize) && (ent < 0)) (
            (clTabE[ii] <= 0) ? ent = ii;
            ii += 1;
        );
    );
    // "elc" is now the element count ; "it" the first play date
    // Look for a block of appropriate size
    (ent >= 0) ? da = getSizBlock(2 * elc + lppEPsnd, 'upnt');
    (da != 0) ? (
        // Free previous block
        (clTabE[ent] > 0) ? freeLstBlock(clTabE[ent]);
        clTabE[ent] = pp = da;
        da[lppEType] = 1; // type of format : std point marker
        da[lppEFlgs] = 0; // flags
        da[lppEElct] = elc; // element count
        da[lppECurItem] = 0; // 1st item to play
        da[lppEItmIncr] = 1; // std. increment of 1
        da[lppED1st] = it; // Start time of the set
        da[lppEDate] = nd; // note (click) date
        da[lppESpeed] = 1; // std. speed of 1
        da[lppEWait] = 0; // next wait time
        td = 0; // total duration
        pp += lppEPsnd;
        (elc > 0) ? (
            // Copy the set in the structure
            ii = 0; while (ii < elc) (
                pp[2 * ii] = markersWA[ii] ;
                ii += 1;
            );
            // sort the set on increasing start time
            ii = 0;
            while (ii < elc - 1) (
                ij = ii + 1;
                while (ij < elc) (
                    is = pp[2*ii]; it = pp[2*ij];
                    (is[plLEntRcrd] > it[plLEntRcrd]) ? (pp[2*ii] = it; pp[2*ij] = is;);
                    ij += 1;
                );
                ii += 1;
            );
            // compute intervals and total duration
            ii = 0; while (ii < elc - 1) (
                is = pp[2*ii]; it = pp[2*ii+2];
                // compute delay to next
                dl = it[plLEntRcrd] - is[plLEntRcrd];
                pp[2*ii+1] = dl; td += dl;
                ii += 1;
            );
            (elc > 1) ? (
                // define delay of last as the mean of others delays
                dl = td / (elc - 1);
            ) :
            (elc === 1) ? (
                // approximate a duration
                dl = 2*max(1, it - pRecTimeCurrent);
            );
            pp[2*ii+1] = dl; td += dl;
        );
        da[lppEDurat] = td;
    );
    0 ? (sprintf(#s, "setPlayMark: (%d  %d/%d) => %d %d", ent, plist, qlist, da, elc); mSL_log(SysLogBox, #s););
);


//====== ACTIONS ======
//  Send Play Mode Parameters to the unit

// Define a dummy space mode entry
dSMAddr = make_array(SMESize);
dSMAddr[idx_Sm_HPFlags] = 0;
dSMAddr[idx_Sm_HPCnt1] = 2;
dSMAddr[idx_Sm_HPCnt2] = 64;
dSMAddr[idx_Sm_HPSet1] = 0;
XsM = XpM = xpAddr = 0;
XcGrp = XcBnk = Kmd = 0;

mSL_signal_b = make_array(8);


// Special HP Conf operations
ksize = HPPSize;
kpts = HPPTab;
kpos = HPATab;
kbase = 0;
klsize = 100; // Std class size
bstval = bstnum = 0;

function
testHPconf(pcf, hpuse)
local(m, i, k)
(
    m = 0;
    k = pcf[0];
    i = 1; while(i <= k) (
        (hpuse[pcf[i]] != 0) ? (m += 1;);
        i += 1;
    );
    m;
);

function
findHPconf(base, cnt, hpuse, bst)
local(i, bst, num, w, e, pcf, r)
(
    bstval = 999; bstnum = base;
    w = irand(cnt); i = 0; // Random start
    while  ((i < cnt) && (bstval != 0)) (
        e = w + base; // one config
        pcf = kpts[e];
        (pcf != 0) ? (
            bst ? (
                r = testHPconf(pcf, hpuse);
                (r < bstval) ? (bstval = r; bstnum = e;);
            ) : (
                // The first (random) one is ok
                bstval = 0; bstnum = e;
            );
        );
        w = (w + 1033) % cnt; // next local entry
        i += 1;
    );
    (bstval == 0) ? bstnum : -bstnum;
);

// Returns a pointer to an entry acceptable for configuration "xcf"
function
checkHPconfig(xcf, hpuse, winfo)
local(ty, hb, ent, cnt, cf, i, j, c, k, kent, lerr, nch, pq, pt, rtc1, rtc2, bst)
(
    lerr = 0; // "local" error
    ent = cf = 0;
    klsize = 100; // Std class size
    kpts = HPPTab;
    kpos = HPATab;
    kbase = 0; // start looking from there in kpts
    ksize = HPPSize; // stop looking before that in kpts
    // Check/create hpuse
    ((hpuse === 0) || (hpuse === Undef)) ? (
        hpuse = HP_use_wa; memset(HP_use_wa, 0, HP_use_siz);
    ) : (
        lerr = mSL_StM_Check(hpuse);
        (lerr === 0) ? (
            (hpuse[-1] != HP_use_siz) ? (lerr = 0137;);
        );
    );
    ((winfo === 0) || (winfo === Undef)) ? (
        winfo = HP_info_wa; memset(HP_info_wa, 0, HP_info_siz);
    ) : (
        lerr = mSL_StM_Check(winfo);
        (lerr === 0) ? (
            (winfo[-1] != HP_info_siz) ? (lerr = 0137;);
        );
    );
    (lerr === 0) ? (
        // Update local addresses
        rtc1 = winfo + HP_info_rtc1;
        rtc2 = winfo + HP_info_rtc2;
        bst = winfo[HP_info_flgs] & 2; // Find the conf with a max of free HP

        ((xcf == 0) || (xcf == Undef)) ? (
            xcf = 2; // Look for conf. 2
        ) :
        (xcf < 0) ? (
            // Find a conf of "-xcf" HPs
            k = -xcf;
            ((k != (0|k)) || (k <= 0) || (k >= HPPSize)) ? (
                lerr = 0140;
            );
            nch = 0 | min(k, 128);
            // Build a sequence of HP_Spec_siz pointers to configs of "nch"
            kpts = HP_Spec_set;
            memset(kpts, 0, HP_Spec_siz);
            pq = kpts + 2;
            i = 0;
            loop (HPPSize,
                pt = HPPTab[i];
                ((pt >= HPATab) && (pt < HPPTab) && (pt[0] === nch) && (pq < HP_Spec_setNd)) ? (
                    pq[] = pt; pq += 1;
                );
                i += 1;
            );
            xcf = 1; //  look for this in kpts
            ksize = pq - kpts;
        ) : (
            // xcf > 0
            ((xcf != (0|xcf)) || (xcf <= 0) || (xcf >= HPPSize)) ? (
                lerr = 0141;
            );
        );
        // Is this a regular config ?
        (((k = kpts[xcf]) > kpos) && (k[-1] === xcf)) ? (
            // regular config, return it
            cf = xcf;
            ent = k;
        );
    );

    ((lerr === 0) && (cf === 0)) ? (
        (((k = kpts[xcf+1]) > kpos)) ? (
            // not a regular config, but a subclass
            // Compute its size
            kbase = xcf+1; ksize =1;
            i=0; while (kpts[kbase+i] > kpos) (
                i += 1; ksize += 1;
            );
        ) :
        (((k = kpts[xcf+1]) == 0)) ? (
            // not a regular config, not a subclass
            // Build the whole class
            ty = klsize * (0|(xcf/klsize)); // conf. type
            // Check it is not empty
            i = 0; k = 0;
            while ((i < klsize) && (k === 0)) (
                (kpts[ty+i] > kpos) ? (k = 1);
                i += 1;
            );
            (k) ? (
                // try the whole list
                kbase = 0; // start looking from there in kpts
                ksize = HPPSize;
            ) : (
                // Use the class
                kbase = ty;
                ksize = klsize;
            );
        );

        // Now, look for a good entry in the set.
        cf = w = findHPconf(kbase, ksize, hpuse, bst);
        ent = kpts[abs(w)];
    );

    (GvErr == 0) ? (
        GvErr = lerr;
        (GvErr != 0) ? (GvErrP1 = xcf;);
    );


    (FlagsTbVals[Flgs_Play] & 4) ? (sprintf(#s, "checkHPconfig/%d/: %d => %d (%d / %d) => %d %d | %d",
             lerr, xcf, cf, ent, kpos, ent[-1], ent[0], paramValues[p_HP_Algo]);
         mSL_log(SysLogBox, #s););

    ent; // return ent

); // checkHPconfig()


//AGMW140 = GMW();

function
HPInstall()
local(hpc1, hpc2,it, e, h, k, dec, flgs, hpfold, hpcnf1, hpcnf2, hpent1, hpent2, zz, hpmin, hpmax)
(
    // Get values from current space mode
    hpcnf1 = SMAddr[idx_Sm_HPSet1];
    hpcnf2 = SMAddr[idx_Sm_HPSet2];
    hpmin = SMAddr[idx_Sm_HPCnt1];
    hpmax = SMAddr[idx_Sm_HPCnt2];
    flgs = SMAddr[idx_Sm_HPFlags];

    // Are some values to reselect ?
    (reSelectHpFlgs > 0) ? (
        flgs = reSelectHpFlgs; reSelectHpFlgs = Undef;
    );
    (reSelectHpSet > 0) ? (
        h = reSelectHpSet; reSelectHpSet = Undef;
        ((h > HPATab) && (h < HPATab+HPASize) && ((k = h[-1]) > 0) && (k < HPPSize) && (HPPTab[k] === h)) ? (
            hpcnf2 = hpcnf1 = k;
            hpent2 = hpent1 = h; flgs |= FLdoForceFChs; // reSelectHpSet
        );
    );
    (reSelectHpSet2 > 0) ? (
        h = reSelectHpSet2; reSelectHpSet2 = Undef;
        ((h > HPATab) && (h < HPATab+HPASize) && ((k = h[-1]) > 0) && (k < HPPSize) && (HPPTab[k] === h)) ? (
            hpcnf2 = k; hpent2 = h; flgs |= FLdoForceFChs; // reSelectHpSet2
        );
    );
    (reSelectHpent > 0) ? (
        // Is this a valid entry ?
        e = reSelectHpent; reSelectHpent = Undef;
        ((e > 0) && (e < HPPSize) && ((h = HPPTab[e]) > HPATab) && (h < HPATab+HPASize) && ((k = h[-1]) > 0) && (k < HPPSize) && (HPPTab[k] === h)) ? (
            hpmin = hpmax = h[0];
            hpcnf1 = k; hpent1 = h; flgs |= FLdoForceFChs; // reSelectHpent
        );
    );
    (reSelectHpent2 > 0) ? (
        // Is this a valid entry ?
        e = reSelectHpent2; reSelectHpent2 = Undef;
        ((e > 0) && (e < HPPSize) && ((h = HPPTab[e]) > HPATab) && (h < HPATab+HPASize) && ((k = h[-1]) > 0) && (k < HPPSize) && (HPPTab[k] === h)) ? (
            hpmin = hpmax = h[0];
            hpcnf2 = k; hpent2 = h; flgs |= FLdoForceFChs; // reSelectHpent
        );
    );
   (reSelectHpcnt > 0) ? (
        hpmin = hpmax = reSelectHpcnt; reSelectHpcnt = Undef;
    );

    hpent1 = checkHPconfig(hpcnf1, 0, 0); // check the entry
    (hpcnf2 === 0) ? hpcnf2 = hpcnf1;
    hpent2 = checkHPconfig(hpcnf2, 0, 0);
    hpcnf1 = hpent1[-1]; // actual numbers
    hpcnf2 = hpent2[-1];

    (GvErr === 0) ? (
        hpc1 = hpent1[0]; dec = 1; // get the entry description
        hpc2 = (hpent2 != 0) ? hpent2[0] : 0;
        gmem[GPlUnit+RCB_Channels_cnfDup] = gmem[GPlUnit+RCB_Channels_conf1] = hpcnf1;
        gmem[GPlUnit+RCB_Channels_conf2] = hpcnf2;
        gmem[GPlUnit+RCB_Channels_cnt_used1] = hpc1;
        gmem[GPlUnit+RCB_Channels_cnt_used2] = hpc2;
        gmem[GPlUnit+RCB_Channels_cnt_min] = hpmin;
        gmem[GPlUnit+RCB_Channels_cnt_max] = hpmax;
        gmem[GPlUnit+RCB_Channels_flgs] = flgs;
        gmem[GPlUnit+RCB_Channels_density] = paramValues[p_HP_Density];
        gmem[GPlUnit+RCB_PBFlgs] |= flgs;
        hpfold = max(1, paramValues[p_GvChnUse]);
        // Declare used all HP - Change origin (from 1 to 0)
        it = 0; loop(hpc1,
            zz = (hpent1[it+dec] - 1) % hpfold;
            HP_Set_Cntr[zz] += HP_Cost;
            it += 1;
        );
        it = 0; loop(hpc2,
            zz = (hpent2[it+dec] - 1) % hpfold;
            HP_Set_Cntr[zz] += HP_Cost;
            it += 1;
        );
    );
); // HPInstall()


function
checkPartial(part, flgs, id)
(
    // Is the partial valid ?
    GvErrP1 = part; GvErrP4 = BKDEcnt;
    ((part >= 0) && (part < BKDEcnt)) ? (
       xpAddr = BKTab + part * BKEsize; // the partial Address
        XcGrp = xpAddr[idx_Pa_Grp]; // group
        XcBnk = xpAddr[idx_Pa_Bnk]; // bank
        XsM = (reSelectSpaceMode >= 0) ? reSelectSpaceMode : xpAddr[idx_Pa_SpM]; // space mode
        GvErrP2 = XsM; GvErrP3 = reSelectSpaceMode;
        ((XsM >= 0) && (XsM < SMEcnt)) ? (
            SMAddr = SMTab + XsM * SMESize;
            (SMAddr[idx_Sm_HPSet1] === Undef) ? (
                GvErr = 0509; // HP set undefined in XsM
            );
            // (SMAddr[idx_Sm_HPSet2] === Undef) ? (
            //    SMAddr[idx_Sm_HPSet2] = SMAddr[idx_Sm_HPSet1];
            //);
        ) : (
            GvErr = 0508; // XsM probably undefined
        );
        XpM = (reSelectPlayMode >= 0) ? reSelectPlayMode : xpAddr[idx_Pa_PlM]; // play mode
        GvErrP2 = XpM; GvErrP3 = reSelectPlayMode;
        ((XpM >= 0) && (XpM < PMEcnt)) ? (
            PMAddr = PMTab + XpM * PMEsize;
            (PMAddr[idx_Pm_Kmd] === Undef) ? (
                GvErr = 0507;
                (FlagsTbVals[Flgs_Pdbg] & 4) ? (
                    // Imprimons voir...
                    sprintf(#ws01, "Err. 507 - PM %d has no command.", XpM);
                    mSL_log(SysLogBox, #ws01);
                );
            );
        );
        //sprintf(#s, "Play:  Part:%d  Sel:%d  Grp:%d  Bnk:%d  XpM:%d  XsM:%d", part, xsel, XcGrp, XcBnk, XpM, XsM);
        //mSL_log(SysLogBox, #s);
    ) : (
        GvErr = ((BKDEcnt <= 0) ? 0503 : 0504); // partial invalid
    );
    ((GvErr != 0) && (FlagsTbVals[Flgs_Play] & 1)) ? (
        sprintf(#s, "checkPartial(%d, %X, %d) Err: %04d [%d %d %d %d]", part, flgs, id, GvErr, GvErrP1, GvErrP2, GvErrP3, GvErrP4);
        mSL_log(SysLogBox, #s);
    );
    (FlagsTbVals[Flgs_Play] & 8) ? (
        sprintf(#s, "checkPartial_(%d, %X, %d) Err: %04d [%d %d %d %d]", part, flgs, id, GvErr, GvErrP1, GvErrP2, GvErrP3, GvErrP4);
        mSL_log(SysLogBox, #s);
    );

); //checkPartial


/*
  Play a clip
    xpart = the partial number
    xsel =
        >= 0 : play this clip with partial parameters
        -1 : play ANY clip from the partial
        -2 : play ANY clip of the group
        -3 : play ANY clip from group & bank
        -4 : play ANY clip with this partial parameters
        -5 : play ANY clip of the selection, with this partial parameter
        -6 : play ANY clip from the system by selecting a random partial
    xflgs =
        0
        FLdoForcePlay = 0x100000
        FLdoForceLoop = 0x200000
        FLdoForceRead = 0x400000
        FLdoForceLock = 0x080000
        GvPlFlDefault = 1+4+32+64
        FlgnoInterrupt = 64
        noInterrupt|1|4|32
    xtype =
        <0 : play a clip range
        GvPlayTypClip : play a specific clip
    xaux =
        second part of a clip rangs
*/
function
doPlayClip(xpart, xsel, xflgs, xtype, xaux)
local(Xkmd, z, v1, v2, v3, part, bladd, klc, khc, newpart, primeX, k, p, pc, ic, clmin, clmax,
    str, strsiz, pts, ch, isl, it, dec, als, lge, c1, c2, ii, ik, ix, iy, iz, v, v3, v4, clcck)
(
    GvErr = 0;
    GvErrP1 = GvErrP2 = GvErrP3 = GvErrP4 = GvErrP5 = GvErrP6 = -1;
    GPlUnit = UGDummy; // just for...
    gmem[GPlUnit+cbStat] = uSDummy;

    v = 0;
    Xkmd = 0;

    (TRC & 0x800) ? (
        ( sprintf(#s, "doPlayClip (%d, %d, %X, %d, %d)", xpart, xsel, xflgs, xtype, xaux); mSL_log(SysLogBox, #s););
    );
    GvErrP6 = newpart = part = xpart;

    clcck = -1; // Future clip number...


    // 1- Is the partial valid ?
    checkPartial(part, xflgs, 1);


    // 2- check "xsel" value
    (GvErr === 0) ? (
        GvErrP2 = xsel; GvErrP3 = -1;
        (xsel < 0) ? (
            (xsel === pACinG) ? (
                // play ANY clip of the group
                newpart = BKSelectParts(XcGrp, -1, xflgs);
            ) :
            (xsel === pACinB) ? (
                // play ANY clip from group & bank
                newpart = BKSelectParts(XcGrp, XcBnk, xflgs);
            ) :
            (xsel === pACinRP) ? (
                // play ANY clip from the system by selecting a random partial
                newpart = 1 + irand(BKDEcnt-1);
            );
        );
        (reSelectPartial >= 0) ? (
            GvErrP5 = newpart = reSelectPartial;
        );
    );

    (newpart != part) ? (
        part = newpart;  // can be < 0 after BKSelectParts
        checkPartial(part, xflgs, 2);
    );


    (GvErr === 0) ? (
        // Set clips numbers by default
        klc = xpAddr[idx_Pa_Clps];
        khc = xpAddr[idx_Pa_Clps+1]; // low & high clips numbers
        ((klc >= 0) && (khc >= 0) && (xpAddr >= Part1st) && convertClipRanges) ? (
            autoConvertClRange(xpAddr);
            (FlagsTbVals[Flgs_Pdbg] & 4) ? (
                sprintf(#s, "   A:(%d/%d) [%d %d => %d %d]", xpAddr, 0|((xpAddr - BKTab)/BKEsize), klc, khc, xpAddr[idx_Pa_Clps], xpAddr[idx_Pa_Clps+1]);
                mSL_log(SysLogBox, #s);
            );
            klc = xpAddr[idx_Pa_Clps];
            khc = xpAddr[idx_Pa_Clps+1]; // low & high clips numbers
        );

        (xsel < 0) ? (
            (xsel === pACinWwP) ? (
                // play ANY clip with this bank parameters
                klc = 0; khc = clTSize-1;
            ) :
            (xsel === pACinSwP) ? (
                // play ANY clip of the selection
                klc = min(GvPlayCl1, GvPlayCl2);
                khc = max(GvPlayCl1, GvPlayCl2);
            );
            // Otherwise, we keep klc and khc of the Partial
        ) : (
            (xtype === GvPlayTypClip) ? (
                // Play a specific clip
                khc = klc = xsel;
            ) : (
                // We have transmitted clip & range
                klc = xsel;
                khc = klc + xaux; // Add range
            );
        );


        Xkmd = PMAddr[idx_Pm_Kmd]; // this is the command to play
    );


    // 3- Player/looper limit ?
    ((GvErr === 0) && ((xflgs & FLdoForcePlay) === 0)) ? (
        GvErrP3 = Xkmd;
        (Xkmd === KmdPlay) ? (
            // check we are allowed to play
            (xflgs & MskForcePlay) === FLdoForceLoop ? (
                GvErr = 0513;
            );
        ) :
        (Xkmd === KmdLoop) ? (
            // check we are allowed to play
            (xflgs & MskForcePlay) === FLdoForceRead ? (
                GvErr = 0515;
            );
        ) :
        (
            GvErr = 0516; // command unknown
        );
    );

    // 4- Allocation de player / clip
    (GvErr === 0) ? (
        GvErrP2 = GvErrP3 = -1;
        z = findPlayer();
        ((z >= UGAddr)) ? (
            GPlUnit = z;
            // Clear parameters area
            isl = 0; loop(RCB_ActualSize, gmem[GPlUnit+isl] = 0; isl+= 1;); // useful ?
            gmem[GPlUnit+RCB_Kmd] = KmdNone;
            gmem[GPlUnit+cbStat] = uSStarting;
            gmem[GPlUnit+RCB_CGrp_nbr] = XcGrp;
            gmem[GPlUnit+RCB_CBnk_nbr] = XcBnk;
            gmem[GPlUnit+RCB_CPart_nbr] = part;
            gmem[GPlUnit+RCB_CPlMd_nbr] = XpM;
            gmem[GPlUnit+RCB_CSpMd_nbr] = XsM;
            gmem[GPlUnit+RCB_StdVol] = 1; // standard volume play
            gmem[GPlUnit+RCB_VolBias] = 0.000004;
            // send play mode parameters to the unit

            // Choose a Clip
            (klc === -1) ? (
                // select a clip in a set
                clcck = clipFromSet(khc); GvErrP2 = ClSet_ErrRe; GvErrP3 = khc;
            ) : (
                // select a clip from a range
                clOffset = min(klc, khc); // first clip of the set
                clSetSize = 1 + abs(khc - klc); // size of the set
                (clSetSize > 1) ? (
                    // Choose a random clip in the set
                    ix = 0;
                    iy = 0;
                    iz = irand(clSetSize); // starting point
                    // we look for an appropriate integer, primeX, prime with clSetSize
                    (clSetSize < 64) ? (
                        primeX = 1;
                    ) :
                    (clSetSize <= 1000) ? (
                        k = 3 + 0|(clSetSize/2); // look for prime number
                        primeX = 0; pc = gmem[pprimecnt]; ic = irand(pc);
                        while (((primeX < k) || (primeX >= clSetSize)) && (ic < pc)) (
                            primeX = gmem[somePrimes + ic];
                            ic = (ic + 1) % pc;
                        );
                    ) : (
                        // very large clSetSize
                        // round the limits to a frontier of 100
                        clmin = 100 * floor(klc/100);
                        clmax = 100 * ceil(khc/100) -1;
                        primeX = gmem[somePrimes + irand(gmem[pprimecnt]);]; // any prime can do
                        clOffset = clmin; clSetSize = clmax - clmin + 1;
                    );
                    while ((ix < randBSize) && (iy < clSetSize)) (
                        k = iz+clOffset; // clip number
                        ((k >= klc) && (k <= khc) && ((v = gmem[clInfStart+k]) >= 0)) ? (
                            randBuff[ix]=k; // keep clip
                            randVals[ix]=v; // and its counter
                            ix += 1;
                        );
                        iy += 1; iz = (iz + primeX) % clSetSize;
                    );
                    clRandCB2 = ix; // count of clips found
                    (clRandCB2 <= 0) ? (
                        clcck = -2; // no clip found in the interval
                    ) : (
                        ik = ix = irand(clRandCB2); // random start point
                        (0 === (searchCnt = (searchCnt+1)%searchMod)) ? (
                            // try to get the "least used" clip
                            iy = 0;
                            k = randVals[ik]; // its usage count
                            while ((iy < clRandCB2) && (k > 0)) (
                                // test next clip entry
                                ix = (ix + 1) % clRandCB2; iy = iy + 1;
                                i = randVals[ix];
                                (i < k) ? ( k = i; ik = ix; );
                            );
                        );
                        clcck = randBuff[ik]; // the clip
                    );
                ) : (
                    clcck = clOffset;  // unique clip in the set
                    clRandCB2 = 1;
                );
                0 ? (sprintf(#s, "   clip From Range [%d %d => %d]", klc, khc, clcck); mSL_log(SysLogBox, #s););
            );

            // clcck is our clip number, or, alas, -1 if none...
            gmem[GPlUnit+RCB_ClipNb] = clcck; // save it for info
            gmem[GPlUnit+RCB_ClpName] = 0; // not aliased
            ((clcck < 0) || (gmem[clInfStart+clcck] < 0)) ? (
                GvErr = 0518;  // unplayable clip
                GvErrP2 = clcck;
                GvErrP3 = (clcck < 0) ? -2 : gmem[clInfStart+clcck];
            ) : (
                // Is the clip an alias ?
                ((als = gmem[clClAlias+clcck]) != 0) ? (
                    getClipName(clcck, aclnAliases);
                    // copy the string in gmem
                    gmem[GPlUnit+RCB_ClpName] = GPlUnit+RCB_Alias_Name; // here is the address
                    mSL_g6packStr(GPlUnit+RCB_Alias_Name, #fname, 0, 63, 0);
                    (TRC & 0x800) ? (
                        sprintf(#u, "Provide \"%s\" as %d (%X)", #fname, clcck, als);
                        mSL_log(SysLogBox, #u);
                    );
                );

                // Indicates "Flags"
                gmem[GPlUnit+RCB_PBFlgs] = xpAddr[idx_Pa_PBFlgs] | xflgs; // From Partial
                gmem[GPlUnit+RCB_PClass] = xpAddr[idx_Pa_PClass] | 0; // From Partial
                // Compute speed
                v1 = PMAddr[idx_Pm_Speed1];
                v2 = PMAddr[idx_Pm_Speed1+1];
                v3 = PMAddr[idx_Pm_Speed1+2];  // sense - in 0 .. 100
                (v1 === Undef) ? v1 = parV(p_Dyn_Rate);
                (v2 === Undef) ? v2 = parV(p_Dyn_Rate);
                (v3 === Undef) ? v3 = 0;
                (v2 < v1) ? (k = v1; v1 = v2; v2 = k;); // should not arrive
                gmem[GPlUnit+RCB_PmMdSpd1] = v1;
                gmem[GPlUnit+RCB_PmMdSpd2] = v2;
                gmem[GPlUnit+RCB_PmMdSpd3] = v3;  // sense - in 0 .. 100
                (v1 < v2) ? (
                    v1 += (v2-v1) * frand(); // choose a speed
                );
                v3 > 0 ? (
                    ((1 - v3) < frand()) ? v1 = - v1; // choose a direction
                );
                gmem[GPlUnit+RCB_SpeedAbs_u] = v1; // "asked" speed from playmode
                gmem[GPlUnit+RCB_SpeedMod1_u] = (reSelectRate != Undef) ? reSelectRate : parV(p_RateCtl); // speed variation initial
                gmem[GPlUnit+RCB_SpeedMod2_u] = 1; // will be dynamic rate variation
                gmem[GPlUnit+RCB_CFrCorr_u] = 0; // Don't know yet the sample rate of the clip
                gmem[GPlUnit+RCB_Transpose_u] = parV(p_Transpose); // Transposition initiale
                gmem[GPlUnit+RCB_Speed_Dir_u] = parV(p_RDirSwitch) ? -1 : 1; // Sens initial de la lecture

            );

        ) : (
            GvErr = 0511; // no unit ready
            GvErrP2 = clcck;
            GvErrP3 = gmem[playerAvail]; // number of available players
        );
    );

    // 5- Select Output configuration
    (GvErr === 0) ? (
        HPInstall();
    );

    // 6- Select play parameters
    (GvErr === 0) ? (

        // Play Duration
        v1 = PMAddr[idx_Pm_PDur1]; v2 = PMAddr[idx_Pm_PDur1+1];
        (reSelectDuration > 0) ? (
            v2 = v1 = reSelectDuration;
        );
        (v1 === Undef) ? (
            v3 = (Xkmd === KmdPlay ? parV(p_playDur) : parV(p_loopDur)) ; // Play duration
            v4 = (Xkmd === KmdPlay ? parV(p_playVar) : parV(p_loopVar)) ; // Play variation
            v1 = v3 / (1 + v4 * (9/10)); v2 = v3 * (1 + v4 * (9/10));
        );
        (v2 === Undef) ? v2 = v1;
        (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
        gmem[GPlUnit+RCB_PmMdDur1] =  v1;
        gmem[GPlUnit+RCB_PmMdDur2] =  v2;
        (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
        gmem[GPlUnit+RCB_Rec_Duration] = gmem[GPlUnit+RCB_PlayTime_sec] =  v1 ; // Duration in seconds

        (Xkmd === KmdPlay) ? (
            // Play Fade-in
            (reSelectFadeIn >= 0) ? (
                v1 = v2 = reSelectFadeIn;
            ) : (
                v1 = PMAddr[idx_Pm_PFdIn1]; v2 = PMAddr[idx_Pm_PFdIn1+1]; // in ms
            );
            (v1 === Undef) ? (v1 = parV(p_fadeIPlTime)) : (v1 < 0) ? (v1 = - v1 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 === Undef) ? (v2 = parV(p_fadeIPlTime)) : (v2 < 0) ? (v2 = - v2 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
            (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
            gmem[GPlUnit+RCB_FadeIn_ms] =  v1; // in ms
            // Play Fade-out
            (reSelectFadeOut >= 0) ? (
                v1 = v2 = reSelectFadeOut;
            ) : (
                v1 = PMAddr[idx_Pm_PFdOut1]; v2 = PMAddr[idx_Pm_PFdOut1+1]; // in ms
            );
            (v1 === Undef) ? (v1 = parV(p_fadeOPlTime)) : (v1 < 0) ? (v1 = - v1 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 === Undef) ? (v2 = parV(p_fadeOPlTime)) : (v2 < 0) ? (v2 = - v2 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
            (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
            gmem[GPlUnit+RCB_FadeOut_ms] =  v1; // in ms
        );

        (Xkmd === KmdLoop) ? (
            // Loop Fade-in
            (reSelectFadeIn >= 0) ? (
                v1 = v2 = reSelectFadeIn;
            ) : (
                v1 = PMAddr[idx_Pm_PFdIn1]; v2 = PMAddr[idx_Pm_PFdIn1+1]; // in ms
            );
            v1 = PMAddr[idx_Pm_PFdIn1]; v2 = PMAddr[idx_Pm_PFdIn1+1]; // in ms
            (v1 === Undef) ? (v1 = parV(p_fadeILpTime)) : (v1 < 0) ? (v1 = - v1 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 === Undef) ? (v2 = parV(p_fadeILpTime)) : (v2 < 0) ? (v2 = - v2 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
            (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
            gmem[GPlUnit+RCB_FadeIn_ms] =  v1; // in ms
            // Loop Fade-out
            (reSelectFadeOut >= 0) ? (
                v1 = v2 = reSelectFadeOut;
            ) : (
                v1 = PMAddr[idx_Pm_PFdOut1]; v2 = PMAddr[idx_Pm_PFdOut1+1]; // in ms
            );
            v1 = PMAddr[idx_Pm_PFdOut1]; v2 = PMAddr[idx_Pm_PFdOut1+1]; // in ms
            (v1 === Undef) ? (v1 = parV(p_fadeOLpTime)) : (v1 < 0) ? (v1 = - v1 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 === Undef) ? (v2 = parV(p_fadeOLpTime)) : (v2 < 0) ? (v2 = - v2 * 10 * gmem[GPlUnit+RCB_PlayTime_sec]);
            (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
            (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
            gmem[GPlUnit+RCB_FadeOut_ms] =  v1; // in ms
        );

        // Grains Sizes
        v1 = PMAddr[idx_Pm_Gsize1]; v2 = PMAddr[idx_Pm_Gsize1+1]; // in seconds
        (v1 === Undef) ? (v1 = parV(p_GrainSizMin)) : (v1 *= 1000);
        (v2 === Undef) ? (v2 = parV(p_GrainSizMax)) : (v2 *= 1000);
        gmem[GPlUnit+RCB_MinGrains_ms] =  min(v1, v2); // in ms
        gmem[GPlUnit+RCB_MaxGrains_ms] =  max(v1, v2); // in ms
        w = (v1 + v2) / 2; // estimation

        // Grain Fade-in
        v1 = PMAddr[idx_Pm_GPFdIn1]; v2 = PMAddr[idx_Pm_GPFdIn1+1]; // in ms
        (v1 === Undef) ? (v1 = parV(p_GrFadeInTime)) : (v1 < 0) ? (v1 = - v1 * w / 100);
        (v2 === Undef) ? (v2 = parV(p_GrFadeInTime)) : (v2 < 0) ? (v2 = - v2 * w / 100);
        (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
        (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
        gmem[GPlUnit+RCB_GrFdIn_ms] =  v1; // in ms

        // Grain Fade-out
        v1 = PMAddr[idx_Pm_GPFdOut1]; v2 = PMAddr[idx_Pm_GPFdOut1+1]; // in ms
        (v1 === Undef) ? (v1 = parV(p_GrFadeOutTime)) : (v1 < 0) ? (v1 = - v1 * w / 100);
        (v2 === Undef) ? (v2 = parV(p_GrFadeOutTime)) : (v2 < 0) ? (v2 = - v2 * w / 100);
        (v2 < v1) ? (k = v1; v1 = v2; v2 = k;);
        (v1 < v2) ? ( v1 += (v2-v1) * frand(); );
        gmem[GPlUnit+RCB_GrFdOut_ms] =  v1; // in ms

        (reSelectGrFades > 0) ? (
            v1 = reSelectGrFades; reSelectGrFades = Undef;
            gmem[GPlUnit+RCB_GrFdIn_ms] = v1;
            gmem[GPlUnit+RCB_GrFdOut_ms] = v1;
        );

        // sprintf(#gfs_mss, "Grains sizes: %.2f / %.2f", gmem[GPlUnit+RCB_GrFdIn_ms], gmem[GPlUnit+RCB_GrFdOut_ms]);
        // mSL_log(SysLogBox, #gfs_mss);

        // Specific Read Algo ?
        v1 = PMAddr[idx_Pm_Spec0]; v2 = PMAddr[idx_Pm_Spec0+1];
        (v1 === Undef) ? (v1 = 0;);
        (v2 === Undef) ? (v2 = 0;);
        (reSelectPmod != Undef) ? (v1 = reSelectPmod);
        gmem[GPlUnit+RCB_Algo_enu] = v1; // algo - from idx_Pm_Spec0
        gmem[GPlUnit+RCB_AlParam] = v2; // param - from idx_Pm_Spec0+1

        // Grain Fade Type
        v1 = PMAddr[idx_Pm_GPFdTy];
        (v1 === Undef) ? (v1 = 0) ;
        gmem[GPlUnit+RCB_Gr_FdType] = v1;  // unused for now

        // Grains Density
        v1 = PMAddr[idx_Pm_GDepth1]; v2 = PMAddr[idx_Pm_GDepth1+1];
        (v1 === Undef) ? v1 = parV(p_GrDsty);
        (v2 === Undef) ? v2 = parV(p_GrDsty);
        gmem[GPlUnit+RCB_MinNGrains_u] = min(v1, v2);
        gmem[GPlUnit+RCB_MaxNGrains_u] = max(v1, v2);

        // Send volume
        v1 = PMAddr[idx_Pm_PVol1]; v2 = PMAddr[idx_Pm_PVol1+1];
        (v1 === Undef) ? v1 = 0;
        (v2 === Undef) ? v2 = v1;
        v3 = min(v1, v2); v2 = max(v1, v2); v1 = v3; // exchange v1 & v2 (using v3)
        v3 = (Xkmd === KmdPlay ? parV(p_PlGain) : parV(p_LpGain)); // vol. change
        (reSelectVolume != Undef) ? ( v3 += reSelectVolume; );
        gmem[GPlUnit+RCB_VolumeMin_dB] = v1 + v3;
        gmem[GPlUnit+RCB_VolumeMax_dB] = v2 + v3;
        v1 += (v2-v1) * frand() + v3;  // choose a target volume, convert to factor
        gmem[GPlUnit+RCB_VolumeTarget_dB] = v1;

        // Generator count
        gmem[GPlUnit+RCB_MinChCnt] = PMAddr[idx_Pm_ChCnt1];
        gmem[GPlUnit+RCB_MaxChCnt] = PMAddr[idx_Pm_ChCnt1+1];

        // Space algo
        v1 = SMAddr[idx_Sm_Algo]; v2 = SMAddr[idx_Sm_Aux];
        gmem[GPlUnit+RCB_SP_Algo] = (v1 != Undef) ? v1 : 0;
        gmem[GPlUnit+RCB_SP_Aux] = (v2 != Undef) ? v2 : 0;
        gmem[GPlUnit+RCB_SM_Par1] = SMAddr[idx_Sm_HPEv];
        gmem[GPlUnit+RCB_SM_Par2] = SMAddr[idx_Sm_HPEv+1];
        gmem[GPlUnit+RCB_SM_Par3] = SMAddr[idx_Sm_HPEv+2];
        gmem[GPlUnit+RCB_SM_Par4] = SMAddr[idx_Sm_HPEv+3];
        gmem[GPlUnit+RCB_SM_Par5] = SMAddr[idx_Sm_Pars];
        gmem[GPlUnit+RCB_SM_Par6] = SMAddr[idx_Sm_Pars+1];
        gmem[GPlUnit+RCB_SM_Par7] = SMAddr[idx_Sm_Pars+2];
        gmem[GPlUnit+RCB_SM_Par8] = SMAddr[idx_Sm_Pars+3];

        // FX volumes
        v1 = PMAddr[idx_Pm_FX1]; v2 = PMAddr[idx_Pm_FX1+1];
        (v1 === Undef) ? v1 = -120;
        (v2 === Undef) ? v2 = -120;
        gmem[GPlUnit+RCB_FX1_a] = v1;
        gmem[GPlUnit+RCB_FX1_b] = v2;
        v1 = PMAddr[idx_Pm_FX2]; v2 = PMAddr[idx_Pm_FX2+1];
        (v1 === Undef) ? v1 = -120;
        (v2 === Undef) ? v2 = -120;
        gmem[GPlUnit+RCB_FX2_a] = v1;
        gmem[GPlUnit+RCB_FX2_b] = v2;

        // Other values
        gmem[GPlUnit+RCB_Serial] = (gmem[clipSerial] += 1);
        gmem[GPlUnit+RCB_CKstart_tim] = time_precise() + timeD;
        gmem[GPlUnit+RCB_PlaySource] = KSource; // keep the source command
        gmem[GPlUnit+RCB_Repl_Src] = 0; // no source
        GvpM = XpM;
        GvsM = XsM;
        BankLink ? padBKVals[0] = part;

        // Dynamic Parameters
        v1 = PMAddr[idx_Pm_FLM1]; // flags 0 from play mode
        (v1 === Undef) ? (v1 = paramValues[p_Dyn_Flgs1]);
        v2 = PMAddr[idx_Pm_FLM1+1]; // flags 1 from play mode
        (v2 === Undef) ? (v2 = paramValues[p_Dyn_Flgs2]);
        ((Xkmd === KmdPlay) || (Xkmd === KmdLoop)) ? (
            ii = 0; loop(paramDynCnt,
                p = paramDyn[ii];
                gmem[GPlUnit+RCB_DynPar+ii] = (v1 & DPInitMode) ? paramValues[p] : paramDynDefault68[p - p_Dyn_First] ;
                ii += 1;
            );
        ) : (
            GvErr = 0517; // not a play command
            GvErrP4 = Xkmd;
        );
        gmem[GPlUnit+RCB_PM_Flgs1] = v1; // flags 0 from play mode
        gmem[GPlUnit+RCB_PM_Flgs2] = v2 ;  // flags 1 from play mode
    ) : (
        GvAutoNxt = Undef;
    );


    // 7- Recording informations
    (GvErr === 0) ? (
        // in any case, keep recordMode and the ref to the entry
        gmem[GPlUnit+RCB_RMode] = recordMode; // trace
        gmem[GPlUnit+cbClipLoop] = gmem[GPlUnit+RCB_Cl_Flgs] = gmem[GPlUnit+RCB_Rec_Entry] = 0;
        // if in Record mode, record the sound about to be played
        ((recordMode === recModeOn) && (PlRecCurrent !== 0)) ? (
            // Allocate an entry for the copy of the UCB
            z = getGmFSA();
            (z !== 0) ? (
                playLastAlloc = z; // The anchor for the sound
                SchedInsertTail(PlRecCurrent, z, 0);
                GXUnit = GPlUnit; // just as a display info
                gmem[GPlUnit+RCB_Rec_Time] = playLastAlloc[plLEntRcrd] = playLastTime = pRecTimeCurrent;
                gmem[GPlUnit+RCB_Rec_Entry] = w = - playLastAlloc[plLEntGRef]; // the gmem entry where you copy the info
                gmem[GPlUnit+RCB_Log_Entry] = playLastAlloc; // the list entry where you copy the info
                gmem[GPlUnit+RCB_Rec_Flag] = 0; // do not rechain it right now
                playLastAlloc[plLEINum] = (gmem[recLogCnt] += 1);
                playReeval = 1; // notify the player that a new entry is available
                /*
                sprintf(#sfc, "Allocate = %d/%d[%04d]  =>  Player %d ", gmem[GPlUnit+RCB_Rec_Entry], gmem[z+1], gmem[GPlUnit+RCB_ClipNb], GPlUnit);
                mSL_log(SysLogBox, #sfc);
                */
                //
            ) : (
               mSL_log(SysLogBox, "Can't allocate a Play Log Entry."); // !!!
               GvErr = 7273; // Can't allocate a Play Log Entry
            );
        );
    );


    // 8- Send command
    gmem[GPlUnit+cbERR] = GvErr; // return code
    (GvErr === 0) ? (
        LockSet = 0;
        gmem[GPlUnit+RCB_PlyerFlgs] = FlagsTbVals[Flgs_Plyers]; // transmit the debugging player flags
        gmem[GPlUnit+RCB_SmpPStart] = 0; // send the start date; 0 is "a.s.a.p."
        (xflgs & FLdoForceLock) ? gmem[GPlUnit+RCB_Cl_Flgs] |= 1;
        // Provide a unique number associated to every clip played
        gmem[GPlUnit+RCB_GClipSeq] = (GClipSeq += 1);
        // Last, but not least, and only now, specify the  command
        gmem[GPlUnit+RCB_Kmd] = Xkmd;
    ) : (
        doESignal(GvErr, GvErrP1, GvErrP2, GvErrP3);
        ((FlagsTbVals[Flgs_Play] & 1)) ? (
            // Trace
            sprintf(#s, "Play(%d, %d, %X, %d) err:  %04d  [%d  %d  %d  %d  %d  %d]  %d / %d",
                    xpart, xsel, xflgs, xtype, GvErr, GvErrP1, GvErrP2, GvErrP3,
                    GvErrP4, GvErrP5, GvErrP6, Kmnd_Pl, KSource);
            mSL_log(SysLogBox, #s);
        );
        // Free the unit, if any
        GvErrP1 = xpart;
        gmem[GPlUnit+cbStat] = uSUnused;
        gmem[GPlUnit+RCB_Kmd] = KmdNone;
    );

    // In all cases, Reset "re" selectors
    reSelectRate = reSelectVolume = reSelectGrFades = reSelectPartial = reSelectPmod =
    reSelectDuration = reSelectSpaceMode = reSelectPlayMode =
    reSelectFadeOut = reSelectFadeIn =
    reSelectHpSet = reSelectHpSet2 = reSelectHpent = reSelectHpent2 = Undef;

    ((FlagsTbVals[Flgs_Play] & 8)) ? (
        // Trace
        sprintf(#s, "Play_(%d, %d, %X, %d) err:  %04d  [%d  %d  %d  %d  %d  %d]  %d / %d",
                xpart, xsel, xflgs, xtype, GvErr, GvErrP1, GvErrP2, GvErrP3,
                GvErrP4, GvErrP5, GvErrP6, Kmnd_Pl, KSource);
        mSL_log(SysLogBox, #s);
    );

    GvErr; // for info
);// doPlayClip


//AGMW150 = GMW();

// flgs = 1 : loop  flgs = 2 : mute
function
doPlayRItem(item, flgs)  // result not used - Unit passed in GXUnit
local (z, r, ii)
(
    // allocate a player
    z = w = g = 0;
    (replayUnMute && (playAllow > 0)) ? ( // only if we do not limit number of player
        z = findPlayer();
        ((z >= UGAddr)) ? (
            gmem[z+RCB_Log_Entry] = item;
            gmem[z+RCB_Rec_Entry] = - item[plLEntGRef]; // the gmem entry where you copy the info
            gmem[z+cbClipLoop] = flgs;
            gmem[z+RCB_Cl_Flgs] = 0; // reset previous flags
            gmem[z+RCB_Rec_Flag] = 0; // do not rechain it right now
            r = gmem[z+RCB_Rec_Entry];
            gmem[playLogRef] = item[plLEINum];
            gmem[playLogDate] = item[plLEntRcrd];
            recOptRecReplay ? (
                // "rerecord" the sound : just add a new entry in the played log
                newitem = getLstBlock(0, plIDNT);
                newitem[plLEntGRef] = w = item[plLEntGRef];
                newitem[plLEINum] = (gmem[recLogCnt] += 1);
                newitem[plLEntRcrd] = pRecTimeCurrent;
                g = RCB_RefCnt - w; // addr. in gmem
                gmem[g] += 1; // increase ref. count
                SchedInsertTail(PlRecCurrent, newitem, 0); // Add in queue
            );
            // gmem[z+RCB_Repl_Src] = recOptMarkReplay ? item : 0; // should we note the replayed sounds
            gmem[z+RCB_Repl_Src] = item;
            (TRC & 0x800) ? (
                sprintf(#sfc, "Item = %d/%d/%d  =>  Player %d  ==> rec %d   -- %d", item, r, gmem[r] === plIDNT, z, w, gmem[z+RCB_Repl_Src]);
                mSL_log(SysLogBox, #sfc);
            );
            // Provide a unique number associated to every clip played
            gmem[GPlUnit+RCB_GClipSeq] = (GClipSeq += 1);
            gmem[z+RCB_Kmd] = KmdPlItem; // send command
            GXUnit = z;
            //URingPut(GXUnit); // enter unit in playing ring
        ) : (
            (TRC & 0x800) ? (
                (sprintf(#sfc, "doPlayRItem : no player for  %d", item); mSL_log(SysLogBox, #sfc); );
            );
            GvErr = 7276; // doPlayRItem Can't find a player
        );
    );
    z;
);//doPlayRItem

function markerDate(ent)
local (r)
(
    r = ent[lppEFlgs] & 0xf;
    (r === 0) ? (
        ent[lppEDate];
    ) :
    (r === 1) ? (
        ent[lppED1st];
    ) :
    (r === 2) ? (
        ent[lppED1st] + ent[lppEDurat] - ((ent[lppEElct] > 0) ? ent[lppEPsnd + 2 * ent[lppEElct] - 1] : 0);
    ) : (
        ent[lppED1st] + ent[lppEDurat];
    );
);

/*
    Look for the first entry to play in a record list
*/
function replayJumpTo(plg, date, direction)
local (pld, ple, plg, pln, plgtpln, pt, phz)
(
    pt = pld = ple = pln = phz = 0;
    plg === 0 ? plg = PlLogCurrent;
    plg === 0 ? plg = PlLogMain;
    gmem[playLogRef] = 0;
    playTime2Next = -1;
    date = max(0, min(date, playTimeMax));
    0 ? (
        sprintf(#s, "replayJumpTo(%d, %.3f, %.3f)", plg, date, direction);
        mSL_log(SysLogBox, #s);
    );
    (plg && (plg[SchedNxtEnt] !== plg[SchedOtherEnd])) ? (
        phz |= 1;
        plgt = plg + 4; // tail of current play log
        (direction >= 0) ? (
            // start from the head
            pt = plg[SchedNxtEnt];
            while ((pt[SchevEvntName] === plIDNT) && (date-pTEpsilon > pt[plLEntRcrd])) (
                pt = pt[SchedNxtEnt]; // jump to next.
                phz |= 0x10;
            );
            ((pt[SchevEvntName] === plIDNT) && (date-pTEpsilon <= pt[plLEntRcrd])) ? (
                ple = pt;
                phz |= 0x20;
            );
        ) : (
            // start from the tail
            pt = plg[SchedTailEnt];
            while ((pt[SchevEvntName] === plIDNT) && (date+pTEpsilon < pt[plLEntRcrd])) (
                pt = pt[SchedPrvEnt]; // jump to previous.
                phz |= 0x40;
            );
            ((pt[SchevEvntName] === plIDNT) && (date+pTEpsilon >= pt[plLEntRcrd])) ? (
                ple = pt;
                phz |= 0x50;
            );
        );
        ((ple !== 0) && (ple[SchevEvntName] === plIDNT)) ? (
            replayEntry = ple; pld = ple[plLEntRcrd];
            pPlayTimeCurrent = date;
            lppRepDate = replayEntry[plLEntRcrd];
            playTime2Next = abs((pPlayTimeCurrent - lppRepDate) / (max (0.0001, abs(direction))));
            replayLogActive = plg;
            gmem[playLogRef] = pln = ple[plLEINum];
            // if found, jump to it
        );
    );
    gmem[playLogDate] = pPlayTimeCurrent = parSet(p_VirtualTime, date);
    0 ? (
        sprintf(#s, "replayJumpTo() -> %x [%.3f  %d/%d, %.2f] id = %d", phz, date, pln, ple, pld, ple[2]);
        mSL_log(SysLogBox, #s);
    );
    ple; // return the Jump Entry
);//replayJumpTo

function doPlayCmd(Kmd, Par1, Par2, Par3, Par4, Par5)
(
    SchedAddTask(Act_Play, Kmd, Par1, Par2, Par3, Par4, Par5);
);


function doPlayCmd(Kmd, Par1, Par2, Par3, Par4)
(
    SchedAddTask(Act_Play, Kmd, Par1, Par2, Par3, Par4, Undef);
);


function doPlayCmd(Kmd, Par1, Par2, Par3)
(
    SchedAddTask(Act_Play, Kmd, Par1, Par2, Par3, Undef, Undef);
);


function doPlayCmd(Kmd, Par1, Par2)
(
    SchedAddTask(Act_Play, Kmd, Par1, Par2, Undef, Undef, Undef);
);

function doPlayCmd(Kmd, Par)
(
    SchedAddTask(Act_Play, Kmd, Par, Undef, Undef, Undef, Undef);
);

function doPlayCmd(Kmd)
(
    SchedAddTask(Act_Play, Kmd, Undef, Undef, Undef, Undef, Undef);
);




tUnix = time();
tInit1 = tUnix - tSUnix;



tInit2 = time() - tUnix;


//====== GENERIC OPERATIONS ======

// Update a  number passed as parameter
// with "key" being the "command"
// maxV the maximum value allowed
function updtNumber(num, key, maxV)
local (cq, cx, flu, flk, kuz, zplm)
(
    zplm = num;
    flu = 0; kuz = 1; cq = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        num = num * 10 + key - '0';
        flu = 1;
    ) :
    ((key === '%')||(key === 'home')) ? (
        num = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        num = (1+num) % maxV;
    ) :
    ((key === ':')||(key === '/')) ? (
        num = (maxV-1+num) % maxV;
    ) :
    ((key === ';')||(key === '.')) ? (
        num = num + 1; flu = 1;
    ) :
    ((key === ',')||(key === '?')) ? (
        num = num - 1; cq = -1; flu = 1;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            num = num + cq;
            flu = 1;
        ) :
        ((key === 'down')) ? (
            num = num + 10; flu = 1;
        ) :
        ((key === 'up')) ? (
            num = num - 10; cq = -1; flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            num = num + 100; flu = 1;
        ) :
        ((key === 'pgup')) ? (
            num = num - 100; cq = -1; flu = 1;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 3;
    ); // indicates that the current key has been used

    flu ? (
        num = (num + 100 * maxV) % maxV;
    );

    num;
);


// Update a big number passed as parameter
// with "key" being the "command"
function updtBNumber(num, key, alt)
local (cq, cx, flu, flk, kuz, zplm)
(
    zplm = num;
    flu = 0; kuz = 1; cq = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        num = num * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'z')) ? (
        num = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        num = num + 8;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        num = num - 8;
    ) :
    ((key === ';')||(key === '.')) ? (
        num = num + 1;
    ) :
    ((key === ',')||(key === '?')) ? (
        num = num - 1; cq = -1; flu = 1;
    ) :
    ((key === '$')) ? (
        num = alt;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            num = num + cq;
        ) :
        ((key === 'down')) ? (
            num = num + 32;
        ) :
        ((key === 'up')) ? (
            num = max(0, num - 32);
        ) :
        ((key === 'pgdn')) ? (
            num = num + 256;
        ) :
        ((key === 'pgup')) ? (
            num = max(0, num - 256);
        ) :
        ((key === 'home')) ? (
            num = 0;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );



    num;
);



// Update a clip number passed as parameter
// with "key" being the "command"
function updClipNumber(cln, key, reason)
local (cq, cx, flu, flk, kuz, zcln)
(
    flu = 0; kuz = 1; cq = 1; flk = key > 0;
    zcln = cln;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        cln = (cln % 1000) * 10 + key - '0';
    ) :
    ((key === ',')||(key === ';')) ? (
        // shift to the next/previous volume modification
        cq = ((key === ';')) ? 1 : clTSize-1;
        cln = (cln + cq) % clTSize;
        cx = clTSize;
        while ((gmem[clClVolumes+cln] === clVolumeBias) && (cx >= 0)) (
            cln = (cln + cq) % clTSize; cx -=1;
        );
    ) :
    ((key === '%')||(key === 'home')) ? (
        cln = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        cln = (1+cln) % clTSize;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        cln = (clTSize-1+cln) % clTSize;
     ) :
    ((key === ';')) ? (
        cln = cln + 1; flu = 1;
    ) :
    ((key === ',')) ? (
        cln = cln - 1; cq = -1; flu = 1;
    ) :
    ((key === '.')) ? (
        cln = cln + 10; flu = 1;
    ) :
    ((key === '?')) ? (
        cln = cln - 10; cq = -1; flu = 1;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            // shift to the next/previous defined clip
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            cln = cln + cq;
            flu = 1;
        ) :
        ((key === 'down')) ? (
            cln = cln + 100; flu = 1;
        ) :
        ((key === 'up')) ? (
            cln = cln - 100; cq = -1; flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            cln = cln + 1000; flu = 1;
        ) :
        ((key === 'pgup')) ? (
            cln = cln - 1000; cq = -1; flu = 1;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = reason + 10000;
    ); // indicates that the current key has been used

    flu ? (
        cx = clTSize; cln = (cln+clTSize) % clTSize;
        while ((gmem[clClInfos+cln] <= 0) && (cx >= 0)) (
            cln = (cln + cq + clTSize) % clTSize; cx -= 1;
        );
        (cln != zcln) ? (
            ui_GFXdoNow |= 1;
            ui_GFXReason = reason + 20000;
        );
    );

    cln; // return the new value
);


// Update a play mode number passed as parameter
// with "key" being the "command"
function updPlMdNumber(plm, key)
local (cq, cx, flu, flk, kuz, zplm)
(
    zplm = plm;
    flu = 0; kuz = 1; cq = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        plm = (plm % 1000) * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'z')||(key === 'home')) ? (
        plm = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        plm = (1+plm) % PMEcnt;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        plm = (PMEcnt-1+plm) % PMEcnt; cq = -1;
    ) :
    ((key === ';')||(key === '.')) ? (
        plm = plm + 1; flu = 1;
    ) :
    ((key === ',')||(key === '?')) ? (
        plm = plm - 1; cq = -1; flu = 1;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            plm = plm + cq;
            flu = 1;
        ) :
        ((key === 'down')) ? (
            plm = plm + 10; flu = 1;
        ) :
        ((key === 'up')) ? (
            plm = plm - 10; cq = -1; flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            plm = plm + 100; flu = 1;
        ) :
        ((key === 'pgup')) ? (
            plm = plm - 100; cq = -1; flu = 1;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 3;
    ); // indicates that the current key has been used

    flu ? (
        cx = PMEcnt; plm = (plm+PMEcnt) % PMEcnt;
        while ((PMTab[plm * PMEsize + idx_Pm_Kmd] <= 0) && (cx >= 0)) (
            plm = (plm + cq + PMEcnt) % PMEcnt; cx -= 1;
        );
        (zplm != plm) ? (
            ui_GFXdoNow |= 1;
            ui_GFXReason = 4;
        );
    );

    plm;
);


// Update a space mode number passed as parameter
// with "key" being the "command"
function updSpMdNumber(spm, key)
local (cq, cx, flu, flk, kuz, zspm)
(
    zspm = spm;
    flu = 0; cq = 1; kuz = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        spm = (spm % 1000) * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'z')||(key === 'home')) ? (
        spm = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        spm = (1+spm) % SMEcnt;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        spm = (SMEcnt-1+spm) % SMEcnt; cq = -1;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')
            || (key === ',')||(key === ';')||(key === '?')||(key === '.')) ? (
            cq = ((key === 'n')||(key === 'rght')||(key === ';')||(key === '.')) ? 1 : -1;
            spm = spm + cq;
            flu = 1;
        ) :
        ((key === 'down')) ? (
            spm = spm + 10; flu = 1;
        ) :
        ((key === 'up')) ? (
            spm = spm - 10; cq = -1; flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            spm = spm + 100; flu = 1;
        ) :
        ((key === 'pgup')) ? (
            spm = spm - 100; cq = -1; flu = 1;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 5;
    ); // indicates that the current key has been used

    flu ? (
        cx = SMEcnt; spm = (spm + SMEcnt) % SMEcnt;
        while ((SMTab[spm * SMEsize] <= 0) && (cx >= 0)) (
            spm = (spm + cq + SMEcnt) % SMEcnt; cx -= 1;
        );
        (zspm != spm) ? (
            ui_GFXdoNow |= 1;
            ui_GFXReason = 6;
        );
    );

    spm; // return the new value
);

// Update a bank or group passed as parameter
// use ty='gr' or ty='bk' ...
function updGrBkNumber(ty, pnb, key)
local (cq, cl, cc, v, flu, flk, kuz, fpo, cmax, ttx, ix, nfnd, tSiz, u, nnum)
(
    flu = 0; cq = 1; kuz = 1; flk = key > 0;
    tSiz = GRPtSiz; // max. bank or group idt
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        pnb = (pnb % 1000) * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'home')) ? (
        pnb = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        pnb = (pnb+1) % tSiz;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        pnb = (pnb+tSiz-1) % tSiz;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'down')) ? (
            pnb += 10; flu = 1;
        ) :
        ((key === 'up')) ? (
            pnb -= 10; flu = 1; cq = -1;
        ) :
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            flu = 1;
            pnb = (pnb + cq + tSiz) % tSiz;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 7;
    );

    flu ? (
        // Try to check that the current value is valid for a group or a bank
        /*
        ix = fpo = 0; cmax = 10000;
        ty === 'gr' ? (fpo = idx_Pa_Grp; cmax = 10000;);
        ty === 'bk' ? (fpo = idx_Pa_Bnk; cmax = 10000;);
        ttx = 999999; nfnd = 1;
        while ((ttx > 0) && (nfnd)) (
            (nfnd = (BKTab[ix * BKEsize + fpo] != pnb)) ? (
                // try next entry
                ix += 1;
                (ix >= BKDEcnt) ? (ix = 0; pnb = (pnb+cq+cmax) % cmax; );
            );
            ttx -= 1;
        );
        */
        ix = fpo = 0; cmax = BKDEcnt;
        ty === 'gr' ? (fpo = idx_Pa_Grp;);
        ty === 'bk' ? (fpo = idx_Pa_Bnk;);
        (cq > 0) ? (
            nnum = 65536;
            while (ix < BKDEcnt) (
                u = BKTab[ix * BKEsize + fpo];
                ((u >= pnb) && (u < nnum)) ? (nnum = u;);
                ix += 1;
            );
            (nnum === 65536) ? (nnum = 0;);
        ) : (
            nnum = -1;
            while (ix < BKDEcnt) (
                u = BKTab[ix * BKEsize + fpo];
                ((u <= pnb) && (u > nnum)) ? (nnum = u;);
                ix += 1;
            );
            (nnum === -1) ? (nnum = 0;);
        );
        pnb = nnum;

    );

    pnb; // return value
);




// Update a bank or group passed as parameter
// starting from the group "gnb" passed as parameter
function updGroupNumber(gnb, key)
local (flu, cq, kuz, flk, tSiz, ix)
(
    flu = 1; cq = 1; kuz = 1; flk = key > 0;
    tSiz = GRPtSiz; // max. bank or group idt
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        gnb = (gnb % 1000) * 10 + key - '0';
        flu = 0; // don't normalize now
    ) :
    ((key === '%')||(key === 'home')) ? (
        gnb = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        gnb = (gnb+1) % tSiz;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        gnb = (gnb+tSiz-1) % tSiz; cq = -1;
    ) :
    ((key === 'down')||(key === 'pgdn')) ? (
        gnb += 10;
    ) :
    ((key === 'up')||(key === 'pgup')) ? (
        gnb -= 10; cq = -1;
    ) :
    ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
        cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
        gnb = (gnb + cq + tSiz) % tSiz;
    ) :
    ((key != 0)) ? (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
    );

    // ADump(GRPtTab);
    (flu && (GRPtTab[gnb] < 0)) ? (
        // normalize the group by associating a real group to it
        ix = 0;
        while ((GRPtTab[gnb] < 0) && (ix < tSiz)) (
            gnb = (gnb + cq + tSiz) % tSiz; ix += 1;
        );
    );
    gnb;

);


// Skip to next / previous Group & bank
// starting from the current partial, "part"
function updGroupBnkNumber(part, key)
local(cq, kuz, flk, u, u_Grp, u_Bnk, ix)
(
    cq = 1; kuz = 1; flk = key > 0;
    key < 0 ? key = -key;
    u = part * BKEsize;
    u_Grp = BKTab[u + idx_Pa_Grp];
    u_Bnk = BKTab[u + idx_Pa_Bnk];

    ((key === 'n')||(key === '+')||(key === '=')) ? (
        part = (part + cq + BKDEcnt) % BKDEcnt;
    ) :
    ((key === 'p')||(key === ':')||(key === '/')||(key === '-')) ? (
        cq = -1;
        part = (part + cq + BKDEcnt) % BKDEcnt;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'rght')) ? (
            cq = 1;
            part = (part + cq + BKDEcnt) % BKDEcnt;
        ) :
        ((key === 'left')) ? (
            cq = -1;
            part = (part + cq + BKDEcnt) % BKDEcnt;
        ) :
        ((key === 'up')||(key === 'pgup')) ? (
            part = (part - 10 + BKDEcnt) % BKDEcnt;
            cq = -1;
        ) :
        ((key === 'down')||(key === 'pgdn')) ? (
            part = (part + 10 + BKDEcnt) % BKDEcnt;
            cq = 1;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    kuz ? (
        ix = 0; u = part * BKEsize;
        while ((ix < BKDEcnt) && (u_Grp === BKTab[u + idx_Pa_Grp]) && (u_Bnk === BKTab[u + idx_Pa_Bnk])) (
            part = (part + cq + BKDEcnt) % BKDEcnt;
            u = part * BKEsize; ix += 1;
        );
    );
    (part === 0) ?
        part = (cq > 0) ? 1 : BKDEcnt - 1;
    part; // return part
);



// Update a partial number passed as parameter
// with "key" being the "command"
function updPartNumber(pnb, key)
local (cq, cl, cc, v, flu, flk, kuz, zpnb)
(
    zpnb = pnb;
    flu = 0; cq = 1; kuz = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        pnb = (pnb % 1000) * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'home')) ? (
        pnb = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        pnb += 1; flu = 1;
    ) :
    ((key === 0)||(key === 1)||(key === '_')) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 1) ? -1 : 1;
    ) :
    ((key === ':')||(key === '/')||(key === '-')) ? (
        pnb -= 1; flu = 1; cq = -1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'up')) ? (
            pnb -= 10; flu = 1; cq = -1;
        ) :
        ((key === 'pgup')) ? (
            pnb -= 100; flu = 1; cq = -1;
        ) :
        ((key === 'down')) ? (
            pnb += 10; flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            pnb += 100; flu = 1;
        ) :
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : BKEcnt-1;
            flu = 1;
            pnb = (pnb + cq) % BKEcnt;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 8;
    ); // indicates that the current key has been used

    flu ? (
        cl = BKEcnt; pnb = (pnb + BKEcnt) % BKEcnt;
        while ((cl >= 0) &&  ((BKTab[pnb * BKEsize + idx_Pa_Clps] === Undef) ||
                            (BGrpLow > (v = BKTab[pnb * BKEsize + idx_Pa_Grp])) ||
                            (BGrpHigh < v))) (
            pnb = (pnb + cq + BKEcnt) % BKEcnt; cl -= 1;
        );
        (cl < 0) ? pnb = 0; // not found : reset partial to 0 by default
        BgrpCurr = BKTab[pnb * BKEsize + idx_Pa_Grp]; // set the current group
        (pnb != zpnb) ? (
            ui_GFXdoNow |= 1;
            ui_GFXReason = 9;
        );
    );
    pnb; // return value
);


// Update entry "ent" of the studio pad based on char "key"
// note that these are already used : "azertyui" and "qsdfghjk"
//
// When the studio pad is active, we work only with "padStCells"
function updStudPadKey(ent, key)
local (val, flgs, cq, cl, u, v, flu, flk, kuz, ty, Oflag, padEnt, dataEnt, ig, kg,
    u_Part, u_Grp, u_Bnk, u_ClL, u_ClH)
(
    flu = 0; cq = 1; kuz = 1; flk = key > 0; key < 0 ? key = - key;
    Oflag = 0;
    padEnt = ent % padStSiz;
    dataEnt = (ent + padStOffset) % padStTotSiz;
    u_Part = padStPVals[dataEnt] % BKEcnt;
    u = u_Part * BKEsize;
    u_Grp = BKTab[u + idx_Pa_Grp];
    u_Bnk = BKTab[u + idx_Pa_Bnk];
    // u_Pnb = BKTab[u + idx_Pa_PNumb];
    u_ClL = padStClipsL[dataEnt] >= 0 ? padStClipsL[dataEnt] : BKTab[u + idx_Pa_Clps];
    u_ClH = padStClipsH[dataEnt] >= 0 ? padStClipsH[dataEnt] : BKTab[u + idx_Pa_Clps+1];

    flgs = padStCells[padEnt]; ///
    ty = flgs & padStFlDspM; // type d'affichage
    // AAAAAAAAAA_ty = ty;
    // AAAAAAAAAA_key = key;
    // AAAAAAAAAA_ent = padEnt;
    // AAAAAAAAAA_part0 = u_Part;


    (key === 0) ? (
        u_ClL = updClipNumber(u_ClL, 0, 333);
        u_ClH = updClipNumber(u_ClH, 0, 333);
        (u_ClH < u_ClL) ? (
            v = u_ClH; u_ClH = u_ClL; u_ClL = v;
        );
        padStCells[padEnt] &= padStFlMsk7; // reset error bit on 0 key
    ) :
    (key === '\'') ? (
        v = u_ClH; u_ClH = u_ClL; u_ClL = v;
    ) :
    (key === '(') ? (
        Oflag = 1;
    ) :
    (key === ')') ? (
        Oflag = 2;
    ) :
    (key === '>') ? (
        Oflag = 3;
    ) :
    (key === ',') ? (
        padStCells[padEnt] = (padStCells[padEnt] & padStFlMsk) | (((padStCells[padEnt] & padStFlDspM) + 1) % padStFlErrbit);
    ) :
    (ty === padStDispPar) ? (
        BGrpLow = 0; BGrpHigh = BKEcnt-1;
        u_Part = updPartNumber(u_Part, key);
        // update the partial
    ) :
    (ty === padStDispGrp) ? (
        BGrpLow = 0; BGrpHigh = BKEcnt-1;
        // Nu_Grp = updGrBkNumber('gr', u_Grp, key);
        u_Grp = updGroupNumber(u_Grp, key);
        u_Part = max(1,GRPtTab[u_Grp]); // return 1st by default
    ) :
    (ty === padStDispGBk) ? (
        u_Part = max(1,updGroupBnkNumber(u_Part, key));
    ) :
    (ty === padStDispClip) ? (
        u_ClH = u_ClL = updClipNumber(u_ClL, key, 333);
    ) :
    (ty === padStDispRng) ? (
        u_ClL = updClipNumber(u_ClL, key, 333);
    ) :
    (ty === padStDispAct) ? (
        u_ClL = updtNumber(u_ClL, key, PMEcnt);
    );

    padStPVals[dataEnt] = u_Part;
    padStClipsL[dataEnt] = u_ClL;
    padStClipsH[dataEnt] = u_ClH;

    //AAAAAAAAAA_part1 = u_Part;
    //AAAAAAAAAA_grp = u_Grp;
    //AAAAAAAAAA_bnk = u_Bnk;

    StdnumUnchkd = 16;
    StdnumLastM = lastTime;

    (Oflag) ? (
        // save cells options
        ig = 0; loop(padStSiz,
            kg = ig + padStOffset;
            padStFlags[kg] = padStCells[ig];
            ig += 1;
        );
        // Update visible position of the pad
        (Oflag === 1) ? (
            padStOffset = padStOffset + padStDeltaOffset;
        ) :
        (Oflag === 2) ? (
            padStOffset = padStOffset + padStMaxOffset - padStDeltaOffset;
        ) : (
            padStOffset = 0;
        );
        padStOffset = padStOffset % padStMaxOffset;
        // reload cell options
        ig = 0; loop(padStSiz,
            kg = ig + padStOffset;
            padStCells[ig] = padStFlags[kg];
            ig += 1;
        );
    );

);



function setControlChanged(type, v1, v2, hdr, fmt)
local (il)
(
    il = 0;
    while (type && il<DispCnt) (
        (DispIds[il] === type) ? (
            DispVa1[il] = v1; DispVa2[il] = v2; type = 0;
        );
        il += 1;
    );
    type ? (
         // Re-use a display
        il = DispUseNow = (DispUseNow + 1) % DispCnt;
        DispFmt[il] = fmt;
        DispHdr[il] = hdr;
        DispVa1[il] = v1;
        DispVa2[il] = v2;
        DispIds[il] = type;
    );

);



/*
=== PARAMETERS DCL ===
*/
function
initAllParameters()
local(ix)
(
    // do some default init. We keep the name uninitialized.
    ix = 0;
    loop(paramCount,
        parDcl(ix, #pUndef, #pUndef, 0, "-", "-", 0, 1, 0, 0.1, 0);
        ix += 1;
    );
    paramBlock[pp_Name] = "(unused)"; // this "locks" entry 0.
    menu_Param_mSL = 0;
    menu_Param_UBS = 0;
    menu_Param_UBD = 0;
    parDclMode = 0xf;
);

function
dclAllParameters()
local (ix, p, pdx, pp, pb, ii, ix, iy, u, w,mi, ma)
(
    paramBlock[pp_Name] = "(unused)"; // this "locks" entry 0.
    // The random generators
    p = 2; // potentiometer curve for amplitude
    parDcl(p_rgenA1,    "Rgen 1 Amp",   "RG1Amp",  0,  "%d %%",     "Rgen 1 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA2,    "Rgen 2 Amp",   "RG2Amp",  0,  "%d %%",     "Rgen 2 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA3,    "Rgen 3 Amp",   "RG3Amp",  0,  "%d %%",     "Rgen 3 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA4,    "Rgen 4 Amp",   "RG4Amp",  0,  "%d %%",     "Rgen 4 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA5,    "Rgen 5 Amp",   "RG5Amp",  0,  "%d %%",     "Rgen 5 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA6,    "Rgen 6 Amp",   "RG6Amp",  0,  "%d %%",     "Rgen 6 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA7,    "Rgen 7 Amp",   "RG7Amp",  0,  "%d %%",     "Rgen 7 Amp: %d %%",      0,  100,    0, 1, p);
    parDcl(p_rgenA8,    "Rgen 8 Amp",   "RG8Amp",  0,  "%d %%",     "Rgen 8 Amp: %d %%",      0,  100,    0, 1, p);
    p = 10; // potentiometer curve for frequency
    parDcl(p_rgenP1,    "Rgen 1 Freq",  "RG1Freq", 0,  "%.2f",     "Rgen 1 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP2,    "Rgen 2 Freq",  "RG2Freq", 0,  "%.2f",     "Rgen 2 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP3,    "Rgen 3 Freq",  "RG3Freq", 0,  "%.2f",     "Rgen 3 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP4,    "Rgen 4 Freq",  "RG4Freq", 0,  "%.2f",     "Rgen 4 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP5,    "Rgen 5 Freq",  "RG5Freq", 0,  "%.2f",     "Rgen 5 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP6,    "Rgen 6 Freq",  "RG6Freq", 0,  "%.2f",     "Rgen 6 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP7,    "Rgen 7 Freq",  "RG7Freq", 0,  "%.2f",     "Rgen 7 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    parDcl(p_rgenP8,    "Rgen 8 Freq",  "RG8Freq", 0,  "%.2f",     "Rgen 8 freq: %.2f s",     0.01, 3600,  1, 0.01,   p, pflg_LedA);
    p = 1.5; // potentiometer curve for players count
    parDcl(p_maxGenerators, "Generators #",  "GenNbr",  i_SP,   "%.2f",  "Generators #: %.2f ",   0,   64,  4,  0.01, p, pflg_WActive, 3);
    parDcl(p_maxPlayers, "Players #",    "PlayNbr",     i_SP,   "%.2f",  "Players #: %.2f ",    0,   64,  2,    0.01, p, pflg_WActive, 3);
    parDcl(p_maxLoopers, "Loopers #",    "LoopNbr",     i_SP,   "%.2f",  "Loopers #: %.2f ",    0,   64,  2,    0.01, p, pflg_WActive, 3);
    parDcl(p_ratioReadLoop, "Reader/Looper",  "RLRatio", i_SP,  "%d %%", "Read/Loop: %d %%",    -100,   100,   0,   1,  0, pflg_WActive, 3);

    parDcl(p_GvChnUse,  "Channels #",   "ChanNbr",  i_SP, "%d",   "Channels #: %d",  2,   64,   2,   1);
    parDcl(p_maxClSize, "Clip.Rd.Lim",  "ClRdLim", i_SP,  "%d s",  "Clip.Rd.Lim: %d s",  1,  600, 60, 1, 3, pflg_WActive,  -clRdMaxSize);
    parDcl(p_RateCtl,   "Rate Initial",   "RateInit",   i_SP,  "%0.3f", "Rate Init.: %.3f",   0.1,  4,   1,  0.001, 3);
    parDcl(p_autoFreq,   "Auto Freq.",  "AutoFreq",    i_SP,   "%.2f",  "Auto Freq.: %.2f s",  0.0,  30,  0.01, 0.01, 5);
    parDcl(p_playDur, "Play Dur.", "PlayDur", i_UB|i_SP, "%.1f s",  "Play Dur.: %.1f s", 0.1, 7200, 20, 0.1, 6, pflg_WActive, 0);
    parDcl(p_loopDur, "Loop Dur.", "LoopDur", i_UB|i_SP, "%.1f s",  "Loop Dur.: %.1f s", 0.1, 7200, 30, 0.1, 6, pflg_WActive, 0);

    parDcl(p_playVar, "Play Var.", "PlayVar", i_UB|i_SP, "%.3f",  "Play Var.: %.3f", 0, 10, 0.2, 0.001, 3);
    parDcl(p_loopVar, "Loop Var.", "LoopVar", i_UB|i_SP, "%.3f",  "Loop Var.: %.3f", 0, 10, 0.2, 0.001, 3);

    parDcl(p_PlayStart, "Cl.Start.Pos",  "ClStPos",  i_UB|i_SP, "%d %%", "Cl.Start.Pos: %d %%",   0,  100,     0,   1);
    parDcl(p_PlGain,    "Play Gain",  "PlayGain",  i_UB|i_SP, "%.1f dB", "Play Gain: %.1f dB",   -40,   20,    0,  0.1, -3);
    parDcl(p_LpGain,    "Loop Gain",  "LoopGain",  i_UB|i_SP, "%.1f dB", "Loop Gain: %.1f dB",   -40,   20,    0,  0.1, -3);

    // Player Fade-in time — uses two entries
    parDcl(p_fadeIPlTime,  "Pl.Fade.In", "PlFadIn", i_Si|RCB_FadeIn_ms|i_SP,  "%d ms",   "Pl.Fade.In: %d ms",      2,   30000, 1000,    1, 6, pflg_WActive, 0);
    parDcl(p_fadeIPlTimeB, "Pl.Fade.In", "PlFadIn", 0,  "%.1f s",  "Pl.Fade.In: %.1f s", 0.002,   30,    1,    0.01, 6);
    parDclAlt(p_fadeIPlTime, p_fadeIPlTimeB, 1000, 1000);
    // Player Fade-out time — uses two entries
    parDcl(p_fadeOPlTime,  "Pl.Fade.Out", "PlFadOut", i_Si|RCB_FadeOut_ms|i_SP,  "%d ms",   "Pl.Fade.Out: %d ms",      3,   30000, 1000,    1, 6, pflg_WActive, 0);
    parDcl(p_fadeOPlTimeB, "Pl.Fade.Out", "PlFadOut",0,  "%.1f s",  "Pl.Fade.Out: %.1f s", 0.003,   30,    1,    0.01, 6);
    parDclAlt(p_fadeOPlTime, p_fadeOPlTimeB, 1000, 1000);
    // Looper Fade-in time — uses two entries
    parDcl(p_fadeILpTime,  "Lp.Fade.In", "LpFadIn", i_UB|i_SP,  "%d ms",   "Lp.Fade.In: %d ms",      2,   30000, 1000,    1, 6, pflg_WActive, 0);
    parDcl(p_fadeILpTimeB, "Lp.Fade.In", "LpFadIn",0,  "%.1f s",  "Lp.Fade.In: %.1f s", 0.002,   30,    1,    0.01, 6);
    parDclAlt(p_fadeILpTime, p_fadeILpTimeB, 1000, 1000);
    // Looper Fade-out time — uses two entries
    parDcl(p_fadeOLpTime,  "Lp.Fade.Out", "LpFadOut", i_UB|i_SP,  "%d ms",   "Lp.Fade.Out: %d ms",      3,   30000, 1000,    1, 6, pflg_WActive, 0);
    parDcl(p_fadeOLpTimeB, "Lp.Fade.Out", "LpFadOut", 0,  "%.1f s",  "Lp.Fade.Out: %.1f s", 0.003,   30,    1,    0.01, 6);
    parDclAlt(p_fadeOLpTime, p_fadeOLpTimeB, 1000, 1000);

    parDcl(p_LocSpeed2, "Speed Var.",  "SpeedVar",  i_Vm|RCB_SpeedMod1_u,  "%0.3f",   "Speed Var.: %.3f",    0.01,    10,  1,  0.001, 5, pflg_WActive);

    parDcl(p_sysSynchro, "Synchro", "Synchro", i_UB|i_SP, "%0.1f", "Synchro: %.1f ms", 1, 120000, 1000, 0.1, 6, pflg_WActive, -synchroDel);
    parDcl(p_sysSynchroB, "Synchro", "Synchro", 0, "%0.1f", "Synchro: %.2f s", 0.001, 120, 1, 0.01, 6);
    parDclAlt(p_sysSynchro, p_sysSynchroB, 1000, 1000);

    parDcl(p_mass, "Mass", "Mass", 0, "%.1f", "Mass: %.1f", 0.1, 10, 1, 0.1, 4, pflg_WActive, -looperMass);

    parDcl(p_uix_jtheme, "UI Theme",  "UITheme",   0,      "%d",   "UI Theme: %d", 0, 16, 0, 1, 0);

    parDcl(p_Randomness, "Randomness", "RandNess",  0,  "%d %%",    "Randomness: %d %%",    0,      100,   0,   1);
    parDcl(p_HP_Density, "HP Density", "HPDensty", i_UB|i_SP, "%d %%", "HP Density: %d %%", 1, 100, 100, 1, 0);

    parDcl(p_SchActive, "Scheduler", "SchAct", 0, "%d",  "Scheduler: %d", 0, 1, 1, 1);
    parDcl(p_GvAutoMd, "Auto Mode", "AutoMode", 0, "%d",  "Auto Mode: %d", 0, 1, 0, 1);

    parDcl(p_GrFadeInTime,  "Gr.Fade.In", "GrFadIn", i_Si|RCB_GrFdIn_ms|i_SP,  "%d ms",   "Gr.Fade.In: %d ms",      1,   3000, 1000,    1, 6);
    parDcl(p_GrFadeInTimeB, "Gr.Fade.In", "GrFadIn",0,  "%.2f s",  "Gr.Fade.In: %.2f s", 0.001,   3,    1,    0.01, 6);
    parDclAlt(p_GrFadeInTime, p_GrFadeInTimeB, 1000, 1000);

    parDcl(p_GrFadeOutTime,  "Gr.Fade.Out", "GrFadOut", i_Si|RCB_GrFdOut_ms|i_SP,  "%d ms",   "Gr.Fade.Out: %d ms",      1,   3000, 1000,    1, 6);
    parDcl(p_GrFadeOutTimeB, "Gr.Fade.Out", "GrFadOut",0,  "%.2f s",  "Gr.Fade.Out: %.2f s", 0.001,   3,    1,    0.01, 6);
    parDclAlt(p_GrFadeOutTime, p_GrFadeOutTimeB, 1000, 1000);

    parDcl(p_VMod1u, "Vol. Mod.", "VolMod", i_dB|RCB_VolumeMod1_u, "%.1f dB", "Vol. Mod.: %.1f dB",   -40,   40,    0,  0.1, 0);
    parDcl(p_RDirSwitch, "Read Reverse", "RdRev", i_HP|i_Vm|RCB_Speed_Dir_u|i_SP, "%d",  "Read Reverse: %d", 0, 1, 0, 1);

    // Max Grain Size — uses two entries
    parDcl(p_GrainSizMax,  "Gr.Max Size", "GrMxSiz", i_Si|RCB_MaxGrains_ms|i_SP,  "%d ms",   "Gr.Max Size: %d ms",      2,   30000, 5000,    1, 6);
    parDcl(p_GrainSizMaxB, "Gr.Max Size", "GrMxSiz", 0,  "%.1f s",  "Gr.Max Size: %.1f s", 0.002,   30,    5,    0.001, 6);
    parDclAlt(p_GrainSizMax, p_GrainSizMaxB, 1000, 1000);

    // Min Grain Size — uses two entries
    parDcl(p_GrainSizMin,  "Gr.Min Size", "GrMnSiz", i_Si|RCB_MinGrains_ms|i_SP,  "%d ms",   "Gr.Min Size: %d ms",      2,   30000, 500,    1, 6);
    parDcl(p_GrainSizMinB, "Gr.Min Size", "GrMnSiz", 0,  "%.1f s",  "Gr.Min Size: %.1f s", 0.002,   30,  0.5,    0.001, 6);
    parDclAlt(p_GrainSizMin, p_GrainSizMinB, 1000, 1000);

    // Channels count - local
    parDcl(p_ChnlUse, "HP Used", "HPUsed", i_HP|RCB_Channels_cnt_used1, "%d", "HP Used: %d", 1, 64, 2, 1);
    parDcl(p_GrDsty, "Gr.Density", "GrDensty", i_HP|RCB_GrXpect|i_SP, "%d", "Gr.Density: %d", 1, 24, 1, 1);

    // End/Start location
    parDcl(p_ClStart, "Cl.Pl.Start", "ClPStart", i_Si|RCB_ClStart, "%d %%", "Cl.Pl.Start %d %%", 0, 100, 0, 0.1);
    parDcl(p_ClEnd, "Cl.Pl.End", "ClPEnd", i_Si|RCB_ClEnd, "%d %%", "Cl.Pl.End %d %%", 0, 100, 100, 0.1);


    // Unused
    parDcl(p_Tempo_Sync, "Tempo Sync.", "TmpoSync", i_Vm|i_SP, "%d", "Tempo Sync.: %d",   0,   1,    0,  1, 0, pflg_WActive, -tempoSync);
    parDcl(p_Tempo_Rate, "Tempo", "Tempo", i_Vm|i_SP, "%.1f", "Tempo: %.1f",   0.1,   480,  60,  0.1, 3, pflg_WActive, 5);


    // Volume modification bias
    parDcl(p_VolGlobBias, "Vol.glob.bias", "VolGlbB", i_SP, "%.1f", "Vol.glob.bias: %.1f", 0, 10, 3, 0.1, 0, pflg_WActive, 4);
    parDcl(p_GRP_Switch, "Grp Switch Time", "GSwtchT", i_SP, "%d s",  "Grp Sw. Time: %d s", 2, 1200, 180, 1, 4);
    parDcl(p_Gen_SwtchTime, "G# Switch Time", "PSwtchT", i_SP, "%d s",  "G# Sw. Time: %d s", 2, 1200, 30, 1, 4);
    parDcl(p_Vol_SwtchTime, "Vol Switch Time", "VSwtchT", i_SP, "%d s",  "Vol Sw. Time: %d s", 2, 1200, 60, 1, 4);


    parDcl(p_Grp_VariVal, "Grp Variation", "GVariat", i_SP, "%d %%", "Grp Variation %d %%", 0, 100, 0, 1);
    parDcl(p_Gen_VariVal, "G# Variation", "PVariat", i_SP, "%d %%", "G# Variation %d %%", 0, 100, 0, 1);
    parDcl(p_Vol_VariVal, "Vol Variation", "VVariat", i_SP, "%d %%", "Vol Variation %d %%", 0, 100, 0, 1);
    parDcl(p_Gen_MinCnt, "Gen min #",  "GenMinCt",  i_SP,   "%.1f",  "Gen min #: %.1f ",   0,   24,  4,  0.1, p, pflg_WActive, 6);
    parDcl(p_Gen_MaxCnt, "Gen max #",  "GenMaxCt",  i_SP,   "%.1f",  "Gen max #: %.1f ",   0,   24,  4,  0.1, p, pflg_WActive, 6);

    parDcl(p_Vol_MinVal, "Vol. Min.", "VolMin", i_SP, "%.1f dB", "Vol. Min.: %.1f dB",   -80,   20,    0,  0.1, 0, pflg_WActive, 6);
    parDcl(p_Vol_MaxVal, "Vol. Max.", "VolMax", i_SP, "%.1f dB", "Vol. Max.: %.1f dB",   -80,   20,    0,  0.1, 0, pflg_WActive, 6);
    parDcl(p_Vol_Global, "Vol. Glob.", "VolGlob", i_SP, "%.1f dB", "Vol. Glob.: %.1f dB",   -80,   20,    0,  0.1, 0, pflg_WActive, 7);

    parDcl(p_Play_Max, "Max players", "MxPlayer", i_SP, "%d", "Max players: %d", 1, 40, 40, 1);

    // Unused
    parDcl(p_XPmode, "Modul. Algorith", "ModAlgo", i_SP, "%d", "Modul. Alg: %d", 0, 10, 0, 1, 0, pflg_WActive, -ModulAlgo);
    parDcl(p_XModDepth, "Modul. Depth", "ModDepth", i_SP, "%d", "Modul. Depth: %d", 1, 10, 0, 1, 0, pflg_WActive, -ModDepth);
    parDcl(p_XModWidth, "Modul. Width", "ModWidth", i_SP, "%d", "Modul. Width: %.3f", 0.001, 1000, 1, 0.001, 8, pflg_WActive, -ModWidth);
    parDcl(p_XModFreq, "Modul. Freq", "ModFreq", i_SP, "%d", "Modul. Freq: %.3f", 0.01, 100, 1, 0.001, 8, pflg_WActive, -ModFreq);
    parDcl(p_SenMinTime, "Sens.Min.Time", "SensMinT", i_SP, "%.1f s", "Sens Min T.: %.1f", 0.1, 30, 3, 0.1, 4, pflg_WActive, 8);


    parDcl(p_HP_Algo, "HP Algorithm", "HPAlgo", i_SP, "%d", "HP Algo: %d", 1, 4, 1, 1);

    parDcl(p_VirtualTime, "Virt. Time", "VirTime", i_SP, "%.3f s", "Virt.Time: %.3f", 0, 60, 0, 0.1, 0, pflg_SpecEdit, 0);
    parDcl(p_VirtTimSpeed, "Time.Speed",  "VSpeed",  i_SP,  "%0.3f",   "Time.Speed: %.3f",    -10,    10,  1,  0.001, 0);

    parDcl(p_ScriptPar1, "Script Parameter 1", "ScPar1", i_SP, "%d", "Script Parameter 1: %d", 0, 100, 0, 1);

    parDcl(p_Interpol, "Interpolation", "Interpol", 0, "%0.3f", "Interpolation %0.3f", -1, 1, 0, 0.001);


    // Dynamic Parameters
    parDcl(p_Dyn_Type, "Dyn.Typ.", "DynType", 0, "%06X", "Dyn.Typ.: %06X",  0, 0xFFF,  0,  1, 0);
    parDcl(p_Dyn_Flgs1, "FLM1", "FLM1", i_UB|i_SP, "%06X", "FLM1: %06X",  0, mSL_Dyn_Flg1_def,  mSL_Dyn_Flg1_def,  1, 0);
    parDcl(p_Dyn_Flgs2, "FLM2", "FLM2", i_UB|i_SP, "%06X", "FLM2: %06X",  0, mSL_Dyn_Flg2_def,  mSL_Dyn_Flg2_def,  1, 0);
    parDcl(p_Dyn_Vol, "Dyn.Vol.", "DynVol", i_UB|i_SP, "%.1f dB", "Dyn.Vol.: %.1f dB",  -80, 20,  0,  0.1, 0);
    parDcl(p_Dyn_GS, "Dyn.GSize",  "DGSize",  i_UB|i_SP,  "%0.5f",   "Dyn.GSize: %.5f",  0.00001, 100, 1, 0.00001, 10);
    parDcl(p_Dyn_Rate, "Dyn.Rate",  "DynRate",    i_UB|i_SP,  "%0.4f",   "Dyn.Rate: %.4f",    0.01,    10,  1,  0.0001, 5);
    parDcl(p_Transpose, "Transpose", "Trnspose", i_Vm|RCB_Transpose_u|i_UB|i_SP, "%d", "Transpose: %d", -24, 24, 0, 1, 0);
    parDcl(p_Dyn_Direct, "Direction",  "DynDir",  i_UB|i_SP,  "%0.1f",   "Direction: %.1f",  0, 100, 0, 0.1, 0);
    parDcl(p_Dyn_Slant, "Dyn.GSlant",  "DGSlan",  i_UB|i_SP,  "%.1f",   "Dyn.GSlant: %.1f",  0, 100, 50, 0.1, 0);
    parDcl(p_Dyn_GTWd, "Dyn.GTop",  "DGTop",  i_UB|i_SP,  "%0.1f",   "Dyn.GTop: %.1f",  0, 100, 50, 0.1, 2);
    parDcl(p_Dyn_GrFISh, "Gr.Fd.In.Shp",  "GrFdInSH",  i_UB|i_SP,  "%0.2f", "Gr.Fd.In.Shp: %.2f", -1, 1, 0, 0.01, 0);
    parDcl(p_Dyn_GrFOSh, "Gr.Fd.Out.Shp",  "GrFdOuSH",  i_UB|i_SP,  "%0.2f", "Gr.Fd.Out.Shp: %.2f", -1, 1, 0, 0.01, 0);
    parDcl(p_Dyn_PlPos, "Dyn.Position",  "DPos",  i_UB|i_SP,  "%0.2f",   "Dyn.Position: %.2f",  0, 100, 50, 0.01, 0);
    parDcl(p_Dyn_PlLat, "Dyn.Pos.var",  "DPVar",  i_UB|i_SP,  "%0.2f",   "Dyn.Pos.var: %.2f",  0, 100, 100, 0.01, 4);
    parDcl(p_Dyn_PlMass, "Dyn.Mass",  "DMass", i_UB|i_SP,  "%0.3f",   "Dyn.Mass.: %.3f",  0.01, 100, 1, 0.001, 6);
    parDcl(p_Dyn_Asynch, "Asynchronicity",  "DAsynch", i_UB|i_SP,  "%0.1f",   "Asynchronicity: %.1f",  0, 100, 0, 0.1, 2);
    parDcl(p_Harmonic_Shape, "Harmonic Shape",  "HarmShp", i_UB|i_SP,  "%0.2f",  "Harmonic Shape: %.0f",  0, 10, 0, 1, 0);
    parDcl(p_Inharmonicity, "Inharmonicity",  "Inharm", i_UB|i_SP,  "%0.2f",  "Inharmonicity: %.2f",  0, 100, 0, 0.01, 4);
    parDcl(p_Dyn_XPan, "Dyn.X-Pan",  "DynXPan", i_UB|i_SP,  "%0.3f",  "Dyn.X-Pan: %.3f",  0, 1, 0, 0.001, 0);


    parDcl(p_XtndFact, "Xtnd.Fact",  "XtndFact", i_UB|i_SP,  "%0.4f",   "Xtnd.Fact: %.4f",    0.0,    10,  1,  0.0001, 5);
    parDcl(p_OvlpSize,  "Ovlp.Size", "OvlpSize", i_UB|i_SP,  "%d ms",   "Ovlp.Size: %d ms",      1,   3000, 100,    1, 6);

    parDcl(p_XPar0, "Xtnd.Par 0",  "XtndP0", i_UB|i_SP,  "%0.3f",   "X.Par 0: %.3f",    0.0,    10000,  1,  0.001, 8);
    parDcl(p_XPar1, "Xtnd.Par 1",  "XtndP1", i_UB|i_SP,  "%0.3f",   "X.Par 1: %.3f",    0.0,    10000,  1,  0.001, 8);
    parDcl(p_XPar2, "Xtnd.Par 2",  "XtndP2", i_UB|i_SP,  "%0.3f",   "X.Par 2: %.3f",    0.0,    10000,  1,  0.001, 8);
    parDcl(p_XPar3, "Xtnd.Par 3",  "XtndP3", i_UB|i_SP,  "%0.3f",   "X.Par 3: %.3f",    0.0,    10000,  1,  0.001, 8);

    // Create a list of dynamic parameters in some significative order
    ix = 0; loop (paramDynSiz,
        gmem[dynParams+ix] = paramDyn[ix] = p_Dyn_First + ix;
        ix += 1;
    );
    gmem[paramDynAct] = paramDynCnt = p_Inharmonicity - p_Dyn_First + 1;

    paramDynNums[0] = p_Dyn_Vol;             paramDynIds[0] = "Volume";
    paramDynNums[1] = 0;                     paramDynIds[1] = "-";
    paramDynNums[2] = p_Dyn_Rate;            paramDynIds[2] = "Speed";
    paramDynNums[3] = p_Transpose;           paramDynIds[3] = "Transpose";
    paramDynNums[4] = p_Dyn_GS;              paramDynIds[4] = "Gr. Size";
    paramDynNums[5] = p_Dyn_Slant;           paramDynIds[5] = "Gr. Slant";
    paramDynNums[6] = 0;                     paramDynIds[6] = "Gr. Shape";
    paramDynNums[7] = p_Dyn_GTWd;            paramDynIds[7] = "Gr. Sustain";
    paramDynNums[8] = p_Dyn_PlPos;           paramDynIds[8] = "Position";
    paramDynNums[9] = p_Dyn_PlLat;           paramDynIds[9] = "Var. Position";
    paramDynNums[10] = p_Dyn_PlMass;         paramDynIds[10] = "Mass";
    paramDynNums[11] = p_Dyn_Asynch;         paramDynIds[11] = "Asynchronicity";
    paramDynNums[12] = p_Dyn_Direct;         paramDynIds[12] = "Direction";
    paramDynNums[13] = p_Inharmonicity;      paramDynIds[13] = "Inharmonicity";
    paramDynNums[14] = p_Harmonic_Shape;     paramDynIds[14] = "Harmonic Shape";
    paramDynNums[15] = p_Dyn_GrFISh;         paramDynIds[15] = "Fade In Shape";
    paramDynNums[16] = p_Dyn_GrFOSh;         paramDynIds[16] = "FadeOut Shape";
    paramDynNums[17] = p_Dyn_XPan;           paramDynIds[17] = "Dyn.X-Pan";
    paramDynNums[18] = 0;                    paramDynIds[18] = "-";
    paramDynNums[19] = 0;                    paramDynIds[19] = "Dyn. Init";
    paramDynNums[20] = 0;                    paramDynIds[20] = "-";
    paramDynNums[21] = 0;                    paramDynIds[21] = "-";
    paramDynNums[22] = 0;                    paramDynIds[22] = "-";
    paramDynNums[23] = 0;                    paramDynIds[23] = "-";
    paramDynNums[24] = 0;                    paramDynIds[24] = "-";
    paramDynNums[25] = 0;                    paramDynIds[25] = "-";
    paramDynNums[26] = 0;                    paramDynIds[26] = "-";
    paramDynNums[27] = 0;                    paramDynIds[27] = "-";
    paramDynNums[28] = 0;                    paramDynIds[28] = "-";
    paramDynNums[29] = 0;                    paramDynIds[29] = "-";
    paramDynNums[30] = 0;                    paramDynIds[30] = "-";
    paramDynNums[31] = 0;                    paramDynIds[31] = "-";

    ii = 0; loop(32,
        p = paramDynNums[ii]; // a param. number
        w = p - p_Dyn_Type;
        ((w >= 0) && (w < paramDynCnt)) ? (
            pb = paramBlock + p * paramEntSize;
            mi = pb[pp_Min];
            ma = pb[pp_Max];
            // Modify some of these values
            (p === p_Dyn_Vol) ? ( mi = -24; ma = 0;) :
            (p === p_Dyn_PlMass) ? ( mi = 0.2; ma = 5;) :
            (p === p_Dyn_Rate) ? ( mi = 0.1; ma = 2;) :
            (p === p_Transpose) ? ( mi = -12; ma = 12;) :
            (p === p_Dyn_GS) ? ( mi = 0.01; ma = 5;) ;
            paramDynBstMin[w] = mi;
            paramDynBstMax[w] = ma;
        );
        ii += 1;
    );

    ppb_VirtualTime = paramBlock + p_VirtualTime * paramEntSize;
    ppb_VirtTimSpeed = paramBlock + p_VirtTimSpeed * paramEntSize;
    ppb_maxGenerators = paramBlock + p_maxGenerators * paramEntSize;
    ppb_Gen_MinCnt = paramBlock + p_Gen_MinCnt * paramEntSize;
    ppb_Gen_MaxCnt = paramBlock + p_Gen_MaxCnt * paramEntSize;
    ppb_Interact = paramBlock + p_Interact * paramEntSize;

    // Create the Main Sliders display menu
    (menu_Param_mSL === 0) ? (
        paramMSLMenuNames[0] = " move up ";
        paramMSLMenuNames[1] = " move down ";
        paramMSLMenuNames[2] = " blank ";
        paramMSLMenuNames[3] = " remove ";
        paramMSLMenuNames[4] = " clear all ";
        paramMSLMenuNames[5] = " 1 column ";
        paramMSLMenuNames[6] = " 2 columns ";
        paramMSLMenuNames[7] = "";
        paramMSLMenuNums[0] = 0;
        paramMSLMenuNums[1] = 0;
        paramMSLMenuNums[2] = 0;
        paramMSLMenuNums[3] = 0;
        paramMSLMenuNums[4] = 0;
        paramMSLMenuNums[5] = 0;
        paramMSLMenuNums[6] = 0;
        paramMSLMenuNums[7] = 0;


        ix = 1; pdx = 8;
        loop(paramCount - 1,
            pp = paramBlock + ix * paramEntSize;
            ((pp[pp_Name] != 0) && (pp[pp_Type] & i_SP)) ? (
                paramMSLMenuNames[pdx] = pp[pp_Name];
                paramMSLMenuNums[pdx] = ix;
                pdx += 1;
            );
            ix += 1;
        );

        paramMSLMenuSize = pdx;
        mSL_Sort_Strings(pdx, 8, paramMSLMenuNames, paramMSLMenuNums, 0, 0);

        ui_jmenu_provided_block = GUI_Sliders_Menu_Block ;
        menu_Param_mSL = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "Sliders", pdx, paramMSLMenuNames);

    );


    // Create the sliders parameters menu
    (menu_Param_UBS === 0) ? (
        paramUBSLMenuNames[0] = "&/ move up ";
        paramUBSLMenuNames[1] = "&/ move down ";
        paramUBSLMenuNames[2] = "&/ blank ";
        paramUBSLMenuNames[3] = "&/ remove ";
        paramUBSLMenuNames[4] = "&/ clear all ";
        paramUBSLMenuNames[5] = "";
        pdx = 6;
        paramUBSLMenuNums[0] = 0;
        paramUBSLMenuNums[1] = 0;
        paramUBSLMenuNums[2] = 0;
        paramUBSLMenuNums[3] = 0;
        paramUBSLMenuNums[4] = 0;
        paramUBSLMenuNums[5] = 0;

        ix = 1;
        loop(paramCount - 1,
            pp = paramBlock + ix * paramEntSize;
            ((pp[pp_Name] != 0) && (pp[pp_Type] & i_UB)) ? (
                paramUBSLMenuNames[pdx] = pp[pp_Name];
                paramUBSLMenuNums[pdx] = ix;
                pdx += 1;
            );
            ix += 1;
        );

        paramUBSLMenuSize = pdx;


        mSL_Sort_Strings(pdx, 6, paramUBSLMenuNames, paramUBSLMenuNums, 0, 0);
        ui_jmenu_provided_block = GUI_Parameters_Menu_Block ;
        menu_Param_UBS = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "Parameters", pdx, paramUBSLMenuNames);
    );


    // Create the displayers parameters menu
    (menu_Param_UBD === 0) ? (
        paramUBDsMenuNames[0] = "&/ move up ";
        paramUBDsMenuNames[1] = "&/ move down ";
        paramUBDsMenuNames[2] = "&/ move left ";
        paramUBDsMenuNames[3] = "&/ move right ";
        paramUBDsMenuNames[4] = "&/ blank ";
        paramUBDsMenuNames[5] = "&/ remove ";
        paramUBDsMenuNames[6] = "&/ clear all ";
        paramUBDsMenuNames[7] = "";
        pdx = 8;
        paramUBDsMenuNums[1] = 0;
        paramUBDsMenuNums[2] = 0;
        paramUBDsMenuNums[3] = 0;
        paramUBDsMenuNums[4] = 0;
        paramUBDsMenuNums[5] = 0;
        paramUBDsMenuNums[6] = 0;
        paramUBDsMenuNums[7] = 0;

        ix = 1;
        loop(paramCount - 1,
            pp = paramBlock + ix * paramEntSize;
            ((pp[pp_Name] != 0) && (pp[pp_Type] & i_UB)) ? (
                paramUBDsMenuNames[pdx] = pp[pp_Name];
                paramUBDsMenuNums[pdx] = ix;
                pdx += 1;
            );
            ix += 1;
        );

        // Add all the RCB/gmem/special info we wish to display...
        paramUBDsMenuNames[pdx] = "Clip #" ;
        paramUBDsMenuNums[pdx] = 4 * 0x10000 + 1 * 0x1000 + RCB_ClipNb; pdx += 1;
        paramUBDsMenuNames[pdx] = "Last Kmd" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_cbCKmd; pdx += 1;
        paramUBDsMenuNames[pdx] = "Vol. bias" ;
        paramUBDsMenuNums[pdx] = 21 * 0x10000 + 1 * 0x1000 + RCB_VolBias; pdx += 1;
        paramUBDsMenuNames[pdx] = "HP Count" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Channels_cnt_used1; pdx += 1;
        paramUBDsMenuNames[pdx] = "HP Config1" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Channels_conf1; pdx += 1;
        paramUBDsMenuNames[pdx] = "HP Config2" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Channels_conf2; pdx += 1;
        paramUBDsMenuNames[pdx] = "Kmd Flags" ;
        paramUBDsMenuNums[pdx] = 7 * 0x10000 + 1 * 0x1000 + RCB_PBFlgs; pdx += 1;
        //paramUBDsMenuNames[pdx] = "HP Set 1" ;
        //paramUBDsMenuNums[pdx] = 25 * 0x10000 + 1 * 0x1000 + RCB_ChSet1_set; pdx += 1;
        //paramUBDsMenuNames[pdx] = "HP Set 2" ;
        //paramUBDsMenuNums[pdx] = 25 * 0x10000 + 1 * 0x1000 + RCB_ChSet2_set; pdx += 1;
        //paramUBDsMenuNames[pdx] = "HP Set 3" ;
        //paramUBDsMenuNums[pdx] = 25 * 0x10000 + 1 * 0x1000 + RCB_ChSet3_set; pdx += 1;
        //paramUBDsMenuNames[pdx] = "HP Set 4" ;
        //paramUBDsMenuNums[pdx] = 25 * 0x10000 + 1 * 0x1000 + RCB_ChSet4_set; pdx += 1;
        paramUBDsMenuNames[pdx] = "Clip flags" ;
        paramUBDsMenuNums[pdx] = 7 * 0x10000 + 1 * 0x1000 + RCB_PBFlgs; pdx += 1;
        paramUBDsMenuNames[pdx] = "Vol.min" ;
        paramUBDsMenuNums[pdx] = 19 * 0x10000 + 1 * 0x1000 + RCB_VolumeMin_dB; pdx += 1;
        paramUBDsMenuNames[pdx] = "Vol.max" ;
        paramUBDsMenuNums[pdx] = 19 * 0x10000 + 1 * 0x1000 + RCB_VolumeMax_dB; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed Adj." ;
        paramUBDsMenuNums[pdx] = 24 * 0x10000 + 1 * 0x1000 + RCB_CFrCorr_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Partiel" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_CPart_nbr; pdx += 1;
        paramUBDsMenuNames[pdx] = "Group" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_CGrp_nbr; pdx += 1;
        paramUBDsMenuNames[pdx] = "Bank" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_CBnk_nbr; pdx += 1;
        paramUBDsMenuNames[pdx] = "Play Mode" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_CPlMd_nbr; pdx += 1;
        paramUBDsMenuNames[pdx] = "Space Mode" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_CSpMd_nbr; pdx += 1;
        paramUBDsMenuNames[pdx] = "Error code" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Errc; pdx += 1;
        paramUBDsMenuNames[pdx] = "Mem. avail" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Mem_Avail; pdx += 1;
        paramUBDsMenuNames[pdx] = "Gmem use" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 3 * 0x1000 + gmemLastUsed; pdx += 1;
        paramUBDsMenuNames[pdx] = "Status" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 1; pdx += 1;
        paramUBDsMenuNames[pdx] = "State" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 2; pdx += 1;
        paramUBDsMenuNames[pdx] = "Remaining" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 3; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed min" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 4; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed max" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 5; pdx += 1;
        paramUBDsMenuNames[pdx] = "Play state" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 7; pdx += 1;
        paramUBDsMenuNames[pdx] = "Play position" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 8; pdx += 1;
        paramUBDsMenuNames[pdx] = "Beat position" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 4 * 0x1000 + 9; pdx += 1;
        paramUBDsMenuNames[pdx] = "Log entry" ;
        paramUBDsMenuNums[pdx] = 0 * 0x10000 + 1 * 0x1000 + RCB_Rec_Entry; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed 0" ;
        paramUBDsMenuNums[pdx] = 11 * 0x10000 + 1 * 0x1000 + RCB_SpeedAbs_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed 1" ;
        paramUBDsMenuNums[pdx] = 11 * 0x10000 + 1 * 0x1000 + RCB_SpeedMod1_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed 2" ;
        paramUBDsMenuNums[pdx] = 11 * 0x10000 + 1 * 0x1000 + RCB_SpeedMod2_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed 3" ;
        paramUBDsMenuNums[pdx] = 11 * 0x10000 + 1 * 0x1000 + RCB_Speed_Dir_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Speed 4" ;
        paramUBDsMenuNums[pdx] = 11 * 0x10000 + 1 * 0x1000 + RCB_CFrCorr_u; pdx += 1;
        paramUBDsMenuNames[pdx] = "Grain Size" ;
        paramUBDsMenuNums[pdx] = 14 * 0x10000 + 1 * 0x1000 + RCB_Gr_Size; pdx += 1;

        paramUBDsMenuSize = pdx;


        mSL_Sort_Strings(pdx, 8, paramUBDsMenuNames, paramUBDsMenuNums, 0, 0);
        ui_jmenu_provided_block = GUI_ParDisp_Menu_Block ;
        menu_Param_UBD = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "Parameters", pdx, paramUBDsMenuNames);
    );
);



// Reset  "dynamic" parameters to default values
function
DynParamsReset()
local (ii, p)
(
    ii = 0; loop(paramDynCnt,
        p = paramDyn[ii];
        parSet(p, parGetPP(p, pp_Def));
        ii += 1;
    );
);

// Save dynamic parameters in an array
function
DynParamsSave(pa)
local (ii, p)
(
    ii = 0; loop(paramDynCnt,
        p = paramDyn[ii];
        pa[ii] = paramValues[p];
        ii += 1;
    );
    pa[paramType] = 1; // saved from Dyn Parameters
);

// Save dynamic parameters defaults in an array
function
DynParamsDefault(pa)
local (ii, p)
(
    ii = 0; loop(paramDynCnt,
        p = paramDyn[ii];
        pa[ii] = parGetPP(p, pp_Def);
        ii += 1;
    );
    pa[paramType] = 1; // saved from Dyn Parameters
);


// Load dynamic parameters from an array
function
DynParamsLoad(pa)
local (ii, p)
(
    ii = 0; loop(paramDynCnt,
        p = paramDyn[ii];
        parSet(p, pa[ii]);
        ii += 1;
    );
);

function
DynParamsInterpol(id, pa1, pa2)
local (ii, p, v)
(
    (pa1 != 0) && (pa2 != 0) ? (
        ii = 3; while(ii < paramDynCnt) (
            v = (pa1[ii] * (1 - id) + pa2[ii] * (1 + id)) / 2;
            p = paramDyn[ii];
            parSet(p, v);
            ii += 1;
        );
    );
);

// randomize/modulate a parameter
function
ParamModulate(pp, alg, p1, p2)
local (pa, minv, maxv, defv, curv, w, k, v, slp, f, g)
(
    // pp is a parameter number
    pa = paramBlock + pp * paramEntSize;
    w = pp - p_Dyn_Type;
    defv = pa[pp_Def]; curv = paramValues[pp];
    slp = pa[pp_Slope];
    // Get "best" min and max values
    minv = paramDynBstMin[w]; maxv = paramDynBstMax[w];
    // Choose a new value at random
    k = p1 * (maxv - minv) / 100; // var. interval
    f = frand(); g = 1; // f <= 1
    (slp > 0) ? (f = pow(f, sqrt(slp)); g = 0.9;);
    v = curv + k * (2 * f - g);
    // Particular cases
    ((pp === p_Transpose) || (pp === p_Harmonic_Shape)) ? (v = floor(v + 0.5););
    v = max(minv, min(maxv, v)); // keep inside limits
    parSet(pp, v);
);


// Modulate all dyn. parameters
function
DynParamModulate(alg, p1, p2)
local (ii, p)
(
    ii = 3; while (ii <paramDynCnt) (
        p = paramDyn[ii]; // a parameter number
        (p != 0) ? ParamModulate(p, alg, p1, p2);
        ii += 1;
    );
);

// A specific func to associate colors to the random leds
function recolorRandLeds()
local (ii, jj)
(
    ii = 0; loop(8,
        jj = ii + p_rgenP1;
        ii += 1;
        paramStatus[jj] = (paramStatus[jj] & pStat_lA_ResetCol) | (ii << pStat_lA_Shftc);
    );
);

function activateRandLeds()
local (ii)
(
    ii = 9; loop(8,
        paramStatus[ii] = (paramStatus[ii] & pStat_lA_ResetBtn) | pStat_lA_btn;
        ii += 1;
    );
);

function cpPlLPRatio(plcnt, lpcnt)
local (r)
(
    (plcnt === lpcnt) ? (
        r = 0;
    ) :
    (plcnt > lpcnt) ? (
        r = 0| ((lpcnt/plcnt - 1) * 100);
    ) : (
        r = 0| ((1 - plcnt/lpcnt) * 100);
    );
    r;
);

initAllParameters();
dclAllParameters();
DynParamsSave(paramDynamic66);
DynParamsSave(paramDynCopy65);
DynParamsDefault(paramDynamic67);
DynParamsDefault(paramDynDefault68);
currcell = 65; currpad = paramDynCopy65;

recolorRandLeds();
activateRandLeds();


parSet(p_VirtTimSpeed, playModeSpeed);


//AGMW160 = GMW();

//====== GC ======
mSL_Dyn_LogSiz = 128;
mSL_Dyn_Log = make_array(mSL_Dyn_LogSiz);
mSL_Dyn_fLogSiz = 128;
mSL_Dyn_fLog = make_array(mSL_Dyn_LogSiz);
// Memory management Arrays
gc_run_phaz = 0;
gc_run_count = 0;
mm_rem_in = 0;
mm_rem_siz = 128;
gc_MMA = mm_rem_mm = make_array(mm_rem_siz); // A list of remanent/protected objects
mm_usr_prot_siz = 64;
mm_usr_prot_ptr = 0;
mm_usr_prot = make_array(mm_usr_prot_siz); // A list of USR defined protected objets
mm_usr_prot[mm_usr_prot_ptr] = blockUsrDesc; mm_usr_prot_ptr += 1; // enter modules descriptions
mm_list_in = 0;
mm_list_pt = 0;
mm_list_cnt = 0;
mm_list_mxc = 0;
mm_list_siz = 49957;
mm_list_mm = make_array(mm_list_siz); // temporary circular list of encountered object
mm_hash_siz = 104729;
mm_hash_mm = make_array(mm_hash_siz); // temporary hashcode table for already encountered objects
mm_tmp_siz = 8;
mm_tmp_in = 0;
mm_tmp_mm = make_array(mm_tmp_siz); // temporary array of blocs to free
mm_xec_ptr = 0;
mm_xec_cnt = 0;
mm_xec_max = 0;
mm_xec_siz = 180;
mm_xec_mm = make_array(mm_xec_siz); // temporary array
mm_cyc_ptr = 0;
mm_cyc_max=0;
mm_cyc_maxU = 0;
mm_cyc_siz = 2048;
mm_cyc_mm = make_array(mm_cyc_siz); // temporary array
mm_dur_mm = make_array(mm_cyc_siz); // temporary array
mm_dur_max = 0;
mm_lowmem = 0; // low and
mm_highmem = 0; // high memory address of the memory allocated blocks
mm_Knew = -2;
mm_show_frbl = 1;
mm_show_usbl = 0;
mm_show_flr = 0;
mm_show_dmg = 0;
mm_show_ttf = 0;
mm_show_ttu = 0;
mSL_gc_start = 0;
mSL_gc_end = 0;
mSL_gc_MaxDur = 0;

mm_bl_huge = 1;
mm_bl_big = 0;
mm_bl_large = 0;
mm_bl_medium = 0;
mm_bl_mini = 0;



<? include("GM-Libs/mSL_DeAsm.jsfx-inc"); ?>



mSL_baseAVSize = 822;
mSL_baseOVSize = 256;
mSL_basePVSize = 128;

// Start here for blocks that will be examined by the garbage collector
//——————————————————————————————————-
//
//


Simple_temp = make_array(10);



mm_lowblocks = make_array(2); // creates a gap of 2 zeroes.
mSL_GC_Protected = make_array(1123, mSL_KODE_protect);

// Create the scheduler structure
SchedSetup();
0 ? (sprintf(#uuu, "    ---> SchedSetup :   %d tasks", SchedListSize(SchedFreePts));mSL_log(SysLogBox, #uuu););

PlayLogSetUp();
//plBlInitChain();  // initialize play log memory
0 ? (sprintf(#uuu, "    ---> PlayLogSetUp : %d  %d  -  %d   %d", SchedListSize(PlLogFree), SchedListSize(PlLogMain), SchBlcksEnd-SchBlcksStart, 8388608 - gMemFree);
        mSL_log(SysLogBox, #uuu););

PlRecCurrent = PlLogCurrent = PlLogMain;
// Sizes of Allocated arrays for the Compiler and the Evaluator
C_compSize = 32 * 1024; // size : 64 kW [kilo words, not kilo watts]
C_progSize = 32 * 1024; // size  for the evaluator
ui_jmake_arraymax = 0x7FFFFFF; // "no" limit in the size of an array...

// Then, initialize all structures of the compiler.
C_compArea = make_array(C_compSize);
C_progArea = make_array(C_progSize);

mm_limit_a = make_array(2);
mm_limit_a[0] = 'STRT'; mm_limit_a[1] = 'MEMR';

// Memory size :
C_memrSize = 28 * 1024 * 1024; // size : X x 1MW - was 14
C_memrArea = make_array(C_memrSize); // THE MEMORY !

mm_limit_b = make_array(2);
mm_limit_b[0] = 'END_'; mm_limit_b[1] = 'MEMR';

//AGMW165 = GMW();;

// Build the memory
mSL_current_memory = mSL_new_memory = 0; // make sure it is clear
AAAAC_5 = mSL_make_memory(C_memrArea, C_memrSize);

memoryBox1[7] = memoryBox2[7] = AAAAC_5 - 2; // actual start
mm_lowmem = mSL_new_memory + mSL_new_memory[mSL_MM_LowAd];
mm_highmem = mSL_new_memory + mSL_new_memory[mSL_MM_HighAd];
// mm_sizmem = max(1, mm_highmem - mm_lowmem);
mm_show_ttf = mm_sizmem = mSL_new_memory[mSL_MM_MemSiz];//
//AGMW166 = GMW();

// Try to provide an independent main symbol table for the compiler - "var" declarations
aprime = 3313;
size = 4 * (aprime + 1);
mem = make_array(size + 4);
A_mSL_GCTab = mSL_buildGVTab(mem, size, aprime);

// Try to provide an independent local symbol table for the compiler - "loc" declarations
aprime = 191;
size = 4 * (aprime + 1);
mem = make_array(size + 4);
A_mSL_LCTab = mSL_buildLCTab(mem, size, aprime);
// Build the compiler
AAAAC_6 = mSL_make_compiler(C_compArea, C_compSize);
// Then, the interpreter
AAAAC_7 = mSL_make_evaluator(C_progArea, C_progSize);
mSL_new_thread = 0;

// define our new extensions
mSL_define_extensions();
// share some values,
// mSL_define_global("extarray", tab); // define an array
// mSL_define_pointer("extpoint", tab+2); // and a pointer
// ... and enter some constants:::::::::::::::::::::::::::::ghvm
mSL_define_constant("version", 1.0107);
mSL_define_constant("system", 10.1106);
mSL_define_constant("machine", mSL_KW_iMac);
mSL_define_global("MIDIlast", MIDIlastcmd); // last MIDI command
mSL_define_global("SYSFlgs", FlagsTbVals); // last MIDI command

mm_limit_g = make_array(2);
mm_limit_g[0] = 'END_'; mm_limit_g[1] = 'COMP';

mm_highblocks = make_array(2); // no block with memory references beyond that





// The threads operations
<? include("GM-Libs/mSL_Threads.jsfx-inc"); ?>


// The Garbage Collector
<? include("GM-Libs/mSL_Garbage_Collector.jsfx-inc"); ?>


// mSL_define_global("GM_Pad", padStPVals); // define an array

mSL_log(SysLogBox, "");
mSL_log(SysLogBox, #GMversion);
mSL_log(SysLogBox, #started);


(RCB_ActualSize > UCBSize) ? (
    err_sys_ini = 9991;
);

(RCB_ActiveSize > RCB_Saved_Size) ? (
    err_sys_ini = 9992;
);

AAAAAAAA_Pad_0 = padStPVals[0];

scripts_siz = 512;
scripts_tab = make_array(scripts_siz);
scripts_cnt = 0;
menu_Scripts = 0;

configs_siz = 256;
configs_tab = make_array(configs_siz);
configs_cnt = 0;
menu_Config = 0;

// Read the file that contains the names of mSL scripts -- call only once !
function get_mSL_scripts()
local (fhd, w)
(
    // menu_Scripts = 0;
    scripts_cnt = 0;
    fhd = GM_file_open(#D_GM_mSL_set, 0);
    // mSL_log(SysLogBox, #tmpFname);
    (fhd >= 0) ? (
        // mSL_log(SysLogBox, "File opened!");
        while (file_avail(fhd)) (
            file_string(fhd,#s);
            ((strlen(#s) > 0) && (scripts_cnt < scripts_siz)) ? (
                w = mSL_Str_Perm();
                strncpy(w, #s, strlen(#s)-1);
                // mSL_log(SysLogBox, w); // just a trace
                scripts_tab [scripts_cnt] = w;
                scripts_cnt += 1;
            );
        );
        file_close(fhd);
    );
    (scripts_cnt > 0) ? (
        // mSL_log(SysLogBox, "Building scripts menu.");
        (menu_Scripts === 0) ? (
            menu_Scripts = make_jmenu(
                ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
                "scripts", scripts_cnt, scripts_tab);
            // mSL_log(SysLogBox, "");
        );
    );
);


// Read the file that contains the names of text configurations -- call only once !
function get_txt_configs()
local (fhd, ss, w)
(
    configs_cnt = 0;
    // menu_Config = 0;
    fhd = GM_file_open(#D_GM_txt_set, 0);
    // mSL_log(SysLogBox, #tmpFname);
    (fhd >= 0) ? (
        // mSL_log(SysLogBox, "File opened!");
        while (file_avail(fhd)) (
            file_string(fhd,#s);
            ((strlen(#s) > 0) && (configs_cnt < configs_siz)) ? (
                ss = strlen(#s)-1;
                // we don't want some names in this list
                (strncmp(#s, #Def_GM_mSL_set, ss) && strncmp(#s, #Def_GM_txt_set, ss)) ? (
                    w = mSL_Str_Perm();
                    strncpy(w, #s, ss);
                    // mSL_log(SysLogBox, w);
                    configs_tab [configs_cnt] = w;
                    configs_cnt += 1;
                );
            );
        );
        file_close(fhd);
    );
    (configs_cnt > 0) ? (
        // mSL_log(SysLogBox, "Building configuration menu.");
        (menu_Config === 0) ? (
            menu_Config = make_jmenu(
                ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
                "configs", configs_cnt, configs_tab);
            // mSL_log(SysLogBox, "");
        );
    );
);


UClipPrime = gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];



/*
    Change the clips directory
*/
function setClDirectory(newDir, newFmt)
local (ii)
(
    (newDir != 0) ? strcpy(#D_clDirectory, newDir);
    (newFmt != 0) ? strcpy(#D_clEdFormat, newFmt);
    strcpy(#D_clNameFormat, #D_clDirectory);
    strcat(#D_clNameFormat, "/");
    strcat(#D_clNameFormat, #D_clEdFormat);
    // Send the new format to the filereaders
    setexpldstr(#D_clNameFormat, 0, 0);
    ii = 0;
    loop(clTSize,
        gmem[clInfStart + ii] = 0;
        gmem[clClSizes + ii] = 0;
        gmem[clClInfos + ii] = 0;
        gmem[clClVolumes + ii] = clVolumeBias;
        gmem[clClDurations + ii] = 0;
        ii += 1;
    );
    // Reset all ClipSets
    resetClipSet(-1);
    // Recheck all clips
    ClCheckFlag = 1;
    ClCheckForce = 1;
    ClCheckCnt = 0;
    ClCheckView = 1; cBk4 = 0;
    // Notify the file readers
    gmem[dirChange] += 1;
    // sprintf(#s, "Clip Dir: %s", #D_clDirectory);
    // mSL_log(SysLogBox, #s);
    //
    sprintf(#s, "Cl.Dir: %s (%d)", #D_clNameFormat, strlen(#D_clNameFormat));
    //
    mSL_log(SysLogBox, #s);
);



/*
    Try to understand the why(s) of an error in mSL
*/
function mSL_error_analysis(thrd)
(
    sprintf(#uuu, " _ Thread: %d", thrd);
    mSL_log(SysLogBox, #uuu);
    sprintf(#uuu, " _ Mem avail: %d", mSL_available_memory());
    mSL_log(SysLogBox, #uuu);
);


// ============ Memory Debug ============
// The debug menu ActionTbSiz
idx = 0;
DebugTbTyps[idx] = 0; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Memory"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = mSL_current_memory-2; DebugTbDecs[idx] = mSL_current_memory; DebugTbNames[idx] = "Mem. mSL"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = serialBlock; DebugTbDecs[idx] = serialBlock; DebugTbNames[idx] = "Presets"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = paramBlock; DebugTbDecs[idx] = paramBlock; DebugTbNames[idx] = "Params"; idx += 1;
DebugTbTyps[idx] = 2; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Gmem"; idx += 1;

DebugTbTyps[idx] = 2; DebugTbAdds[idx] = HP_usage; DebugTbDecs[idx] = HP_usage; DebugTbNames[idx] = "HP usage"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = AAAAC_thrdArea; DebugTbDecs[idx] = AAAAC_thrdArea; DebugTbNames[idx] = "Threads"; idx += 1;
DebugTbTyps[idx] = 0x101; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "C.thread"; idx += 1;
DebugTbTyps[idx] = 0x101; DebugTbAdds[idx] = 1; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Tree.gen"; idx += 1;
DebugTbTyps[idx] = 0x10D; DebugTbAdds[idx] = 2; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Blocks.gen"; idx += 1;
DebugTbTyps[idx] = 0xF; DebugTbAdds[idx] = 0x300; DebugTbDecs[idx] = 0x300; DebugTbNames[idx] = "Ugens"; idx += 1;
DebugTbTyps[idx] = 0xF; DebugTbAdds[idx] = clInfStart; DebugTbDecs[idx] = clInfStart; DebugTbNames[idx] = "Clp status"; idx += 1;
DebugTbTyps[idx] = 0xF; DebugTbAdds[idx] = clClVolumes; DebugTbDecs[idx] = clClVolumes; DebugTbNames[idx] = "Clp vol/flgs"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = BKTab; DebugTbDecs[idx] = BKTab; DebugTbNames[idx] = "Banks"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = SchedArea; DebugTbDecs[idx] = SchedArea; DebugTbNames[idx] = "Sched ents"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = HPATab; DebugTbDecs[idx] = HPATab; DebugTbNames[idx] = "HP Sets"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = HPPTab; DebugTbDecs[idx] = HPPTab; DebugTbNames[idx] = "HP Ptrs"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = SMTab; DebugTbDecs[idx] = SMTab; DebugTbNames[idx] = "Space Modes"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = PMTab; DebugTbDecs[idx] = PMTab; DebugTbNames[idx] = "Play Modes"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = MIDISeqncs; DebugTbDecs[idx] = MIDISeqncs; DebugTbNames[idx] = "Sensors"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Tab; DebugTbDecs[idx] = Mac_WA_Tab; DebugTbNames[idx] = "Macros"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Temp; DebugTbDecs[idx] = Mac_WA_Temp; DebugTbNames[idx] = "M.Expensions"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Errs; DebugTbDecs[idx] = Mac_WA_Errs; DebugTbNames[idx] = "Errors"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Tcrs; DebugTbDecs[idx] = Mac_WA_Tcrs; DebugTbNames[idx] = "Play info"; idx += 1;
DebugTbTyps[idx] = 2; DebugTbAdds[idx] = plHDStrt; DebugTbDecs[idx] = plHDStrt; DebugTbNames[idx] = "Play store"; idx += 1;
DebugTbTyps[idx] = 2; DebugTbAdds[idx] = playLogStrt; DebugTbDecs[idx] = playLogStrt; DebugTbNames[idx] = "Play entries"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = playTimes; DebugTbDecs[idx] = playTimes; DebugTbNames[idx] = "Play line"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = SlidersBlockA; DebugTbDecs[idx] = SlidersBlockA; DebugTbNames[idx] = "P.Blocks"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = clipsWorkArea; DebugTbDecs[idx] = clipsWorkArea; DebugTbNames[idx] = "Clips WA"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = ClSetTab; DebugTbDecs[idx] = ClSetTab; DebugTbNames[idx] = "ClipSets"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = psKPlaying; DebugTbDecs[idx] = psKPlaying; DebugTbNames[idx] = "Active Players"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = clTabE; DebugTbDecs[idx] = clTabE; DebugTbNames[idx] = "Log Padd"; idx += 1;
DebugCount = idx;

mSL_Sort_Strings(DebugCount, 0, DebugTbNames, DebugTbTyps, DebugTbAdds, DebugTbDecs);

menu_Debug = make_jmenu(
    ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "debug", DebugCount, DebugTbNames);

debugDSize = 128;
memoryBox1[12] = make_array(debugDSize);
memoryBox2[12] = make_array(debugDSize);
// Preselect "Memory"
// Look for the "Memory" entry.
dbg_curr_sel = -1;
ii = 0; while ((dbg_curr_sel < 0) && (ii < DebugCount)) (
(DebugTbNames[ii] == "Memory") ? dbg_curr_sel = ii;
ii += 1;
);
memoryBox1[6] = memoryBox2[6] = dbg_curr_sel;
memoryBox1[8] = memoryBox2[8] = 0;
memoryBox1[9] = memoryBox2[9] = 0;
memoryBox1[10] = memoryBox2[10] = 0;
memoryBox1[11] = memoryBox2[11] = 0;
memoryBox1[13] = memoryBox2[13] = 0;
memoryBox1[14] = memoryBox2[14] = 0;



//AGMW180 = GMW();
//============== Record/Replay Operations ===============

rmodeAutoMd = 0;

function setRModeStop()
(
    (recordMode != recModeOff) ? (
        recordMode = recModeOff;
        recOptLockSnds ? SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all
        parSet(p_GvAutoMd, 0); // and stop playing
    );
);
// switch to "record mode"
function setRModeRec()
(
    (recordMode != recModeOn) ? (
        recordMode = recModeOn;
        parSet(p_GvAutoMd, rmodeAutoMd); // and restart playing if necessary
    );
    recOptLockSnds ? SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all
);

// switch to "pause" mode
function setRModePause()
(
    (recordMode != recModePause) ? (
        recordMode = recModePause;
        recOptLockSnds ? SchedAddTask(5, 1|ActFlg1, 1, -1, 0, 0, 0); // Lock & unmute all
        rmodeAutoMd = paramValues[p_GvAutoMd];
        parSet(p_GvAutoMd, 0); // and stop playing
    );
);

function setPModeStop()
(
    (replayMode != replayModeOff) ? (
        replayMode = replayModeOff;
    );
);
function setPModePlay()
(
    ((replayEntry === 0) || (replayEntry[SchevEvntName] !== plIDNT)) ?  replayJumpTo(0, pPlayTimeCurrent, playModeSpeed);
    (replayMode != replayModeOn) ? (
        replayMode = replayModeOn;
    );
);

function setPModePause()
(
    (replayMode != replayModePause) ? (
        replayMode = replayModePause;
    );
);


function setPModeNow()
(
    ((replayMode === replayModeOn) || (replayMode === replayModePause)) ? (
        pPlayTimeCurrent = parV(p_VirtualTime);
    );
);

function setPModeStop()
(
    (replayMode != replayModeOff) ? (
        replayMode = replayModeOff;
    );
);

function setRModeSwitch()
(
    (recordMode === recModeOn) ? (
        setRModePause();
    ) : (
        setRModeRec();
    );
);


function setPModeSwitch()
(
    (replayMode === replayModeOn) ? (
        setPModePause();
    ) : (
        setPModePlay();
    );
);

function playRewind()
(
    // rewind
    //(playModeSpeed >= 0) ? (  pPlayTimeCurrent = 0; ) : ( pPlayTimeCurrent = playTimeMax;) ;
    pPlayTimeCurrent = 0;
    !playRepeatMd ? (
        // pause
        replayMode = replayModePause;
    );
    gmem[playLogRef] = playTime2Next = 0;
    gmem[playLogDate] = parSet(p_VirtualTime, pPlayTimeCurrent);
    playReeval = 1;
);

//============== mSL Run Time ===============

/*
    Global data of "Set Table"
    —————————————
    For sensors:
        MIDISeqncs : the array to keep the information
        MIDISeqPtr : the "allocation" pointer in this array
        MIDISeqSiz : the size of the array

    Used Keywords
        mSL_KW_Table mSL_KW_Clear mSL_KW_End mSL_KW_Sensors
        mSL_KW_MMode mSL_KW_DefSeq mSL_KW_DoKmd mSL_KW_Enter mSL_KW_SDur
    Vars :
*/
        ST_mmd = 0; // current MIDI mode
    // =============


// FlagsTbVals[Flgs_Set_Pr] = 0;

/*


*/
// Implementation of the mSL "table" operation
function
Set_Table(tbl)
local (st, itc, ptr, lptr, cwd, cwdMin, err, cid, hct, pt1st, xmct, flgs, stback, rd_err, pt, zpt, totsize, tout, pttr,
    Cl_n, Cl_dB, ii, s1, s2, s3, s4, s5, ty, n, ps, cp, cnt, kct, vmin, vmax, pos, stnext, kmax, cvl, LWA, LWAsiz,
    AddT)
(
    cvl = ptr = 0;
    LWA = 0; LWAsiz = 32000; // a large work area
    itc = tbl[-1]; // item count
    xmct = 2 * itc; // max loop count
    st = 1; // start from state 1
    STBerr = 0000;
    rd_err = 0;
    flgs = FlagsTbVals[Flgs_Set_Pr]; // trace flags


    while ((ptr < itc) && (rd_err === 0) && (xmct > 0)) (
        xmct -= 1;
	    cwd = tbl[lptr = ptr]; // current word
        (flgs & 4) ? (
            // print the status
            sprintf(#s, "State %d - %d/%d - Input: %s", st, ptr, itc, mSL_edit_value(#u, cwd));
            mSL_log(SysLogBox, #s);
        );
        (cwd === mSL_KW_EofMark) ? (
            // this stops all works
            cwd = mSL_KW_End; // change this to a simple "End";
            (st <= 1) ? (ptr = itc);
            ptr -= 1; // <eof> or again "EofMark";
        );

        (st&0x80)?((st&0x40)?((st&0x20)?((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-255-+=//
            STBerr = 0255;
            //—-255-+=//

        ):(

            //—-254-+=//
            STBerr = 0254;
            //—-254-+=//

        );):((st&0x1)?(

            //—-253-+=//
            STBerr = 0253;
            //—-253-+=//

        ):(

            //—-252-+=//
            STBerr = 0252;
            //—-252-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-251-+=//
            STBerr = 0251;
            //—-251-+=//

        ):(

            //—-250-+=//
            STBerr = 0250;
            //—-250-+=//

        );):((st&0x1)?(

            //—-249-+=//
            STBerr = 0249;
            //—-249-+=//

        ):(

            //—-248-+=//
            STBerr = 0248;
            //—-248-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-247-+=//
            STBerr = 0247;
            //—-247-+=//

        ):(

            //—-246-+=//
            STBerr = 0246;
            //—-246-+=//

        );):((st&0x1)?(

            //—-245-+=//
            STBerr = 0245;
            //—-245-+=//

        ):(

            //—-244-+=//
            STBerr = 0244;
            //—-244-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-243-+=//
            STBerr = 0243;
            //—-243-+=//

        ):(

            //—-242-+=//
            STBerr = 0242;
            //—-242-+=//

        );):((st&0x1)?(

            //—-241-+=//
            STBerr = 0241;
            //—-241-+=//

        ):(

            //—-240-+=//
            STBerr = 0240;
            //—-240-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-239-+=//
            STBerr = 0239;
            //—-239-+=//

        ):(

            //—-238-+=//
            STBerr = 0238;
            //—-238-+=//

        );):((st&0x1)?(

            //—-237-+=//
            STBerr = 0237;
            //—-237-+=//

        ):(

            //—-236-+=//
            STBerr = 0236;
            //—-236-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-235-+=//
            STBerr = 0235;
            //—-235-+=//

        ):(

            //—-234-+=//
            STBerr = 0234;
            //—-234-+=//

        );):((st&0x1)?(

            //—-233-+=//
            STBerr = 0233;
            //—-233-+=//

        ):(

            //—-232-+=//
            STBerr = 0232;
            //—-232-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-231-+=//
            STBerr = 0231;
            //—-231-+=//

        ):(

            //—-230-+=//
            STBerr = 0230;
            //—-230-+=//

        );):((st&0x1)?(

            //—-229-+=//
            STBerr = 0229;
            //—-229-+=//

        ):(

            //—-228-+=//
            STBerr = 0228;
            //—-228-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-227-+=//
            STBerr = 0227;
            //—-227-+=//

        ):(

            //—-226-+=//
            STBerr = 0226;
            //—-226-+=//

        );):((st&0x1)?(

            //—-225-+=//
            STBerr = 0225;
            //—-225-+=//

        ):(

            //—-224-+=//
            STBerr = 0224;
            //—-224-+=//

        );););););):((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-223-+=//
            STBerr = 0223;
            //—-223-+=//

        ):(

            //—-222-+=//
            STBerr = 0222;
            //—-222-+=//

        );):((st&0x1)?(

            //—-221-+=//
            STBerr = 0221;
            //—-221-+=//

        ):(

            //—-220-+=//
            STBerr = 0220;
            //—-220-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-219-+=//
            STBerr = 0219;
            //—-219-+=//

        ):(

            //—-218-+=//
            STBerr = 0218;
            //—-218-+=//

        );):((st&0x1)?(

            //—-217-+=//
            STBerr = 0217;
            //—-217-+=//

        ):(

            //—-216-+=//
            STBerr = 0216;
            //—-216-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-215-+=//
            STBerr = 0215;
            //—-215-+=//

        ):(

            //—-214-+=//
            STBerr = 0214;
            //—-214-+=//

        );):((st&0x1)?(

            //—-213-+=//
            STBerr = 0213;
            //—-213-+=//

        ):(

            //—-212-+=//
            STBerr = 0212;
            //—-212-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-211-+=//
            STBerr = 0211;
            //—-211-+=//

        ):(

            //—-210-+=//
            STBerr = 0210;
            //—-210-+=//

        );):((st&0x1)?(

            //—-209-+=//
            STBerr = 0209;
            //—-209-+=//

        ):(

            //—-208-+=//
            STBerr = 0208;
            //—-208-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-207-+=//
            STBerr = 0207;
            //—-207-+=//

        ):(

            //—-206-+=//
            STBerr = 0206;
            //—-206-+=//

        );):((st&0x1)?(

            //—-205-+=//
            STBerr = 0205;
            //—-205-+=//

        ):(

            //—-204-+=//
            STBerr = 0204;
            //—-204-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-203-+=//
            STBerr = 0203;
            //—-203-+=//

        ):(

            //—-202-+=//
            STBerr = 0202;
            //—-202-+=//

        );):((st&0x1)?(

            //—-201-+=//
            STBerr = 0201;
            //—-201-+=//

        ):(

            //—-200-+=//
            STBerr = 0200;
            //—-200-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-199-+=//
            STBerr = 0199;
            //—-199-+=//

        ):(

            //—-198-+=//
            STBerr = 0198;
            //—-198-+=//

        );):((st&0x1)?(

            //—-197-+=//
            STBerr = 0197;
            //—-197-+=//

        ):(

            //—-196-+=//
            STBerr = 0196;
            //—-196-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-195-+=//
            STBerr = 0195;
            //—-195-+=//

        ):(

            //—-194-+=//
            STBerr = 0194;
            //—-194-+=//

        );):((st&0x1)?(

            //—-193-+=//
            STBerr = 0193;
            //—-193-+=//

        ):(

            //—-192-+=//
            STBerr = 0192;
            //—-192-+=//

        ););););););):((st&0x20)?((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-191-+=//
            STBerr = 0191;
            //—-191-+=//

        ):(

            //—-190-+=//
            STBerr = 0190;
            //—-190-+=//

        );):((st&0x1)?(

            //—-189-+=//
            STBerr = 0189;
            //—-189-+=//

        ):(

            //—-188-+=//
            STBerr = 0188;
            //—-188-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-187-+=//
            STBerr = 0187;
            //—-187-+=//

        ):(

            //—-186-+=//
            STBerr = 0186;
            //—-186-+=//

        );):((st&0x1)?(

            //—-185-+=//
            STBerr = 0185;
            //—-185-+=//

        ):(

            //—-184-+=//
            STBerr = 0184;
            //—-184-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-183-+=//
            STBerr = 0183;
            //—-183-+=//

        ):(

            //—-182-+=//
            STBerr = 0182;
            //—-182-+=//

        );):((st&0x1)?(

            //—-181-+=//
            STBerr = 0181;
            //—-181-+=//

        ):(

            //—-180-+=//
            STBerr = 0180;
            //—-180-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-179-+=//
            STBerr = 0179;
            //—-179-+=//

        ):(

            //—-178-+=//
            STBerr = 0178;
            //—-178-+=//

        );):((st&0x1)?(

            //—-177-+=//
            STBerr = 0177;
            //—-177-+=//

        ):(

            //—-176-+=//
            STBerr = 0176;
            //—-176-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-175-+=//
            STBerr = 0175;
            //—-175-+=//

        ):(

            //—-174-+=//
            STBerr = 0174;
            //—-174-+=//

        );):((st&0x1)?(

            //—-173-+=//
            STBerr = 0173;
            //—-173-+=//

        ):(

            //—-172-+=//
            STBerr = 0172;
            //—-172-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-171-+=//
            STBerr = 0171;
            //—-171-+=//

        ):(

            //—-170-+=//
            STBerr = 0170;
            //—-170-+=//

        );):((st&0x1)?(

            //—-169-+=//
            STBerr = 0169;
            //—-169-+=//

        ):(

            //—-168-+=//
            STBerr = 0168;
            //—-168-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-167-+=//
            STBerr = 0167;
            //—-167-+=//

        ):(

            //—-166-+=//
            STBerr = 0166;
            //—-166-+=//

        );):((st&0x1)?(

            //—-165-+=//
            STBerr = 0165;
            //—-165-+=//

        ):(

            //—-164-+=//
            STBerr = 0164;
            //—-164-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-163-+=//
            STBerr = 0163;
            //—-163-+=//

        ):(

            //—-162-+=//
            STBerr = 0162;
            //—-162-+=//

        );):((st&0x1)?(

            //—-161-+=//
            STBerr = 0161;
            //—-161-+=//

        ):(

            //—-160-+=//
            STBerr = 0160;
            //—-160-+=//

        );););););):((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-159-+=//
            STBerr = 0159;
            //—-159-+=//

        ):(

            //—-158-+=//
            STBerr = 0158;
            //—-158-+=//

        );):((st&0x1)?(

            //—-157-+=//
            STBerr = 0157;
            //—-157-+=//

        ):(

            //—-156-+=//
            STBerr = 0156;
            //—-156-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-155-+=//
            STBerr = 0155;
            //—-155-+=//

        ):(

            //—-154-+=//
            STBerr = 0154;
            //—-154-+=//

        );):((st&0x1)?(

            //—-153-+=//
            STBerr = 0153;
            //—-153-+=//

        ):(

            //—-152-+=//
            STBerr = 0152;
            //—-152-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-151-+=//
            STBerr = 0151;
            //—-151-+=//

        ):(

            //—-150-+=//
            STBerr = 0150;
            //—-150-+=//

        );):((st&0x1)?(

            //—-149-+=//
            STBerr = 0149;
            //—-149-+=//

        ):(

            //—-148-+=//
            STBerr = 0148;
            //—-148-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-147-+=//
            STBerr = 0147;
            //—-147-+=//

        ):(

            //—-146-+=//
            STBerr = 0146;
            //—-146-+=//

        );):((st&0x1)?(

            //—-145-+=//
            STBerr = 0145;
            //—-145-+=//

        ):(

            //—-144-+=//
            STBerr = 0144;
            //—-144-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-143-+=//
            STBerr = 0143;
            //—-143-+=//

        ):(

            //—-142-+=//
            STBerr = 0142;
            //—-142-+=//

        );):((st&0x1)?(

            //—-141-+=//
            STBerr = 0141;
            //—-141-+=//

        ):(

            //—-140-+=//
            STBerr = 0140;
            //—-140-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-139-+=//
            STBerr = 0139;
            //—-139-+=//

        ):(

            //—-138-+=//
            STBerr = 0138;
            //—-138-+=//

        );):((st&0x1)?(

            //—-137-+=//
            STBerr = 0137;
            //—-137-+=//

        ):(

            //—-136-+=//
            STBerr = 0136;
            //—-136-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-135-+=//
            STBerr = 0135;
            //—-135-+=//

        ):(

            //—-134-+=//
            STBerr = 0134;
            //—-134-+=//

        );):((st&0x1)?(

            //—-133-+=//
            STBerr = 0133;
            //—-133-+=//

        ):(

            //—-132-+=//
            STBerr = 0132;
            //—-132-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-131-+=//
            STBerr = 0131;
            //—-131-+=//

        ):(

            //—-130-+=//
            STBerr = 0130;
            //—-130-+=//

        );):((st&0x1)?(

            //—-129-+=//
            STBerr = 0129;
            //—-129-+=//

        ):(

            //—-128-+=//
            STBerr = 0128;
            //—-128-+=//

        );););););););):((st&0x40)?((st&0x20)?((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-127-+=//
            STBerr = 0127;
            //—-127-+=//

        ):(

            //—-126-+=//
            STBerr = 0126;
            //—-126-+=//

        );):((st&0x1)?(

            //—-125-+=//
            STBerr = 0125;
            //—-125-+=//

        ):(

            //—-124-+=//
            STBerr = 0124;
            //—-124-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-123-+=//
            STBerr = 0123;
            //—-123-+=//

        ):(

            //—-122-+=//
            STBerr = 0122;
            //—-122-+=//

        );):((st&0x1)?(

            //—-121-+=//
            STBerr = 0121;
            //—-121-+=//

        ):(

            //—-120-+=//
            STBerr = 0120;
            //—-120-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-119-+=//
            STBerr = 0119;
            //—-119-+=//

        ):(

            //—-118-+=//
            STBerr = 0118;
            //—-118-+=//

        );):((st&0x1)?(

            //—-117-+=//
            STBerr = 0117;
            //—-117-+=//

        ):(

            //—-116-+=//
            STBerr = 0116;
            //—-116-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-115-+=//
            STBerr = 0115;
            //—-115-+=//

        ):(

            //—-114-+=//
            STBerr = 0114;
            //—-114-+=//

        );):((st&0x1)?(

            //—-113-+=//
            STBerr = 0113;
            //—-113-+=//

        ):(

            //—-112-+=//
            STBerr = 0112;
            //—-112-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-111-+=//
            STBerr = 0111;
            //—-111-+=//

        ):(

            //—-110-+=//
            STBerr = 0110;
            //—-110-+=//

        );):((st&0x1)?(

            //—-109-+=//
            STBerr = 0109;
            //—-109-+=//

        ):(

            //—-108-+=//
            STBerr = 0108;
            //—-108-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-107-+=//
            STBerr = 0107;
            //—-107-+=//

        ):(

            //—-106-+=//
            STBerr = 0106;
            //—-106-+=//

        );):((st&0x1)?(

            //—-105-+=//
            STBerr = 0105;
            //—-105-+=//

        ):(

            //—-104-+=//
            STBerr = 0104;
            //—-104-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-103-+=//
            STBerr = 0103;
            //—-103-+=//

        ):(

            //—-102-+=//
            STBerr = 0102;
            //—-102-+=//

        );):((st&0x1)?(

            //—-101-+=//
            STBerr = 0101;
            //—-101-+=//

        ):(

            //—-100-+=//
            STBerr = 0100;
            //—-100-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-99-+=//
            STBerr = 0099;
            //—-99-+=//

        ):(

            //—-98-+=//
            STBerr = 0098;
            //—-98-+=//

        );):((st&0x1)?(

            //—-97-+=//
            STBerr = 0097;
            //—-97-+=//

        ):(

            //—-96-+=//
            STBerr = 0096;
            //—-96-+=//

        );););););):((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-95-+=//
            STBerr = 0095;
            //—-95-+=//

        ):(

            //—-94-+=//
            STBerr = 0094;
            //—-94-+=//

        );):((st&0x1)?(

            //—-93-+=//
            STBerr = 0093;
            //—-93-+=//

        ):(

            //—-92-+=//
            STBerr = 0092;
            //—-92-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-91-+=//
            STBerr = 0091;
            //—-91-+=//

        ):(

            //—-90-+=//
            STBerr = 0090;
            //—-90-+=//

        );):((st&0x1)?(

            //—-89-+=//
            STBerr = 0089;
            //—-89-+=//

        ):(

            //—-88-+=//
            STBerr = 0088;
            //—-88-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-87-+=//
            STBerr = 0087;
            //—-87-+=//

        ):(

            //—-86-+=//
            STBerr = 0086;
            //—-86-+=//

        );):((st&0x1)?(

            //—-85-+=//
            STBerr = 0085;
            //—-85-+=//

        ):(

            //—-84-+=//
            STBerr = 0084;
            //—-84-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-83-+=//
            STBerr = 0083;
            //—-83-+=//

        ):(

            //—-82-+=//
            STBerr = 0082;
            //—-82-+=//

        );):((st&0x1)?(

            //—-81-+=//
            STBerr = 0081;
            //—-81-+=//

        ):(

            //—-80-+=//
            STBerr = 0080;
            //—-80-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-79-+=//
            STBerr = 0079;
            //—-79-+=//

        ):(

            //—-78-+=//
            STBerr = 0078;
            //—-78-+=//

        );):((st&0x1)?(

            //—-77-+=//
            STBerr = 0077;
            //—-77-+=//

        ):(

            //—-76-+=//
            STBerr = 0076;
            //—-76-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-75-+=//
            STBerr = 0075;
            //—-75-+=//

        ):(

            //—-74-+=//
            STBerr = 0074;
            //—-74-+=//

        );):((st&0x1)?(

            //—-73-+=//
            STBerr = 0073;
            //—-73-+=//

        ):(

            //—-72-+=//
            STBerr = 0072;
            //—-72-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-71-+=//
            STBerr = 0071;
            //—-71-+=//

        ):(

            //—-70-+=//
            STBerr = 0070;
            //—-70-+=//

        );):((st&0x1)?(

            //—-69-+=//
            STBerr = 0069;
            //—-69-+=//

        ):(

            //—-68-+=//
            STBerr = 0068;
            //—-68-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-67-+=//
            STBerr = 0067;
            //—-67-+=//

        ):(

            //—-66-+=//
            STBerr = 0066;
            //—-66-+=//

        );):((st&0x1)?(

            //—-65-+=//
            STBerr = 0065;
            //—-65-+=//

        ):(

            //—-64-+=//
            STBerr = 0064;
            //—-64-+=//

        ););););););):((st&0x20)?((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-63-+=//
            STBerr = 0063;
            //—-63-+=//

        ):(

            //—-62-+=//
            STBerr = 0062;
            //—-62-+=//

        );):((st&0x1)?(

            //—-61-+=//
            STBerr = 0061;
            //—-61-+=//

        ):(

            //—-60-+=//
            STBerr = 0060;
            //—-60-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-59-+=//
            STBerr = 0059;
            //—-59-+=//

        ):(

            //—-58-+=//
            // We are defining a special partial [in 0 - BKFrst]
            s1 = s2 = AddT[idx_Pa_PNumb]; // will keep in this specific entry
            // Accept in 0 - 127 ; reduce to 0 - 63
            ((s1 >= 'a') && (s1 <= 'z')) ? (s1 = s1 - 'a' + 10;) :
            ((s1 >= 'A') && (s1 <= 'Z')) ? (s1 = s1 - 'A' + 36;) :
            (s1 >= 64) ? (s1 = 0;);
            BKDESpEnt = s1;
            // (sprintf(#s, ":About to define Partial: \"%d/%d\"", s2, s1); mSL_log(SysLogBox, #s););
            memset(curPartial, 0, BKEsize); // zero values are ok for most fields
            AddT[idx_Pa_Bnk] = BKDESpEnt;
            AddT[idx_Pa_Clps2] = 9999;
            AddT[idx_Pa_PWeight] = 1;
            bankCheckbfnd = 1; // A Bnk command will close the partiel
            st = 41; // 38
            //—-58-+=//

        );):((st&0x1)?(

            //—-57-+=//
            cwdMin = 0;
            // we expect a keyword:
            ((cwd === mSL_KW_Clips) || (cwd === mSL_KW_Clps)) ? (    // "Clips" or "Clps"
                // expect a sequence of numbers of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 51; // then there
                ty = 1;
                kmax = 1000;
            ) :
            ((cwd === mSL_KW_ClRange) || (cwd === mSL_KW_Range)) ? (   //  "ClRange" or "Range"
                // expect a range of of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 52; // then there
                ty = 1;
            ) :
            (cwd === mSL_KW_MinDur) ? (   //  "MinDur"
                // expect a decimal value
                stback = st; // return here
                ptr +=1; st = 53; // go there first
                pos = ClSet_MinL; // MinDur
            ) :
            (cwd === mSL_KW_MaxDur) ? (   //  "MaxDur"
                // expect a decimal value
                stback = st; // return here
                ptr +=1; st = 53; // go there first
                pos = ClSet_MaxL; // MaxDur
            ) :
            ((cwd === mSL_KW_Xcept) || (cwd === mSL_KW_Xclude)) ? (   //  "Xcept" or "Xclude"
                // expect a sequence of numbers of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 51; // then there
                ty = 0; // erase
                kmax = 1000;
            ) :
            ((cwd === mSL_KW_Copy) || (cwd === mSL_KW_Idem)) ? (   //  "Copy" or "Idem"
                // copy the clips from an other set
                ptr +=1;
                // we expect an integer
                stback = 55; // continue there
                pos = ClSet_1stC; // put set number in this position
                vmin = 0;
                vmax = 999;
                kmax = 1;
                st = 31; // go there to get an int
            ) :
            ((cwd === mSL_KW_Set) || (cwd === mSL_KW_Seq)) ? (
                // close set
                closeClipSet();
                st = 48; // go there for a new initialization
            ) :
            (cwd === mSL_KW_End) ? (
                // close set
                closeClipSet();
                // save table
                ptr +=1; st = 1; // Return to step 1
            ) :
            (
                STBerr = 0057;
            );
            //—-57-+=//

        ):(

            //—-56-+=//
            // First, check the Seq number
            (((n = AddT[ClSet_num]) < 0) || (n > ClSetPSize) || (ClSetPtr[n] !== -1)) ? (
                // the number is already in use
                STBerr = 0056;
            );
            // We expect now a type keyword
            (cwd === mSL_KW_RR) ? (
                AddT[ClSet_Algo] |= 1; ptr += 1;
                AddT[ClSet_Rnd] = 1;
            ) :
            (cwd === mSL_KW_ARR) ? (
                AddT[ClSet_Algo] |= 1; ptr += 1;
                AddT[ClSet_Rnd] = -1;
            ) :
            (cwd === mSL_KW_RRR) ? (
                ptr += 1;
            ) :
            (cwd === mSL_KW_Random) ? (
                AddT[ClSet_Algo] |= 2; ptr += 1;
                AddT[ClSet_Rnd] = 1;
                0 ? (sprintf(#s, "   Seqv b(%d)  Alg:%d ", AddT[ClSet_num], AddT[ClSet_Algo]); mSL_log(SysLogBox, #s););
            );
            ((AddT[ClSet_Algo] & 0xFF) === 0) ? (
                AddT[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
            );
            // Is "PLUC" the next keyword ?
            (tbl[ptr] === mSL_KW_PLUC) ? (
                AddT[ClSet_Algo] |= 0x100; ptr += 1;
            );
            st = 57; // continue there
            //—-56-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-55-+=//
            // Manage "Idem <set>" or "Copy set>" - First Check alt. set number
            (((n = AddT[ClSet_1stC]) < 0) || (n > ClSetPSize) || (ClSetPtr[n] < 0)) ? (
                STBerr = 0055;
            ) : (
                // Install all items of the set in our area
                AddT[ClSet_1stC] = -2;
                ps = ClSetPtr[n] + ClSet_lCl;
                0 ? (sprintf(#s, "   Idem [%d]  @   %d", n, ps); mSL_log(SysLogBox, #s););
                while ((cp = ps[0]) >= 0) (
                    s1 = 0|(cp / clipsWorkAreaSize); s2 = cp % clipsWorkAreaSize;
                    0 ? (sprintf(#s, "         Copy from:%d to:%d", s1, s2); mSL_log(SysLogBox, #s););
                    while (s1 <= s2) (
                        clipsWorkArea[s1] = s1; s1 += 1;
                    );
                    ps += 1;
                );
                st = 49; // back to 49
            );
            //—-55-+=//

        ):(

            //—-54-+=//
            // First, check the Set number
            (((n = AddT[ClSet_num]) < 0) || (n > ClSetPSize) || (ClSetPtr[n] !== -1)) ? (
                // the number is already in use
                STBerr = 0054;
            );
            // We expect now a type keyword
            (cwd === mSL_KW_RR) ? (
                AddT[ClSet_Algo] |= 1; ptr += 1;
                AddT[ClSet_Rnd] = 1;
                AddT[ClSet_Lst] = AddT[ClSet_Start] = 0;
            ) :
            (cwd === mSL_KW_ARR) ? (
                AddT[ClSet_Algo] |= 1; ptr += 1;
                AddT[ClSet_Rnd] = -1;
                AddT[ClSet_Lst] = AddT[ClSet_Start] = 0;
            ) :
            (cwd === mSL_KW_RRR) ? (
                ptr += 1;
            ) :
            (cwd === mSL_KW_Random) ? (
                AddT[ClSet_Algo] |= 2; ptr += 1;
                AddT[ClSet_Rnd] = 1;
                0 ? (sprintf(#s, "   Set(%d)  Alg:%d ", AddT[ClSet_num], AddT[ClSet_Algo]); mSL_log(SysLogBox, #s););
            );
            ((AddT[ClSet_Algo] & 0xFF) === 0) ? (
                AddT[ClSet_Rnd] = smallPrimeList[smallPrimePtr = (smallPrimePtr + 1) % smallPrimeSize];
            );
            // Is "PLUC" the next keyword ?
            (tbl[ptr] === mSL_KW_PLUC) ? (
                AddT[ClSet_Algo] |= 0x100; ptr += 1;
            );
            st = 49; // continue there
            //—-54-+=//

        );):((st&0x1)?(

            //—-53-+=//
            // Expect one decimal value in seconds, in [0+ 3600]
            ((cwd >= 0.001) && (cwd <= 3600)) ? (
                AddT[pos] = cwd;
                st = stback;
                ptr +=1;
            ) : (
                STBerr = 0053;
            );
            //—-53-+=//

        ):(

            //—-52-+=//
            // Get 2nd of a range of clips
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999)) ? (
                cwd < cwdMin ? (ii = cwd; cwd = cwdMin; cwdMin = ii;);
                ii = cwdMin; loop (cwd - cwdMin + 1, clipsWorkArea[ii] = ii; ii += 1);
                0 ? (sprintf(#s, "   cl: %d to %d", cwdMin, cwd); mSL_log(SysLogBox, #s););
                ptr +=1;
                st = stback; // keep the input, go back to decode
            ) : (
                STBerr = 0052;
            );
            //—-52-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-51-+=//
            // Get the rest of a sequence of clips
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999) && (kmax > 0)) ? (
                clipsWorkArea[cwd] = ty ? cwd : -1;
                0 ? (sprintf(#s, "   cl: %d/%d", cwd, ty); mSL_log(SysLogBox, #s););
                ptr +=1; kmax -= 1;
            ) : (
                // probably finished with that
                st = stback; // keep the input, go back to
            );
            //—-51-+=//

        ):(

            //—-50-+=//
            // Get first of a sequence of clips
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999)) ? (
                cwdMin = cwd;
                clipsWorkArea[cwd] = ty ? cwd : -1;
                0 ? (sprintf(#s, "   cl: %d/%d", cwd, ty); mSL_log(SysLogBox, #s););
                ptr +=1; st = stnext;
            ) : (
                STBerr = 0050;
            );
            //—-50-+=//

        );):((st&0x1)?(

            //—-49-+=//
            cwdMin = 0;
            // we expect a keyword:
            ((cwd === mSL_KW_Clips) || (cwd === mSL_KW_Clps)) ? (    // "Clips" or "Clps"
                // expect a sequence of numbers of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 51; // then there
                ty = 1;
                kmax = 1000;
            ) :
            ((cwd === mSL_KW_ClRange) || (cwd === mSL_KW_Range)) ? (   //  "ClRange" or "Range"
                // expect a range of of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 52; // then there
                ty = 1;
            ) :
            (cwd === mSL_KW_MinDur) ? (   //  "MinDur"
                // expect a decimal value
                stback = st; // return here
                ptr +=1; st = 53; // go there first
                pos = ClSet_MinL; // MinDur
            ) :
            (cwd === mSL_KW_MaxDur) ? (   //  "MaxDur"
                // expect a decimal value
                stback = st; // return here
                ptr +=1; st = 53; // go there first
                pos = ClSet_MaxL; // MaxDur
            ) :
            ((cwd === mSL_KW_Xcept) || (cwd === mSL_KW_Xclude)) ? (   //  "Xcept" or "Xclude"
                // expect a sequence of numbers of clips
                stback = st; // return here
                ptr +=1; st = 50; // go there first
                stnext = 51; // then there
                ty = 0; // erase
                kmax = 1000;
            ) :
            ((cwd === mSL_KW_Copy) || (cwd === mSL_KW_Idem)) ? (   //  "Copy" or "Idem"
                // copy the clips from an other set
                ptr +=1;
                // we expect an integer
                stback = 55; // continue there
                pos = ClSet_1stC; // put set number in this position
                vmin = 0;
                vmax = 999;
                kmax = 1;
                st = 31; // go there to get an int
            ) :
            ((cwd === mSL_KW_Set) || (cwd === mSL_KW_Seq)) ? (
                // close set
                closeClipSet();
                st = 48; // go there for a new initialization
            ) :
            (cwd === mSL_KW_End) ? (
                // close set
                closeClipSet();
                // save table
                ptr +=1; st = 1; // Return to step 1
            ) :
            (
                STBerr = 0049;
            );
            //—-49-+=//

        ):(

            //—-48-+=//   ++ClipSets++
            //   mSL_KW_ClipSets
            (cwd === mSL_KW_Set) ? (
                (ClSetTAPtr < ClSetDSize) ? (
                    AddT = ClSetTab + ClSetTAPtr; // for now keep info in this area
                    memset(AddT, -2, ClSet_lCl + 2); // should check we don't overflow
                    AddT[ClSet_cnt] = -1; // actual count of clips updated later;
                    AddT[ClSet_Algo] = 0; // default algorithm type;
                    AddT[ClSet_MinL] = 0.001; // default min length : 0.001 seconds;
                    AddT[ClSet_MaxL] = 3600; // default max length : 1 hour;
                    AddT[ClSet_Start] = AddT[ClSet_Lst] = irand(10000); // last entry used, random starting;
                    AddT[ClSet_Genc] = 0; // number of clip generated;
                    pos = ClSet_num; // put set number in 1st position
                    memset(clipsWorkArea, -1, clipsWorkAreaSize); // clear work area
                    ptr +=1;
                    // we expect an integer
                    stback = 54; // continue there
                    vmin = 0;
                    vmax = 999;
                    kmax = 1;
                    st = 31; // go there to get an int
                ) : (
                    STBerr = 0051;
                );
            ) :
            (cwd === mSL_KW_Seq) ? (
                (ClSetTAPtr < ClSetDSize) ? (
                    AddT = ClSetTab + ClSetTAPtr; // for now keep info in this area
                    memset(AddT, -2, ClSet_lCl + 2); // should check we don't overflow
                    AddT[ClSet_cnt] = -1; // actual count of clips updated later;
                    AddT[ClSet_Algo] = 0; // default algorithm type;
                    AddT[ClSet_MinL] = 0.001; // default min length : 0.001 seconds;
                    AddT[ClSet_MaxL] = 3600; // default max length : 1 hour;
                    AddT[ClSet_Start] = AddT[ClSet_Lst] = irand(10000); // last entry used, random starting;
                    AddT[ClSet_Genc] = 0; // number of clip generated;
                    pos = ClSet_num; // put set number in 1st position
                    // We will need a large work area
                    // (LWA === 0) ? (LWA = mSL_malloc(LWAsiz, 'data'););
                    (LWA === 0) ? (LWA = mSL_Dyn_Alloc(LWAsiz, 'data', mSL_StM_FlClear););
                    LWpt = 0; // pointer in LWA
                    ptr +=1;
                    // we expect an integer
                    stback = 56; // continue there
                    vmin = 0;
                    vmax = 999;
                    kmax = 1;
                    st = 31; // go there to get an int
                ) : (
                    STBerr = 0051;
                );
            ) :
            (cwd === mSL_KW_Clear) ? (
                clearClipSets();
                ptr +=1;
            ) :
            (cwd === mSL_KW_End) ? (
                ptr +=1; st = 1; // Return to step 1
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    ClipSetsVersion = cwd;
                ) : (
                    STBerr = 0716; // Invalid configuration identification
                );
            ) :
            (
                STBerr = 0048;
            )
            //—-48-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //==================================================================

            //—-47-+=//
            // Expect second number of a range
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999)) ? (
                ii = Cl_n;
                while (ii <= cwd) (
                    gmem[clClVolumes+ii] = (gmem[clClVolumes+ii] & clVolumeFlgs) + Cl_dB + clVolumeBias; ii+=1;
                );
                st = 45; ptr +=1;
            ) : (
                STBerr = 0047;
            );
            //—-47-+=//

        ):(

            //—-46-+=//
            // Expect first number of a range
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999)) ? (
                Cl_n = cwd;
                st = 47; ptr +=1;
            ) : (
                STBerr = 0046;
            );
            //—-46-+=//

        );):((st&0x1)?(

            //—-45-+=//
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 9999)) ? (
                gmem[clClVolumes+cwd] = (gmem[clClVolumes+cwd] & clVolumeFlgs) + Cl_dB + clVolumeBias;
                ptr +=1;
            ) :
            (cwd === mSL_KW_ClVol) ? (
                st = 44; ptr +=1;
            ) :
            (cwd === mSL_KW_ClRange) ? (
                st = 46; ptr +=1;
            ) :
            (cwd === mSL_KW_End) ? (
                ClMEntries = ii = 0; loop(clTSize,
                    ((gmem[clClVolumes+ii] & clVolumeMask) != clVolumeBias) ? ClMEntries +=1; ii+=1;
                ); // Count module. entries
                sprintf(#s, "%d Entries != %d\n",ClMEntries,clVolumeBias);mSL_log(SysLogBox, #s);
                st = 1; ptr +=1; // finished
            ) :
            (
                STBerr = 0045;
            );
            //—-45-+=//

        ):(

            //—-44-+=//
            // Expect one decimal value in dB
            ((cwd >= -40) && (cwd <= 24)) ? (
                Cl_dB = cwd;  st = 45;
                ptr +=1;
            ) : (
                STBerr = 0044;
            );
            //—-44-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-43-+=// st = 43
            Cl_dB = 0;
            (cwd === mSL_KW_ClVol) ? (
                st = 44; ptr +=1;
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    ClipConfigVersion = cwd;
                ) : (
                    STBerr = 0723; // Invalid configuration identification
                );
            ) :
            (cwd === mSL_KW_ClipDir) ? (
                // Set the clip directory
                ptr +=1; cwd = tbl[ptr]; // parameter
                ptr +=1;
                (mSL_isString(cwd)) ? (
                    // Copy the string in the directory
                    setClDirectory(cwd, 0);
                    // sprintf(#s, "Dir: \"%s\"", cwd);
                    // mSL_log(SysLogBox, #s);
                ) : (
                    //
                    sprintf(#s, "Error? \"%s\"   %d", cwd, cwd);
                    //
                    mSL_log(SysLogBox, #s);
                    STBerr = 0724; // Invalid directory identification
                );
            ) :
            (cwd === mSL_KW_ClipFmt) ? (
                // Set the clip format
                ptr +=1; cwd = tbl[ptr]; // parameter
                ptr +=1;
                (mSL_isString(cwd)) ? (
                    // Copy the string in the directory
                    setClDirectory(0, cwd);
                    // sprintf(#s, "Dir: \"%s\"", cwd);
                    // mSL_log(SysLogBox, #s);
                ) : (
                    // sprintf(#s, "Error? \"%s\"   %d", cwd, cwd);
                    // mSL_log(SysLogBox, #s);
                    STBerr = 0725; // Invalid directory identification
                );
            ) :
            (cwd === mSL_KW_Clear) ? (
                // Reset the clip volume area
                ii = 0; loop(clTSize, gmem[clClVolumes+ii] = clVolumeBias; ii+=1;); // reset all to 0dB
                ptr +=1;
                sprintf(#s, "Reset %d clips in %d to %d \n",clTSize, clClVolumes,clVolumeBias);mSL_log(SysLogBox, #s);
            ) :
            (cwd === mSL_KW_End) ? (
                st = 45; // skip to 45
            ) :
            (
                STBerr = 0043;
            )
            //—-43-+=//

        ):(

            //==================================================================

            //—-42-+=// st = 42
            ((cwd == (0|cwd)) && (cwd >= vmin) && (cwd <= vmax)) ? (
                AddT[pos] = cwd;
                st = stback; ptr +=1;
            ) :
            (
                STBerr = 0042;
            );
            //—-42-+=//

        );):((st&0x1)?(

            //—-41-+=// st = 41
            stback = 41; // to return here
            ((cwd === mSL_KW_PlM) || (cwd === mSL_KW_PMd)) ? ( // expect "PlM" or "PMd"
                // expect a playmode
                pos = idx_Pa_PlM;
                vmin = 0; vmax = PMEcnt;
                st = 42; ptr +=1;
            ) :
            ((cwd === mSL_KW_SpM) || (cwd === mSL_KW_SMd)) ? ( // expect "SpM" or "SMd"
                // expect a spacemode
                pos = idx_Pa_SpM;
                vmin = 0; vmax = SMEcnt;
                st = 42; ptr +=1;
            ) :
            (cwd === mSL_KW_prVol) ? ( // expect "prVol"
                // A volume between -24 and + 24 dB
                pos = idx_Pa_prVol; // in this position
                kmax = 2;
                vmin = -24; // in dB
                vmax = 24;
                ptr +=1; st = 20; // get at least 1 decimal value
            ) :
            (cwd === mSL_KW_PClass) ? ( // expect a "class"
                pos = idx_Pa_PClass;
                vmin = 0;
                vmax = 65536;
                ptr +=1; st = 42; // get  1 integer value
            ) :
            (cwd === mSL_KW_PWeight) ? ( // expect a weight
                pos = idx_Pa_PWeight;
                vmin = 0.01;
                vmax = 32767;
                ptr +=1; st = 19; // get at single decimal value
            ) :
            (cwd === mSL_KW_PBFlgs) ? ( // expect a set of flags
                pos = idx_Pa_PBFlgs;
                vmin = 0;
                vmax = mSL_Max_Flgs;
                ptr +=1; st = 42; // get  1 integer value
            ) :
            ((cwd === mSL_KW_Clips) || (cwd === mSL_KW_Clps)) ? (    // "Clips" or "Clps"
                bankCheckcfnd ? BankCheckEntry();  // enter the previous partiel, if any
                kmax = 2; pos = idx_Pa_Clps;
                vmin = 0; vmax = 9999;
                st = 39; ptr +=1; // get 2 integer values
                bankCheckcfnd = 1; // a clip/set will close the partial
            ) :
            (cwd === mSL_KW_Set) ? (  // expect "Set"
                bankCheckcfnd ? BankCheckEntry();  // enter the previous partiel, if any
                // expect a single Set number
                AddT[idx_Pa_Clps] = -1;
                pos = idx_Pa_Clps+1;
                vmin = 0; vmax = 999;
                st = 42; ptr +=1; // get  1 integer value
                bankCheckcfnd = 1; // a clip/set will close the partial
            ) :
            (cwd === mSL_KW_Bnk) ? (  // expect "Bnk"
                //sprintf(#s, "> 31    PlM:%d  SpM:%d  Bnk:%d", PlM_nb, SpM_nb, Bnk_nb);
                //mSL_log(SysLogBox, #s);
                bankCheckbfnd ? BankCheckEntry();  // enter the previous partiel, if any
                st = 37; ptr +=1; bankCheckbfnd = 1;
            ) :
            (cwd === mSL_KW_Grp) ? ( // or "Grp"
                BankCheckEntry();  // enter the previous partiel, if any
                st = 35; ptr +=1;
            ) :
            (cwd === mSL_KW_End) ? ( // or even "End"
                BankCheckEntry();  // enter the previous partiel, if any
                st = 1; ptr +=1;
            ) :
            (cwd == mSL_KW_Partiel) ? (
                BankCheckEntry();  // enter the previous partiel, if any
                // expect an integer in 0 - BKFrst
                AddT = curPartial;
                pos = idx_Pa_PNumb;
                vmin = 0; vmax = 127;
                st = 42; ptr +=1;
                stback = 58; // continue in 58
            ) :
            (
                STBerr = 0041;
            )
            //—-41-+=//

        ):(

            //—-40-+=// st = 40
            ((cwd == (0|cwd)) && (cwd >= vmin) && (cwd <= vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd;
                kmax -= 1; pos += 1;
                st = 40; ptr +=1;
            ) :
            (
                st = 41;
            );
            //—-40-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-39-+=// st = 39
            ((cwd == (0|cwd)) && (cwd >= vmin) && (cwd <= vmax)) ? (
                AddT[pos+1] = AddT[pos] = cwd;
                kmax -= 1; pos += 1;
                st = 40; ptr +=1;
            ) :
            (
                STBerr = 0039;
            );
            //—-39-+=//

        ):(

            //—-38-+=// st = 38
            ((cwd === mSL_KW_Clips) || (cwd === mSL_KW_Clps)) ? (    // "Clips" or "Clps"
                kmax = 2; pos = idx_Pa_Clps;
                vmin = 0; vmax = 9999;
                st = 39; ptr +=1;
            ) :
            (cwd === mSL_KW_Set) ? (  // expect "Set"
                // expect a Set number
                pos = idx_Pa_Clps+1;
                AddT[idx_Pa_Clps] = -1;
                vmin = 0; vmax = 999;
                stback = 41; // to return here
                st = 42; ptr +=1; // get  1 integer value
            ) :
            (
                STBerr = 0038;
            );
            //—-38-+=//

        );):((st&0x1)?(

            //—-37-+=// st = 37
            // Expect an integer, a bank number in 0, 1999
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= 1999)) ? (
                PlM_nb = SpM_nb = Bnk_nb = cwd; // The bank - also sets the default space mode and play mode
                st = 38; ptr +=1;
                //sprintf(#s, "> 37    PlM:%d  SpM:%d  Bnk:%d", PlM_nb, SpM_nb, Bnk_nb);
                //mSL_log(SysLogBox, #s);
            ) :
            (
                STBerr = 0037;
            );
            //—-37-+=//

        ):(

            //—-36-+=// st = 36
            (cwd === mSL_KW_Bnk) ? (  // expect "Bnk"
                st = 37; ptr +=1; bankCheckbfnd = 1;
            ) :
            ((cwd === mSL_KW_Clips) || (cwd === mSL_KW_Clps)) ? (    // "Clips" or "Clps"
                PlM_nb = SpM_nb = Bnk_nb = 0; // default values
                kmax = 2; pos = idx_Pa_Clps;
                vmin = 0; vmax = 9999;
                st = 39; ptr +=1;
            ) :
            (cwd === mSL_KW_Set) ? (  // expect "Set"
                PlM_nb = SpM_nb = Bnk_nb = 0; // default values
                // expect a Set number
                AddT[idx_Pa_Clps] = -1;
                pos = idx_Pa_Clps+1;
                vmin = 0; vmax = 999;
                stback = 41; // continue there
                st = 42; ptr +=1; // get  1 integer value
            ) :
            (
                STBerr = 0036;
            );
            //—-36-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-35-+=// st = 35
            // Expect an integer, a group number in 0, 1999
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < GRPtSiz)) ? (
                Grp_nb = cwd; // The group
                st = 36; ptr +=1;
            ) :
            (
                STBerr = 0035;
            );
            //—-35-+=//

        ):(

            //—-34-+=//  st = 34 ++Banks++
            AddT = curPartial; // work done in this WA
            (cwd === mSL_KW_Grp) ? (
                st = 35; ptr +=1;
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    BanksDefsVersion = cwd;
                ) : (
                    STBerr = 0756; // Invalid configuration identification (==> 956)
                );
            ) :
            (cwd === mSL_KW_Clear) ? (
                defBankInit() ;
                st = 34; ptr +=1; // Stay here
            ) :
            (cwd === mSL_KW_End) ? (
                st = 1; ptr +=1; // Return to step 1
            ) :
            (cwd == mSL_KW_Partiel) ? (
                // expect an integer in 0 - BKFrst
                pos = idx_Pa_PNumb; // Put value here
                vmin = 0; vmax = 127;
                st = 42; ptr +=1;
                stback = 58; // continue in 58
            ) :
            (
                STBerr = 0034;
            );
            //—-34-+=//

        );):((st&0x1)?(
            //==================================================================

            //—-33-+=// st = 33
            // Get second of 2 integer values
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd; pos += 1;
                ptr +=1; kmax -= 1;
            ) : (
                // probably finished with that
                st = stback; // keep the input, go back to
            );
            //—-33-+=//

        ):(

            //—-32-+=//
            // Get first of 2 integer values
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < vmax)) ? (
                AddT[pos] = cwd; pos += 1;
                ptr +=1; st = 33;
            ) : (
                STBerr = 0032;
            );
            //—-32-+=//

        );););););):((st&0x10)?((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-31-+=//
            // Expect one single integer value
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < vmax)) ? (
                AddT[pos] = cwd;
                ptr +=1; st = stback;
            ) : (
                STBerr = 0031;
            );
            //—-31-+=//

        ):(

            //—-30-+=//  st = 30
            // All Space Mode internal defs.
            stback = 30; // return there
            (cwd === mSL_KW_HPSet) ? (
                ptr +=1; st = 32; // get one to for values
                pos = idx_Sm_HPSet1; // in this position
                vmax = HPPSize; kmax = 4;
            ) :
            (cwd === mSL_KW_HPCnt) ? (
                ptr +=1; st = 32; // get one or two values
                pos = idx_Sm_HPCnt1; // in this position
                vmax = 128; kmax = 2;
            ) :
            (cwd === mSL_KW_HPFlags) ? (
                ptr +=1; st = 31; // get one value
                pos = idx_Sm_HPFlags; // in this position
                vmax = mSL_Max_Flgs; kmax = 1;
            ) :
            (cwd === mSL_KW_SPAux) ? (
                ptr +=1; st = 31; // get one value
                pos = idx_Sm_Aux; // in this position
                vmax = mSL_Max_Flgs; kmax = 1;
            ) :
            ((cwd === mSL_KW_HPEv)) ? (
                ptr +=1; st = 32; // get some values
                pos = idx_Sm_HPEv; // in this position
                vmax = mSL_Max_Flgs; kmax = 4;
            ) :
            ((cwd === mSL_KW_SPPar)) ? (
                ptr +=1; st = 32; // get some values
                pos = idx_Sm_Pars; // in this position
                vmax = mSL_Max_Flgs; kmax = 6;
            ) :
            (cwd === mSL_KW_SPAlgo) ? (
                ptr +=1; st = 32; // get some value
                pos = idx_Sm_Algo; // in this position
                vmax = mSL_Max_Flgs; kmax = 2;
            ) :
            ((cwd === mSL_KW_SMd) || (cwd === mSL_KW_SpM) || (cwd === mSL_KW_End)) ? (
                // We have finished with this entry. Update the value
                //
                st = 28; //
            ) : (
                STBerr = 0030;
            );
            //—-30-+=//

        );):((st&0x1)?(

            //—-29-+=//
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < SMEcnt)) ? (
                SEntry = cwd;
                AddT = SMTab + SMESize * SEntry;  // The address
                memset(AddT, Undef, SMESize); // clear the entry
                AddT[idx_Sm_sMnum] = SEntry; // keep the entry number
                vmin = 0;
                pos = 0;
                ptr +=1; st = 30;
            ) : (
                STBerr = 0029;
            );
            //—-29-+=//

        ):(

            //—-28-+=//   +++++SpaceModes+++++
            // Expect a "SMd"
            ((cwd === mSL_KW_SMd) || (cwd === mSL_KW_SpM)) ? (
                ptr +=1; st = 29;
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    SpaceModesVersion = cwd;
                ) : (
                    STBerr = 0714; // Invalid configuration identification
                );
            ) :
            (cwd === mSL_KW_Clear) ? (
                // Clear the table
                memset(SMTab, Undef, SMESize * SMEcnt);
                ptr +=1;
            ) :
            (cwd === mSL_KW_End) ? (
                // Finished with the table
                updSMEntries(); // update the entries
                ptr +=1; st = 1; // Return to step 1
            ) : (
                STBerr = 0028;
            );
            //—-28-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-27-+=//
            STBerr = 0027;
            //—-27-+=//

        ):(
            //==================================================================
            //—-26-+=//
            // Expect the number of a hp or a configuration
            ((cwd == (0|cwd)) && (cnt < hct) &&
                (      ((cvl > 0) && (cwd >= 0) && (cwd <= 256)) // regular conf - accept HP 0
                    || ((cvl < 0) && (cwd > 0) && (cwd <= HPPSize)) // seq. confs.
                ) ) ? (
                cnt += 1; ptr +=1;
            ) :
            (cwd === 0) ? (
                // end of list
                (hct != cnt) ? (
                    // The numbers doesn't match
                    STBerr = 0741;
                ) :
                (HPPTab[cid] != 0) ? (
                    // The configuration already exists
                    STBerr = 0747; // conf. exists
                ) :
                (HPApt + cnt + 3 >= HPASize) ? (
                    STBerr = 0748; // table overflow
                ) : (
                    // keep the configuration
                    HPPTab[cid] = HPATab + HPApt + 1;
                    zpt = HPATab + HPApt;
                    loop (cnt + 3,
                        HPATab[HPApt] = tbl[pt1st];
                        HPApt+=1; pt1st+=1;
                    );
                    // Finished for this one
                    (flgs & 16) ? (
                        // Dump it
                        sprintf(#s, "HPC: %d %d %d %d %d %d %d %d %d %d %d %d ...", zpt[0], zpt[1], zpt[2], zpt[3], zpt[4],
                                 zpt[5], zpt[6], zpt[7], zpt[8], zpt[9], zpt[10], zpt[11]);
                        mSL_log(SysLogBox, #s);
                    );
                    // Return to next
                    ptr +=1; st = 24;
                );
            ) : (
                STBerr = 0026;
            );
            //—-26-+=//

        );):((st&0x1)?(

            //—-25-+=//
            // Expect a list length
            ((cwd == (0|cwd)) && (cwd > 0) && (cwd <= 256)) ? (
                hct = cwd; st = 26; ptr +=1;
            ) : (
                STBerr = 0025;
            );
            //—-25-+=//

        ):(

            //—-24-+=//  // ++++HPConfig++++  HP Configuration definition
            (cwd === mSL_KW_Clear) ? (
                HPConfInit(); // HPConfInit();
                ptr +=1;
            ) :
            (cwd === mSL_KW_Default) ? (
                HPConfDefBuild();
                ptr +=1;
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    HPConfigVersion = cwd;
                ) : (
                    STBerr = 0715; // Invalid configuration identification
                );
            ) :
            (cwd === mSL_KW_End) ? (
                HPConfCheck(); // Count and check HP and configurations
                st = 1; ptr +=1; // Return to step 1
            ) :
            ((cwd == (0|cwd)) && (((cwd > 0) && (cwd < HPPSize)) || ((cwd < 0) && (cwd > - HPPSize)))) ? (
                // can be a conf number of a conf set number
                pt1st = ptr; cnt = 0; cvl = cwd; cid = abs(cwd); st = 25; ptr +=1;
            ) :
            (
                STBerr = 0024;
            );
            //—-24-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(
            //==================================================================

            //—-23-+=//
            // Expect other integer values
            ((cwd == (0|cwd)) && (cwd >= vmin) && (cwd <= vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd;
                ptr +=1; pos += 1;
                kmax -= 1;
            ) : (
                st = stback; // else, get back
            );
            //—-23-+=//

        ):(

            //—-22-+=// st = 22
            // Expect one first integer value
            ((cwd == (0|cwd)) && (cwd >= vmin) && (cwd <= vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd;  st = 23; // next state
                ptr +=1; pos += 1;
                kmax -= 1;
            ) : (
                STBerr = 0022;
            );
            //—-22-+=//

        );):((st&0x1)?(

            //—-21-+=//
            // Expect other decimal values
            ((cwd >= vmin) && (cwd <= vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd;
                ptr +=1; pos += 1;
                kmax -= 1;
            ) : (
                st = stback; // else, get back
            );
            //—-21-+=//

        ):(

            //—-20-+=// st = 20
            // Expect one first decimal value
            ((cwd >= vmin) && (cwd <= vmax) && (kmax > 0)) ? (
                AddT[pos] = cwd;  st = 21;
                ptr +=1; pos += 1;
                kmax -= 1;
            ) : (
                STBerr = 0020;
            );
            //—-20-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-19-+=//  st = 19
            // Expect one single decimal value
            ((cwd >= vmin) && (cwd <= vmax)) ? (
                AddT[pos] = cwd;
                ptr +=1; st = stback;
            ) : (
                STBerr = 0019;
            );
            //—-19-+=//

        ):(

            //—-18-+=//
            // Expect one single integer value
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd <= vmax)) ? (
                AddT[pos] = cwd;
                ptr +=1; st = stback;
            ) : (
                STBerr = 0018;
            );
            //—-18-+=//

        );):((st&0x1)?(

            //—-17-+=//
            // Expect the play mode type
            (cwd === mSL_KW_KmdPlay) ? (
                ptr +=1; st = stback; //
                AddT[idx_Pm_Kmd] = KmdPlay; // code for "Play"
            ) :
            (cwd === mSL_KW_KmdLoop) ? (
                ptr +=1; st = stback; //
                AddT[idx_Pm_Kmd] = KmdLoop; // code for "Loop"
            ) :
            (
                STBerr = 0017;
            );
            //—-17-+=//

        ):(

            //—-16-+=//
            // Decode all the internal fields
            vmin = 0;
            vmax = 100;
            stback = 16; // to return here
            (cwd === mSL_KW_Kmd) ? (
                ptr +=1; st = 17; // get the keywords
                pos = idx_Pm_Kmd; // in this position
            ) :
            (cwd === mSL_KW_FLM) ? (
                ptr +=1; st = 22; // get one or 2 integer values : a flag set
                pos = idx_Pm_FLM1; // in this position
                kmax = 2;
                vmin = 0;
                vmax = 0x10000000;
            ) :
            (cwd === mSL_KW_Speed) ? (
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_Speed1; // in this position
                kmax = 3;
                vmin = -12;
                vmax = 12;
            ) :
            (cwd === mSL_KW_GDepth) ? (
                ptr +=1; st = 22; // get at least 1 integer value
                pos = idx_Pm_GDepth1; // in this position
                kmax = 2;
                vmin = 0;
                vmax = 24;
            ) :
            (cwd === mSL_KW_PVol) ? ( // volumes
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_PVol1; // in this position
                kmax = 2;
                vmin = -120; // in dB
                vmax = 12;
            ) :
            (cwd === mSL_KW_Gsize) ? ( // grain sizes
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_Gsize1; // in this position
                kmax = 2;
                vmin = 0.001; // in seconds
                vmax = 30;
            ) :
            (cwd === mSL_KW_PDur) ? ( // play duration
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_PDur1; // in this position
                kmax = 2;
                vmin = 0.01; // in seconds
                vmax = 300;
            ) :
            (cwd === mSL_KW_FX1) ? ( // FX1 volumes
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_FX1; // in this position
                kmax = 2;
                vmin = -120; // in dB
                vmax = 12;
            ) :
            (cwd === mSL_KW_FX2) ? ( // FX2 volumes
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_FX2; // in this position
                kmax = 2;
                vmin = -120; // in dB
                vmax = 12;
            ) :
            (cwd === mSL_KW_ChCnt) ? (
                ptr +=1; st = 22; // get at least 1 integer value
                pos = idx_Pm_ChCnt1; // in this position
                kmax = 2;
                vmin = 1;
                vmax = 128;
            ) :
            (cwd === mSL_KW_PMod) ? ( // mods
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_Spec0; // in this position
                kmax = 2; // and up to 2
                vmin = - 0x40000000;
                vmax = 0x40000000;
            ) :
            (cwd === mSL_KW_FdIn) ? ( // Fade-in
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_PFdIn1; // in this position
                kmax = 2; // and up to 2
                vmin = -100; // negative is -% of duration, positive is ms
                vmax = 60000; // up to 1 minute
            ) :
            (cwd === mSL_KW_FdOut) ? ( // Fade-out
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_PFdOut1; // in this position
                kmax = 2; // and up to 2
                vmin = -100; // negative is -% of duration, positive is ms
                vmax = 60000; // up to 1 minute
            ) :
            (cwd === mSL_KW_GrFdIn) ? ( // Grain Fade-in
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_GPFdIn1; // in this position
                kmax = 2; // and up to 2
                vmin = -100; // negative is -% of duration, positive is ms
                vmax = 60000; // up to 1 minute
            ) :
            (cwd === mSL_KW_GrFdOut) ? ( // Grain Fade-out
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_GPFdOut1; // in this position
                kmax = 2; // and up to 2
                vmin = -100; // negative is -% of duration, positive is ms
                vmax = 60000; // up to 1 minute
            ) :
            (cwd === mSL_KW_GrFdTy) ? ( // Grain Fade type
                ptr +=1; st = 20; // get at least 1 decimal value
                pos = idx_Pm_GPFdTy; // in this position
                kmax = 1; // and up to 1
                vmin = - 0x40000000;
                vmax = 0x40000000;
            ) :
            // Other expected keywords
            ((cwd === mSL_KW_PMd) || (cwd === mSL_KW_PlM) || (cwd === mSL_KW_End)) ? (
                // just return to base state
                st = 14;
            ) :
            (
                STBerr = 0016;
            );
            //—-16-+=//

        ););););):((st&0x8)?((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-15-+=//
            // expect a playmode number
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < PMEcnt)) ? (
                AddT = PMTab + PMEsize * cwd;
                memset(AddT, Undef, PMEsize); // clear the entry
                pos = 0; ptr +=1; st = 16;
            ) : (
                STBerr = 0015;
            )
            //—-15-+=//

        ):(

            //—-14-+=//   ++++PlayModes++++
            // Main Playmode Entry
            // Expect a "PMd" and a number
            ((cwd === mSL_KW_PMd) || (cwd === mSL_KW_PlM)) ? (
                ptr +=1; st = 15;
            ) :
            (cwd === mSL_KW_Clear) ? (
                // Clear the table
                defPMEntryInit(); // the whole array is set to "Undef"
                ptr +=1;  // stay in this state
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    PlayModesVersion = cwd;
                ) : (
                    STBerr = 0712; // Invalid configuration identification
                );
            ) :
            (cwd === mSL_KW_End) ? (
                // Finished with the table
                updPMEntries(); // update the entries
                ptr +=1; st = 1; // Return to step 1
            ) : (
                STBerr = 0014;
            );
            //—-14-+=//

        );):((st&0x1)?(

            //—-13-+=//
            STBerr = 0013;
            //—-13-+=//

        ):(
            //==================================================================

            //—-12-+=//
            // After a "DoKmd", keep the inputs, except a few keywords
            ((cwd === mSL_KW_DefSeq) || (cwd === mSL_KW_Enter) || (cwd === mSL_KW_MMode) || (cwd === mSL_KW_End) ||
             (cwd === mSL_KW_FIdent) || (cwd === mSL_KW_Table) || (cwd === mSL_KW_DoKmd) || (cwd === mSL_KW_Clear)) ? (
                // A "new" keyword is found
                // time to register the full command
                pt =  MIDISeqncs + MIDISeqPtr; // The address
                zpt = pt;
                totsize = cnt + kct + 5 + 2; // Total entry size
                ((cnt < 1) || (cnt > 5) || (kct < 1) || (kct > kmdlsize)) ? (
                    // error in sensor # or commands count
                    STBerr = 0777;
                ) :
                (MIDISeqPtr + totsize > MIDISeqSiz - 2) ? (
                    STBerr = 0788; // capacity exceeded
                ) : (
                    MIDISeqPtr += totsize;
                    pt[0] = totsize;
                    pt[1] = ST_mmd; // MIDI mode of the command
                    (tout == 0) ? tout = cnt * MIDISensDefTout;
                    pt[2] = tout; // Time out for input events sequence
                    pt[3] = cnt; // number of sensors/event input
                    pt = pt + 4; // new pt
                    // Enter all sensors
                    (cnt >= 1) ? (pt[0] = s1; pt += 1;);  // enter next sensor
                    (cnt >= 2) ? (pt[0] = s2; pt += 1;);
                    (cnt >= 3) ? (pt[0] = s3; pt += 1;);
                    (cnt >= 4) ? (pt[0] = s4; pt += 1;);
                    (cnt >= 5) ? (pt[0] = s5; pt += 1;);
                    // Insert command list
                    pttr = pt; // start of list
                    pt[0] = kct + 2; // size of command list
                    pt += 1; pt[0] = 255; pt += 1; pt[0] = 0; // add move cmd
                    loop (kct,
                        pt += 1;
                        pt[0] = tbl[pt1st];
                        pt1st += 1;
                    );
                    //
                    // Dump it
                    (flgs & 8) ? (
                        sprintf(#s, "Sensor %g %g %g %g %g %g %g %g %g %g %g %g %g %g", zpt[0], zpt[1], zpt[2], zpt[3], zpt[4],
                                 zpt[5], zpt[6], zpt[7], zpt[8], zpt[9], zpt[10], zpt[11], zpt[12], zpt[13]);
                        mSL_log(SysLogBox, #s);
                    );
                    // Return to accept
                    st = 8;
                    // Parse it...
                );
            ) :
            (cwd >= -1000) ? (
                // consider it as a command/parameter
                // this includes keywords, macro names, etc.
                kct += 1; ptr +=1;
            ) : (
                STBerr = 0012;
            );
            //—-12-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-11-+=//
            (cwd === mSL_KW_DoKmd) ? (
                // skip to the command recording
                ptr +=1; st = 12; pt1st = ptr; // pointer to the first command
            ) :
            ((cwd == (0|cwd)) && (cwd > 0) && (cwd <= MIDI_Sensors_Max)) ? (
                s5 = s4; s4 = s3; s3 = s2; s2 = s1; s1 = cwd;
                cnt += 1; ptr +=1; // stay in this state
            ) : (
                STBerr = 0011;
            );
            //—-11-+=//

        ):(

            //—-10-+=//
            // Expect a "MIDI sequence duration"
            (cwd === mSL_KW_SDur) ? (
                // A duration is noted for the sequence
                ptr +=1; cwd = tbl[ptr]; // The duration
                ((cwd < 1) || (cwd > 600)) ? (
                    STBerr = 0010;
                ) : (
                    tout = cwd; ptr += 1;
                );
            );
            // wait for sensors sequence
            st = 11;
            //—-10-+=//

        );):((st&0x1)?(

            //—-9-+=//
            // A "MMode" command - expect an integer in [0 ... max MIDI mode]
            ((cwd == (0|cwd)) && (cwd >= 0) && (cwd < MIDI_States_Max_siz)) ? (
                ST_mmd = cwd; ptr +=1; st = 8;
            ) : (
                STBerr = 0009;
            );
            //—-9-+=//

        ):(

            //—-8-+=//    ++++Sensors++++
            (cwd === mSL_KW_DefSeq) ? (
                s1 = s2 = s3 = s4 = s5 = 0;
                tout = kct = cnt = 0;
                st = 10; ptr +=1;
            ) :
            (cwd === mSL_KW_MMode) ? (
                st = 9; ptr +=1;
            ) :
            (cwd === mSL_KW_Enter) ? (
                s2 = s3 = s4 = s5 = 0; s1 = EnterSens;
                tout = kct = 0; cnt = 1;
                st = 12; ptr +=1; pt1st = ptr;
            ) :
            (cwd === mSL_KW_Clear) ? (
                // The "clear" command resets the content of the sensors table
                MIDISeqPtr = 0; memset(MIDISeqncs, 0, MIDISeqSiz);
                ptr +=1; //
            ) :
            (cwd === mSL_KW_FIdent) ? (
                // The "FIdent" command defines a version number for the table
                ptr +=1; cwd = tbl[ptr]; // current word
                ptr +=1;
                ((cwd < mSL_Max_Vers) && (cwd > 0) && (cwd == (0|cwd))) ? (
                    SensorsCfVersion = cwd;
                ) : (
                    STBerr = 0711; // Invalid configuration identification
                );
            ) :
            (cwd === mSL_KW_End) ? (
                st = 1; ptr +=1; // Return to step 1
            ) : (
                STBerr = 0008;
            );
            //—-8-+=//

        );););):((st&0x4)?((st&0x2)?((st&0x1)?(

            //—-7-+=//
            STBerr = 0007;
            //—-7-+=//

        ):(

            //—-6-+=//
            STBerr = 0006;
            //—-6-+=//

        );):((st&0x1)?(

            //—-5-+=//
            ((cwd === mSL_KW_End) || (cwd === mSL_KW_DefM) || (cwd === mSL_KW_Clear) || (cwd === mSL_KW_Table) ||
            (cwd === mSL_KW_MMode) || (cwd === mSL_KW_DefSeq) || (cwd === mSL_KW_Enter) || (cwd === mSL_KW_DoKmd)
            ) ? (
                st = 4; // reserved names
            ) : (
                // "record"
                ptr += 1;
            );
            //—-5-+=//

        ):(

            //—-4-+=//
            (cwd === mSL_KW_End) ? (
                // Record Macro
                (Mac_Start > 0) ? (
                    mac_enter(tbl + Mac_Start, ptr - Mac_Start - 1);
                );
                Mac_Start = -1;
                st = 1; ptr +=1;//
            ) :
            (cwd === mSL_KW_Table) ? (
                // Record Macro
                (Mac_Start > 0) ? (
                    mac_enter(tbl + Mac_Start, ptr - Mac_Start - 1);
                );
                Mac_Start = -1;
                st = 1; //
            ) :
            (cwd === mSL_KW_DefM) ? (
                // Record Macro
                (Mac_Start > 0) ? (
                    mac_enter(tbl + Mac_Start, ptr - Mac_Start - 1);
                );
                Mac_Start = -1;
                st = 3; ptr +=1;//
            ) :
            (cwd === mSL_KW_Clear) ? (
                memset(Mac_WA_Tab, 0, Mac_WA_Siz);
                memset(Mac_WA_Hash, 0, Mac_WA_HSiz);
                Mac_WA_Ptmc = 1;
                Mac_Start = -1;
                ptr +=1;//
            ) : (
                // error
                STBerr = 0004;
            );
            //—-4-+=//

        ););):((st&0x2)?((st&0x1)?(

            //—-3-+=//
            // Expect a macro name - some ids are reserved
            ((cwd === mSL_KW_End) || (cwd === mSL_KW_DefM) || (cwd === mSL_KW_Clear) || (cwd === mSL_KW_Table) ||
            (cwd === mSL_KW_MMode) || (cwd === mSL_KW_DefSeq) || (cwd === mSL_KW_Enter) || (cwd === mSL_KW_DoKmd)
            ) ? (
                STBerr = 0702; // reserved names
            ) :
            ((cwd >= mSL_Sym_Low) && (cwd <= mSL_Sym_High)) ? (
                // The name is valid. "Record" Macro
                Mac_Start = ptr; // where the name is
                st = 5; ptr +=1;//
            ) : (
                STBerr = 0003;
            );
            //—-3-+=//

        ):(
            //==================================================================

            //—-2-+=// State 2 - expect the name of a table
            (cwd === mSL_KW_Sensors) ? (
                // Perform some var. initialization
                ST_mmd = 0; // current MIDI mode
                st = 8; ptr +=1; // start
            ) :
            (cwd === mSL_KW_HPConf) ? (
                st = 24; ptr +=1; //
            ) :
            (cwd === mSL_KW_SpModes) ? (
                st = 28; ptr +=1; //
            ) :
            (cwd === mSL_KW_PlModes) ? (
                st = 14; ptr +=1; //
            ) :
            (cwd === mSL_KW_Banks) ? (
                st = 34; ptr +=1; //
            ) :
            (cwd === mSL_KW_Clips) ? (
                st = 43; ptr +=1; //
            ) :
            (cwd === mSL_KW_ClipSets) ? (
                st = 48; ptr +=1; //
            ) :
            (cwd === mSL_KW_Macros) ? (
                Mac_Start = -1;
                st = 4; ptr +=1; //
            ) :
            (
                STBerr = 0002;
            );
            //—-2-+=//

        );):((st&0x1)?(

            //—-1-+=// State 1 we expect some keywords
            (cwd === mSL_KW_Table) ? (
                st = 2; ptr +=1; //
            ) :
            (cwd === mSL_KW_End) ? (
                st = 1; ptr +=1;//
            ) :
            (cwd === mSL_KW_DefM) ? (
                st = 3; ptr +=1;//
            ) :
            (
                // error otherwise
                rd_err = 0735;
                err_pos = ptr;
            );
            //—-1-+=//

        ):(

            //—-0-+=//   +++end loop+++
            // Expect the end of input
            (ptr != itc) ? (
                rd_err = 0730;
                err_pos = ptr;
            );
            //—-0-+=//

        ););););););););

        (err_fbnk != 0) ? (
            STBerr =  err_fbnk; err_fbnk = 0;
        );
        (STBerr != 0) ? (
            rd_err = ((STBerr < 200) ? 0500 : 0) + STBerr;
        );



    );

    // End of input/error.
    (rd_err === 0) ? (
        (st != 1) ? (rd_err = 0731;) :
        (ptr != itc) ? (rd_err = 0732;) :
        (xmct <= 0) ? (rd_err = 0733;) ;
    );

    ((flgs & 2) || (rd_err != 0)) ? (
        // print the final status
        sprintf(#s, "EndState %d - %d/%d/%d - Input: %s - Err: %d", st, ptr, itc, cvl, mSL_edit_value(#u, cwd), rd_err);
        mSL_log(SysLogBox, #s);
    );

    (LWA != 0) ? mSL_Dyn_Free(LWA);
    rd_err;

);



<? include("GM-Libs/mSL_Events.jsfx-inc"); ?>



//===============================================
//          Execute a list of actions


function
Simple_Action(src)
local (zz, xp, mr, ccnt, ent, s1, mpt, w1, pindx, err, p, flgs, auxKmd, auxRes,
    par1, par2, par3, par4, par5, par6, par7, par8)
(
    flgs = FlagsTbVals[Flgs_Acts]; // trace flags
    auxKmd = ccnt = xp = err = 0;
    auxRes = Undef;
    zz = src;
    (src < MIDISeqncs) ? (
        err = 0258; // address of action list too low
        (flgs & 1) ? (
            sprintf(#s, "    Action @ %d  siz: %d error: %d", src, src[0], err);
            mSL_log(SysLogBox, #s);
        );
    ) : (
        (zz[0] > 32767) ? ( // size of the action list
            err = 0257; // action list too long
        ) : (
            ccnt = zz[0]; zz += 1; // count
            xp = zz[0]; zz += 1; // 1st code
        );
    );

    (xp === 255) ? (
        p = src[2];
        (p === 0) ? (
            // Action list not yet parsed
            w1 = Expand_Action_List(src); // parse and return old / new source replacement
            (w1 < 0) ? (
                err = -w1;
            ) :
            (src != w1) ? (
                src[2] = pars[2] = src = w1; // update
            ) : (
                src[2] = -1; // no update has been done
            );
            p = src[2];
        );
        (p > MIDISeqncs) ? (
            src = p; // a forward address
            (flgs & 2) ? (
                sprintf(#s, "    Skip to:  %d  siz: %d ", src, src[0]);
                mSL_log(SysLogBox, #s);
            );
        );
        // skip to this code
        ccnt = src[0] - 2;
        zz = src + 3; // point to next code
        xp = zz[0]; zz += 1; // 1st code
    );



    while ((ccnt > 0) && (err === 0)) (
        ccnt -=1;
        AAAAAA_xp = xp;

        xp4 = xp3; xp3 = xp2; xp2 = xp1; xp1 = xp;

        // Is this a symbol ?
        ((xp >= mSL_Sym_Low) && (xp <= mSL_Sym_High)) ? (
            // Should already have been replaced
            // Is this a defined action ?
            (((ent = act_pos(xp)) >= 0) && (ActionHsTab[ent] === xp)) ? (
                zz[-1] = xp = ActionHsNums[ent];
            ) : (
                xp = 0; err = 263;
            );
        );


        ((xp >= 300 && xp < 500)) ? xp = xp - 299;

        ((xp < 0) || (xp > 255)) ? (
            err = 0261; // unsupported action
            xp = 0;
        );


       (flgs & 2) ? (
            sprintf(#s, "Exec Action: %d   @:  %d", xp, zz-1);
            mSL_log(SysLogBox, #s);
        );

        // NOTE : All the bit tests after this comment are automatically generated by a "c" program.

        (xp&0x80)?((xp&0x40)?((xp&0x20)?((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-255—-//
            // Redirection
            act=255;
            zz += 1; ccnt -=1; // skip value for now
            //—-255—-//

        ):(

            //—-254—-//
            err=254;
            //—-254—-//

        );):((xp&0x1)?(

            //—-253—-//
            err=253;
            //—-253—-//

        ):(

            //—-252—-//
            err=252;
            //—-252—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-251—-//
            err=251;
            //—-251—-//

        ):(

            //—-250—-//
            err=250;
            //—-250—-//

        );):((xp&0x1)?(

            //—-249—-//
            err=249;
            //—-249—-//

        ):(

            //—-248—-//
            err=248;
            //—-248—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-247—-//
            err=247;
            //—-247—-//

        ):(

            //—-246—-//
            err=246;
            //—-246—-//

        );):((xp&0x1)?(

            //—-245—-//
            err=245;
            //—-245—-//

        ):(

            //—-244—-//
            err=244;
            //—-244—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-243—-//
            err=243;
            //—-243—-//

        ):(

            //—-242—-//
            err=242;
            //—-242—-//

        );):((xp&0x1)?(

            //—-241—-//
            err=241;
            //—-241—-//

        ):(

            //—-240—-//
            err=240;
            //—-240—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-239—-//
            err=239;
            //—-239—-//

        ):(

            //—-238—-//
            err=238;
            //—-238—-//

        );):((xp&0x1)?(

            //—-237—-//
            err=237;
            //—-237—-//

        ):(

            //—-236—-//
            err=236;
            //—-236—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-235—-//
            err=235;
            //—-235—-//

        ):(

            //—-234—-//
            err=234;
            //—-234—-//

        );):((xp&0x1)?(

            //—-233—-//
            err=233;
            //—-233—-//

        ):(

            //—-232—-//
            err=232;
            //—-232—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-231—-//
            err=231;
            //—-231—-//

        ):(

            //—-230—-//
            err=230;
            //—-230—-//

        );):((xp&0x1)?(

            //—-229—-//
            err=229;
            //—-229—-//

        ):(

            //—-228—-//
            err=228;
            //—-228—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-227—-//
            err=227;
            //—-227—-//

        ):(

            //—-226—-//
            err=226;
            //—-226—-//

        );):((xp&0x1)?(

            //—-225—-//
            err=225;
            //—-225—-//

        ):(

            //—-224—-//
            err=224;
            //—-224—-//

        );););););):((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-223—-//
            err=223;
            //—-223—-//

        ):(

            //—-222—-//
            err=222;
            //—-222—-//

        );):((xp&0x1)?(

            //—-221—-//
            err=221;
            //—-221—-//

        ):(

            //—-220—-//
            err=220;
            //—-220—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-219—-//
            err=219;
            //—-219—-//

        ):(

            //—-218—-//
            err=218;
            //—-218—-//

        );):((xp&0x1)?(

            //—-217—-//
            err=217;
            //—-217—-//

        ):(

            //—-216—-//
            err=216;
            //—-216—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-215—-//
            err=215;
            //—-215—-//

        ):(

            //—-214—-//
            err=214;
            //—-214—-//

        );):((xp&0x1)?(

            //—-213—-//
            err=213;
            //—-213—-//

        ):(

            //—-212—-//
            err=212;
            //—-212—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-211—-//
            err=211;
            //—-211—-//

        ):(

            //—-210—-//
            err=210;
            //—-210—-//

        );):((xp&0x1)?(

            //—-209—-//
            err=209;
            //—-209—-//

        ):(

            //—-208—-//
            err=208;
            //—-208—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-207—-//
            err=207;
            //—-207—-//

        ):(

            //—-206—-//
            err=206;
            //—-206—-//

        );):((xp&0x1)?(

            //—-205—-//
            err=205;
            //—-205—-//

        ):(

            //—-204—-//
            err=204;
            //—-204—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-203—-//
            err=203;
            //—-203—-//

        ):(

            //—-202—-//
            err=202;
            //—-202—-//

        );):((xp&0x1)?(

            //—-201—-//
            err=201;
            //—-201—-//

        ):(

            //—-200—-//
            err=200;
            //—-200—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-199—-//
            err=199;
            //—-199—-//

        ):(

            //—-198—-//
            err=198;
            //—-198—-//

        );):((xp&0x1)?(

            //—-197—-//
            err=197;
            //—-197—-//

        ):(

            //—-196—-//
            err=196;
            //—-196—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-195—-//
            err=195;
            //—-195—-//

        ):(

            //—-194—-//
            err=194;
            //—-194—-//

        );):((xp&0x1)?(

            //—-193—-//
            err=193;
            //—-193—-//

        ):(

            //—-192—-//
            err=192;
            //—-192—-//

        ););););););):((xp&0x20)?((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-191—-//
            err=191;
            //—-191—-//

        ):(

            //—-190—-//
            err=190;
            //—-190—-//

        );):((xp&0x1)?(

            //—-189—-//
            err=189;
            //—-189—-//

        ):(

            //—-188—-//
            err=188;
            //—-188—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-187—-//
            err=187;
            //—-187—-//

        ):(

            //—-186—-//
            err=186;
            //—-186—-//

        );):((xp&0x1)?(

            //—-185—-//
            err=185;
            //—-185—-//

        ):(

            //—-184—-//
            err=184;
            //—-184—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-183—-//
            err=183;
            //—-183—-//

        ):(

            //—-182—-//
            err=182;
            //—-182—-//

        );):((xp&0x1)?(

            //—-181—-//
            err=181;
            //—-181—-//

        ):(

            //—-180—-//
            err=180;
            //—-180—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-179—-//
            err=179;
            //—-179—-//

        ):(

            //—-178—-//
            err=178;
            //—-178—-//

        );):((xp&0x1)?(

            //—-177—-//
            err=177;
            //—-177—-//

        ):(

            //—-176—-//
            err=176;
            //—-176—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-175—-//
            err=175;
            //—-175—-//

        ):(

            //—-174—-//
            err=174;
            //—-174—-//

        );):((xp&0x1)?(

            //—-173—-//
            err=173;
            //—-173—-//

        ):(

            //—-172—-//
            err=172;
            //—-172—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-171—-//
            err=171;
            //—-171—-//

        ):(

            //—-170—-//
            err=170;
            //—-170—-//

        );):((xp&0x1)?(

            //—-169—-//
            err=169;
            //—-169—-//

        ):(

            //—-168—-//
            err=168;
            //—-168—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-167—-//
            err=167;
            //—-167—-//

        ):(

            //—-166—-//
            err=166;
            //—-166—-//

        );):((xp&0x1)?(

            //—-165—-//
            err=165;
            //—-165—-//

        ):(

            //—-164—-//
            err=164;
            //—-164—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-163—-//
            err=163;
            //—-163—-//

        ):(

            //—-162—-//
            err=162;
            //—-162—-//

        );):((xp&0x1)?(

            //—-161—-//
            err=161;
            //—-161—-//

        ):(

            //—-160—-//
            err=160;
            //—-160—-//

        );););););):((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-159—-//
            err=159;
            //—-159—-//

        ):(

            //—-158—-//
            err=158;
            //—-158—-//

        );):((xp&0x1)?(

            //—-157—-//
            err=157;
            //—-157—-//

        ):(

            //—-156—-//
            err=156;
            //—-156—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-155—-//
            err=155;
            //—-155—-//

        ):(

            //—-154—-//
            err=154;
            //—-154—-//

        );):((xp&0x1)?(

            //—-153—-//
            err=153;
            //—-153—-//

        ):(

            //—-152—-//
            err=152;
            //—-152—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-151—-//
            err=151;
            //—-151—-//

        ):(

            //—-150—-//
            err=150;
            //—-150—-//

        );):((xp&0x1)?(

            //—-149—-//
            err=149;
            //—-149—-//

        ):(

            //—-148—-//
            err=148;
            //—-148—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-147—-//
            err=147;
            //—-147—-//

        ):(

            //—-146—-//
            err=146;
            //—-146—-//

        );):((xp&0x1)?(

            //—-145—-//
            err=145;
            //—-145—-//

        ):(

            //—-144—-//
            err=144;
            //—-144—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-143—-//
            err=143;
            //—-143—-//

        ):(

            //—-142—-//
            err=142;
            //—-142—-//

        );):((xp&0x1)?(

            //—-141—-//
            err=141;
            //—-141—-//

        ):(

            //—-140—-//
            err=140;
            //—-140—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-139—-//
            err=139;
            //—-139—-//

        ):(

            //—-138—-//
            err=138;
            //—-138—-//

        );):((xp&0x1)?(

            //—-137—-//
            err=137;
            //—-137—-//

        ):(

            //—-136—-//
            err=136;
            //—-136—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-135—-//
            err=135;
            //—-135—-//

        ):(

            //—-134—-//
            err=134;
            //—-134—-//

        );):((xp&0x1)?(

            //—-133—-//
            err=133;
            //—-133—-//

        ):(

            //—-132—-//
            err=132;
            //—-132—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-131—-//
            err=131;
            //—-131—-//

        ):(

            //—-130—-//
            auxKmd = 20 | (1 << 16) ; //  Delay next work by some frames; operation has 1 parameter
            //—-130—-//

        );):((xp&0x1)?(

            //—-129—-//
            auxKmd = 19 ; // Stop delaying the script; operation has no parameter
            //—-129—-//

        ):(

            //—-128—-//
            auxKmd = 18 ; // stop script; operation has no parameter
            //—-128—-//

        );););););););):((xp&0x40)?((xp&0x20)?((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-127—-//
            err=127;
            //—-127—-//

        ):(

            //—-126—-//
            auxKmd = 16 | (1 << 16) ; // Perform a specific REAPER action
            //—-126—-//

        );):((xp&0x1)?(

            //—-125—-//
            auxKmd = 15 | (1 << 16) ; // Perform a specific REAPER action
            //—-125—-//

        ):(

            //—-124—-//
            auxKmd = 14 ; // Get the playrate of the project.
            //—-124—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-123—-//
            auxKmd = 13 ; // Moves the cursor to the start of the project.
            //—-123—-//

        ):(

            //—-122—-//
            auxKmd = 12 | (1 << 16) ; // Change the position of the edit-cursor in the current project. play at new position
            //—-122—-//

        );):((xp&0x1)?(

            //—-121—-//
            auxKmd = 11 | (1 << 16); // Change the position of the edit-cursor in the current project. keep old position
            //—-121—-//

        ):(

            //—-120—-//
            auxKmd = 10 ; // get the editcursor-position in seconds
            //—-120—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-119—-//
            auxKmd = 9 ; // returns, in which play-state the current project is &1=playing,&2=pause,&=4 is recording
            // 0, stop ; 1, play ; 2, paused play ; 5, recording ; 6, paused recording
            //—-119—-//

        ):(

            //—-118—-//
            auxKmd = 8 ; // returns position of next audio block being processed
            //—-118—-//

        );):((xp&0x1)?(

            //—-117—-//
            auxKmd = 7 ; // get the playposition in seconds
            //—-117—-//

        ):(

            //—-116—-//
            auxKmd = 6 ; // Toggles pause/play during play or pause/rec during recording in the current project. When stopped, it will start paused play.
            //—-116—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-115—-//
            auxKmd = 5 ; // Stops playing/recording.
            //—-115—-//

        ):(

            //—-114—-//
            auxKmd = 4 ; // Starts playing at edit-cursor. Will stop recording, when executed during recording.
            //—-114—-//

        );):((xp&0x1)?(

            //—-113—-//
            auxKmd = 3 | (1 << 16) ; // Jump to a marker in markers order - Par1 is the marker number
            //—-113—-//

        ):(

            //—-112—-//
            auxKmd = 2 | (1 << 16) ; // Jump to a marker in read order - Par1 is the marker number
            //—-112—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-111—-//
            auxKmd = 1 | (1 << 16) ; // exec script func 1; get previous Script trace
            //—-111—-//

        ):(

            //—-110—-//
            auxRes = Unavailable; // not available
            //—-110—-//

        );):((xp&0x1)?(

            //—-109—-//
            auxRes = Unavailable; // not available
            //—-109—-//

        ):(

            //—-108—-//
            auxRes = Unavailable; // not available
            //—-108—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-107—-//
            auxRes = Unavailable; // not available
            //—-107—-//

        ):(

            //—-106—-//
            auxRes = gmem[workToDo] > 0 ; // script is currently delaying its work
            //—-106—-//

        );):((xp&0x1)?(

            //—-105—-//
            auxRes = gmem[dateDone] > gmem[dateRqst]; // last work asked has been performed
            //—-105—-//

        ):(

            //—-104—-//
            // Get script last return
            (gmem[dateDone] > gmem[dateCfrm]) ? (
                auxRes = gmem[rtrnVal1];
            ) : (
                auxRes = Unavailable; // not available
            );
            //—-104—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-103—-//
            // Get script return "x"
            p = max(-64, min(16, 0|zz[0])); zz += 1; ccnt -= 1;
            (gmem[dateDone] > gmem[dateCfrm]) ? (
                auxRes = gmem[rtrnVal1+p];
            ) : (
                auxRes = Unavailable; // not available
            );
            //—-103—-//

        ):(

            //—-102—-//
            // Get script traces
            auxRes = gmem[scptTrcs];
            //—-102—-//

        );):((xp&0x1)?(

            //—-101—-//
            auxRes = gmem[versionGMScript]; // return script version
            //—-101—-//

        ):(

            //—-100—-//
            err=100;
            //—-100—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-99—-//
            err=99;
            //—-99—-//

        ):(

            //—-98—-//
            err=98;
            //—-98—-//

        );):((xp&0x1)?(

            //—-97—-//
            err=97;
            //—-97—-//

        ):(

            //—-96—-//
            err=96;
            //—-96—-//

        );););););):((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-95—-//
            err=95;
            //—-95—-//

        ):(

            //—-94—-//
            err=94;
            //—-94—-//

        );):((xp&0x1)?(

            //—-93—-//
            err=93;
            //—-93—-//

        ):(

            //—-92—-//
            err=92;
            //—-92—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-91—-//
            err=91;
            //—-91—-//

        ):(

            //—-90—-//  // Delay next work by some frames
            auxKmd = 20 | (1 << 16) ; // operation has 1 parameter
            //—-90—-//

        );):((xp&0x1)?(

            //—-89—-// // Stop delaying the script
            auxKmd = 19 ; // operation has no parameter
            //—-89—-//

        ):(

            //—-88—-// aka 0x12 : stop script
            auxKmd = 18 ; // operation has no parameter
            //—-88—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-87—-//
            err=87;
            //—-87—-//

        ):(

            //—-86—-//
            auxKmd = 16 | (1 << 16) ; // operation has 1 parameter
            //—-86—-//

        );):((xp&0x1)?(

            //—-85—-//
            auxKmd = 15 | (1 << 16) ; // operation has 1 parameter
            //—-85—-//

        ):(

            //—-84—-//
            auxKmd = 14 ; // operation has no parameter
            //—-84—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-83—-//
            auxKmd = 13 ; // operation has no parameter
            //—-83—-//

        ):(

            //—-82—-//
            auxKmd = 12 | (1 << 16) ; // operation has 1 parameter
            //—-82—-//

        );):((xp&0x1)?(

            //—-81—-//
            auxKmd = 11 | (1 << 16); // operation has 1 parameter
            //—-81—-//

        ):(

            //—-80—-//
            auxKmd = 10 ; // operation has no parameter
            //—-80—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-79—-//
            auxKmd = 9 ; // operation has no parameter
            //—-79—-//

        ):(

            //—-78—-//
            auxKmd = 8 ; // operation has no parameter
            //—-78—-//

        );):((xp&0x1)?(

            //—-77—-//
            auxKmd = 7 ; // operation has no parameter
            //—-77—-//

        ):(

            //—-76—-//
            auxKmd = 6 ; // operation has no parameter
            //—-76—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-75—-//
            auxKmd = 5 ; // operation has no parameter
            //—-75—-//

        ):(

            //—-74—-//
            auxKmd = 4 ; // exec script func 4; it has no parameter
            //—-74—-//

        );):((xp&0x1)?(

            //—-73—-//
            auxKmd = 3 | (1 << 16) ; // exec script func 3; it has 1 parameter
            //—-73—-//

        ):(

            //—-72—-//
            auxKmd = 2 | (1 << 16) ; // exec script func 2; it has 1 parameter
            //—-72—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-71—-//
            auxKmd = 1 | (1 << 16) ; // exec script func 1; it has 1 parameter
            //—-71—-//

        ):(

            //—-70—-//
            auxRes = Unavailable; // not available
            //—-70—-//

        );):((xp&0x1)?(

            //—-69—-//
            auxRes = Unavailable; // not available
            //—-69—-//

        ):(

            //—-68—-//
            auxRes = Unavailable; // not available
            //—-68—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-67—-//
            auxRes = Unavailable; // not available
            //—-67—-//

        ):(

            //—-66—-//
            auxRes = gmem[workToDo] > 0 ; // script is currently delaying its work
            //—-66—-//

        );):((xp&0x1)?(

            //—-65—-//
            auxRes = gmem[dateDone] > gmem[dateRqst]; // last work asked has been performed
            //—-65—-//

        ):(

            //—-64—-//
            // Get script last return
            (gmem[dateDone] > gmem[dateCfrm]) ? (
                auxRes = gmem[rtrnVal1];
            ) : (
                auxRes = Unavailable; // not available
            );
            //—-64—-//

        ););););););):((xp&0x20)?((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-63—-//
            // Get script return "x"
            p = max(-64, min(16, 0|zz[0])); zz += 1; ccnt -= 1;
            (gmem[dateDone] > gmem[dateCfrm]) ? (
                auxRes = gmem[rtrnVal1+p];
            ) : (
                auxRes = Unavailable; // not available
            );
            //—-63—-//

        ):(

            //—-62—-//
            // Get script traces
            auxRes = gmem[scptTrcs];
            //—-62—-//

        );):((xp&0x1)?(

            //—-61—-//
            auxRes = gmem[versionGMScript]; // return script version
            //—-61—-//

        ):(

            //—-60—-// 359 Notify process -
            // Notify `recipient `messname p1 p2 ...
            par1 = zz[0]; zz += 1; ccnt -= 1;  // recipient name
            par2 = zz[0]; zz += 1; ccnt -= 1; // message name
            par3 = zz[0]; zz += 1; ccnt -= 1;  // delay before send
            par4 = zz[0]; zz += 1; ccnt -= 1; // evnt flags
            par5 = zz[0]; zz += 1; ccnt -= 1; // evnt code
            par6 = zz[0]; zz += 1; ccnt -= 1; // evnt p1
            par7 = zz[0]; zz += 1; ccnt -= 1; // evnt p2
            par8 = zz[0]; zz += 1; ccnt -= 1; // evnt p3
            (flgs & 0x08) ? (sprintf(#s, "   A 358 Notify [send %s to %s]", mSL_edit_value(#, par2), mSL_edit_value(#,par1));
            mSL_log(SysLogBox, #s););
            event_Notify(0, 0, mSL_KW_Sensors, 0, par1, par2, par3, evnt_ttl, par4, par5, par6, par7, par8);
            //—-60—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-59—-// 358 "Play clip from Set Limited" "PlFrSetL"
            // Get one parameter, a set number, and play a clip from this set
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            par2 = zz[0];
            (par2 > 0) ? (
                zz[0] = 0|par2 - 1;
                GvPlayCl0 = clipFromSet(par1);
                GvPlayPart = 0;
                noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
                // 0 ? (sprintf(#s, "   A 358 [%d => %f]", par1, GvPlayCl0); mSL_log(SysLogBox, #s););
                KSource = 0358;
                doPlayClip(0, GvPlayCl0, GvPlFlTemp, GvPlayTypClip, 0);
                noInterrupt = 0;
                GvPlFlTemp = GvPlFlDefault;
            );
            zz += 1; ccnt -= 1;
            //—-59—-//

        ):(

            //—-58—-// 357 "Play clip from Set" "PlFrSet"
            // Get one parameter, a set number, and play a clip from this set
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            GvPlayCl0 = clipFromSet(par1);
            GvPlayPart = 0;
            noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
            // (sprintf(#s, "   A 357 [%d => %f]", par1, GvPlayCl0); mSL_log(SysLogBox, #s););
            KSource = 0357;
            doPlayClip(0, GvPlayCl0, GvPlFlTemp, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            //—-58—-//

        );):((xp&0x1)?(

            //—-57—-// 356
            pindx = zz;
            (pindx[0] >= ACPTrTAB) ? pindx = pindx[0]; // using indirection
            zz += 1; ccnt -= 1;
            ssiz = getpos(zz, -111, 128); // find -111 in "zz"
            entc = 0|(ssiz / 4);
            (pindx[0] < entc) ? (
                pos = zz + 4 * pindx[0];
                // On choisit une variation de volume
                reSelectVolume = pos[2];
                pos[1] > 0 ? (
                    // On choisit une durée de verrouillage
                    padSensInhib[currSens-1] = 1;
                    Schedule(SchedRelative, pos[1], 2, currSens, 0, 0, 0);
                );
                // Autres paramètres - fixés
                // On joue le clip
                GvPlayCl0 = par1 = pos[0];
                GvPlayPart = 0;
                // doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
                KSource = 0356;
                doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
                pindx[0] = pindx[0] + 1;
            );
            zz += ssiz+1; ccnt -= ssiz+1;
            GvPlFlTemp = GvPlFlDefault;
            //—-57—-//

        ):(

            //—-56—-// 355
            // Play one random clip in the sequence
            pindx = zz; //  position of the counter;
            (pindx[0] >= ACPTrTAB) ? pindx = pindx[0]; // using indirection
            zz += 1; ccnt -= 1;
            ssiz = getpos(zz, -1, 32); // find -1 in "zz"
            (pindx[0] > 0) ? (
                par1 = getrandelt(zz, ssiz); // get one element at random
                pindx[0] = pindx[0] - 1;
                GvPlayCl0 = par1;
                GvPlayPart = 0;
                noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
                // doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
                KSource = 0355;
                doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
                noInterrupt = 0;
                GvPlFlTemp = GvPlFlDefault;
            );
            zz += ssiz+1; ccnt -= ssiz+1;
            //—-56—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-55—-// 354
            // Play once a full sequence of clips, one by one
            pindx = zz; //  position of the index;
            (pindx[0] >= ACPTrTAB) ? pindx = pindx[0]; // using indirection
            zz += 1; ccnt -= 1;
            ssiz = getpos(zz, -1, 32); // find -1 in "zz", default 32
            u = pindx[0];
            (flgs & 4) ? (
                sprintf(#sfc, "Act. 55/354:  idx: %d  siz: %d", u, ssiz);
                mSL_log(SysLogBox, #sfc);
            );
            (pindx[0] < ssiz) ? (
                GvPlayCl0 = par1 = zz[pindx[0]];
                GvPlayPart = 0;
                (flgs & 4) ? (
                    sprintf(#sfc, "Act. 55/354:  Play:%d    Cmd: %d    %d", GvPlayCl0, cmdClMdBase + GvPlayTypClip, GvPlFlTemp);
                    mSL_log(SysLogBox, #sfc);
                );
                noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
                // doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
                KSource = 0354;
                doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
                noInterrupt = 0;
                GvPlFlTemp = GvPlFlDefault;
                pindx[0] = pindx[0] + 1;
            );
            zz += ssiz+1; ccnt -= ssiz+1;
            //—-55—-//

        ):(

            //—-54—-// 353
            // Round robin on a sequence of clips
            pindx = zz; //  position of the index;
            (pindx[0] >= ACPTrTAB) ? pindx = pindx[0]; // using indirection
            zz += 1; ccnt -= 1;
            ssiz = getpos(zz, -1, 32); // find -1 in "zz", default 32
            u = pindx[0];
            (flgs & 4) ? (
                sprintf(#sfc, "Act. 54/353:  idx: %d  siz: %d", u, ssiz);
                mSL_log(SysLogBox, #sfc);
            );
            GvPlayCl0 = par1 = zz[pindx[0]];
            GvPlayPart = 0;
            (flgs & 4) ? (
                sprintf(#sfc, "Act. 54/353:  Play:%d    Cmd: %d    %d", GvPlayCl0, cmdClMdBase + GvPlayTypClip, GvPlFlTemp);
                mSL_log(SysLogBox, #sfc);
            );
            // doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
            KSource = 0353;
            doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            pindx[0] = (pindx[0] + 1) % ssiz;
            zz += ssiz+1; ccnt -= ssiz+1;
            //—-54—-//

        );):((xp&0x1)?(

            //—-53—-// 352
            // Get two parameters, a clip number, a set of flags, and play it
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            par2 = zz[0];
            zz += 1; ccnt -= 1;
            //GvPlayCl0 = par1;
            //GvPlayPart = 0;
            //noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
            // doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
            KSource = 0352;
            doPlayClip(0, par1, par2, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            //—-53—-//

        ):(

            //—-52—-// 351
            // Play one clip in the sequence
            ssiz = getpos(zz, -1, 32); // find -1 in "zz", default 32
            par1 = getrandelt(zz, ssiz); // get one element at random
            zz += ssiz+1; ccnt -= ssiz+1;
            //GvPlayCl0 = par1;
            //GvPlayPart = 0;
            //doPlayCmd(cmdClMdBase + GvPlayTypClip, GvPlFlTemp, GvPlayCl0, GvPlayPart);
            KSource = 0351;
            doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            //—-52—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-51—-// 350
            // Get one parameter, a clip number, and play it unmodified
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            GvPlayCl0 = par1;
            GvPlayPart = 0;
            noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
            /*
            doPlayCmd(cmdClMdBase + GvPlayTypClip, noInterrupt+1+4+32, GvPlayCl0, GvPlayPart);
            */
            KSource = 0350;
            doPlayClip(0, par1, noInterrupt|1|4|32, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            //—-51—-//

        ):(

            //—-50—-// 349
            // Get one parameter, a clip number, and play it
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            GvPlayCl0 = par1;
            GvPlayPart = 0;
            noInterrupt |= FlgnoInterrupt & GvPlFlTemp;
            KSource = 0349;
            doPlayClip(0, par1, GvPlFlTemp, GvPlayTypClip, 0);
            noInterrupt = 0;
            GvPlFlTemp = GvPlFlDefault;
            /*
            doPlayCmd(cmdClMdBase + GvPlayTypClip, 0, GvPlayCl0, GvPlayPart);
            */
            //—-50—-//

        );):((xp&0x1)?(

            //—-49—-// 348
            // Lock current sensor - Get the time to lock
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            padSensInhib[currSens-1] = 1;
            SchedRemove(SchedDlydPts, 2, uix_bit_set[currSens - 1]); // remove previous
            Schedule(SchedRelative, par1, 2, uix_bit_set[currSens - 1], 0, 0, 0); // schedule release in "par2" seconds
            //—-49—-//

        ):(

            //—-48—-// 347
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            parSet(p_Vol_Global, par1);
            //—-48—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-47—-// 346
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            parSet(p_VolGlobBias, par1);
            //—-47—-//

        ):(

            //—-46—-// 345
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            par2 = 0|zz[0];
            zz += 1; ccnt -=1;
            Schedule(SchedRelative, par2, 4, par1, 0, 0, 0); // schedule
            //—-46—-//

        );):((xp&0x1)?(

            //—-45—-// 344
            // release all sensors
            releaseSensors(-1);
            SchedRemove(SchedDlydPts, 2); // remove all codes "2"
            //—-45—-//

        ):(

            //—-44—-// 343
            AddDummyMIDIIn(0);
            //—-44—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-43—-// 342
            // Get one parameter, a sensor to lock
            // get a 2nd param, the time to lock
            v = par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            par2 = 0|zz[0];
            zz += 1; ccnt -=1;
            (par1 <= 0) ? (
                v1 = 0;
                loop(padSensMaxSiz,
                    padSensInhib[v1] = 1;
                    v1 += 1;
                );
            ) :
            ((par1 >= 1) && (par1 <= padSensSiz)) ? (
                padSensInhib[par1 - 1] = 1;
                v = uix_bit_set[par1 - 1];
            );
            SchedRemove(SchedDlydPts, 2, v); // remove previous
            Schedule(SchedRelative, par2, 2, v, 0, 0, 0); // schedule release in "par2" seconds
            //—-43—-//

        ):(

            //—-42—-// 341
            // Get one parameter, a new MIDI mode
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            MIDI_Sens_mode = max(0, min(MIDI_States_siz - 1, par1));
            releaseSensors(-1);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            SchedRemove(SchedDlydPts, 2); // remove any previous release task
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-42—-//

        );):((xp&0x1)?(

            //—-41—-// 340
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            //—-41—-//

        ):(

            //—-40—-// 339
            // Unlock a set of sensors
            jj = 0|zz[0]; zz += 1; ccnt -=1;
            ii = 0;
            loop(padSensMaxSiz,
                (jj & 1) ? (
                    padSensInhib[ii] = 0;
                );
                ii += 1; jj = jj >> 1;
            );
            //—-40—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-39—-// 338
            // Copier un partiel en "0"
            k =  0|zz[0]; zz += 1; ccnt -= 1;
            (k > 1000) ? (
                k = BKSelectParts(0|(k/1000), k%1000, 0);
            );
            ((k > 0) & (k < BKDEcnt)) ? (
                memcpy(BKTab, BKTab + k*BKEsize, BKEsize);
                0 ? (
                b = BKTab;
                sprintf(#s2, "**P1  %d %d %d %d --- %d %d %d %d", b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
                mSL_log(SysLogBox, #s2);
                );
            );
            //—-39—-//

        ):(

            //—-38—-// 337
            // Get one parameter, a set of sensors to lock
            // get a 2nd param, the time to lock
            par1 = 0|zz[0];

            zz += 1; ccnt -=1;
            par2 = 0|zz[0];
            zz += 1; ccnt -=1;
            ii = 0; jj = par1;
            loop(padSensMaxSiz,
                (jj & 1) ? (
                    padSensInhib[ii] = 1;
                );
                ii += 1; jj = jj >> 1;
            );

            SchedRemove(SchedDlydPts, 2, par1); // remove previous
            Schedule(SchedRelative, par2, 2, par1, 0, 0, 0); // schedule release in "par2" seconds

            //—-38—-//

        );):((xp&0x1)?(

            //—-37—-// 336
            // Trace a string passed as parameter
            sprintf(#s, "A> %s", zz[0]);
            mSL_log(SysLogBox, #s);
            zz += 1; ccnt -= 1;
            //—-37—-//

        ):(

            //—-36—-// 335
            // Conditional execution of the rest of the sequence
            // Probablity in [0 1]
            // 335, Probability, ...
            par1 = zz[0]; zz += 1; ccnt -=1;
            (par1 > frand()) ? (ccnt = 0);
            //—-36—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-35—-// 334
            // Delay the rest of the sequence...
            // 334, 60, 0, ....  delay for 60 seconds
            par1 = zz[0]; zz += 1; ccnt -=1;
            ((ccnt > 1) && (par1 > 0)) ? (
                zz[0] = ccnt - 1;
                Schedule(SchedRelative, par1, 9, zz, 0, 0, 0);
            );
            ccnt = 0;
            //—-35—-//

        ):(

            //—-34—-// 333
            par1 = 0|zz[0];
            zz += 1; ccnt -=1;
            par2 = 0|zz[0];
            zz += 1; ccnt -=1;
            parSet(par1, par2);
            //—-34—-//

        );):((xp&0x1)?(

            //—-33—-// 332
            ssiz = getpos(zz, -1, 32); // find -1 in "zz", default 32
            par1 = getrandelt(zz, ssiz); // get one element at random
            zz += ssiz+1; ccnt -= ssiz+1;
            AddDummyMIDIImm(par1);
            //—-33—-//

        ):(

            //—-32—-// 331
            // set Max players
            v1 = zz[0];
            (v1 <= 0) ? (
                UplayControl = 0;
            ) : (
                UplayControl = 1;// p_Play_Max
                parSet(p_Play_Max, v1);
            );
            zz += 1; ccnt -= 1;
            //—-32—-//

        );););););):((xp&0x10)?((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-31—-// 330
            reSelectGrFades = zz[0];
            zz += 1; ccnt -= 1;
            //—-31—-//

        ):(

            //—-30—-// 329
            noInterrupt = FlgnoInterrupt;
            //—-30—-//

        );):((xp&0x1)?(

            //—-29—-// 328
            reSelectVolume = zz[0];
            zz += 1; ccnt -= 1;
            //—-29—-//

        ):(

            //—-28—-// 327
            reSelectDuration = zz[0];
            zz += 1; ccnt -= 1;
            //—-28—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-27—-// 326
            reSelectPartial = k =  zz[0];
            (k > 1000) ? (
                reSelectPartial = BKSelectParts(0|(k/1000), k%1000, 0);
            );
            zz += 1; ccnt -= 1;
            //—-27—-//

        ):(

            //—-26—-// 325
            reSelectHpent = zz[0];
            zz += 1; ccnt -= 1;
            //—-26—-//

        );):((xp&0x1)?(

            //—-25—-// 324
            // Get one parameter, a Play mode,
            // and change partial zero
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            BKTab[idx_Pa_PlM] = GvPlayPM = par1;

            0 ? (
            b = BKTab;
            sprintf(#s2, "**P2  %d %d %d %d --- %d %d %d %d", b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
            mSL_log(SysLogBox, #s2);
            );
            //—-25—-//

        ):(

            //—-24—-// 323
            // Get one parameter, a Space mode,
            // and change partial zero
            par1 = zz[0];
            zz += 1; ccnt -= 1;
            BKTab[idx_Pa_SpM] = GvPlaySM = par1;

            0 ? (
            b = BKTab;
            sprintf(#s2, "**P3  %d %d %d %d --- %d %d %d %d", b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
            mSL_log(SysLogBox, #s2);
            );
            //—-24—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-23—-// 322
            reSelectPlayMode = zz[0];
            zz += 1; ccnt -= 1;
            //—-23—-//

        ):(

            //—-22—-// 321
            reSelectSpaceMode = zz[0];
            zz += 1; ccnt -= 1;
            //—-22—-//

        );):((xp&0x1)?(

            //—-21—-// 320 PlayGrp
            doPlayCmd(cmdClMdBase + GvPlayTypGroup);
            parSet(p_GvAutoMd, 0);
            //—-21—-//

        ):(

            //—-20—-// 319
            MIDI_Sens_mode = (MIDI_Sens_mode - 1 + MIDI_States_siz) % MIDI_States_siz;
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-20—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-19—-// 318
            MIDI_Sens_mode = (MIDI_Sens_mode + 1) % MIDI_States_siz;
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-19—-//

        ):(

            //—-18—-// 317
            MIDI_Sens_mode = 7;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-18—-//

        );):((xp&0x1)?(

            //—-17—-// 316
            MIDI_Sens_mode = 6;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-17—-//

        ):(

            //—-16—-// 315
            MIDI_Sens_mode = 5;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-16—-//

        ););););):((xp&0x8)?((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-15—-// 314
            MIDI_Sens_mode = 4;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-15—-//

        ):(

            //—-14—-// 313
            MIDI_Sens_mode = 3;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-14—-//

        );):((xp&0x1)?(

            //—-13—-// 312
            MIDI_Sens_mode = 2;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-13—-//

        ):(

            //—-12—-// 311
            MIDI_Sens_mode = 1;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-12—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-11—-// 310
            MIDI_Sens_mode = 0;
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
            parSet(p_GvAutoMd, 0);
            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
            //—-11—-//

        ):(

            //—-10—-// 309
            // Set default flags
            GvPlFlDefault = GvPlFlTemp = 0|zz[0];
            zz += 1; ccnt -= 1;
            //—-10—-//

        );):((xp&0x1)?(

            //—-9—-// 308
            // Set temporary flags
            GvPlFlTemp = 0|zz[0];
            zz += 1; ccnt -= 1;
            //—-9—-//

        ):(

            //—-8—-// 307
            // switch to next group
            GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', GvPlayGrp +1, 0);
            //—-8—-//

        );););):((xp&0x4)?((xp&0x2)?((xp&0x1)?(

            //—-7—-// 306
            // switch to group "x"
            v1 = zz[0];
            zz += 1; ccnt -= 1;
            GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', v1, 0);
            //—-7—-//

        ):(

            //—-6—-// 305
            gmem[APCdispvalue] = MIDI_Sens_mode + 10;
            //—-6—-//

        );):((xp&0x1)?(

            //—-5—-// 304
            parSet(p_GvAutoMd, 0); // Auto Play off
            doActivePlayer(-1, KmdQStop, 0);  // stop all players
            releaseSensors(-1);
            //—-5—-//

        ):(

            //—-4—-// 303
            doActivePlayer(-1, KmdQStop, 0);  // stop all players
            //—-4—-//

        ););):((xp&0x2)?((xp&0x1)?(

            //—-3—-// 302
            parSet(p_GvAutoMd, 1 - parV(p_GvAutoMd)); // invert Auto Play
            //—-3—-//

        ):(

            //—-2—-// 301
            parSet(p_GvAutoMd, 1); // Auto Play on
            //—-2—-//

        );):((xp&0x1)?(

            //—-1—-// 300
            parSet(p_GvAutoMd, 0); // Auto Play off
            //—-1—-//

        ):(

            //—-0—-//
            act=0;
            //—-0—-//

        ););););););););


        // Is there a command for the auxiliary external processor ?
        (auxKmd != 0) ? (
            gmem[cmndKode] = auxKmd & 0xFF; gmem[cmndPar1] = zz[0]; gmem[cmndPar2] = zz[1]; gmem[cmndPar3] = zz[1];
            ((p = (auxKmd >> 16) & 0xf) > 0) ? ( // number of arguments
                zz += p; ccnt -= p;
            );
            gmem[dateRqst] = gmem[dateCfrm] = time_precise() + timeD;
        );

        xp = zz[0]; zz += 1;

    );

    (err != 0) ? (
        - err;
    ) : (
        (auxRes === Undef) ? ccnt : auxRes;
    );
);



function Simple_Action(code, seq)
(
    Simple_temp[0] = 1;
    Simple_temp[1] = code;
    Simple_temp[2] = seq[0];
    Simple_temp[3] = seq[1];
    Simple_temp[4] = seq[2];
    Simple_temp[5] = seq[3];
    Simple_temp[6] = seq[4];
    Simple_temp[7] = seq[5];
    Simple_temp[8] = seq[6];
    Simple_Action(Simple_temp);
);



function sysout(logbox)
local (i, j, k, l, m, dst, ss, bsiz, s1st)
(
    (gmem[versionGMScript] != 0) ? (
        // Edit the name of the file to print
        l = strlen(bn = logbox[9]);
        dst = xplStr2;
        i = 0; while (l > 0) (
            gmem[dst+i] = str_getchar(bn, i, 'cu');
            i += 1; l -= 1;
        );
        // construct the name
        gmem[dst+i] = '-'; i += 1;
        ss = nowIs();
        gmem[dst+i] = str_getchar(ss, 6, 'cu'); i += 1;
        gmem[dst+i] = str_getchar(ss, 7, 'cu'); i += 1;
        gmem[dst+i] = str_getchar(ss, 8, 'cu'); i += 1;
        gmem[dst+i] = str_getchar(ss, 9, 'cu'); i += 1;
        gmem[dst+i] = '-'; i += 1;
        gmem[dst+i] = str_getchar(ss, 3, 'cu'); i += 1;
        gmem[dst+i] = str_getchar(ss, 4, 'cu'); i += 1;
        gmem[dst+i] = '-'; i += 1;
        gmem[dst+i] = str_getchar(ss, 0, 'cu'); i += 1;
        gmem[dst+i] = str_getchar(ss, 1, 'cu'); i += 1;
        l = strlen(ss) - 10;
        j = 10; while (l > 0) (
            c = str_getchar(ss, j, 'cu');
            ((c < '0') || (c > '9')) ? (c = '-';) ;
            gmem[dst+i] = c;
            i += 1; l -= 1; j += 1;
        );
        gmem[dst+i-1] = 'txt.';
        gmem[dst+i] = 0;
        // mSL_g6unpackArray(#s, dst, 0);
        // mSL_log(SysLogBox, #s);


        // ready to output the contents
        bsiz = logbox[2]; s1st = logbox[1]; k = logbox[3];
        i = 0; j = 0; l = 0; m = 0;
        dst = infoBStarts;

        k = 1;
        while ((i < bsiz) && (j < infoBSize)) (
            #txt = s1st + k;
            j = mSL_g6packStr(dst, #txt, j, infoBSize, 7); k = (k + 1) % bsiz; i += 1;
        );

        gmem[scptPar2] = xplStr2;
        gmem[scptPar3] = infoBStarts;

        gmem[dateRqst] = gmem[dateCfrm] = time_precise() + timeD;
        gmem[cmndKode] = 30;
    ) : (
        mSL_log(SysLogBox, "No auxiliary script present");
    );
);



/*
    Events management operations
*/
function
mSL_event_ops(argc, argv)
local (res, kw, id, ent, k, p1, p2, p3)
(
    res = 0;
    ent = mSL_active_Thread[mSL_THR_SchedEnt]; // the scheduler entry

    (FlagsTbVals[Flgs_Evnts] & 1) ? (
        sprintf(#s, "  - mSL_event_ops  for %d/%d   argc=%d ", ent, (ent - SchedFirstEnt)/SchedEntSiz, argc);
        mSL_log(SysLogBox, #s);
    );
    (argc > 0) ? (
        kw = argv[0];
        (FlagsTbVals[Flgs_Evnts] & 1) ? (
            sprintf(#s, "  - mSL_event_ops  %s / %s ", mSL_edit_value(#, argv[0]), mSL_edit_value(#, argv[1]));
            mSL_log(SysLogBox, #s);
        );
        (kw === mSL_KW_check) ? (
            res = (SchedListNonEmpty(ent + SchedHQB));
        ) :
        ((kw === mSL_KW_wait) || (kw === mSL_KW_getnext)) ? (
            // Do we already have a message ?
            (SchedListNonEmpty(ent + SchedHQB)) ? (
                // return it
                res = SchedDetachHead(ent + SchedHQB);
                (FlagsTbVals[Flgs_Evnts] & 1) ? (
                sprintf(#s, "  --> SchedDetachHead  %d", res); mSL_log(SysLogBox, #s);
                );
            ) :
            (SchedDly[ent] < 0) ? (
                // a time-out has been notified
                SchedDly[ent] = 0;
                res = -1;
                (FlagsTbVals[Flgs_Evnts] & 1) ? (
                sprintf(#s, "  --> SchedDly[ent] < 0"); mSL_log(SysLogBox, #s);
                );

            ) : (
                // lets wait for one event ; first, a wait delay
                k = (argc > 1) ? argv[1] : evnt_ttw;
                k = (k <= 0) ? evnt_ttw : max(1, min(evnt_ttw * 4, k));
                SchedDly[ent] = time_precise() + timeD + k;
                SchedmSLEvWait = mSL_RC_WEvent;
            );
        ) :
        (kw === mSL_KW_find) ? (
            p1 = p2 = p3 = 0;
            (argc === 2) ? (
                p1 = argv[1]; p2 = 0; p3 = 2;
            ) :
            (argc === 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = 2;
            ) :
            (argc >= 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = argv[2];
            );
            res = event_check_recipient(p1, p2, p3);
        ) :
        (kw === mSL_KW_ready) ? (
            (argc >= 2) ? (
                res = event_ready_pid(argv[1]);
            );
        ) :
        (kw === mSL_KW_build) ? (
            (argc >= 14) ? (
                res = event_build_msg(argv[1], argv[2], argv[3], argv[4], argv[5],
                    argv[6], argv[7], argv[8], argv[9], argv[10], argv[11], argv[12], argv[13])
            );
        ) :
        (kw === mSL_KW_notify) ? (
            (argc >= 14) ? (
                res = event_Notify(argv[1], argv[2], argv[3], argv[4], argv[5],
                    argv[6], argv[7], argv[8], argv[9], argv[10], argv[11], argv[12], argv[13])
            );
        ) :
        (kw === mSL_KW_send) ? (
            (argc >= 2) ? (
                res = event_send_msg(argv[1]);
            );
        ) :
        (kw === mSL_KW_recycle) ? (
            (argc >= 2) ? (
                msg_recycle(argv[1], 3);
            );
            0 ? (
                sprintf(#s, "  - mSL_event_ops  recycle list size: %d", SchedListSize(SchedRcyclPts));
                mSL_log(SysLogBox, #s);
            );
            res = SchedListSize(SchedRcyclPts);
        ) :
        (kw === mSL_KW_count) ? (
            (argc === 2) ? (
                id = argv[1];
            ) : (
                id = 0;
            );
            p1 = res = 0; p2 = ent + SchedHQB;
            p3 = SchedPrvEnt[p2[SchedOtherEnd]]; // start at tailwhile
            ((p3 != p2) && (p3 >= SchedFirstEnt) && (p1 <= SchedNEmax)) ? (
                ((id === 0) || (id === p3[SchevEvntName])) ? siz += 1;
                p1 += 1;
                p3 = SchedPrvEnt[p3];
            );
        ) :
        (kw === mSL_KW_clearall) ? (
            // remove all pending messages
            while (SchedListNonEmpty(ent + SchedHQB)) (
                SchedDetachHead(ent + SchedHQB);
            );
        ) :
        (kw === mSL_KW_unchain) ? (
            (argc === 2) ? (
                k = argv[1]; p1 = k[SchedThList];
                SchedUnchainEnt(p1, k, 2);
            );
        );
    );
    (FlagsTbVals[Flgs_Evnts] & 1) ? (
        sprintf(#s, "  - mSL_event_ops `%s return: %s", mSL_edit_value(#, kw), mSL_edit_value(#, res));
        mSL_log(SysLogBox, #s);
    );
    res;
);


/*
    Threads management = single operation on thread
*/
function
mSL_thread_ops(argc, argv)
local (res, k, kw, ent)
(
    res = -1;
    (argc > 0) ? (
        kw = argv[0];
        //sprintf(#ms, "** kw ** => %g  %s", kw, mSL_edit_value(#mt, kw));
        //mSL_log(SysLogBox, #ms);
        // we expect a keyword
        (kw === mSL_KW_new) ? (
            // expect : `new, func, params...
            k = argv[1];
            //sprintf(#ms, "** new ** => %d/%d", k, mSL_bl_check(k));
            //mSL_log(SysLogBox, #ms);
            ((argc > 1) && mSL_bl_check(k) && (k[mSL_CC_Key] === mSL_CC_KeyCKod)) ? (
                // The func is supposed to have no locals and no parameters
                ((k[mSL_CC_ParCnt] === 0) && (k[mSL_CC_LocCnt] === 0)) ? (
                    // this is a correct func - load it in a new thread
                    ent = getNewThread();
                    //sprintf(#ms, "** ent ** => %d/%d", ent, KRun_mSL_Thread);
                    // mSL_log(SysLogBox, #ms);
                    ent ? (
                        SchedPar1[ent] = k; // keep the code to execute
                        SchedPar4[ent] = 0; // use std locals
                        SchedCode[ent] = KRun_mSL_Thread; // ready to start
                        mSL_init_thread(ent);
                        SchedInsertTail(SchedSuspPts, ent, SchETypeThrd);
                        res = ent[SchedPid]; // return the process ID
                    ) : (
                        mSL_errX = 2408; // can't get a thread
                    );
                ) : (
                    res = 2411; // invalid function type
                );
            ) : (
                res = 2415; // function expected
            );
        ) :
        (kw === mSL_KW_run) ? (
            // k = argv[1]; // the thread id contains the entry number
            // ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz; // points to "a" thread
            ((argc > 1) && (k = argv[1])
                && (ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz)
                && (k === ent[SchedPid])
            ) ? (
                // this is a correct reference
                // ent is supposed to be in SchedSuspPts !
                SchedUnchainEnt(SchedSuspPts, ent, SchETypeThrd);
                SchedStatus[ent] |= SchThrUsed;  // now in use
                // introduce in the active list
                SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
                (FlagsTbVals[Flgs_Thrds] & 4) ? ( // trace flags
                    sprintf(#ms, "** RUN ** [%g:%g] => %d/%d", ent, SchedThrdPt[ent], (floor(k/SchedNEmax)), (k & SchedNMask));
                    mSL_log(SysLogBox, #ms);
                );
                res = k; // done
            );
        ) :
        (kw === mSL_KW_idt) ? (
            ent = mSL_active_Thread[mSL_THR_SchedEnt];
            ((ent >= SchedFirstEnt) && (ent <= SchedLastEnt)) ? (
                res = ent[SchedPid]; // return the process ID
            );
        ) :
        (kw === mSL_KW_name) ? (
            ent = mSL_active_Thread[mSL_THR_SchedEnt];
            ((ent >= SchedFirstEnt) && (ent <= SchedLastEnt)) ? (
                res = ent[SchedThrName]; // return the process name
                (argc > 1) ? (
                    // use 2nd word as name
                    ent[SchedThrName] = argv[1];
                    (FlagsTbVals[Flgs_Thrds] & 4) ? (
                        sprintf(#ms, "  --> Name : %s", mSL_edit_value(0, ent[SchedThrName]));
                        mSL_log(SysLogBox, #ms);
                    );
                );
            );
        ) :
        (kw === mSL_KW_status) ? (
            k = argv[1]; // should be in SchedSuspPts !
            res = 0; // undefined
            ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz; // points to "a" thread
            ((k === ent[SchedPid]) && (argc > 1)) ? (
                res = SchedStatus[ent]; // done
            );
        ) :
        (kw === mSL_KW_find) ? (
            p1 = p2 = p3 = 0;
            (argc === 2) ? (
                p1 = argv[1]; p2 = 0; p3 = 2;
            ) :
            (argc === 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = 2;
            ) :
            (argc >= 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = argv[2];
            );
            res = event_check_recipient(p1, p2, p3);
        ) :
        (kw === mSL_KW_count) ? (
            (argc === 2) ? (
                kw = argv[1]; ent = SchedFirstEnt; res = 0;
                loop (SchedNEmax,
                    (SchedThrName[ent] === kw) && (SchedStatus[ent] != 0) ? res += 1;
                    ent += SchedEntSiz;
                );
            );
        ) :
        (
            res = -4007;
        );
    );
    res;
);// mSL_thread_ops


/*
    Play operations = single operation for playing in mSL
*/
function
mSL_play_ops(argc, argv)
local (kw, ksiz, clip, cllow, clhigh, par, pflgs, do_it, res, rty)
(
    //sprintf(#ms, "** mSL_play_ops ** => IN: %d/%d", argc, argv);
    //mSL_log(SysLogBox, #ms);
    reSelectPartial = reSelectPlayMode = reSelectHpent = reSelectHpent2 = reSelectDuration = reSelectHpSet =
    reSelectFadeOut = reSelectFadeIn =
    reSelectHpSet2 = reSelectRate = reSelectGrFades = reSelectVolume = reSelectSpaceMode = Undef;
    cllow = 0; clhigh = 9999;
    GPlUnit = UGDummy; // just for...
    rty = par = pflgs = 0;
    kw = 0; // reset kw
    res = -1; do_it = (argc > 0); // expect at least one command
    while ((argc > 0) && do_it) (
        kw = argv[0]; // The keyword introducing the command
        par = argv[1];
        ksiz = 2;  // a default size : kw + value
        //sprintf(#ms, "** mSL_play_ops ** => KW:%s   %g  %d/%d", mSL_edit_value(#sv, kw), par, argc, argv);
        //    mSL_log(SysLogBox, #ms);
        (kw === mSL_KW_clip) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (par >= 0) && (par <= 9999))) ? (
                clip = par;
            );
        ) :
        (kw === mSL_KW_vol) ? (
            par = argv[1];
            (par === Default) ? (
                par = 0;
            );
            (do_it = ((argc > 1) && (par >= -48) && (par <= 12))) ? (
                reSelectVolume = par;
            );
        ) :
        (kw === mSL_KW_plmode) ? (
            par = argv[1];
            (par === Default) ? (
                par = 0;
            );
            (do_it = ((argc > 1) && (par >= 0) && (par <= 999))) ? (
                reSelectPlayMode = par;
            );
        ) :
        (kw === mSL_KW_spmode) ? (
            par = argv[1];
            (par === Default) ? (
                par = 0;
            );
            (do_it = ((argc > 1) && (par >= 0) && (par <= 999))) ? (
                reSelectSpaceMode = par;
            );
        ) :
        (kw === mSL_KW_hpent) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (par >= 0) && (par <= 9999))) ? (
                (reSelectHpent === Undef) ?
                reSelectHpent = par :
                reSelectHpent2 = par;
            );
        ) :
        (kw === mSL_KW_hpset_) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (SharedLowMemory >= 0) && (par <= SharedHighMemory))) ? (
                (reSelectHpSet === Undef) ?
                reSelectHpSet = par :
                reSelectHpSet2 = par;
            );
        ) :
        (kw === mSL_KW_hpset2) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (SharedLowMemory >= 0) && (par <= SharedHighMemory))) ? (
                reSelectHpSet2 = par;
            );
        ) :
        (kw === mSL_KW_rate) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (par >= -10) && (par <= 10))) ? (
                reSelectRate = par;
            );
        ) :
        (kw === mSL_KW_part) ? (
            par = argv[1];
            (do_it = ((argc > 1) && (par >= 0) && (par < BKDEcnt))) ? (
                reSelectPartial = par;
            );
        ) :
        (kw === mSL_KW_PBFlgs) ? (
            pflgs = 0 | argv[1];
        ) :
        (kw === mSL_KW_dur) ? (
            par = argv[1];  // duration in s
            (do_it = ((argc > 1) && (par >= 0.001) && (par < 3600))) ? (
                reSelectDuration = par;
            );
        ) :
        (kw === mSL_KW_grfades) ? (
            par = argv[1]; // fades duration is ms
            (do_it = ((argc > 1) && (par >= 0.1) && (par < 6000))) ? (
                reSelectGrFades = par;
            );
        ) :
        (kw === mSL_KW_PMod) ? (
            par = argv[1]; //
            (do_it = ((argc > 1) && (par >= 0) && (par < mSL_Max_Flgs))) ? (
                reSelectPmod = par;
            );
        ) :
        (kw === mSL_KW_unit) ? (
            rty = ksiz = 1;
        ) :
        (
            do_it = 0;
        );
        (do_it === 0) ? (
            res = (kw === 0) ? 1 : kw;
            (FlagsTbVals[Flgs_Play] & 2) ? ( // trace flags
                sprintf(#ms, "** mSL_play_ops ** => ERR:%s     %d/%d", mSL_edit_value(#sv, res), argc, argv);
                mSL_log(SysLogBox, #ms);
            );
        ); // return the erroneous kw
        argc -= ksiz; argv += ksiz;
    );
    do_it ? (
        // play the clip
        KSource = 0333;
        res = doPlayClip(0, clip, pflgs, GvPlayTypClip, 0) ;
        (FlagsTbVals[Flgs_Play] & 2) ? ( // trace flags
            sprintf(#ms, "** doPlayClip %d [%X] ** => %d", clip, pflgs, res);
            mSL_log(SysLogBox, #ms);
        );
        GvErr = 0; // reset error condition, if any
    ) : (
        sprintf(#ms, "** doPlayClip error **  %s/%d", mSL_edit_value(0, kw), argc);
        mSL_log(SysLogBox, #ms);
    );
    rty ? GPlUnit : res;
);// mSL_play_ops




/*
    Implementation of the mSL "get"
*/
function
mSL_get(argc, argv)
local (pfid, ref, addr, res, flg, kod, size, s, ip, k, k2, pt, kid, pid)
(
    pfid = argv[0]; ref = argv[1];
    res = addr = flg = 0;
    kod = size = -1;
    kid = (argc > 1) && (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max)));

    // is this a keyword ?
    ((pfid > mSL_Sym_Low) && (pfid < mSL_Sym_High)) ? (
        /*
        (FlagsTbVals[Flgs_PrOps] & 1) ? (
            // just for trace
            strcpy(#sZ0, mSL_id2Str(pfid));
            (argc <= 1) ? (
                sprintf(#sfc, "mSL_get[%d]  \"%s\".", argc, #sZ0);
            ) :
            (
                sprintf(#sfc, "mSL_get[%d]  \"%s\"  \"%s\" / %d", argc, #sZ0, mSL_edit_value(#sZ1, ref), kid);
            );
            mSL_log(SysLogBox, #sfc);
        );
        */
        pid = -1;
        ((pfid === mSL_KW_JSFX) || (pfid === mSL_KW_jsfx_) || (pfid === mSL_KW_GM) || (pfid === mSL_KW_GM_)) ? (
            // acces a JSFX variable
            res = mSL_vGet(ref);
        ) :
        ((pfid === mSL_KW_JSFXref) || (pfid === mSL_KW_jsfxref_)) ? (
            // acces a JSFX variable reference
            res = mSL_get_var_idt(ref);
        ) :
        (pfid === mSL_KW_PNum) ? (
            // Get a parameter number
            (kid && ((k = mSL_getinHT(paramHashTbl, ref)) >= 0)) ? (
                pid = mSL_getinHTaux; // use the auxiliary result = param number
            );
            res = pid;
        ) :
        (pfid === mSL_KW_ParamV) ? (
            // get a parameter value
            pid = 0; k = -2; // for now
            // Get the value of a parameter by name or by number
            (kid) ? (
                // look for the ident. in a table
                ((k = mSL_getinHT(paramHashTbl, ref)) >= 0) ? (
                    pid = mSL_getinHTaux;
                );
            ) :
            ((ref >= 0) && (ref < paramNMax)) ? (
                pid = ref;
            );
            (pid >= 0) ? (
                res = parGetV(pid);
            );
            // sprintf(#sfc, "Get Param  %d / %d =>  %f", pid, k, res);
            // mSL_log(SysLogBox, #sfc);
        ) :
        (pfid === mSL_KW_Host) ? (
            res = the_host;
        ) :
        //(pfid === mSL_KW_vars) ? (
        //    // return the "vars" array
        //    res = mSL_baseAVars;
        //) :
        //(pfid === mSL_KW_locs) ? (
        //    // return the "locs" array
        //    res = mSL_baseOVars;
        //):
        (
            res = mSL_vGet(pfid);
        );
    ) : (
        // Is the first parameter the address of a table ?
        (((addr = pfid) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        // Is this the "raw" address of a table ?
        (((addr = pfid + 2) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        // Let's consider it as a simple pointer...
        (
            addr = pfid; // don't know much more
            size = 0x1000000; // default access...
        );


        (kid) ? (
            // look for an entry in the table
            ip = 0; k = addr[ip];
            (flg && ((ref === 'size') || (ref === mSL_KW_size))) ? (
                res = size; flg = 0;
            );
            (flg && ((ref === 'type') || (ref === mSL_KW_type))) ? (
                res = kod; flg = 0;
            );
            while (flg && (((k > mSL_Sym_Low) && (k < mSL_Sym_High)) || ((k >= mSL_MKey_min) && (k <= mSL_MKey_max)))) (
                (ip >= size) ? (
                    flg = 0;
                ) :
                (k === ref) ? (
                    res = addr[ip+1]; flg = 0;
                ) :
                (
                    ip += 2; k = addr[ip];
                );
            );
        ) :
        ((addr >= 0) && ((pt = addr + ref) >= 0)) ? (
            (pt < mSL_lastmemory) ? (
                res = pt[0];
            );
        ) :
        (addr < 0) ? (
            (((pt = -addr + ref) > 0) && (pt < 0x8000000)) ? (
                res = gmem[pt];
            );
        );

    );
    res;
);//mSL_get

/*
    Set the value of field ; return previous one
*/
function
mSL_set(argc, argv)
local (pfid, ref, value, force, addr, res, flg, kod, size, s, ip, k, k2, pt, kid)
(

    pfid = argv[0]; ref = argv[1]; value = argv[2]; force = argv[3];
    res = addr = flg = 0;
    kod = size = -1;
    kid = (argc > 1) && (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max)));

    // is this a keyword ?
    ((pfid > mSL_Sym_Low) && (pfid < mSL_Sym_High)) ? (
        (FlagsTbVals[Flgs_PrOps] & 1) ? (
            strcpy(#sZ0, mSL_id2Str(pfid));
            sprintf(#sfc, "mSL_set[%d]  \"%s\"  \"%s\" / %d    %g",argc, #sZ0, mSL_edit_value(#sZ1, ref), kid, value);
            mSL_log(SysLogBox, #sfc);
        );
        ((pfid === mSL_KW_JSFX) || (pfid === mSL_KW_jsfx_) || (pfid === mSL_KW_GM) || (pfid === mSL_KW_GM_)) ? (
            // acces a JSFX variable
            (argc > 2) ? (
                res = mSL_vSet(ref, value);
            );
        ) :
        (pfid === mSL_KW_ParamV) ? (
            pid = -1; // for now
            // Get the value of a parameter by name or by number
            (kid) ? (
                // look for the ident. in a table
                ((k = mSL_getinHT(paramHashTbl, ref)) >= 0) ? (
                    pid = mSL_getinHTaux; // use the auxiliary result
                );
            ) :
            ((ref >= 0) && (ref < paramNMax)) ? (
                pid = ref;
            );
            // Set the value of a parameter
            (pid >= 0) ? (
                pid = 0|max(0,min(paramNMax,pid));
                res = paramValues[pid];
                parSet(pid, value);
            );
        ) :
        (
            (argc > 1) ? (
                res = mSL_vSet(pfid, ref);
            );
        );
    ) : (
        // Is this a table ?
        (((addr = pfid) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        (((addr = pfid + 2) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        (
            addr = pfid; // don't know much more
            size = 0x1000000; // default access...
        );

        (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max))) ? (
            // look for an entry in the table
            ip = 0; k = addr[ip];
            (flg && ((ref === 'type') || (ref === mSL_KW_type)) && (force & 1) && (value >= mSL_MKey_min) && (value <= mSL_MKey_max)) ? (
                flg = 0;  addr[-2] = value; addr[s+1] = value ~ mSL_CC_Chksum;
            );
            while (flg && (((k > mSL_Sym_Low) && (k < mSL_Sym_High)) || ((k >= mSL_MKey_min) && (k <= mSL_MKey_max)))) (
                (k === ref) ? (
                    res = addr[ip+1];
                    addr[ip+1] = value;
                    flg = 0;
                ) :
                (ip >= size) ? (
                    flg = 0;
                ) : (
                    ip += 2; k = addr[ip];
                );
            );
            (flg && (force & 1)) ? (
                // try to create the entry
                ip = 0; flg = 1;
                while (flg) (
                    (ip >= size) ? (
                        flg = 0;
                    ) :
                    (addr[ip] === 0) ? (
                        addr[ip] = ref;
                        addr[ip+1] = res = value;
                        flg = 0;
                    ) :
                    (
                        ip += 2; k = addr[ip];
                    );
                );
            );
        ) :
        ((addr >= 0) && ((pt = addr + ref) >= 0)) ? (
            (pt < mSL_lastmemory) ? (
                // but this may write anywhere in the memory !
                res = pt[0];
                pt[0] = value;
            );
        ) :
        (addr < 0) ? (
            (((pt = -addr + ref) > 0) && (pt < 0x8000000)) ? (
                // but this may write anywhere in the shared memory !
                res = gmem[pt];
                gmem[pt] = value;
            );
        );
    );
    res;
);//mSL_set




/*
    Call operations = call a JSfX func from mSL
*/
function
mSL_call_ops(argc, argv)
local(res, kw, Un)
(
    // Decode the parameters - could be integers or keywords
    0 ? (
        sprintf(#s, "*mSL_call_ops[%d]  %18.0f   \"%s\"   \"%s\"    %g",
            argc, argv[0], mSL_edit_value(#s1, argv[0]), mSL_edit_value(#s2, mSL_KW_SensorSize), argv[1]);
        mSL_log(SysLogBox, #s);
    );
    res = Undef;
    (argc > 0) ? (
        kw = argv[0];
        (kw >= mSL_Sym_Low) ? (
            // a symbol
            ((kw === mSL_KW_clear_) && (argc === 2)) ? (
                res = mSL_bl_clear(argv[1]);
            ) :
            ((kw === mSL_KW_clear_) && (argc === 3)) ? (
                res = mSL_bl_clear(argv[1], argv[2]);
            ) :
            ((kw === mSL_KW_explode) && (argc === 3)) ? (
                res = mSL_str_explode(argv[1], argv[2]);
            ) :
            ((kw === mSL_KW_implode) && (argc === 3)) ? (
                res = mSL_str_implode(argv[1], argv[2]);
            ) :
            ((kw === mSL_KW_strclean) && (argc === 3)) ? (
                res = mSL_strclean(argv[1], argv[2]);
            ) :
            ((kw === mSL_KW_search) && (argc === 3)) ? (
                res = mSL_search_elt(argv[1], argv[2], 0);
            ) :
            ((kw === mSL_KW_search) && (argc === 4)) ? (
                res = mSL_search_elt(argv[1], argv[2], argv[3]);
            ) :
            ((kw === mSL_KW_log) && (argc === 3)) ? (
                res = mSL_log(argv[1], argv[2]);
            ) :
            ((kw === mSL_KW_player) && (argc >= 3)) ? (
                // Send a command to a player
                Un = argv[1]; // The first parameter should be a player address
                k = argv[2];
                ((Un >= UGAddr) && (Un < UGAddrLast) && (((Un - UGAddr) % UCBSize) === 0)) ? (
                    i=j=0; res = argc; argc -= 3;
                    // Get a location to copy the command and parameters
                    loc = getTmpEnt();
                    while ((argc > 0) && (j < 74)) (
                        v = argv[i+3];
                        // is v a block ? if so, copy its values
                        mSL_bl_check(v) ? (
                            k = 0;
                            while (j < 74) (
                                gmem[loc+j] = v[k]; j += 1; k += 1;
                            );
                        ) : (
                            gmem[loc+j] = v; j+= 1;
                        );
                        i+=1; argc -= 1;
                    );
                    gmem[loc+j] = USep; // add a final separator
                    // Enter the address in RCB
                    pq = Un + RCB_alt_par0; gmem[Un + RCB_alt_parm] = 0;
                    while (gmem[pq] != 0) (pq += 1);
                    ((k === KmdDly) || (k === mSL_KW_KmdDly) || (k === mSL_KW_Dly)) ? (loc = - loc;);
                    gmem[pq] = loc;
                    gmem[Un+RCB_KmdAlt] = KmdAct; // Second parameter is the command, set last
                );
            ) :
            ((kw === mSL_KW_idt) && (argc === 2)) ? (
                res = mSL_get_var_idt(argv[1]);
            ) :
            ((kw === mSL_KW_fromSet) && (argc === 2)) ? (
                res = clipFromSet(argv[1]);
            ) :
            ((kw === mSL_KW_now) && (argc === 1)) ? (
                res = nowIs();
            ) :
            (kw === mSL_KW_stop) ? (
                (argc === 1) ? ( i = -1 ) : (i = argv[1]);
                res = doActivePlayer(i, KmdStop, 0);
            ) :
            (kw === mSL_KW_qstop) ? (
                (argc === 1) ? ( i = -1 ) : (i = argv[1]);
                res = doActivePlayer(i, KmdQStop, 0);
            ) :
            ((kw === mSL_KW_protect) && (argc === 2)) ? (
                res = gc_protect(argv[1]);
            ) :
            ((kw === mSL_KW_checkHPcnf) && (argc === 4)) ? (
                res = checkHPconfig(argv[1], argv[2], argv[3]);
            ) :
            ((kw === mSL_KW_SensorSize) && (argc === 1)) ? (
                res = padSensShowSiz;
            ) :
            ((kw === mSL_KW_SensorSize) && (argc === 2)) ? (
                0 ? (sprintf(#s, "mSL_call_ops[%d]  \"%s\"    %g",
                        argc, mSL_edit_value(0, kw), argv[1]);
                    mSL_log(SysLogBox, #s);
                );
                res = setSensorSize(argv[1]);
            ) :
            ((kw === mSL_KW_id2str) && (argc === 2)) ? (
                0 ? (sprintf(#s, "mSL_call_ops[%d]  \"%s\"    %g",
                        argc, mSL_edit_value(0, kw), argv[1]);
                    mSL_log(SysLogBox, #s);
                );
                res = mSL_id2Str(argv[1]);
            ) :
            ((kw === mSL_KW_schLstSize) && (argc === 2)) ? (
                0 ? (sprintf(#s, "mSL_call_ops[%d]  \"%s\"    %g",
                        argc, mSL_edit_value(0, kw), argv[1]);
                    mSL_log(SysLogBox, #s);
                );
                res = SchedListSize(argv[1]);
            ) :
            ((kw === mSL_KW_rprimes) && (argc === 3)) ? (
                res = are_Rel_Primes(argv[1], argv[2]);
            );
        );
    );
    res;
);// mSL_call_ops




/*
    Send an action to a player
*/
function
mSL_players_ops(argc, argv)
local(res, kw, Un, p, fdly, i, j, loc, v, k, pq)
(
    res = Undef;
    fdly = 0;
    (argc > 0) ? (
        Un = argv[0]; // The first parameter should be a player address
        kw = argv[1]; p = 1;
        ((kw === mSL_KW_KmdDly) || (kw === mSL_KW_Dly)) ? (fdly = 1; p = 2;);
        ((kkw === mSL_KW_KmdImm) || (kw === mSL_KW_Imm)) ? (fdly = 0; p = 2;);
        ((Un >= UGAddr) && (Un < UGAddrLast) && (((Un - UGAddr) % UCBSize) === 0)) ? (
            i=j=0; res = argc; argc -= p;
            // Get a location to copy the command and parameters
            loc = getTmpEnt();
            while ((argc > 0) && (j < 74)) (
                v = argv[i+p];
                // is v a block ? if so, copy its values
                mSL_bl_check(v) ? (
                    k = 0;
                    while (j < 74) (
                        gmem[loc+j] = v[k]; j += 1; k += 1;
                    );
                ) : (
                    gmem[loc+j] = v; j+= 1;
                );
                i+=1; argc -= 1;
            );
            gmem[loc+j] = USep; // add a final separator
            // Enter the address in RCB
            pq = Un + RCB_alt_par0; gmem[Un + RCB_alt_parm] = 0;
            while (gmem[pq] != 0) (pq += 1);
            (fdly) ? (loc = - loc;);
            gmem[pq] = loc;
            gmem[Un+RCB_KmdAlt] = KmdAct; // Second parameter is the command, set last
        );
    );
    res;
);// mSL_players_ops



/*
    Execute a GUI operation
*/
function
mSL_gui_ops(argc, argv)
local(res, kw, npar, pp, r, sr, n, cnt, i, j, v, chk, idt)
(
    res = Undef;
    (argc > 1) ? (
        kw = argv[0];
        npar = argv[1];

        (kw === mSL_KW_slider) ? (
            pp = 0;
            ((npar === (0|npar)) && (npar >= 0) && (npar < paramCount)) ? (
                pp = paramBlock + npar * paramEntSize;
            ) :
            ((npar > mSL_Sym_Low) && (npar < mSL_Sym_High) && (mSL_getinHT(paramHashTbl, ref) >= 0)) ? (
                pp = paramBlock + (npar = mSL_getinHTaux) * paramEntSize;
            );
            (pp != 0) ? (
                (argc >= 11) ? (
                    parDclMode = 1;
                    r = parDcl(npar, argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
                        ((argc >= 12) ? argv[11]: 0), ((argc >= 13) ? argv[12]: 0), ((argc >= 14) ? argv[13]: 0),
                        ((argc >= 15) ? argv[14]: 0), ((argc >= 16) ? argv[15]: 0), ((argc >= 17) ? argv[16]: 0));
                    (r === 0) ? (
                        argc = 2; // return/build the entry
                    ) : (
                        // signal error
                        sprintf(#u, "++Slider error: %d - %d", npar, r);mSL_log(SysLogBox, #u);
                        argc = 2;
                    );
                );
                ((argc === 2) && (pp[pp_Name] != 0) && (pp[pp_Name] != #pUndef)) ? (
                    // return, if any, the slider block reference
                    sr = pp[pp_mSL_Ref];
                    ((sr > 0) && (mSL_bl_check(sr, 'sldr')) && (sr[-1] >= 12)) ? (
                        res = sr;
                    ) : (
                        pp[pp_mSL_Ref] = res = mSL_Dyn_Alloc(12, 'sldr', mSL_StM_FlClear);
                    );
                    // Create/update the slider descriptor
                    pp[pp_Addr] = res + 3;
                    paramFlags[npar] |= pflg_ChkWrite;
                    res[0] = mSL_KW_slider;
                    res[1] = npar;
                    res[2] = pp[pp_mSL_Code];
                    res[3] = parGetV(npar);
                    res[4] = pp[pp_Name];
                    res[5] = pp[pp_SFmt];
                    res[6] = pp[pp_MFmt];
                );
            );
        ) :
        (kw === mSL_KW_declare) ? (
            (mSL_bl_check(npar, 'umod') && (argc >= 4)) ? (
                idt = argv[2]; // uname
                n = argv[3]; // module. num
                (mSL_isString(idt) && (n === (0|n)) && (n >= 0) && (n <= dcbUModsSiz)) ? (
                    // declare the module
                    blockUsrNames[n] = idt;
                    blockUsrRefs[n] = npar;
                    res = n;
                );
            );
        ) :
        (kw === mSL_KW_update) ? (
            ((npar === mSL_KW_sliders) || (npar === mSL_KW_Params)) ? (
                // Rebuild parameters sliders
                menu_Param_mSL = 0;
                menu_Param_UBS = 0;
                menu_Param_UBD = 0;
                parDclMode = 0;
                dclAllParameters();
            ) :
            (npar === mSL_KW_modules) ? (
                // After creating new users modules
                checkUsrMods(); // valid blocks
                mkModuleMenu();// rebuild the menu
            );
        ) :
        (kw === mSL_KW_sbox) ? (
            // Creating a Slider Box
            cnt = argc - 1; // count of expected sliders references
            i = 1; n = 0; loop(cnt,
                v = argv[i];
                // lets check that v is a slider reference
                mSL_bl_check(v, 'sldr') ? (n += 1);
                i += 1;
            );
            (n === cnt) ? (
                // all parameters are sliders. Let's create the container
                res = mSL_Dyn_Alloc(ubx_isiz+cnt, 'sbox', mSL_StM_FlClear);
                //----
                res[ubx_ty] = 'sbox'; // this is a slider box
                res[ubx_flgs] = ubx_final; // object is final
                res[ubx_mref] = res;  // points to itself
                res[ubx_anc] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = 0; // no direct descendants
                res[ubx_icnt] = cnt; // items count
                res[ubx_1st] = 0; // not relevant for now
                res[ubx_tcnt] = 0; // no descendants at all
                //----
                res[ubx_l] = 0; // not relevant for now
                res[ubx_t] = 0; // not relevant for now
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = ui_jd_slidh * cnt; // actual value in pixels, "correct"
                //----
                res[ubx_minw] = Undef; // not known yet
                res[ubx_maxw] = Undef; // not known yet
                //----
                i = 1; j = ubx_isiz; loop(cnt,
                    res[j] = argv[i]; i += 1; j += 1;
                );
            );
        ) :
        (kw === mSL_KW_ibox) ? (
            // Create an info box with a set of infos to display
            cnt = argc - 1; // count of expected parameters
            (cnt > 1) ? (
                // all objects seem ok. Let's create the module
                res = mSL_Dyn_Alloc((s = ubx_isiz+cnt+1), 'ibox', mSL_StM_FlClear);
                //----
                res[ubx_ty] = 'ibox'; // This is an infobox
                res[ubx_flgs] = ubx_final; // object is final
                res[ubx_mref] = res; // points to itself
                res[ubx_name] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = 0; // direct descendants count
                res[ubx_icnt] = 1;  // one item
                res[ubx_1st] = 0; // relative pointer to 1st descendant
                res[ubx_tcnt] = 0; // total count of all descendants
                //----
                res[ubx_l] = Undef; // not known yet
                res[ubx_t] = Undef; // not known yet
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = ui_jd_tboxs+5; // appropriate height
                //----
                res[ubx_minw] = ui_MinSubColSize; // min size
                res[ubx_maxw] = 5 * ui_MinSubColSize; // not known yet
                //----
                // Copy references
                ptb = res + ubx_isiz; // where to copy
                ptb[0] = cnt;
                i = 0; loop(cnt,
                    i += 1; ptb += 1;
                    ptb[0] = argv[i];
                );
            );
        ) :
        ((kw === mSL_KW_hbox)) ? (
            // Create an horizontal box, expect a set of '*box'
            xbox = 'hbox';
            k = argc - 1; // count of parameters
            chk = i = 1; chkprev = cnt = w = n = 0;
            loop(k,
                v = argv[i];
                ((chk && chkprev && (v < 1024))) ? (
                    w += 1;
                    chkprev = 0;
                ) :
                (chk = (chk && mSL_bl_check(v) && ((v[-2] & 0xffffff) === 'box'))) ? (
                    n += 1 + v[ubx_tcnt]; // count of internal objects
                    cnt += 1;
                    chkprev = 1;
                );
                i += 1;
            );
            chk ? (
                // all objects seem ok. Let's create the module
                res = mSL_Dyn_Alloc((s = ubx_isiz+2*cnt), xbox, mSL_StM_FlClear);
                res_end = res + s;
                //----
                res[ubx_ty] = xbox; // This is an horizontal box
                res[ubx_flgs] = 0; // not relevant for now
                res[ubx_mref] = res; // points to itself
                res[ubx_name] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = cnt; // direct descendants count
                res[ubx_icnt] = 0;  // no items
                res[ubx_1st] = 0; // relative pointer to 1st descendant
                res[ubx_tcnt] = n; // total count of all descendants
                //----
                res[ubx_l] = Undef; // not known yet
                res[ubx_t] = Undef; // not known yet
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = Undef; // not known yet
                //----
                res[ubx_minw] = Undef; // not known yet
                res[ubx_maxw] = Undef; // not known yet
                //----
                // Copy references
                ptb = res + ubx_isiz; // where to copy references
                ptw = ptb + cnt; // where to copy widths
                k = argc - 1; // count of parameters
                i = 1; chkprev = 0; w = 0;
                loop(k,
                    v = argv[i];
                    ((chkprev && (v < 1024))) ? (
                        ptw[w-1] = v;
                        chkprev = 0;
                    ) :
                    (mSL_bl_check(v) && ((v[-2] & 0xffffff) === 'box')) ? (
                        ptb[w] = v;
                        ptw[w] = Undef; // default width
                        chkprev = 1;
                        w += 1;
                    );
                    i += 1;
                );
            );
        ) :
        ((kw === mSL_KW_vbox)) ? (
            // Create a vertical box, expect a set of '*box'
            xbox = 'vbox';
            cnt = argc - 1; // count of expected references
            chk = i = 1; n = 0; loop(cnt,
                v = argv[i];
                (chk = (chk && mSL_bl_check(v) && ((v[-2] & 0xffffff) === 'box'))) ? (
                    n += 1 + v[ubx_tcnt]; // count of internal objects
                );
                i += 1;
            );
            chk ? (
                // all objects seem ok. Let's create the module
                res = mSL_Dyn_Alloc((s = ubx_isiz+n), xbox, mSL_StM_FlClear);
                res_end = res + s;
                //----
                res[ubx_ty] = xbox; // This is a vertical box
                res[ubx_flgs] = 0; // not relevant for now
                res[ubx_mref] = res; // points to itself
                res[ubx_name] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = cnt; // direct descendants count
                res[ubx_icnt] = 0;  // no items
                res[ubx_1st] = 0; // relative pointer to 1st descendant
                res[ubx_tcnt] = n; // total count of all descendants
                //----
                res[ubx_l] = Undef; // not known yet
                res[ubx_t] = Undef; // not known yet
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = Undef; // not known yet
                //----
                res[ubx_minw] = Undef; // not known yet
                res[ubx_maxw] = Undef; // not known yet
                //----
                // Copy references
                ptb = res + ubx_isiz; // where to copy
                i = 1; loop(cnt,
                    ptb[0] = argv[i]; i += 1; ptb += 1;
                );
            );
        ) :
        (kw === mSL_KW_tbox) ? (
            // Create a text box - Expect a string as parameter
            txt = argv[1];
            (chk = mSL_isString(txt)) ? (
                res = mSL_Dyn_Alloc((s = ubx_isiz+1), 'tbox', mSL_StM_FlClear);
                //----
                res[ubx_ty] = 'tbox'; // this is a slider box
                res[ubx_flgs] = ubx_final; // object is final
                res[ubx_mref] = res;  // points to itself
                res[ubx_anc] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = 0; // no direct descendants
                res[ubx_icnt] = 1; // items count
                res[ubx_1st] = 0; // not relevant for now
                res[ubx_tcnt] = 0; // no descendants at all
                //----
                res[ubx_l] = 0; // not relevant for now
                res[ubx_t] = 0; // not relevant for now
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = ui_jd_vtext; // actual value in pixels, "correct"
                //----
                res[ubx_minw] = Undef; // not known yet
                res[ubx_maxw] = Undef; // not known yet
                //----
                res[ubx_isiz] = txt; // the string number
            );
        ) :
        (kw === mSL_KW_module) ? (
            // Expect a module name
            // idt = argv[1];
            // chk = mSL_isString(idt);
            cnt = argc - 1; // count of expected references
            chk = i = 1; n = 0; loop(cnt,
                v = argv[i];
                (chk = (chk && mSL_bl_check(v) && ((v[-2] & 0xffffff) === 'box'))) ? (
                    n += 1 + v[ubx_tcnt]; // count of internal objects
                );
                i += 1;
            );
            chk ? (
                // all objects seem ok. Let's create the module
                res = mSL_Dyn_Alloc((s = ubx_isiz+n*ubx_isiz), 'umod', mSL_StM_FlClear);
                res_end = res + s;
                //----
                res[ubx_ty] = 'umod'; // This is a module
                res[ubx_flgs] = 0; // not relevant for now
                res[ubx_mref] = res; // points to itself
                res[ubx_name] = 0; // not relevant for now
                //----
                res[ubx_lcnt] = cnt; // direct descendants count
                res[ubx_icnt] = 0;  // no items
                res[ubx_1st] = 0; // relative pointer to 1st descendant
                res[ubx_tcnt] = n; // total count of all descendants
                //----
                res[ubx_l] = Undef; // not known yet
                res[ubx_t] = Undef; // not known yet
                res[ubx_w] = Undef; // not known yet
                res[ubx_h] = Undef; // not known yet
                //----
                res[ubx_minw] = Undef; // not known yet
                res[ubx_maxw] = Undef; // not known yet
                res[ubx_thread] = mSL_current_thread; //current thread
                res[ubx_thrdid] = mSL_current_thread[mSL_THR_UTId]; // current thread id
                res[ubx_xxxx] = 0; //
                //sprintf(#b, "a ===>    0:%d   //", res[ubx_ty]); mSL_log(SysLogBox, #b);
                //----
                // First insert direct references
                ptb = res + ubx_isiz; // where to copy / create the boxes descriptions
                pts = argv + 1; // local sources
                lct = cnt; // local count
                pta = res; // current ancestor : the module we are creating
                while ((chk) && (ptb < res_end)) (
                    // Create a local box from current src
                    while ((chk) && (lct > 0)) (
                        ds = pts[0];
                        // this must be a correct reference
                        (chk = (mSL_bl_check(ds) && ((ds[-2] & 0xffffff) === 'box'))) ? (
                            // indicate first descendant
                            (pta[ubx_1st] === 0) ? (pta[ubx_1st] = ptb - res;);
                            lct -= 1;
                            // insert the source
                            //----
                            ptb[ubx_ty] = ds[ubx_ty];
                            ptb[ubx_flgs] = ds[ubx_flgs];
                            ptb[ubx_mref] = ds;
                            ptb[ubx_anc] = pta - res;
                            //----
                            ptb[ubx_lcnt] = ds[ubx_lcnt];
                            ptb[ubx_icnt] = ds[ubx_icnt];;
                            ptb[ubx_1st] = 0;
                            ptb[ubx_tcnt] = ds[ubx_tcnt];
                            //----
                            ptb[ubx_t] = ds[ubx_t];
                            ptb[ubx_l] = ds[ubx_l];
                            ptb[ubx_w] = ds[ubx_w];
                            ptb[ubx_h] = ds[ubx_h];
                            //----
                            ptb[ubx_minw] = ds[ubx_minw];
                            ptb[ubx_maxw] = ds[ubx_maxw];
                            //----
                            pts += 1; // next source
                            ptb += ubx_isiz; // where we will copy it
                        );
                    );
                    (chk && (ptb < res_end) && (lct <= 0)) ? (
                        // skip to next set source
                        pta = pta + ubx_isiz; // new ancestor
                        ref = pta[ubx_mref]; // just recheck
                        (chk = (mSL_bl_check(ref))) ? (
                            lct = ref[ubx_lcnt]; // number of direct references to include
                            pts = ref + ubx_isiz; // point to this box references
                        );
                    );
                );
                // sprintf(#b, "b ===>    0:%d   //", res[ubx_ty]); mSL_log(SysLogBox, #b);
            );
            (!chk) ? (
                res = Undef;
            );
        ) :
        (kw === mSL_KW_delete) ? (
            (npar === mSL_KW_modules) ? (
                deleteUsrMods(); // delete all, then
                mkModuleMenu();// rebuild the menu
            ) :
            (npar === mSL_KW_sliders) ? (
                i = p_ActSize;
                while (i < paramCount) (
                    parRemove(i);
                    i += 1;
                );
                menu_Param_mSL = 0;
                menu_Param_UBS = 0;
                menu_Param_UBD = 0;
                parDclMode = 0;
                dclAllParameters();
            );
        );
    );
    res;
);//mSL_gui_ops




// Insert here the mSL interpreter
<? include("GM-Libs/mSL_Evaluator.jsfx-inc"); ?>




// Last aspects of initialization

FlagsTbVals[Flgs_TblUpd] = 0xffffff; // for at least set tables to default
GvPlayTyp = GvPlayTypGroup; // default select group

mSL_log(SysLogBox, "End of initialization");

uuuFLG = 0;
#text = "Initial Text";
last_text = 0;
gmem[timeDelta] = timeD;



TabAddrMax = mSL_StM_FreePt; // max. address recognized for an array
SharedHighMemory = lastmemory = make_array(2); // last use of the function
current_Memory_Mode = mSL_MMd_Dynamic;  // change allocation mode




//AGMW190 = GMW();



function
ttsym(str)
local(res, zu, fl, h, e, k)
(
    zu = mSL_symbol(str);
    fl = (zu > mSL_Sym_Low) && (zu < mSL_Sym_High);
    //res = mSL_symbol2(str);
    h = mSL_symhash(zu); e = h % HSZ_Siz;
    sprintf(#sfc, "\"%s\"  =>  \"%s\"  => %18.0f/%d =>  %d   %d", str, mSL_id2Str(zu), zu, fl, h, e);
    mSL_log(SysLogBox, #sfc);
    // Enter the object
    k = H_Table[e];
    (k === -1) ? (
        // enter the object
        H_Table[e] = zu; H_Codes[e] = h;
    ) : (
        H_Dupl[e] = zu;  // a synonym
        H_Colls += 1;
    );
    H_Tsts += 1;

);


function ttsdmp()
local (e)
(
    sprintf(#sfc, "** Collisions : %d/%d/%d **", H_Colls, H_Tsts, HSZ_Siz);
    mSL_log(SysLogBox,#sfc);
    e = 0; loop(HSZ_Siz,
        (H_Dupl[e] != 0) ? (
            sprintf(#sfc, "Dup %d \"%s\"/%d  \"%s\"/%d", e, mSL_id2Str(H_Table[e]), mSL_symhash(H_Table[e]), mSL_id2Str(H_Dupl[e]), mSL_symhash(H_Dupl[e]));
            mSL_log(SysLogBox, #sfc);
        );
        e += 1;
    );
    mSL_log(SysLogBox,"** End **");
);


function ttshow(sym)
(
    sprintf(#sfc, "Sym: %18.0f  ==  \"%s\"  ==  \"%s\"", sym, mSL_id2Str(sym), mSL_edit_value(#, sym));
    mSL_log(SysLogBox, #sfc);
);







//============================ TEMPORARY TESTS ============================
/*/
//kktr = 1;
kk2tr = 0;

AGMXXX = 0;

ttsym("hello");
ttsym("world");

//* /
// ttsym("variable");
ttsym("Color_Dark_Gray");
ttsym("configuration");
ttsym("free_blocks_chaining");
ttsym("processus_status");
/* /
ttsym("Identification");
ttsym("Identification_1");
ttsym("Identification_2");
ttsym("Identification_a");
ttsym("Identification_b");

ttsym("variable");
ttsym("variabld");
ttsym("variablf");
ttsym("variablg");
ttsym("variablh");
ttsym("variabli");
ttsym("variable1");
ttsym("variable2");
ttsym("variable3");
ttsym("variable_1");
ttsym("variable_2");
ttsym("variable_3");
ttsym("variable11");
ttsym("variable12");
ttsym("variable13");

ttsym("mSL_W_fidt");
ttsym("mSL_Sys_log320");
ttsym("QuiteALongIdentifier");

ttsym("Ab_ie_de_eph_ehe_ei_ie_aja_aka_A_E");

ttsym("Game_Player");
ttsym("configuration");
ttsym("initialisation");
ttsym("interpretation");
ttsym("modification");
ttsym("generateurs");
ttsym("studDispPPrev");
ttsym("Color_Dark_Gray_2");
ttsym("ui_jcolor_inactive_grey");

ttsym("mSL_smallest_free");
ttsym("mSL_lastmemory");
ttsym("mSL_current_memory");
ttsym("mSL_current_StrPtrs");
ttsym("mSL_new_memory");
ttsym("mSL_define_primitives");
ttsym("mSL_MM_HighAdId");
ttsym("mSL_MM_HighAd");
ttsym("SchedStatus");
ttsym("SchedNxtEnt");
ttsym("SchedPrvEnt");

ttsym("mSL_clearGCTab");
ttsym("mSL_enterGCode");
ttsym("mSL_symbol");
ttsym("mSL_symbol2");

ttsym("A_Pretty_Long_Identifier_With_A_Lot_Of_Characters");
ttsym("A_Pretty_Long_Identifier_With_A_Lot_Of_Characters_Again");
ttsym("A_Pretty_Long_Identifier_Also_With_A_Lot_Of_Characters");
ttsym("A_Pretty_Long_Identifier_Still_With_A_Lot_Of_Characters");
ttsym("And_A_Last_Pretty_Long_Identifier_With_A_Lot_Of_Characters");

ttsym("padPlayStoreNL");
ttsym("padPlayStoreNC");
ttsym("padPlayStoreSiz");
ttsym("padPlayStorep");
ttsym("padPlayStoreLabs");
ttsym("padPlayStoreColrs");
ttsym("padPlayStoreCells");
ttsym("padPlayStoreVals");



kk2tr = 1;
ttsym("A");
ttsym("AA");

ttsym("_Toto");
kk2tr = 0;
ttsym("A_");
ttsym("A__");
ttsym("_A");
ttsym(".A");
ttsym("#A");
ttsym(":A");
ttsym(":A_");
ttsym(":A__");
ttsym(":A:");
ttsym(":A::");

ttsym(".Toto");
ttsym("#Toto");
ttsym(":Toto");


ttsym("_Toto_est_beau");
ttsym(".Toto_est_beau");
ttsym("#Toto_est_beau");
ttsym(":Toto_est_beau");


ttsdmp();

kktr = 0;
//*/
/*
// Try compacting algos.
mSL_log(SysLogBox, "***STRING TEST***");
pte = mSL_g6packStr(xplStr1, "This is a long string, with a lot of chars in it.", 0, 511, 1);

pte = mSL_g6packStr(xplStr1, " Followed by another.", pte, 511, 1);
pte = mSL_g6packStr(xplStr1, " And yet another.", pte, 511, 1);

mSL_log(SysLogBox, mSL_g6unpackArray(#sfc, xplStr1, 0));


mSL_log(SysLogBox, "***STRING TEST END***");

*/




/*
//  Try string limits algo
mSL_log(SysLogBox, "***STRING TEST***");
#AZ0 = "";
#AZ1 = "X";
loop (12,
    strcat(#AZ0, #AZ1);
    sprintf(#s, "Sizes : %d, %d", strlen(#AZ1), strlen(#AZ0)); mSL_log(SysLogBox, #s);
    strcat(#AZ1, #AZ0);
    sprintf(#s, "Sizes : %d, %d", strlen(#AZ0), strlen(#AZ1)); mSL_log(SysLogBox, #s);
);

mSL_log(SysLogBox, "***STRING TEST PHASE 2***");

strcpy(#AZ2, #AZ1);

loop (16,
    strncpy(#AZ3, #AZ2, ceil(strlen(#AZ2)/2));
    strcat(#AZ0, #AZ3);
    strcat(#AZ1, #AZ3);
    strcpy(#AZ2, #AZ3);
    sprintf(#s, "Sizes : %d, %d  <= %d", strlen(#AZ0), strlen(#AZ1), strlen(#AZ2));
    mSL_log(SysLogBox, #s);
);

mSL_log(SysLogBox, "***STRING TEST PHASE 3***");
strncpy(#AZ4, #AZ1, 16384);
sprintf(#s, "Size AZ4 %d", strlen(#AZ4)); mSL_log(SysLogBox, #s);
strcpy(#AZ5, #AZ4);
sprintf(#s, "Size AZ5 %d", strlen(#AZ5)); mSL_log(SysLogBox, #s);
strcat(#AZ5, #AZ4);
sprintf(#s, "Size AZ5 %d", strlen(#AZ5)); mSL_log(SysLogBox, #s);
strcat(#AZ4, #AZ5);
sprintf(#s, "Size AZ4 %d", strlen(#AZ4)); mSL_log(SysLogBox, #s);


mSL_log(SysLogBox, "***STRING TEST PHASE 4***");
strncpy(#AZ4, #AZ1, 16385);
sprintf(#s, "Size AZ4 %d", strlen(#AZ4)); mSL_log(SysLogBox, #s);
strcpy(#AZ5, #AZ4);
sprintf(#s, "Size AZ5 %d", strlen(#AZ5)); mSL_log(SysLogBox, #s);
strcat(#AZ5, #AZ4);
sprintf(#s, "Size AZ5 %d", strlen(#AZ5)); mSL_log(SysLogBox, #s);
strcat(#AZ4, #AZ5);
sprintf(#s, "Size AZ4 %d", strlen(#AZ4)); mSL_log(SysLogBox, #s);


mSL_log(SysLogBox, "***STRING TEST PHASE 5***");
strncpy(#AZ4, #AZ1, 16384);
sprintf(#s, "Size AZ4 %d", strlen(#AZ4)); mSL_log(SysLogBox, #s);
strcpy(#AZ5, #AZ4);
strcat(#AZ5, #AZ4);
sprintf(#s, "Size AZ5 %d", strlen(#AZ5)); mSL_log(SysLogBox, #s);
strcpy(#AZ6, #AZ4);
strcat(#AZ6, #AZ5);
sprintf(#s, "Size AZ6 %d", strlen(#AZ6)); mSL_log(SysLogBox, #s);
strcpy(#AZ7, #AZ4);
strcat(#AZ7, #AZ6);
sprintf(#s, "Size AZ7 %d", strlen(#AZ7)); mSL_log(SysLogBox, #s);
strcpy(#AZ8, #AZ4);
strcat(#AZ8, #AZ7);
sprintf(#s, "Size AZ8 %d", strlen(#AZ8)); mSL_log(SysLogBox, #s);

strcpy(#AZ9, #AZ8);
sprintf(#s, "Size AZ9 <= AZ8 %d", strlen(#AZ9)); mSL_log(SysLogBox, #s);


mSL_log(SysLogBox, "***STRING TEST END***");


*/



/*/

sprintf(#s, "**** %g  ****  %g  ****  %g  ****  %g  ****", xrand(0.5,1), xrand(10,10000), xrand(10,10000), xrand(10,10000));

mSL_log(SysLogBox, #s);
//* /



xyz = time();
loop (20,
    xyz = (xyz * Rndm_a + Rndm_c) % Rndm_m ;
    sprintf(#s,"  rnd: %12.0f", xyz);
    mSL_log(SysLogBox, #s);
);

//*/


/*

// Some tests
Rndm_n = 0;
loop (10,
    r0 = irand(10000); r1 = irand(10000);
    r2 = irand(10000); r3 = irand(10000);
    r4 = irand(10000); r5 = irand(10000);
    r6 = irand(10000); r7 = irand(10000);
    r8 = irand(10000); r9 = irand(10000);
    sprintf(#s, "   %5d     %5d    %5d    %5d    %5d    %5d    %5d    %5d    %5d    %5d ",
              r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
    mSL_log(SysLogBox, #s);
);

*/







/*


function xed(str, val)
(
    sprintf(str, "%d", val);
    str;
);

sprintf(#dbg_trace0, "Ex-1:  %s  %s", xed(#A1, 345), xed(#A2, 678));

xed(#A3, 345);
xed(#A4, 678);

sprintf(#dbg_trace2, "Ex-2:  %s  %s", #A3, #A4);

*/



function define_loaded()
(
    flagPMRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_PlMd;
    flagSPRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_SpMd;
    flagBKRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Bnks;
    flagHPCRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_HPC;
    flagClVRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Clips;
    flagClSetload = FlagsTbVals[Flgs_TblUpd] & flag_ld_ClSets;
    flagSnsrRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Sensrs;
    flagGM_mSL_ini = FlagsTbVals[Flgs_TblUpd] & flag_ld_Profile;
);

// execute this after a preser load
function after_load_actions()
(
    // +++ Temporary flags setting while debugging
    FlagsTbVals[Flgs_Inits] = 3;
    FlagsTbVals[Flgs_Play] = 0; // 0xf;
    FlagsTbVals[Flgs_Plyers] = 0;
    FlagsTbVals[Flgs_TblUpd] |= 0xffff;
    FlagsTbVals[Flgs_ConfLd] |= flag_ld_PlMd | flag_ld_SpMd | flag_ld_Bnks | flag_ld_HPC
                            | flag_ld_Clips | flag_ld_ClSets | flag_ld_Sensrs | flag_ld_Profile;
    flagDoLoadScripts = 1;
    define_loaded();
    //sprintf(#dbg_trace2, "Flags:  0x%X  0x%X  0x%X  0x%X", FlagsTbVals[Flgs_Play], FlagsTbVals[Flgs_Plyers],
    //                      FlagsTbVals[Flgs_ConfLd],FlagsTbVals[Flgs_TblUpd] );
);

//sprintf(#dbg_trace0, "Memory1: %d  %s  %s  %s", blockMemory1, MM1, blockDispNames[blockMemory1], memoryBox1[5]);
//sprintf(#dbg_trace1, "Memory2: %d  %s  %s  %s", blockMemory2, MM2, blockDispNames[blockMemory2], memoryBox2[5]);

GMW2("Init MAIN");




// Attempt to create a pair of users modules
/*
blockUsrNames[8] = "Module Urfé";
blockUsrRefs[8] = mSL_Dyn_Alloc(8, 'umod', mSL_StM_FlClear);
blockUsrNames[4] = "Special Timer";
blockUsrRefs[4] = mSL_Dyn_Alloc(8, 'umod', mSL_StM_FlClear);
checkUsrMods(); // valid blocks
mkModuleMenu();// rebuild the menu
*/








//====== SLIDERS ======
@slider


ibs = 1;
while (ibs < JSFXSlCnt) (
    ibv = slider(ibs);
    (sliders_current[ibs] != ibv) ? (
        sliders_current[ibs] = ibv;
        (ibv < sliders_Min[ibs]) ? sliders_Min[ibs] = ibv;
        (ibv > sliders_Max[ibs]) ? sliders_Max[ibs] = ibv;
        MIDILogActive ? (
            // Log into log
            sprintf(#s, "Slider %d : %g [%g %g]", ibs, ibv, sliders_Min[ibs], sliders_Max[ibs]);
            mSL_log(SysLogBox, #s);
        );
        ((u = getLinkEntry(Slider_Source_Ty+ibs)) >= 0) ? (
            // An action is associated
            // can we perform it ?
            sl_zz = sliders_Max[ibs] - sliders_Min[ibs];
            (sl_zz > 0) ? (
                W_Actions_Ent[W_Actions_Ptr] = u; // keep the entry
                // compute the appropriate value as a [0-1]
                W_Actions_Par[W_Actions_Ptr] = (ibv - sliders_Min[ibs]) / sl_zz; // a [0 1] value
                W_Actions_Flg = 1;
                W_Actions_Ptr = (W_Actions_Ptr + 1) % W_Actions_Siz;

            );
        );
    );
    ibs += 1;
);









































































//====== BLOCK ======

@block
// Update various times...
pTBlockStart = time_precise() + timeD; // date of start of @block
gmem[timeUnix] = tUnix = time();
pTDelta = pTBlockStart - pTimePrevious; // time from last run
pTimePrevious = pTBlockStart;

(T0 >= T_maxk) ? (
    T0 = T0 - T_maxk;
    T1 += 1; // we don't really care for overflows in T1 :-)
    S1 = T1 * T_div;
);



/*
(AGMXXX === 0) ? AGMW400 = GMW();
(AGMXXX === 1) ? AGMW410 = GMW();
(AGMXXX === 2) ? AGMW420 = GMW();
(AGMXXX === 3) ? AGMW430 = GMW();
(AGMXXX === 4) ? AGMW440 = GMW();
(AGMXXX === 5) ? AGMW450 = GMW();
(AGMXXX === 6) ? AGMW460 = GMW();
(AGMXXX === 7) ? AGMW470 = GMW();
(AGMXXX === 8) ? AGMW480 = GMW();
(AGMXXX === 9) ? AGMW490 = GMW();

AGMXXX += 1;
*/


// Check first words of memory, to detect eventual bugs
((!GMW()) && (XDcount > 0)) ? (
    sprintf(#s2, "Game Master Damaged! %s %s %s %s %s %s %s %s", mSL_edit_value(#, 0[0]), mSL_edit_value(#, 0[1]),
                mSL_edit_value(#, 0[2]), mSL_edit_value(#, 0[3]), mSL_edit_value(#, 0[4]), mSL_edit_value(#, 0[5]),
                mSL_edit_value(#, 0[6]), mSL_edit_value(#, 0[7]));
    mSL_log(SysLogBox, #s2);
    XDcount -= 1;
    XDcount > 0 ? GMI();
);



// Manage HP use counting
(HP_uDelta != 0) ? (
    (HP_uDelta < 0) ? (
        ib = HP_usage; loop(min(HPInstCnt,max(1, 0|paramValues[p_GvChnUse])),
            gmem[ib] = 0; ib += 1;
        );
        HP_uDelta = 0;
    ) :
    (pTBlockStart > HP_uTime) ? (
        HP_uTime = max(HP_uTime+HP_uDelta, pTBlockStart);
        ib = HP_usage; loop(min(HPInstCnt,max(1, 0|paramValues[p_GvChnUse])),
            gmem[ib] += 1; ib += 1;
        );
    );
);

(playReeval) ? (
    playReeval = 0;
    replayJumpTo(0, pPlayTimeCurrent, playModeSpeed); // updates p_VirtualTime
);

(recordMode === recModeOn) ? (
    pRecTimeCurrent += pTDelta; // keep "recorded" time value
    ppb_VirtualTime[pp_Max] = playTimeMax = max(ppb_VirtualTime[pp_Max], pRecTimeCurrent + playEpilog);
);


(replayMode === replayModeOn) ? (
    iprev = pPlayTimeCurrent;
    playFward = playModeSpeed >= 0;
    pPlayTimeCurrent += pTDelta * playModeSpeed; // keep "virtual" time value
    ((replayEntry != 0) && (replayEntry[SchevEvntName] === plIDNT)) ? (
        lppRepDate = replayEntry[plLEntRcrd];
        (playModeStep) ? (
            pPlayTimeCurrent = lppRepDate;
        );
        bk = 0;
        playTime2Next = abs((pPlayTimeCurrent - lppRepDate) / (max (0.0001, abs(playModeSpeed))));
        (playFward) ? (
            // should we play now ?
            (bk = (pPlayTimeCurrent >= lppRepDate - pTEpsilon)) ? (
                // play this entry
                doPlayRItem(replayEntry, playItemsFlags);
                // next entry to prepare ?
                replayEntry = replayEntry[SchevNxtEnt];
                (playModeStep) ? (
                    replayMode = replayModePause;
                    //sprintf(#dbg_trace1, "STEP1+ -> %d  %d", replayEntry, (replayEntry[SchevEvntName] === plIDNT));
                );
            );
        ) : (
            (bk = (pPlayTimeCurrent <= lppRepDate + pTEpsilon)) ? (
                // play this entry
                doPlayRItem(replayEntry, playItemsFlags);
                // next entry to prepare ?
                replayEntry = replayEntry[SchevPrvEnt];
                (playModeStep) ? (
                    replayMode = replayModePause;
                    //sprintf(#dbg_trace1, "STEP1- -> %d  %d", replayEntry, (replayEntry[SchevEvntName] === plIDNT));
                );
            );
        );
        (replayEntry[SchevEvntName] !== plIDNT) ? (
            // no more items to play
            gmem[playLogRef] = replayEntry = 0;
            playTime2Next = -1;
            // turn to pause ?
            (playAutoStop) ? (
                replayMode = replayModePause;
            );
            (playModeStep) ? (
                pPlayTimeCurrent = playFward ? playTimeMax : 0;
                replayMode = replayModePause;
                //sprintf(#dbg_trace2, "STEP2* -> %d  %d", pPlayTimeCurrent, replayMode);
            );
        ) : (
            (bk && playAndStop) ? (
                replayMode = replayModePause;
            );
        );
    ) : (
        gmem[playLogRef] = 0;
        playTime2Next = -1;
        (playAutoStop) ? (
            replayMode = replayModePause;
        );
        (playModeStep) ? (
            pPlayTimeCurrent = playFward ? playTimeMax : 0;
            replayMode = replayModePause;
            //sprintf(#dbg_trace2, "STEP2: -> %d  %d", pPlayTimeCurrent, replayMode);
        );
    );
    (lppLoopMd) ? (
        // we may have to loop
        (playFward) ? (
            (playJmpLoop || (pPlayTimeCurrent >= imax)) ? (
                ((pPlayTimeCurrent <= imin) || ((pPlayTimeCurrent >= imax) && (iprev <= imax)) || ((pPlayTimeCurrent >= imax) && playJmpLoop)) ? (
                    pPlayTimeCurrent = imin; playReeval = 1;
                );
            );
            // ((pPlayTimeCurrent >= imax) || (playJmpLoop && (pPlayTimeCurrent <= imin))) ? (pPlayTimeCurrent = imin; playReeval = 1;);
        ) : (
            //((pPlayTimeCurrent <= imin) || (playJmpLoop && (pPlayTimeCurrent >= imax))) ? (pPlayTimeCurrent = imax; playReeval = 1;);
            (playJmpLoop || (pPlayTimeCurrent <= imin)) ? (
                ((pPlayTimeCurrent >= imax) || ((pPlayTimeCurrent <= imin) && (iprev >= imin)) || ((pPlayTimeCurrent <= imin) && playJmpLoop)) ? (
                    pPlayTimeCurrent = imax; playReeval = 1;
                );
            );
        );
    ) : (
        (playSkipSlnc && (playTime2Next > playSkipDur)) ? (
            (playFward) ? (
                pPlayTimeCurrent += playTime2Next - playSkipDur;
            ) : (
                pPlayTimeCurrent -= playTime2Next - playSkipDur;
            );
            playReeval = 1;
        );
        (playSkipSlnc && (playTime2Next < 0)) ? (
            pPlayTimeCurrent = 0;
            playReeval = 1;
        );
    );
    ((pPlayTimeCurrent > playTimeMax-pTEpsilon) && (playFward)) ? (
        playRewind();
    );
    ((pPlayTimeCurrent - TEpsilon <= 0) && (playModeSpeed < 0)) ? (
        pPlayTimeCurrent = playTimeMax - TEpsilon;
        !playRepeatMd ? ( replayMode = replayModePause; );
        playReeval = 1;
    );
    gmem[playLogDate] = parSet(p_VirtualTime, pPlayTimeCurrent);
);



timeFlag0 = timeFlag1 = timeFlag2 = timeFlag3 = 0;
(pTBlockStart >= timeEvent0) ? (
    timeFlag0 = 1; timeEvent0 = timeEvent0 + 1;
);
(pTBlockStart >= timeEvent1) ? (
    timeFlag1 = 1; timeEvent1 = timeEvent1 + 1.173;
);
(pTBlockStart >= timeEvent2) ? (
    timeFlag2 = 1; timeEvent2 = timeEvent2 + 1.281;
);
(pTBlockStart >= timeEvent3) ? (
    timeFlag3 = 1; timeEvent3 = timeEvent3 + 1.389;
);

// Is there a script request ?
(scRq = gmem[thrdRqst]) ? (
    gmem[thrdRqst] = 0;
    sprintf(#s, "AS: %s  [%d  %d  %d]", mSL_edit_value(0,scRq), gmem[scptPar1], gmem[scptPar2], gmem[scptPar3]);
    mSL_log(SysLogBox, #s);
    (scRq === 'Done') ? (
        // most usual request : something is done...
        gmem[scptLock] = 0; // "unlock" access to script
    ) :
    (scRq === 'Path') ? (
        // Script signals current project Path
        getexpldstr(#s,gmem[scptPar1]);
        /*
        // mSL_log(SysLogBox, #s);
        #pat = "*"; strcat(#pat, #Def_AudioDir);
        match(#pat, #s) ? (
            strncpy(#D_GM_Project_Path, #s, strlen(#s)-strlen(#Def_AudioDir));
            strcpy(#D_GM_Project_Path_FX, #D_GM_Project_Path); strcat(#D_GM_Project_Path_FX, "Effects/*");
            mSL_log(SysLogBox, #D_GM_Project_Path);
            mSL_log(SysLogBox, #D_GM_Project_Path_FX);
        );
        */
        strcpy(#D_GM_Project_Path, #s); strcat(#D_GM_Project_Path, "/");
        mSL_log(SysLogBox, #D_GM_Project_Path);
        strcpy(#D_GM_Project_Path_FX, #D_GM_Project_Path); strcat(#D_GM_Project_Path_FX, "Effects/*");
        mSL_log(SysLogBox, #D_GM_Project_Path_FX);
    );
);

(tUnix != lastTime) ? (
    // EVERY SECOND

    // Update time
    lastTime = tUnix;
    locT.DTG_update(tUnix); // update with time
    // keep values available for others
    timeGMemUpdate();
    (lastMn != gmem[timeMinute]) ? (
        // Edit time every minute
        nowTime();
        // Check users modules
        checkUsrMods();
    );

    (lppLoopMd = ((lppLoop1 >= 0) && (lppLoop2 >= 0))) ? (
        // we may have to loop
        imax = max(markerDate(clTabE[lppLoop1]), markerDate(clTabE[lppLoop2]));
        imin = min(markerDate(clTabE[lppLoop1]), markerDate(clTabE[lppLoop2]));
    );

    (blockMinCntr > blockCntr) ? blockMinCntr = blockCntr;
    blockCntr = 0; // reset block counter

    // EVERY TICK
    (lastTick != gmem[timeTick]) ? (
        lastTick = gmem[timeTick];
        gmem[ticksCount] += 1;
        SharedHighMemory = mSL_StM_FreePt;
        SharedHighMemorySize = __memtop() - SharedHighMemory - 1;
        // Manage a tick counting, for statistics purposes
        blockTickCntr += 1;
        ((blockTickCntr % 23)== 3) ? (
            blockMinCntr = 99999; blockMaxCntr = 0;
         );

        // Update our players addresses
        upp = addPlayer;
        while (upp <= addPlayerLast) (gmem[upp] = UGDummy;  upp+= 1; );
        Ua = UGAddr; upp = addPlayer; readerCount = 0;
        memset(SUTrAddr, 0, SUTrASize);
        loop (uCnt,
            ty = gmem[Ua+cbType];
            ((ty != 0) && ((gmem[Ua+cbInacFlg] += 1) > 6)) ? (ty = gmem[Ua+cbType] = 0);
            ((ty === uPlayer) && (gmem[Ua+cbStat] != uSUnused)) ? (
                // we have a player
                (upp <= addPlayerLast) ? (
                    gmem[upp] = Ua; upp+= 1;
                    gmem[Ua+cbPlIdt] = readerCount; readerCount += 1;
                );
                SUTrAddr[gmem[Ua+RCB_My_Track]] = ua;
            );
            Ua += UCBSize;
        );
        ppb_maxGenerators[pp_Max] =  ppb_Gen_MinCnt[pp_Max] =  ppb_Gen_MaxCnt[pp_Max] = gmem[playerAvail] = readerCount;
        // Manage clips counting
        updClBk(cBk1);
        cBk1 = (cBk1 + 1) % clNBanks;

        mSL_Dyn_Recycle(-1);
        mSL_Dyn_TmpProtect(-1);

        // Update error display
        (err_sys === 0) ? (
              err_sys_ini ? (err_sys = err_sys_ini; err_sys_ini=0;)
            : mSL_StM_Err ? (err_sys = mSL_StM_Err; mSL_StM_Err=0;)
            : err_sys_rtm ? (err_sys = err_sys_rtm; err_sys_rtm=0;)
            : err_sys_gfx ? (err_sys = err_sys_gfx; err_sys_gfx=0;)
            : err_fclp ? (err_sys = err_fclp; err_fclp=0;)
            : err_fplm ? (err_sys = err_fplm; err_fplm =0;)
            : err_fhpc ? (err_sys = err_fhpc; err_fhpc=0;)
            : err_fspm ? (err_sys = err_fspm; err_fspm=0;)
            : err_fbnk ? (err_sys = err_fbnk; err_fbnk=0;)
            : err_sdfr ? (err_sys = err_sdfr; err_sdfr=0;)
            ;
        );


        BPlTresh1024 = 4 * (BPlTresh256 = 4 * (BPlTresh64 = 4 * (BPlTresh16 = 4 * (BPlTresh4 = 4 * paramValues[p_maxPlayers]))));
        BLpTresh1024 = 4 * (BLpTresh256 = 4 * (BLpTresh64 = 4 * (BLpTresh16 = 4 * (BLpTresh4 = 4 * paramValues[p_maxLoopers]))));

        atomic_set(mSL_Lock,max(atomic_get(mSL_Lock),0)); // unlock threads execution on error

        // Adapt Generator count
        (paramValues[p_maxGenerators] == 0) ? parSet(p_maxGenerators, paramValues[p_maxPlayers] + paramValues[p_maxLoopers]);

    );

    // EVERY SECOND
    // Manage process counting
    mSL_act = count_p_list(SchedActivPts);
    mSL_wait = count_p_list(SchedDlydPts) + count_p_list(SchedEvntPts);
    mSL_plck = count_p_list(SchedSuspPts) + count_p_list(SchedLockdPts);
    mSL_pmsg = count_p_list(SchedRcyclPts);

    ((mSL_Lock != 0) && (mSL_loc_tim <= 0) && (SchedLockAll === 0)) ? (
        mSL_Lock < 0 ? mSL_Lock = - mSL_Lock;
        atomic_add(mSL_loc_tim,20); // "gfx" ticks, so about 2"
        atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
    );

    mSL_malloc_failed ? (
        atomic_add(mSL_Lock,1);
        atomic_add(mSL_loc_tim,10);
        // run a GC
        gc_run_phaz = 1;
        mSL_malloc_failed = 0; // unset flag
    );

    (Schedrestart1 && (SchedLockAll === 0)) ? (
        (SchedListNonEmpty(SchedEvntPts)) ? (
            xgent = SchedDetachHead(SchedEvntPts);
            SchedInsertTail(SchedLockdPts, xgent, SchETypeThrd);
            mSL_log(SysLogBox, "SchedEvntPts  ——> SchedLockdPts");
        ) :
        (SchedListNonEmpty(SchedSuspPts)) ? (
            xgent = SchedDetachHead(SchedSuspPts);
            SchedInsertTail(SchedLockdPts, xgent, SchETypeThrd);
            mSL_log(SysLogBox, "SchedSuspPts  ——> SchedLockdPts");
        ) ;
        Schedrestart1 = 0;
    );

    (uuuMslFn != 0) ? (
        atomic_set(mSL_Lock, max(1,atomic_get(mSL_Lock)));
    );

    // Encore pertinent ?
    AAAAAA___ModulAlgo =  gmem[ModulAlgo];
    AAAAAA___ModulAlgoPl =  gmem[ModulAlgoPl];
    AAAAAA___ModPl =  gmem[ModPl];
    AAAAAA___ModDepth =  gmem[ModDepth];
    AAAAAA___ModWidth =  gmem[ModWidth];
    AAAAAA___ModWidthL =  gmem[ModWidthL];
    AAAAAA___ModFreq =  gmem[ModFreq];
    AAAAAA___ModTR1 =  gmem[ModTR1];
    AAAAAA___ModTR2 =  gmem[ModTR2];
    AAAAAA___ModTR3 =  gmem[ModTR3];
    AAAAAA___ModTR4 =  gmem[ModTR4];
    AAAAAA___ModTR5 =  gmem[ModTR5];
    AAAAAA___ModTRSWav =  gmem[ModSWav];

    playItemsFlags = playAndUnLock ? 0 : playAndLock;
    gmem[playerFLGS] = TRC = FlagsTbVals[Flgs_Plyers]; // transmit players flags
);



//  EVERY BLOCK
// Update our copies of System Variables
syssrate = srate;
sysTempo = tempo;
sysPlayState = play_state;
sysPlayPosition = play_position;
sysBeatPosition = beat_position;
sysSampPosition = 0 | (0.5 + sysPlayPosition * syssrate);
sysSampBeatPosition = 0 | (0.5 + sysPlayPosition * syssrate * sysTempo / 60);
sysSampBeat = 60 / sysTempo;

// Keep the number of samples to handle
sysSamplesBlock = samplesblock;
// This is the max. time allowed for the block
Curr_Block_Max_Delay = (sysSamplesBlock / srate); // in s.
// decide we wont work for more than a small percent of that
Curr_Block_Alloc = BlDurationProp * Curr_Block_Max_Delay;
// And here is the date at wich we expect to leave the block
ptBlockLimit = pTBlockStart + Curr_Block_Alloc;
TLeftMin = Curr_Block_Alloc * 0.35;


// Update the @block counter
blockCntr += 1; // block counter


// Do we have an mSL file loaded and compiled, ready to execute ?
(uuuMslFent != 0) ? (
    (FlagsTbVals[Flgs_Scripts] & 1) ? (
        (mSL_errX === 0) ? (
            // ready to introduce in the queue
            sprintf(#s, "Loaded %s", uuuMslFname);
        ) : (
            sprintf(#s, "File %s: err %d", uuuMslFname, mSL_errX);
        );
        mSL_log(SysLogBox, #s);
    );
    mSL_bl_clear(mSL_GC_Protected); // free compiler's structures
    uuuMslFent = 0;
    uuuMslLastFname = uuuMslFname;
    uuuMslFname = 0;
    atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
);

// Have we just achieved a GC ?
(gc_run_phaz > 2) ? (
    // gc is over
    gc_run_phaz = 0;
    (FlagsTbVals[Flgs_GC] & 2) ? (
        mem_walk(0);
        (FlagsTbVals[Flgs_GC] & 1) ? (
            mem_show();
        );
    );
    FlagsTbVals[Flgs_GC] = 0;
    atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
);

function StudioPadClick(num)
local (u, w)
(
    u = padStCells[num];
    (u & ui_jpad_ct_selec) ? (
        (u & ui_jpad_ct_round) ? (
            // stop playing the pad
            padStCells[num] = u ~ ui_jpad_ct_round;
            w = cmdPadBase + num + padStOffset | FLdoForcePlay | FLdoForceLock;
            doPlayer(-1, KmdUnlock, w); // unlock the player
        ) : (
            // start playing & lock
            padStCells[num] = u | ui_jpad_ct_round;
            Kbtp = cmdPadBase + num + padStOffset | FLdoForcePlay | FLdoForceLock;
        );
    ) : (
        // standard play
        Kbtp = cmdPadBase + num + padStOffset | FLdoForcePlay;
    );
    BKnumLastM = lastTime; BKnumUnchkd  = 16; // ?
);


//====== MIDI RECV ======
ucbMIDIstart();
while ((Minp = ucbMIDIget())  || (Minp = localMIDIget())) (
    MIDI_Received += 1;
    AAAA_MIDI_Received = MIDI_Received;
    // expect "note on"
    MIDIlastcmd[0] = MIDI_msgTim = gmem[Minp+3];
    MIDIlastcmd[1] = 3;
    MIDIlastcmd[2] = MIDI_msg1 = gmem[Minp];
    MIDIlastcmd[3] = MIDI_msg2 = gmem[Minp+1];
    MIDIlastcmd[4] = MIDI_msg3 = gmem[Minp+2];
    MIDIlastcmd[5] = MIDI_pack = (MIDI_msg1 << 8) | MIDI_msg2; // as a command word

    MIDILogActive ? (
        // Log into log
        sprintf(#s, "MIDI: %02X %02X %02X", MIDI_msg1, MIDI_msg2, MIDI_msg3);
        mSL_log(SysLogBox, #s);
    );

    SysLinksActive ? (
        // Set MIDI link flag
        SysLinkFlag = 1;
        MIDI_lk_msg1 = MIDI_msg1;
        MIDI_lk_msg2 = MIDI_msg2;
        MIDI_lk_msg3 = MIDI_msg3;
    );

    // Signal : "MIDI", Kmd (with channel), P1, P2, P1/P2 packed, date
    // mSL_signal_event(mSL_KW_MIDI, MIDI_msg1, MIDI_msg2, MIDI_msg3, MIDI_pack, MIDI_msgTim);


    ((u = getLinkEntry(MIDI_pack)) >= 0) ? (
        // Enter the action in the micro queue
        W_Actions_Ent[W_Actions_Ptr] = u; // keep the entry and the parameter
        W_Actions_Par[W_Actions_Ptr] = MIDI_msg3/127; // a [0 1] value
        MIDILogActive ? (
            sprintf(#s, "MIDI: %02X-%02X found. @ %d  [%d] %g ", MIDI_msg1, MIDI_msg2, u, W_Actions_Ptr, W_Actions_Par[W_Actions_Ptr]);
            mSL_log(SysLogBox, #s);
        );
        W_Actions_Flg = 1;
        W_Actions_Ptr = (W_Actions_Ptr + 1) % W_Actions_Siz;
    ) :

    SensorsActive ? (
        ((MIDI_msg1 & 0xF0) === 0x90) ? (
            MIDI_msg2 += 1;
            SensMIDIIn();
        );
    ) :

    ((MIDI_msg1 & 0xF0) === 0x90) ? (
        MIDILogActive ? (
            sprintf(#s, "Note-On %02X-%02X", MIDI_msg1, MIDI_msg2);
            mSL_log(SysLogBox, #s);
        );
        // StudioPadClick(MIDI_msg2);
    ) ;


);



//================= SHORTCUTS HANDLING ================
(W_Actions_Flg) ? (
    // locals: pak uak vak
    // restart from last
    W_Actions_x = W_Actions_Ent[W_Actions_Last];
    while ((ent = W_Actions_Ent[W_Actions_Last]) >= 0)  (
        sysAct = Links_Actn[ent];
        sysKode = Links_HTab[ent];
        sysVal = W_Actions_Par[W_Actions_Last]; // a 0-1 value for sliders or MIDI CC
        sysPar1 = Links_Par1[ent];
        sysPar2 = Links_Par2[ent];
        // clear the entry
        W_Actions_Ent[W_Actions_Last] = -1;

        // Some action is to be executed...
        uak = sysAct & MIDI_LinkMask; // The type, as  0xT000
        pak = sysAct & MIDI_LinkPar; // The parameter
        vak = sysPar1;
        (uak === MIDI_LinkTY_SV) ? (
            // Set a parameter to a single value
            parSet(pak, vak);
        ) :
        (uak === MIDI_LinkTY_CC) ? (
            // Set a parameter to a value interpolated from a MIDI CC
            pp = paramBlock + pak * paramEntSize; // its block description
            vak = uix_slider_ratio_to_value(sysVal, sysPar1, sysPar2, pp[pp_Slope]);
            parSet(pak, vak);
        ) :
        (uak === MIDI_LinkTY_Slid) ? (
            // Set a parameter to a value interpolated from a Slider
            pp = paramBlock + pak * paramEntSize; // its block description
            vak = uix_slider_ratio_to_value(sysVal, sysPar1, sysPar2, pp[pp_Slope]);
            parSet(pak, vak);
        ) :
        (uak === MIDI_LinkTY_Act) ? (
            // perform an action
            vak = pak; // TO DO
            Simple_temp[0] = 4; Simple_temp[1] = pak;
            Simple_temp[2] = sysPar1; Simple_temp[3] = sysPar2;
            Simple_temp[4] = 0; Simple_temp[5] = sysPar2; Simple_temp[6] = 0; Simple_temp[7] = 0;
            Simple_Action(Simple_temp);
        );
        // Trace
        MIDILogActive ? (
            sprintf(#s, "Action %d %d [%g %g] %g @ %d [%d] %g", (uak >> 12), pak, sysPar1, sysPar2, vak, ent, W_Actions_Last, sysVal);
            mSL_log(SysLogBox, #s);
        );
        W_Actions_Last = (W_Actions_Last + 1) % W_Actions_Siz;
        // done
    );
    W_Actions_Flg = 0;
    (W_Actions_Last != W_Actions_Ptr) ? (W_Actions_Last = (W_Actions_Last + 1) % W_Actions_Siz;);
);


(MIDI_Flag) ? (
    // try to recognize a sequence
    // ADump(MIDISeqncs);
    AAAAAA_MIDI_mode = MIDI_Sens_mode;
    memset(MIDILastSeq, 0, 8);
    AAAAAA_MIDI0 = MIDILastSeq[0] = MIDIMsgB[MIDI_Curr+1];
    AAAAAA_MIDI1 = MIDILastSeq[1] = MIDIMsgB[vv2 = (MIDI_Curr+1+MIDIbfSize-4)%MIDIbfSize];
    AAAAAA_MIDI2 = MIDILastSeq[2] = MIDIMsgB[vv3 = (MIDI_Curr+1+MIDIbfSize-8)%MIDIbfSize];
    AAAAAA_MIDI3 = MIDILastSeq[3] = MIDIMsgB[vv4 = (MIDI_Curr+1+MIDIbfSize-12)%MIDIbfSize];
    AAAAAA_MIDI4 = MIDILastSeq[4] = MIDIMsgB[vv5 = (MIDI_Curr+1+MIDIbfSize-16)%MIDIbfSize];
    xt2 = MIDI_msgTim - MIDIMsgB[vv2+2];
    xt3 = MIDI_msgTim - MIDIMsgB[vv3+2];
    xt4 = MIDI_msgTim - MIDIMsgB[vv4+2];
    xt5 = MIDI_msgTim - MIDIMsgB[vv5+2];


    GlKom = -1;
    AAAAAA_MIDI3 += 1;
    zza = findMIDIseq(MIDILastSeq, xt2, xt3, xt4, xt5);
    zza != 0 ? (
        Simple_Action(zza);
    );
    MIDI_Flag = 0;
);


//====== Scheduler management ======
while (ent = Scheduler()) (
    // locals: ksc
    AAAA_Sch_code = code = SchedCode[ent];
    AAAA_Sch_par1 = par1 = SchedPar1[ent];
    AAAA_Sch_par2 = par2 = SchedPar2[ent];
    AAAA_Sch_par3 = par3 = SchedPar3[ent];
    AAAA_Sch_par3 = par4 = SchedPar4[ent];

    // do some work...

    (code & SchedWBit) ? (
        SchedCode[ent] &= SchedWBMask ; // suppress wait bit
        SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
        ent = 0;
    ) :
    (code === 1) ? (
        // A defered action to perform
        (par1 === 'task') ? (
            // introduce this task in active list
            // par2 can be an entry number (in 1... 4096) or an entry address
            zact = par2;
            ((par2 > 0) && (par2 < SchedNEmax)) ? (
                zact = SchedFirstEnt + SchedEntSiz * par2;
            );
            ((zact >= SchedFirstEnt) && (zact <= SchedLastEnt)) ? (
                // This refers to an entry to execute
                SchedInsertTail(SchedActivPts, zact, SchETypeThrd);
            );
            SchedPar2[ent] = 0; // ok
        ) :
        (par1 === 'smsg') ? (
            // send a message to some task.
            // par2 is supposed to be a message - this is checked by event_send_msg
            (SchETypeMess === mSL_Mbl_check(par2)) ? (
                SchevDateSent[par2] = 0; // clear send date
                event_send_msg(par2);
            );
            SchedPar2[ent] = 0; // message has been transmitted
        );
    ) :
    (code === 2) ? (
        releaseSensors(par1);
    ) :
    (code === 3) ? (
        releaseSensors(-1);
        SchedRemove(SchedDlydPts, 2); // remove all codes "2"
    ) :
    (code === 4) ? (
        AddDummyMIDIImm(par1);
    ) :
    (code === 5) ? (
        // Switch to next group
        SchedAddTask(4, 0, 0, 0, 0, 0, 0);
        ksc = paramValues[p_GRP_Switch] * (1 + 0.8 * (2*frand() - 1));
        Schedule(SchedRelative, ksc, 5, 0, 0, 0, 0);
    ) :
    (code === 6) ? (
        // change randomly volume
        SchedAddTask(2, 0, 0, 0, 0, 0, 0);
        // reschedule...
        ksc = paramValues[p_Vol_SwtchTime] * (1 + 0.8 * (2*frand() - 1));
        Schedule(SchedRelative, ksc, 6, 0, 0, 0, 0);
    ) :
    (code === 7) ? (
        // change max player
        SchedAddTask(9, 0, 0, 0, 0, 0, 0);
        // reschedule...
        ksc = paramValues[p_Gen_SwtchTime] * (1 + 0.8 * (2*frand() - 1));
        Schedule(SchedRelative, ksc, 7, 0, 0, 0, 0);
    ) :
    (code === 8) ? (
        // Run entry "0" of tasks
        ksc = 0; // should refer to a compiled code ???
        sprintf(#u, "Code 8: Ksc: %d - Err: %04d", ksc, mSL_errX);
        mSL_log(SysLogBox, #u);
        mSL_errX = 0;
        ((mSL_bl_check(ksc, Undef, 9793) === 0) && (ksc[mSL_CC_Key] === mSL_CC_KeyCKod)) ? (
            // try to execute the gizmo
            (ent = getNewThread()) ? (
                SchedPar1[ent] = ksc; // keep the code to execute
                SchedPar4[ent] = 0; // use current own variables
                SchedCode[ent] = KRun_mSL_Thread; // ready to start running a thread
                mSL_init_thread(ent);
            ) : (
                err_sys_rtm = 9606;
            );
            (mSL_errX === 0) ? (
                SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
                ent = 0;
            ) : (
                sprintf(#u, "Code 8: Ent: %d - Err: %04d", ent, mSL_errX);
                mSL_log(SysLogBox, #u);
                // ADump(ksc);
            );
        );
    ) :
    (code === 9) ? (
        // execute a delayed list of "simple actions"
        Simple_Action(par1);
    ) :
    (code === KRun_mSL_Thread)? ( // 10
        // A delayed mSL Thread
        // reintroduce the thread in the queue
        SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
        ent = 0;
    );
    // possibly free the entry
    ent ? SchedFree(ent); // appropriate free operation
);


/*
=== Recurring Actions each block ===
*/
//======
//======
//======
//======

//  ??? !!!
iii=0; mm_cyc_max=0; mm_dur_max = 0;
loop(mm_cyc_siz,
    k = mm_cyc_mm[iii]; (k > mm_cyc_max ? mm_cyc_max = k);
    k = mm_dur_mm[iii]; (k > mm_dur_max ? mm_dur_max = k);
    iii += 1;
);
mm_cyc_ptr = (mm_cyc_ptr + 1) % mm_cyc_siz;
mm_cyc_mm[mm_cyc_ptr] = 0; mm_dur_mm[mm_cyc_ptr] = 0;



timeFlag0 ? (

    // EVERY SECOND

    // mSL stats: mean (on 3 minutes) and max number of mSL instruction every second.
    iii=0; mm_xec_cnt=0; mm_xec_max=0;
    loop(mm_xec_siz, k = mm_xec_mm[iii]; mm_xec_cnt += mm_xec_mm[iii]; (k > mm_xec_max ? mm_xec_max = k); iii += 1; );
    mm_xec_cnt = 0|(mm_xec_cnt/mm_xec_siz);
    mm_xec_ptr = (mm_xec_ptr + 1) % mm_xec_siz;
    mm_xec_mm[mm_xec_ptr] = 0;

    mSL_CP_Flags = FlagsTbVals[Flgs_Cplr]; // update compiler flags

    // check waiting processes for a time-out
    ient = SchedFirstEnt;
    while (ient <= SchedLastEnt) (
        ((ient[SchedThList] === SchedEvntPts) && (ient[SchedDly] < pTBlockStart)) ? (
            ient = SchedUnchainEnt(SchedEvntPts, ient, 0);
            ient[SchedDly] = -1;
            SchedInsertTail(SchedActivPts, ient, 0);
        );
        ient += SchedEntSiz;
    );


    gmem[APCdispvalue] = MIDI_Sens_mode + 10;

    // Are we playing something ?
    ibg = 0;
    Bcpy = Beop = Bflg = BPlc = BLpc = 0;
    xplay1 = xplay = UFirst = UNext = 0;
    xplay1 = xplay = -1;
    // Should we stop older players ?
    playAllow = UplayControl ? paramValues[p_Play_Max] : 999;
    allowOldUbg = 0;
    ppc = 0;
    allowOldTim = pTBlockStart;
    pKP = pKRP = 0; memset(psKPlaying, -1, 2 * psKPlaySiz);
    loop (uCnt,
        Ubg = UGAddr + ibg * UCBSize;
        (gmem[Ubg + cbType] === uPlayer) ? (
            stat = gmem[Ubg+cbStat];
            ppc += 1;
            (stat === uSUnused) ? (
                (gmem[Ubg + RCB_Kmd] === KmdPlay) ? BPlc += 1;
                (gmem[Ubg + RCB_Kmd] === KmdLoop) ? BLpc += 1;
                (gmem[Ubg + RCB_cbCKmd] === KmdPlay) ? BPlc += 1; // L=>C
                (gmem[Ubg + RCB_cbCKmd] === KmdLoop) ? BLpc += 1; // L=>C
            ) : (
                xplayf = 0;
                Bcpy += gmem[Ubg + cbClipCnt];
                Beop += gmem[Ubg + cbErC];
                (stat === uSBusy) ? (
                    // The unit is busy playing; is it one we should stop ?
                    playAllow -= 1;
                    ((allowOldTim > gmem [Ubg+RCB_CPStart_tim]) && ((gmem[Ubg+RCB_PBFlgs] & FLdoForceKeep) === 0)) ? (
                        // keep reference
                        allowOldUbg = Ubg; allowOldTim = gmem [Ubg+RCB_CPStart_tim];
                    );
                    (gmem[Ubg+RCB_Repl_Src] > 0) ? (
                        psKReplaying[pKRP] = gmem[Ubg+RCB_Repl_Src]; pKRP += 1; // keep only replayed entries
                    ) :
                    (gmem[Ubg+RCB_Log_Entry] > 0) ? (
                        psKPlaying[pKP] = gmem[Ubg+RCB_Log_Entry]; pKP += 1; // keep only logged entries
                    );
                    (gmem[Ubg + RCB_Cl_Flgs] === 0) ? (
                        (UFirst === 0) ? Ufirst = Ubg;
                        ((UNext === 0) && (ULast < Ubg)) ? UNext = Ubg;
                    );
                    Bflg += 1;
                    (gmem[Ubg + RCB_cbCKmd] === KmdPlay) ? (BPlc += 1; xplayf = 2; xplay1 = xplay; xplay = ibg;); // L=>C
                    (gmem[Ubg + RCB_cbCKmd] === KmdLoop) ? (BLpc += 1; xplayf = 2; xplay1 = xplay; xplay = ibg;); // L=>C
                    (xplayf) ? (
                        bpla = Bplayers;
                        loop (BplayerInfoCount,
                            (bpla[0] === 1) ? (  // "last" ?
                                (xplayf === 2)? (
                                    xplayf = 1; bpla[1]=xplay;
                                    bpla[2]= gmem[UGAddr + UCBSize * xplay + cbPlIdt];
                                ) :
                                ((xplayf === 1) && (xplay1 >= 0)) ? (
                                    xplayf = 0; bpla[1]=xplay1;
                                    bpla[2]= gmem[UGAddr + UCBSize * xplay1 + cbPlIdt];
                                ) ;
                            );
                            bpla += BCtrlInfoSize;
                        );
                        // ui_GFXdoNow |= 1;
                    );
                );
            );
        );
        ibg+= 1;
    );
    (UNext === 0) ? UNext = UFirst;
    ((playAllow < 0) && (allowOldUbg > 0)) ? (
        // kill the oldest playing
        gmem[allowOldUbg+RCB_Kmd] = KmdStop;
        gmem[allowOldUbg+cbStat] = uSHalting;
        // prepare a new exploration
        timeEvent0 -= 0.8;
    );


    (pcheckGPLR) ? (
        pcheckGPLR = 0;

        // Players & Loopers count management
        (paramStatus[p_maxPlayers] & pStat_Mod) ? (
            paramStatus[p_maxPlayers] &= mStat_UnMod;
            updGR = 1;
        );

        (paramStatus[p_maxLoopers] & pStat_Mod) ? (
            paramStatus[p_maxLoopers] &= mStat_UnMod;
            updGR = 1;
        );

        (updGR) ? (
            plct = paramValues[p_maxPlayers]; lpct = paramValues[p_maxLoopers];
            // we update the generators count and the player/looper ratio
            parSet(p_maxGenerators, plct + lpct);
            parSet(p_ratioReadLoop, cpPlLPRatio(plct, lpct));
            paramStatus[p_maxGenerators] &= mStat_UnMod;
            paramStatus[p_ratioReadLoop] &= mStat_UnMod;
            updTrsh = 1;
            updGR = 0;
        );



        (paramStatus[p_maxGenerators] & pStat_Mod) ? (
            paramStatus[p_maxGenerators] &= mStat_UnMod;
            updPL = 1;
        );

        (paramStatus[p_ratioReadLoop] & pStat_Mod) ? (
            paramStatus[p_ratioReadLoop] &= mStat_UnMod;
            updPL = 1;
        );

        (updPL) ? (
            gnct = paramValues[p_maxGenerators];
            rat = paramValues[p_ratioReadLoop];
            // update: compute players, deduce loopers
            (rat >= 0) ? (
                // players <= loopers
                plct = 0.1 * (0 | (10 * gnct * (rat - 100) / (rat - 200))) ;
                lpct = gnct - plct;
            ) : (
                lpct = 0.1 * (0 | (10 * gnct * (rat + 100) / (rat + 200))) ;
                plct = gnct - lpct;
            );
            //
            parSet(p_maxPlayers, plct);
            parSet(p_maxLoopers, lpct);
            paramStatus[p_maxPlayers] &= mStat_UnMod;
            paramStatus[p_maxLoopers] &= mStat_UnMod;
            updTrsh = 1;
            updPL = 0;
        );

        (updTrsh) ? (
            BPLCTAbase = BPLCTime = 0;
            BPlTresh1024 = 4 * (BPlTresh256 = 4 * (BPlTresh64 = 4 * (BPlTresh16 = 4 * (BPlTresh4 = 4 * paramValues[p_maxPlayers]))));
            BLpTresh1024 = 4 * (BLpTresh256 = 4 * (BLpTresh64 = 4 * (BLpTresh16 = 4 * (BLpTresh4 = 4 * paramValues[p_maxLoopers]))));
            ui_GFXdoNow |= 1;
            updTrsh = 0;
        );



        (paramValues[p_Gen_MinCnt] > paramValues[p_Gen_MaxCnt]) ? (
            uv = paramValues[p_Gen_MinCnt]; paramValues[p_Gen_MinCnt] = paramValues[p_Gen_MaxCnt]; paramValues[p_Gen_MaxCnt] = uv;
        );


        (paramValues[p_Vol_MinVal] > paramValues[p_Vol_MaxVal]) ? (
            uv = paramValues[p_Vol_MinVal]; paramValues[p_Vol_MinVal] = paramValues[p_Vol_MaxVal]; paramValues[p_Vol_MaxVal] = uv;
        );

        (paramValues[p_GrainSizMin] > paramValues[p_GrainSizMax]) ? (
            uv = paramValues[p_GrainSizMin]; paramValues[p_GrainSizMin] = paramValues[p_GrainSizMax]; paramValues[p_GrainSizMax] = uv;
        );




    );
    ppb = paramBlock + p_Play_Max * paramEntSize;
    ppb[pp_Max] = playersCount = ppc;
);


timeFlag1 ? (

    // HP Used management [every second]
    ibl = 0;
    loop (HP_Set_Used,
        HP_Set_Cntr[ibl] = max(0,  HP_Set_Cntr[ibl]-1);
        ibl += 1;
    );

    AllowedPlA = (paramValues[p_maxPlayers] > 0); // allowed to play (Absolute)
    AllowedLpA = (paramValues[p_maxLoopers] > 0); // allowed to loop (Absolute)
    AllowedPlR = (paramValues[p_maxPlayers] > 0) && (max(paramValues[p_maxPlayers], 1) > BPlc); // allowed to play (Restricted)
    AllowedLpR = (paramValues[p_maxLoopers] > 0) && (max(paramValues[p_maxLoopers], 1) > BLpc); // allowed to loop (Restricted)

    // Maintain Loop/play stats every second
    // Players checking
    BPlSig4 = max(0, BPlSig4+BPlc-BPlBuf4[BPlPtr4]); BPlBuf4[BPlPtr4] = BPlc; BPlPtr4 = (BPlPtr4+1)%4;
    BPlSig16 = max(0, BPlSig16+BPlc-BPlBuf16[BPlPtr16]); BPlBuf16[BPlPtr16] = BPlc; BPlPtr16 = (BPlPtr16+1)%16;
    BPlSig64 = max(0, BPlSig64+BPlc-BPlBuf64[BPlPtr64]); BPlBuf64[BPlPtr64] = BPlc; BPlPtr64 = (BPlPtr64+1)%64;
    BPlSig256 = max(0, BPlSig256+BPlc-BPlBuf256[BPlPtr256]); BPlBuf256[BPlPtr256] = BPlc; BPlPtr256 = (BPlPtr256+1)%256;
    BPlSig1024 = max(0, BPlSig1024+BPlc-BPlBuf1024[BPlPtr1024]); BPlBuf1024[BPlPtr1024] = BPlc; BPlPtr1024 = (BPlPtr1024+1)%1024;
    // Loopers checking
    BLpSig4 = max(0, BLpSig4+BLpc-BLpBuf4[BLpPtr4]); BLpBuf4[BLpPtr4] = BLpc; BLpPtr4 = (BLpPtr4+1)%4;
    BLpSig16 = max(0, BLpSig16+BLpc-BLpBuf16[BLpPtr16]); BLpBuf16[BLpPtr16] = BLpc; BLpPtr16 = (BLpPtr16+1)%16;
    BLpSig64 = max(0, BLpSig64+BLpc-BLpBuf64[BLpPtr64]); BLpBuf64[BLpPtr64] = BLpc; BLpPtr64 = (BLpPtr64+1)%64;
    BLpSig256 = max(0, BLpSig256+BLpc-BLpBuf256[BLpPtr256]); BLpBuf256[BLpPtr256] = BLpc; BLpPtr256 = (BLpPtr256+1)%256;
    BLpSig1024 = max(0, BLpSig1024+BLpc-BLpBuf1024[BLpPtr1024]); BLpBuf1024[BLpPtr1024] = BLpc; BLpPtr1024 = (BLpPtr1024+1)%1024;



    BPLCTime = max(BPLCTAbase, (BPLCTime + 1) % BPLCTlimit);
    BPLCTAbase = min(BPLCTime, BPLCTbase);
    AAAAAA_Time = BPLCTime;
    AAAAAA_Tbase = BPLCTbase;
    AAAAAA_TAbase = BPLCTAbase;
    AAAAAA_Tlimit = BPLCTlimit;

    BPladd = BLpadd = 0;

    (BPLCTime < 1024) ? (
        (BPLCTime < 256) ? (
            (BPLCTime < 64) ? (
                (BPLCTime < 16) ? (
                    (BPLCTime < 4) ? (
                        BPlDoPlay = paramValues[p_maxPlayers] > 0 ;
                        BLpDoPlay = paramValues[p_maxLoopers] > 0 ;
                        BPlRat = (paramValues[p_maxPlayers] > 0) ? BPlc / paramValues[p_maxPlayers] : 1;
                        BLpRat = (paramValues[p_maxLoopers] > 0) ? BLpc / paramValues[p_maxLoopers] : 1;
                        BPladd = paramValues[p_maxPlayers] - BPlc;
                        BLpadd = paramValues[p_maxLoopers] - BLpc;
                    ) : (
                        BPlRat = BPlTresh4 > 0 ? BPlSig4/BPlTresh4 : 1;
                        BLpRat = BLpTresh4 > 0 ? BLpSig4/BLpTresh4 : 1;
                        BLpDoPlay = (BLpTresh4 * BPlAdjF) > BLpSig4;
                        BPlDoPlay = (BPlTresh4 * BPlAdjF) > BPlSig4;
                        (BLpDoPlay && BPlDoPlay) ? (
                            BPlRat > BLpRat ? (BPlDoPlay = 0) : (BLpDoPlay = 0);
                        );
                        BPladd = paramValues[p_maxPlayers] - BPlSig4/4;
                        BLpadd = paramValues[p_maxLoopers] - BLpSig4/4;
                    );
                ) : (
                    BPlDoPlay = (BPlTresh16 * BPlAdjF) > BPlSig16;
                    BPlRat = BPlTresh16 > 0 ? BPlSig16/BPlTresh16 : 1;
                    BLpDoPlay = (BLpTresh16 *  BPlAdjF) > BLpSig16;
                    BLpRat = BLpTresh16 > 0 ? BLpSig16/BLpTresh16 : 1;
                    (BLpDoPlay && BPlDoPlay) ? (
                        BPlRat > BLpRat ? (BPlDoPlay = 0) : (BLpDoPlay = 0);
                    );
                    BPladd = paramValues[p_maxPlayers] - BPlSig16/16;
                    BLpadd = paramValues[p_maxLoopers] - BLpSig16/16;
                );
            ) : (
                BPlDoPlay = (BPlTresh64 * BPlAdjF) > BPlSig64;
                BPlRat = BPlTresh64 > 0 ? BPlSig64/BPlTresh64 : 1;
                BLpDoPlay = (BLpTresh64 * BPlAdjF) > BLpSig64;
                BLpRat = BLpTresh64 > 0 ? BLpSig64/BLpTresh64 : 1;
                (BLpDoPlay && BPlDoPlay) ? (
                    BPlRat > BLpRat ? (BPlDoPlay = 0) : (BLpDoPlay = 0);
                );
                BPladd = paramValues[p_maxPlayers] - BPlSig64/64;
                BLpadd = paramValues[p_maxLoopers] - BLpSig64/64;
            );
        ) : (
            BPlDoPlay = BPlTresh256 * BPlAdjF > BPlSig256;
            BPlRat = BPlTresh256 > 0 ? BPlSig256/BPlTresh256 : 1;
            BLpDoPlay = BLpTresh256 * BPlAdjF > BLpSig256;
            BLpRat = BLpTresh256 > 0 ? BLpSig256/BLpTresh256 : 1;
            (BLpDoPlay && BPlDoPlay) ? (
                BPlRat > BLpRat ? (BPlDoPlay = 0) : (BLpDoPlay = 0);
            );
            BPladd = paramValues[p_maxPlayers] - BPlSig256/256;
            BLpadd = paramValues[p_maxLoopers] - BLpSig256/256;
        );
    ) : (
        BPlDoPlay = BPlTresh1024 * BPlAdjF > BPlSig1024;
        BPlRat = BPlTresh1024 > 0 ? BPlSig1024/BPlTresh1024 : 1;
        BLpDoPlay = BLpTresh1024 * BPlAdjF > BLpSig1024;
        BLpRat = BLpTresh1024 > 0 ? BLpSig1024/BLpTresh1024 : 1;
        (BLpDoPlay && BPlDoPlay) ? (
            BPlRat > BLpRat ? (BPlDoPlay = 0) : (BLpDoPlay = 0);
        );
        BPladd = paramValues[p_maxPlayers] - BPlSig1024/1024;
        BLpadd = paramValues[p_maxLoopers] - BLpSig1024/1024;
    );


    AAAAAA_flags = (paramStatus[p_maxPlayers] & pStat_Mod) | ((paramStatus[p_maxLoopers] & pStat_Mod) * 10) |
        ((paramStatus[p_maxGenerators] & pStat_Mod) * 100) | ((paramStatus[p_ratioReadLoop] & pStat_Mod) * 1000);
    AAAAAA_loopers = paramValues[p_maxLoopers];
    AAAAAA_readers = paramValues[p_maxPlayers];
    AAAAAA_generators = paramValues[p_maxGenerators];
    AAAAAA_pllpratio = paramValues[p_ratioReadLoop];
    AAAAAA_BPlDoPlay = BPlDoPlay = (BPlDoPlay && AllowedPlR);
    AAAAAA_BLpDoPlay = BLpDoPlay = (BLpDoPlay && AllowedLpR);
    AAAAAA_BPladd = BPladd ;
    AAAAAA_BLpadd = BLpadd ;



    cbuffsecs[cbsptr] = (Bflg != 0); cbsptr = (1 + cbsptr) % cbsecsize;
    gmem[comPlCnt] = Bflg; // keep active count for info
    gmem[comPlClips] = Bcpy; // keep total clips played up to now
    gmem[comPlErrs] = Beop; // keep total clip errors found

    // Should we stop some sound generator ?
    flagStopOne ? (
        flagStopOne = max(0, flagStopOne - 1);
        UNext ? (
            ULast = UNext;
            gmem[UNext + RCB_Kmd] = KmdQStop;
        );
    );

    // TRACE

    ibg = 0; Bcnt = 0;
    loop (cbsecsize, Bcnt += cbuffsecs[ibg]; ibg +=1;);
    statmin = Bcnt / 60;  // stats on floating last minute

    (gmem[comPlCnt] > 0) ? play_time += 1;



    // EVERY MINUTE
    (lastMn != gmem[timeMinute]) ? (
        lastMn = gmem[timeMinute];
        decimalHour = gmem[timeHour] + lastMn/100; // so 8h30 is 8.30

        // Edit time every minute
        // nowTime();
        // updGR =
        pcheckGPLR = 1; // check parameters coherency

        // keep statistics for each minute
        cbuffmin[cbmptr] = Bcnt; cbmptr = (1 + cbmptr) % cbminsize;
        ibg = 0; Bcnt = 0;
        loop (cbminsize, Bcnt += cbuffmin[ibg]; ibg +=1;);
        stathour = Bcnt / 3600;

        // Get our own local prime...
        ULocPrime = gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];

        // EVERY HOUR
        (lastHr != gmem[timeHour]) ? (
            lastHr = gmem[timeHour];

            (menu_Scripts === 0) ? get_mSL_scripts();
            (menu_Config === 0) ? get_txt_configs();
            (cBk2 >= clNBanks) ? cBk2 = 0; // rescan banks when they are displayed


            // Update our units prime number
            ibg = irand(1001);
            loop (uCnt,
                ibg = (ibg + 1) % uCnt;
                Ubg = UGAddr + ibg * UCBSize;
                //(gmem[Ubg + cbType] != 0) ? (
                    gmem[Ubg+cbLocPrime] =
                        gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];
                //);
            );

            cbuffhours[cbhptr] = Bcnt; cbhptr = (1 + cbhptr) % cbhoursize;
            ibg = 0; Bcnt = 0;
            loop (cbhoursize, Bcnt += cbuffhours[ibg]; ibg +=1;);
            statday = Bcnt / 86400;

            mSL_log(SysLogBox, #nowis);
            flagShowMemory = 1;
        );

        // Keep info for the last ten minutes
        Bcnt = 0;  ibg = (cbmptr - 10 + cbminsize) % cbminsize;
        loop (10, Bcnt += cbuffmin[ibg]; ibg = (ibg + 1) % cbminsize;);
        stat10m = Bcnt / 600;



        // bidouillage infâme ?
        ((paramStatus[p_rgenP6] & pStat_lA_MaskC) === 0) ? (
            recolorRandLeds();
        );
    );


    DynParamsSave(paramDynamic66);    // Update dyn. parameters

);



timeFlag2 ? (
    timeFlag2Cnt += 1;
    // update some not so critical informations
    ubXcnt = ubXdur = ubXmax = 0;
    gbCPU = gbXmax = gbXdur = 0;
    ubm = 0; loop (blStatSiz,
        ubXcnt += blStatXecCnt[ubm];
        ubXdur += blStatCPUUse[ubm];
        ubXmax = max(ubXmax, blStatCPUMax[ubm]);
        gbXdur += blStatGFXUse[ubm];
        gbXmax = max(gbXmax, blStatGFXMax[ubm]);
        ubm += 1;
    );
    ubMeanT = ubXdur/max(1, ubXcnt); // durée moyenne par bloc
    ubm = (blStatThis + blStatSiz - 60) % blStatSiz;
    loop (60,
        gbCPU += blStatGFXUse[ubm];
        ubm = (ubm + 1) % blStatSiz;
    );


    //============== Configuration Loading ================
    A_0001_FlagsTbVals = FlagsTbVals;
    A_0001_FlagsTbValsCfl = FlagsTbVals[Flgs_ConfLd];
    // EVERY SECOND
    (delayLoad > 0) ? (
        delayLoad -= 1;
    ) : (
        (flagClSetload != 0) && (flagDoLoadScripts != 0) ? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_ClipSetConf); mSL_log(SysLogBox, #s);
            );
            flagClSetload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_ClSets) ? (
                (match("*.mSL", #D_ClipSetConf)) ? (
                    // Impose de recharger les banques !
                    flagBKRload = 1;
                    0 ? mSL_log(SysLogBox, "Set flagBKRload in Configuration Loading");
                    doMslCompile(#D_ClipSetConf);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_ClipSetConf) != 0) ? (
                        sprintf(#s, "ClipSetConf: \"%s\" is not a loadable file", #D_ClipSetConf);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                clearClipSets();
                flagBKRload = 1; // we will have to reload the banks
                0 ? mSL_log(SysLogBox, "Set flagBKRload in clearClipSets()");
            );
        ) :
        (flagClVRload != 0) && (flagDoLoadScripts != 0) ? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_ClipsModifiers); mSL_log(SysLogBox, #s);
            );
            flagClVRload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_Clips) ? (
                (match("*.mSL", #D_ClipsModifiers)) ? (
                    doMslCompile(#D_ClipsModifiers);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_ClipsModifiers) != 0) ? (
                        sprintf(#s, "Clips Modifiers: \"%s\" is not a loadable file", #D_ClipsModifiers);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                clearClipsCharacteristics();
                mSL_log(SysLogBox, "Clips Modifiers reinitialized");
            );
        ) :
        (flagHPCRload != 0) && (flagDoLoadScripts != 0) ? (
           (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_HPConfigs); mSL_log(SysLogBox, #s);
            );
            flagHPCRload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_HPC) ? (
                (match("*.mSL", #D_HPConfigs)) ? (
                    //
                    doMslCompile(#D_HPConfigs);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_HPConfigs) != 0) ? (
                        sprintf(#s, "HP Configs: \"%s\" is not a loadable file", #D_HPConfigs);
                        mSL_log(SysLogBox, #s);
                    ) : (
                        HPConfDefBuild();
                    );
                );
            ) : (
                HPConfDefBuild(); // HPConfInit();
                mSL_log(SysLogBox, "HP Configs reinitialized");
            );
        ) :
        (flagSPRload != 0) && (flagDoLoadScripts != 0)? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_SpaceModes); mSL_log(SysLogBox, #s);
            );
            flagSPRload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_SpMd) ? (
                (match("*.mSL", #D_SpaceModes)) ? (
                    doMslCompile(#D_SpaceModes);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_SpaceModes) != 0) ? (
                        sprintf(#s, "Space Modes: \"%s\" is not a loadable file", #D_SpaceModes);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                defSMEntryDefault(); updSMEntries();
                mSL_log(SysLogBox, "Space Modes reinitialized");
            );
        ) :
        (flagPMRload != 0) && (flagDoLoadScripts != 0) ? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_PlayModes); mSL_log(SysLogBox, #s);
            );
            flagPMRload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_PlMd) ? (
                (match("*.mSL", #D_PlayModes)) ? (
                    doMslCompile(#D_PlayModes);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_PlayModes) != 0) ? (
                        sprintf(#s, "Play Modes: \"%s\" is not a loadable file", #D_PlayModes);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                0 ? (mSL_log(SysLogBox, "::Flag not set"););
                defPMEntryInit(); updPMEntries();
                mSL_log(SysLogBox, "Play Modes reinitialized");
            );
        ) :
        (flagBKRload != 0) && (flagDoLoadScripts != 0) ? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_BanksDefs); mSL_log(SysLogBox, #s);
            );
            flagBKRload = 0;
            0 ? (mSL_log(SysLogBox, "ReSet flagBKRload in Configuration Loading"););
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_Bnks) ? (
                (match("*.mSL", #D_BanksDefs)) ? (
                    doMslCompile(#D_BanksDefs);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_BanksDefs) != 0) ? (
                    sprintf(#s, "BanksDefs: \"%s\" is not a loadable file", #D_BanksDefs);
                    mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                defBankInit();
                0 ? mSL_log(SysLogBox, "Banks reinitialized");
            );
        ) :
        (flagSnsrRload != 0) && (flagDoLoadScripts != 0) ? (
            (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_InSens_Name); mSL_log(SysLogBox, #s);
            );
            flagSnsrRload = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_Sensrs) ? (
                (match("*.mSL", #D_InSens_Name)) ? (
                    doMslCompile(#D_InSens_Name);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_InSens_Name) != 0) ? (
                        sprintf(#s, "Sensors: \"%s\" is not a loadable file", #D_InSens_Name);
                        mSL_log(SysLogBox, #s);
                    );
                );
            ) : (
                SensorsClear();
            );
        ) :
        (flagGM_mSL_ini != 0) && (flagDoLoadScripts != 0) ? (
           (FlagsTbVals[Flgs_Inits] & 1) ? (
                sprintf(#s, "::About to load: \"%s\"", #D_GM_mSL_ini); mSL_log(SysLogBox, #s);
            );
            flagGM_mSL_ini = 0;
            (FlagsTbVals[Flgs_ConfLd] & flag_ld_Profile) ? (
                // Load the mSL profile
                (match("*.mSL", #D_GM_mSL_ini)) ? (
                    doMslCompile(#D_GM_mSL_ini);
                    delayLoad += delayLdInt;
                ) : (
                    (strlen(#D_GM_mSL_ini) != 0) ? (
                        sprintf(#s, "Profile: \"%s\" is not a loadable file", #D_GM_mSL_ini);
                        mSL_log(SysLogBox, #s);
                    );
                );
            );
        ) :
        (
            delayLoad += 60;
        );
    );

    (PMnumUnchkd && (PMnumLastM < lastTime - waitAfterMod)) ? (
        PMnumUnchkd  = 0;
        // padPMVals[0] = 0|max(0, min(PMEcnt-1, padPMVals[0]));
        padPMVals[0] = updPlMdNumber(padPMVals[0], 0);
    );

    (SMnumUnchkd && (SMnumLastM < lastTime - waitAfterMod)) ? (
        SMnumUnchkd  = 0;
        // padSMVals[0] = 0|max(0, min(SMEcnt-1, padSMVals[0]));
        padSMVals[0] = updSpMdNumber(padSMVals[0], 0);
    );

    (VlCnumUnchkd && (VlCnumLastM < lastTime - waitAfterMod)) ? (
        VlCnumUnchkd  = 0;
        padVlcVals[0] = 0|max(0, min(9999, padVlcVals[0]));
    );

    (HPnumUnchkd && (HPnumLastM < lastTime - waitAfterMod)) ? (
        HPnumUnchkd  = 0;
        padHPVals[0] = 0|max(0, min(HPPSize-1, padHPVals[0]));
    );

    (BKnumUnchkd && (BKnumLastM  < lastTime - waitAfterMod)) ? (
        BKnumUnchkd = 0;
        // ce = padBKVals[0] % BKEcnt; (ce >= BKDEcnt) ? ce = 0; padBKVals[0] = ce;
        padBKVals[BShowEntry] = updPartNumber(padBKVals[BShowEntry], 0);
    );

    (StdnumUnchkd && (StdnumLastM  < lastTime - waitAfterMod)) ? (
        ib = 0; loop(padStTotSiz,
            updStudPadKey(ib, 0); //
            padStFlags[ib] &= padStFlMsk7;
            ib += 1;
        );
        StdnumUnchkd = 0;
    );

    (StdActUnchkd && (StdActLastM  < lastTime - waitAfterMod)) ? (
        StdActUnchkd = 0;

        // Update a lot of things in the command pad.
        GvPlayPM = padAcVals[6] = updPlMdNumber(padAcVals[6], 0);
        GvPlaySM = padAcVals[7] = updSpMdNumber(padAcVals[7], 0);
        padBKVals[0] = GvPlayPart = padAcVals[5] = updPartNumber(padAcVals[5], 0);

        // Update the clip number...
        GvPlayCl0 = padAcVals[13] = updClipNumber(padAcVals[13], 0, 1000);
        GvPlayCl1 = padAcVals[14] = updClipNumber(padAcVals[14], 0, 1001);
        GvPlayCl2 = padAcVals[15] = updClipNumber(padAcVals[15], -1, 1002);
        (GvPlayCl1 > GvPlayCl2) ? (
            padAcVals[14] = GvPlayCl2;
            padAcVals[15] = GvPlayCl1;
            GvPlayCl1 = padAcVals[14];
            GvPlayCl2 = padAcVals[15]
        );
    );

);


timeFlag3 ? (

    // Every second : update scheduler display status
    memset(SchedActv, 0, padSchSiz);
    esent = SchedDlydPts[SchedNxtEnt];
    xend = SchedDlydPts[SchedOtherEnd];
    while (esent != xend) (
        (((k = SchedCode[esent]) >= 0) && (k < padSchSiz)) ? SchedActv[k] = 1;
        esent = SchedNxtEnt[esent];
    );

    MIDI_Flgs = FlagsTbVals[Flgs_MIDI]; // MIDI trace flags

    // If necessary, update script file names
    updScriptfiles ? (
        ib = 0; loop(K_padSScriptsSiz,
            (strlen(namScriptfiles[ib]) != 0) ? (
                ic = strlen(shortScriptfiles[ib]) == 0;
                mSL_extractFile(shortScriptfiles[ib], namScriptfiles[ib]);
                sprintf(#a, "IB=  %d  IC = %d \"%s\"  =>  \"%s\"", ib, ic, namScriptfiles[ib], shortScriptfiles[ib]);
            );
            ib += 1;
        );
        updScriptfiles = 0;
    );


);


// ======
// ======
// ======
// ======
// ======







// ======
// At every bloc run

// When played from the "play pad"
(Kbtp >= 0) ? (
    // a command to play something
    // enter it in "playlist"
    doPlayCmd(Kbtp); Kbtp = -1;
);

(PlayRelay >= 0) ? (
    (BKTab[PlayRelay * BKEsize] === 0) ? (
        KSource = 0332;
        doPlayClip(PlayRelay, PlayCell, GvPlFlTemp, GvPlayTypClip, 0);
    );
    PlayRelay = -1;
);

// Manage random states timers
bt = time_precise() + timeD; bd = (0|(bt-rndMainTimer)*1000) ; rndMainTimer=bt;
ib=0; loop(RandomStates,
    bm=gmem[RandomSChSL+ib];
    bv=gmem[RandomSTimr+ib]+bd;
    (bv >= bm) ? (bv = bv % bm; gmem[RandomSFlags+ib]=1; );
    gmem[RandomSType] != 0 ? gmem[RandomSFlags+ib]=1;
    gmem[RandomSTimr+ib]=bv;
    ib += 1;
);



//===== AutoPlay =====
paF = parV(p_autoFreq);
GvPlayOnce ? parSet(p_GvAutoMd, 1);
while (SchedActive && paramValues[p_GvAutoMd] && (GvAutoNxt <= pTBlockStart) && ((BPladd > 0) || (BLpadd > 0)))  (
    (AutoSw = ! AutoSw) ? (
        (BPladd > 0) ? (
            (paramValues[p_maxPlayers] > BPlc) ? (
                GvAutoNxt = pTBlockStart + paF;
                Kbtp = cmdClMdBase + GvPlayTypGrPlay + FLdoForceRead;
                BPlc += 1;
                doPlayCmd(Kbtp);
                GvPlayOnce ? parSet(p_GvAutoMd, (GvPlayOnce = 0));
            );
            BPladd -= 1;
        );
    ) : (
        (BLpadd > 0) ? (
            (paramValues[p_maxLoopers] > BLpc) ? (
                GvAutoNxt = pTBlockStart + paF;
                Kbtp = cmdClMdBase + GvPlayTypGrLoop + FLdoForceLoop;
                BLpc += 1;
                doPlayCmd(Kbtp);
                GvPlayOnce ? parSet(p_GvAutoMd, (GvPlayOnce = 0));
            );
            BLpadd -= 1;
        );
    );
    AAAAAA_Kbtp = Kbtp; // keep last command for info
);


(GvAutoNxt > pTBlockStart + paF) ? GvAutoNxt = pTBlockStart + paF;

Kbtp = -1;


// Unlock all waiting processes after a "load" or a "gc"
while (SchedListNonEmpty(SchedLockdPts) && (atomic_get(mSL_Lock) === 0)) (
    SchX = SchedDetachHead(SchedLockdPts);
    SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
);


// ==== ACTIONS INTERPRETER ====
(flagKillAllThreads) ? (
    flagKillAllThreads = 0;
    mSL_kill_all_thread();
);


/*
    New actions interpreter
*/



lstrt = time_precise() + timeD;
XeSched = 1; // set to 1 to make sure we execute at least 1 task during each @block execution
/*
=== GLOBAL Interpreter ===
*/
while (SchedActive &&
    ((((TLeft = ptBlockLimit - (gstrt = time_precise() + timeD)) > TLeftMin)) || XeSched) &&
    ((SchX = SchedDetachHead(SchedActivPts)) != SchedNone))
(
    // Get some parameters
    // Execute the action
    XeSched = 0;
    xop = SchedCode[SchX];   // actually, only 1 to 13 are being used
    curr_Proc_PID = SchedPid[SchX]; // current process ident
    curr_Proc_Name = SchedThrName[SchX]; // current process name
    mSL_xop_cnt = (mSL_xop_cnt + 1) % 1000000;



    //++++++++++++++++++++++++++++++++++++



    (xop<16)?((xop<8)?((xop<4)?((xop<2)?((xop<1)?(


        //++++0++++//
        0;
        //++++0++++//


    ):(


        //++++1++++//
        // Play one of the exec pad / auto play
        // replaces "doPlayCmd"
        KSource = ActPar1 = SchedPar1[SchX]; // unmodified source
        cmdCurrPar = SchedPar2[SchX]; // 2nd parameter
        (SchedPar3[SchX] != Undef) ? ( GvPlayCl0 = SchedPar3[SchX]; );
        (SchedPar4[SchX] != Undef) ? ( GvPlayPart = SchedPar4[SchX]; );
        KpFlags = ActPar1 & MskdoKeepHgFlgs;
        Kmnd_Pl = ActPar1 & MskdoKeepKmnd;
        // First, rebuild partial entry 0
        memset(BKTab, 0, BKEsize);
        BKTab[idx_Pa_Grp] = GvPlayGrp;
        BKTab[idx_Pa_Bnk] = GvPlayBnk;
        BKTab[idx_Pa_Clps] = GvPlayCl1;
        BKTab[idx_Pa_Clps+1] = GvPlayCl2;
        BKTab[idx_Pa_PlM] = GvPlayPM;
        BKTab[idx_Pa_SpM] = GvPlaySM;
        BKTab[idx_Pa_PWeight] = 1;
        BKTab[idx_Pa_PBFlgs] = 0;
        Kptyp = Krtc = Kaux = 0;

        (FlagsTbVals[Flgs_Pdbg] & 1) ? (
            b = BKTab;
            sprintf(#s2, "**P[%X]  %d %d %d %d --- %d %d %d %d --- %d %d %d %d",
                ActPar1, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11]);
            mSL_log(SysLogBox, #s2);
        );

        // Is there a "pad to play" ?
        ((Kmnd_Pl >= cmdPadBase) && (Kmnd_Pl < (cmdPadBase + padStTotSiz))) ? (
            Kmnd_Pl -= cmdPadBase;
            // KpFlags are the high bits from the command
            Krtc = 0;
            KbtpPlayed = Kmnd_Pl;
            Kpart = padStPVals[Kmnd_Pl]; // base Partial
            Kselect = pACinP; // play any clip from partial as default
            (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
            // (Kvu5 != padStDispNone) ? (
            Kvuu = (Kvu0 = padStPVals[Kmnd_Pl] % BKEcnt) * BKEsize; // Kvu0 : n° partiel
            Kvu4 = BKTab[Kvuu + idx_Pa_Clps]; // first clip of range
            // which mode are we using ?
            Kvu5 = padStFlags[Kmnd_Pl] & padStFlDspM;
            (Kvu5 === padStDispPar) ? (
                // we want to play a specific partial
                Kselect = pACinP; // the clip we want to play
            ) :
            (Kvu5 === padStDispGrp) ? (
                Kselect = pACinG; // any clip from the group of the partiel
            ) :
            (Kvu5 === padStDispGBk) ? (
                Kselect = pACinB; // any clip from bank and group of the partiel
            ) :
            (Kvu5 === padStDispRng) ? (
                Kselect = padStClipsL[Kmnd_Pl]; // the 1st clip of the range we want to play
                Kaux = abs(padStClipsH[Kmnd_Pl] - padStClipsL[Kmnd_Pl]); // the range
            ) :
            (Kvu5 === padStDispClip) ? (
                // we want to play a specific clip
                Kselect = padStClipsL[Kmnd_Pl]; // the clip we want to play
                Kptyp = GvPlayTypClip;
            ) :
            (Kvu5 === padStDispAct) ? (
                Kselect = Kpart; // we have an action to perform
                Kpart = -1; // nothing to play
                //
                m = padStClipsL[Kmnd_Pl]; p = q = r = 0;
                // temporary, accept various commands...
                ((m >= 1) && (m <= 7)) ? (
                    // change global volume
                    (m === 1) ? (q = -120; ) :
                    (m === 2) ? (q = paramValues[p_Vol_MinVal]; ) :
                    (m === 3) ? (q = paramValues[p_Vol_MaxVal]; ) :
                    (m === 4) ? (q = -3; ) :
                    (m === 5) ? (q = 0; ) :
                    (m === 6) ? (q = 3; ) :
                    (m === 7) ? (q = 6; ) ;
                    // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
                    // gmem[commonGlobalVolume] = 10 ^ (q/20); // convert as a number
                    parSet(p_Vol_Global, q);
                    // parSet(p_VolGlobBias, 9);
                );
                (p != 0) ? (
                    SchedAddTask(p, q, r, s, t, 0, 0);
                );
            ) :
            (Kvu5 === padStDispSpec) ? (
                // we want to have a specific MIDI action to send
                Kselect = padStClipsL[Kmnd_Pl]; // the clip we want to play
                Kptyp = GvPlayTypClip;
            ) : (
                Kpart = -1; // nothing to play
            );
            (Kpart >= 0) ? (
                KSource = 0331;
                padStErrors[Kmnd_Pl] = Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp, Kaux); // keep err. return
            );
            // );
            // return code from playing ?
            (Krtc != 0) ? (
                KbtpLast = Kmnd_Pl;
                padStFlags[Kmnd_Pl] = padStFlags[Kmnd_Pl] | padStFlErrbit;
                StdnumLastM = lastTime; StdnumUnchkd = 16;
            ) : (
                padStFlags[Kmnd_Pl] = padStFlags[Kmnd_Pl] & padStFlMsk7;
            );
            // StdnumLastM = lastTime; StdnumUnchkd = 16;
            ui_GFXdoNow |= 2;
            ui_GFXReason = 12;
        ) :

        // A play command in a specific mode ?
        ((Kmnd_Pl >= cmdClMdBase) && (Kmnd_Pl < (cmdClMdBase + 16))) ? (
            Kmnd_Pl -= cmdClMdBase;
            // play from a specific setting
            Kselect = pACinP;
            Kpart = 0;
            // select command according to current mode
            (Kmnd_Pl === GvPlayTypGrPlay) ? (
                // play a player from the "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd_Pl === GvPlayTypGrLoop) ? (
                // play a looper from the "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd_Pl === GvPlayTypGroup) ? (
                // play "group"
                Kselect = pACinG;
                // Kpart = 0;
            ) :
            (Kmnd_Pl === GvPlayTypBank) ? (
                // play "bank"
                Kselect = pACinB;
                // Kpart = 0;
            ) :
            (Kmnd_Pl === GvPlayTypPartial) ? (
                // play this "partial"
                Kselect = pACinP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd_Pl === GvPlayTypClip) ? (
                // play "clip"
                Kselect = GvPlayCl0;
                Kpart = GvPlayPart;
                Kptyp = GvPlayTypClip;
            ) :
            (Kmnd_Pl === GvPlayTypRange) ? (
                // play "Range"
                Kselect = pACinSwP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd_Pl === GvPlayTypAnyClip) ? (
                // play "Any clip"
                Kselect = pACinWwP;
                Kpart = GvPlayPart;
            ) :
            (Kmnd_Pl === GvPlayTypAnyBank) ? (
                // play "Any clip from a partial"
                Kselect = pACinRP;
            ) :
            (Kmnd_Pl === GvPlayClipClicked) ? (
                // play "clip"
                Kselect = GvPlayCl3;
                Kpart = GvPlayPart;
            ) : (
                // This is an error
                GvErr = 0500;
            ) ;
            // AAAA_doPlaycnt += 1;
            (cmdCurrPar != Undef) ? KpFlags |= cmdCurrPar;
            (FlagsTbVals[Flgs_Pdbg] & 2) ? (
                sprintf(#s2, "**Q[%X]  Kpa:%d  Kse:%d  KpF:%X  Kty:%d",
                            Kmnd_Pl, Kpart, Kselect, KpFlags, Kptyp);
                mSL_log(SysLogBox, #s2);
            );
            KSource = 0330;
            Krtc = doPlayClip(Kpart, Kselect, KpFlags, Kptyp, 0);
            // (Krtc != 0) ? AAAA_Krtccnt += 1;
        );

        // Otherwise, ignore the command
        Kmnd_Pl = -1;

        //++++1++++//


    );):((xop<3)?(


        //++++2++++//
        // Random Change global volume
        m = (paramValues[p_Vol_MaxVal] + paramValues[p_Vol_MinVal]) / 2;
        p = (10 + paramValues[p_Vol_VariVal])/90;
        u = (paramValues[p_Vol_MaxVal] - paramValues[p_Vol_MinVal]) / 2;
        // AAAAAAAA_p = p;
        (frand() > 0.5) ? (
            x = frand(); m += x * x * p * 1.5 * u;
        ) : (
            m -= frand() * p * 1.1 * u;
        );
        // AAAAAAAA_m = m;
        m = max(paramValues[p_Vol_MinVal], min(paramValues[p_Vol_MaxVal], m));
        // gmem[commonGlobalVolume] = 10 ^ (m/20); // convert as a number
        // gmem[gVolBias] = 0.0000002; // use a very very slow volume change
        parSet(p_Vol_Global, m);
        // parSet(p_VolGlobBias, 9);
       //++++2++++//


    ):(


        //++++3++++//
        // OP 3 : Set a parameter
        parSet(SchedPar1[SchX], SchedPar2[SchX]);
        //++++3++++//


    ););):((xop<6)?((xop<5)?(


        //++++4++++//
        // Switch to next group - or more
        m = 0|(1 + (paramValues[p_Grp_VariVal] / 8));
        GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', GvPlayGrp + m, 0);
        //++++4++++//


    ):(


        //++++5++++//
        // OP 5 : Modify Some/ALL players status
        // p1 === 0 : do nothing
        // p1 === 1 : lock all & set flags to p2
        // p1 === 2 : unlock all & reset flags
        // p1 === 3 : toggle lock p2/p3
        // p1 === 4 : unlock p2/p3
        // p1 === 5 : solo p2/p3
        // p1 === 6 : mute/unmute p2/p3
        // p1 === 7 : stop p2/p3
        // p1 === 8 : unlock p2/p3
        xopKmd = (ActPar1 = SchedPar1[SchX]) & 0xff; // actual op code
        Actpar2 = SchedPar2[SchX];
        Actpar3 = SchedPar3[SchX];
        Actpar4 = SchedPar4[SchX];
        xopFlgs = ActPar1 & 0xffff00; // addtl. flags
        xopFlgs & ActFlg1 ? parSet(p_GvAutoMd, 0);
        msk = uid = pid = 0;
        AAAAAAAA_Task5_1 = ActPar1;
        loop (uCnt,
            Un = UGAddr + UCBSize * uid;
            pid = gmem[Un+cbPlIdt]; // the ID of the pad
            ty = gmem[Un+cbType];
            ((ty === uPlayer) && (xopKmd === 2)) ? ( // unlock, unmute all
                gmem[Un+RCB_Cl_Flgs] = LockSet = 0;
                padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                msk = i_dB;
            ) :
            ((ty === uPlayer)
                && ((st = gmem[Un+cbStat]) === uSBusy)
                && (((pm = gmem[Un+RCB_cbCKmd]) === KmdPlay) || (pm === KmdLoop))) ? ( // L=>C
                (xopKmd === 1) ? ( // lock and set all to p2
                    gmem[Un+RCB_Cl_Flgs] = LockSet = Actpar2;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                ((xopKmd === 3) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // toggle lock p2/p3
                    (gmem[Un+RCB_Cl_Flgs] & 1) ? (
                        gmem[Un+RCB_Cl_Flgs] = 0;
                        padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    ) : (
                        gmem[Un+RCB_Cl_Flgs] |= 1;
                        padUCells[pid] |= ui_jpad_ct_selec;
                    );
                    msk = i_dB;
                ) :
                ((xopKmd === 4) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // unlock p2/p3
                    gmem[Un+RCB_Cl_Flgs] = 0;
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                (xopKmd === 5) ? (
                    // solo p2/p3
                    padUCells[pid] |= ui_jpad_ct_selec;
                    gmem[Un+RCB_Cl_Flgs] =
                        ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3)) ? 1 : 3;
                    msk = i_dB;
                ) :
                ((xopKmd === 6) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // toggle mute p2/p3
                    AAAAAAAA_pid = pid;
                    gmem[Un+RCB_Cl_Flgs] = (gmem[Un+RCB_Cl_Flgs] & 2) ? 1 : 3;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                    // padUCells[0] |= ui_jpad_ct_selec;
                ) :
                ((xopKmd === 7) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                    gmem[Un + RCB_Kmd] = KmdQStop; // send stop command
                ) :
                (xopKmd === 8) ? (
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                    ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                        // Set play volume to Actpar4
                        gmem[Un+RCB_StdVol] = Actpar4;
                        msk = i_dB;
                    );
                ) :
                (xopKmd === 9) ? (
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                    ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                        // Set play volume bias to Actpar4
                        parSet(p_VolGlobBias, Actpar4);
                        gmem[Un+RCB_VolBias] =  gmem[gVolBias];
                        msk = i_dB;
                    );
                ) :
                ((xopKmd === 10) && ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3))) ? (
                    // lock p2/p3
                    gmem[Un+RCB_Cl_Flgs] |= 1;
                    padUCells[pid] |= ui_jpad_ct_selec;
                    msk = i_dB;
                ) :
                (xopKmd === 11) ? (
                    ((gmem[Un+cbPlIdt] === Actpar2) || (gmem[Un+cbUnitIdt] === Actpar3) ||
                    ((Actpar2 === -1) && (Actpar3 === -1))) ? (
                        // only lock the player(s)
                        gmem[Un+RCB_Cl_Flgs] |= 1;
                        padUCells[pid] |= ui_jpad_ct_selec;
                        msk = i_dB;
                    );
                );
            );
            gmem[Un+RCB_State_Changed] |= msk; // somthing have changed
            uid += 1;
        );
        //++++5++++//


    );):((xop<7)?(


        //++++6++++//
        // random play one clip of current group
        doPlayCmd(cmdClMdBase + GvPlayTypGroup);
        //++++6++++//


    ):(


        //++++7++++//
        // everybody play reverse !
        parSet(p_GvAutoMd, 0);
        doPlayer(-1, KmdSpF1, 1);
        //++++7++++//


    );););):((xop<12)?((xop<10)?((xop<9)?(


        //++++8++++//
        // Stop play
        parSet(p_GvAutoMd, 0);
        // clearCmd();
        doActivePlayer(-1, KmdQStop, 0);  BPLSTClear();
        //++++8++++//


    ):(


        //++++9++++//
        // Random change max generators
        m = paramValues[p_Gen_MaxCnt] / 2.5;
        p = (10 + paramValues[p_Gen_VariVal])/90;
        //AAAAAAAA_p = p;
        (frand() > 0.4) ? (
            x = frand(); m += x * x * p * 2.0 * m;
        ) : (
            m -= frand() * p * 1.2 * m;
        );
        //AAAAAAAA_m = m;
        parSet(p_maxGenerators, max(paramValues[p_Gen_MinCnt], min(paramValues[p_Gen_MaxCnt], paramValues[p_Gen_MinCnt]+m)));
        //++++9++++//


    );):((xop<11)?(


        //++++10++++//
        //====== mSL EXECUTION ======
        // mSL_errX=10;
        mSL_dispatch_entry = SchX;
        atomic_get(mSL_Lock) ? (
            // We are doing some exclusive operation. mSL Threads are not allowed to execute
            SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd); // insert the thread in locked pts
            SchX = -1;
        ) : (
            tstrt = time_precise() + timeD;
            mSL_active_Thread = SchedThrdPt[SchX]; // the thread
            ((SchedStatus[mSL_dispatch_entry] & SchmSLThrUsed) != SchmSLThrUsed) ? (
                (mSL_errX === 0) ? mSL_errX = 3381; // thread not noted active ?
            );
            mSL_load_thread(mSL_active_Thread);
            mSL_max_TOS = mSL_active_Thread[mSL_THR_basePhStack];

            (mSL_errX != 0) ? (
                thread_error(mSL_active_Thread, mSL_errX, SchX);
            ) : (
                mm_xec_mm[mm_xec_ptr] -=  mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] -=  mSL_ICount;
                // Curr_Block_Alloc
                AAAAAAAA_mSL_rpeat = mSL_rpeat = max(4096, 0|(mSL_insts_per_s * min(TLeft, Curr_Block_Alloc * 0.15))) ; // A large number
                mSL_evaluate();
                AAAAAAAA_mSL_evaluate_count += 1;
                mSL_High_Stack = max(mSL_High_Stack, mSL_max_TOS - mSL_active_Thread[mSL_THR_basePhStack]);
                //sprintf(#uuu, "End of evaluation - CR: %d - XC: %d", mSL_CodeStop, AAAAAAAA_mSL_evaluate_count);
                //mSL_log(SysLogBox, #uuu);
                mSL_save_thread(mSL_active_Thread);
                ((mSL_CodeStop === 0) || (mSL_CodeStop === mSL_RC_Yield)) ? (
                    // reintroduce the thread in the queue
                    SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Wait) ? (
                    (mSL_WaitDuration > 0) ? (
                        // introduce the entry in the wait queue
                        Schedule(SchedRelative, mSL_WaitDuration, 0, SchX, 0, 0, 0);
                    ) : (
                        // reintroduce the thread in the queue
                        SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    );
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Stop) ? (
                    // finished, free the thread
                    freeSchedThread(SchX);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    mSL_dispatch_entry = SchX = -1;
                    flagShowMemory = 1;
                ) :
                (mSL_CodeStop === mSL_RC_WEvent) ? (
                    // introduce the entry in the wait queue
                    SchedInsertTail(SchedEvntPts, SchX, SchETypeThrd);
                    (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                        sprintf(#s, "Insert in Evnt : ent: %d thrd: %d siz: %d ", SchX, mSL_active_Thread, SchedListSize(SchedEvntPts));
                        mSL_log(SysLogBox, #s);
                    );
                    AAAAA__Schx = Schx;
                    AAAAA__SchxNum = ent[SchedPid] & SchedNMask;
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_WAITGC) ? (
                    // introduce in the wait for GC list
                    SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (
                    //AAAAAAAA_Errx = mSL_errX;
                    thread_error(mSL_active_Thread, mSL_errX, mSL_CodeStop);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    // sprintf(#uuu, "End of evaluation [%d]  CR: %d  Err: %d", SchX, mSL_CodeStop, mSL_errX);
                    (mSL_wbl != 0) ? (
                        sprintf(#uuu, "Block damaged @ %d", mSL_wbl);mSL_log(SysLogBox, #uuu);
                    );
                    mSL_error_analysis(mSL_active_Thread);
                    SchedFree(SchX);
                    SchX = -1;
                    flagShowMemory = 1;
                    mSL_errC = 0; mSL_errX = 1717; // "error previously detected"
                    mSL_errX = 0; // let other threads progress
                );
                mm_xec_mm[mm_xec_ptr] += mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] += mSL_ICount;
            );
            mm_dur_mm[mm_cyc_ptr] += time_precise() + timeD - tstrt;
        );
        mSL_active_Thread = -1;

        //++++10++++//


    ):(


        //++++11++++//
        // random play one clip of current group
        doPlayCmd(cmdClMdBase + GvPlayTypGroup);
        //++++11++++//


    ););):((xop<14)?((xop<13)?(


        //++++12++++//
        // play a recorded item :
        doPlayRItem(SchedPar1[SchX], SchedPar2[SchX]); //
        //++++12++++//


    ):(


        //++++13++++///
        // play a frozen sound/sequence
        pp = SchedPar1[SchX]; // the 88 w block
        init = SchedPar2[SchX];
        std = SchedPar3[SchX]; // start date
        kbf = SchedPar5[SchX]; // keyboard modifiers
        pent = SchedPar6[SchX]; // entry number
        pl = pp + lppEPsnd; // list of sounds
        itm = pp[lppECurItem]; // number of sound to play
        scnt = pp[lppEElct]; // number of sounds
        kmd = (pp[lppEType] & 0xff) -psmPosSS + 2;
        inc = pp[lppEItmIncr];
        (kmd === 1) ? (
            // Play a single sound
            scnt > 0 ? doPlayRItem(pl[2*itm], (kbf === 0x10)); // send the itm FSND reference
        ) :
        (kmd === 2) ? (
            // Play a random sound
            scnt > 0 ? doPlayRItem(pl[2*irand(scnt)], (kbf === 0x10)); // send a random reference in the list
        ) :
        (kmd === 3) ? (
            // Play items in round robin mode
            scnt > 0 ? (
                doPlayRItem(pl[2*itm], (kbf === 0x10)); // send the itm FSND reference
                pp[lppECurItem] = max(0, itm + inc + scnt) % scnt; // next entry
            );
        ) :
        ((kmd === 4)) ? (
            // Chord play
            ii = 0; loop (scnt,
                doPlayRItem(pl[ii], (kbf === 0x10)); // send the itm FSND reference
                ii += 2;
            );
        ) :
        ((kmd === 5)) ? (
            // Sequence play, once
            (init & 1) ? (
                SchedPar2[SchX] = 0; // reset init
                SchedPar4[SchX] = scnt; // number of sounds to play
                SchedPar5[SchX] = itm; // first sound to play
                SchedDly[SchX] = std; // from start date
                ( (kbf === 0x10) || (pp[lppEType] & 0xff00)) ? SchedPar2[SchX] = 0x10;
            ) ;
            (SchedPar4[SchX] > 0) ? (
                SchedPar4[SchX] -= 1; // decrement counter
                itm = SchedPar5[SchX]; // number of sound to play
                doPlayRItem(pl[2*itm], (SchedPar2[SchX] & 0x10) !== 0); // play the entry
                (SchedPar4[SchX] > 0) ? (
                    SchedDly[SchX] += pl[2 * itm + 1] * pp[lppESpeed]; // add the delay
                    SchedPar5[SchX] = max(0, itm + inc + scnt) % scnt; // select next entry
                    SchedCode[SchX] |= SchedWBit;
                    // SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);  // recycle entry
                    Schedule(SchedAbsolute, SchedDly[SchX], 0, SchX, 0, 0, 0, 0, 0);
                    SchX = -1; // do not delete the task
                );
            )
        );
        0 ? (
            sprintf(#u, "playing a FSND !  -> %d   [%d %d %d %d %d]",  pp,  kmd,  pp[lppECurItem],  u,  pp[lppEElct],  pp[lppEItmIncr]);
            mSL_log(SysLogBox, #u);
        );
        //++++13++++//


    );):((xop<15)?(


        //++++14++++//
        Err=14;
        //++++14++++//


    ):(


        //++++15++++//
        Err=15;
        //++++15++++//


    ););););):((xop<24)?((xop<20)?((xop<18)?((xop<17)?(


        //++++16++++//
        Err=16;
        //++++16++++//


    ):(


        //++++17++++//
        Err=17;
        //++++17++++//


    );):((xop<19)?(


        //++++18++++//
        Err=18;
        //++++18++++//


    ):(


        //++++19++++//
        Err=19;
        //++++19++++//


    ););):((xop<22)?((xop<21)?(


        //++++20++++//
        Err=20;
        //++++20++++//


    ):(


        //++++21++++//
        Err=21;
        //++++21++++//


    );):((xop<23)?(


        //++++22++++//
        Err=22;
        //++++22++++//


    ):(


        //++++23++++//
        Err=23;
        //++++23++++//


    );););):((xop<28)?((xop<26)?((xop<25)?(


        //++++24++++//
        Err=24;
        //++++24++++//


    ):(


        //++++25++++//
        Err=25;
        //++++25++++//


    );):((xop<27)?(


        //++++26++++//
        Err=26;
        //++++26++++//


    ):(


        //++++27++++//
        Err=27;
        //++++27++++//


    ););):((xop<30)?((xop<29)?(


        //++++28++++//
        Err=28;
        //++++28++++//


    ):(


        //++++29++++//
        Err=29;
        //++++29++++//


    );):((xop<31)?(


        //++++30++++//
        Err=30;
        //++++30++++//


    ):((xop<32)?(


        //++++31++++//
        Err=31;
        //++++31++++//


    ):(


        //++++32++++//
        Err=32;
        //++++32++++//


    ););););););




    //++++++++++++++++++++++++++++++++++++

    // Free the block if necessary
    SchX > 0 ? SchedFree(SchX);
    gmaxd = max(gmaxd, time_precise() + timeD - gstrt);
);

lmaxd = max(lmaxd, time_precise() + timeD - lstrt);

// ADump(blStatCPUMax);
(blockCntr > blockMaxCntr) ? blockMaxCntr = blockCntr;
gmem[timeSubsec] = blockCntr; // current subTime, in [0 .. p]

blStatGFXUse[blStatThis] = ui_j_cumul_time;
blStatGFXMax[blStatThis] = max(blStatGFXMax[blStatThis], ui_j_cumul_time);
blStatThis = tUnix % blStatSiz;
(blStatThis != blStatPrev) ? (
    blStatPrev = blStatThis;
    blStatXecCnt[blStatThis] = 0;
    blStatCPUUse[blStatThis] = 0;
    blStatCPUMax[blStatThis] = 0;
    blStatGFXUse[blStatThis] = 0;
    blStatGFXMax[blStatThis] = 0;
    ui_j_cumul_time = 0;
);
blStatXecCnt[blStatThis] += 1;
blStatCPUUse[blStatThis] += (blu = time_precise() + timeD - pTBlockStart);
blStatCPUMax[blStatThis] = max(blStatCPUMax[blStatThis], blu);

AAAAAAblu = blu * 1000; // ms. used




































































































@sample
// Here we GENERATE our own sample count for the various players
spl0 = T0 * T_div; // spl0 is also S0, not used.
spl1 = S1;
// The following computation is done in every FILE READER
currSmpl = (floor(spl0 * T_fact)) + (floor(spl1 * T_fact)) * 16777216;

T0 += 1;






































































@serialize
//
//===== PRESETS ======
//
//
ui_GFXdoNow |= 1;
ui_GFXReason = 13;
serial_counter += 1;

LoadMode = file_avail(0) >= 0;
//updGR =
pcheckGPLR = 1; // check parameters coherency


loadMode ? (

    /*
    ===LOAD===
    */
    doLoad = 1;
    // First, load the block
    // file_mem(0, serialBlock, serialSize);
    file_mem(0, serialBlock, serialHead);
    // Then update values from preset

    // Subblock 0 - size 8 - Always loaded
    // Individual values
    presetVersionLoaded = serialBlock[Pr7_pr_vers];
    presetCheckLoaded = serialBlock[Pr7_pr_check];
    presetAux1 = serialBlock[Pr7_pr_aux1];
    presetAux2 = serialBlock[Pr7_pr_aux2];

    (presetVersionLoaded < ui_version(1,4,5)) ? (
        (presetVersionLoaded < ui_version(1,4,2)) ? (
            sprintf(#v, "%d.%d.%d", (presetVersionLoaded >> 16),
                     (presetVersionLoaded >> 8) & 0xff, presetVersionLoaded & 0xff);
            sprintf(#s, "Can't load presets older than %s.", #v);
            doLoad = 0;
        ) : (
            sprintf(#v, "%d.%d.%d", (presetVersionLoaded >> 16),
                     (presetVersionLoaded >> 8) & 0xff, presetVersionLoaded & 0xff);
            sprintf(#s, "Old preset (%s). Please, resave.", #v);
        );
        mSL_log(SysLogBox, "");
        mSL_log(SysLogBox, #s);
    );

    doLoad ? (

        // Subblock 1 - size 120
        // Load the rest of the standard preset
        file_mem(0, serialBlock + serialHead, serialSize - serialHead);
        GvPlayGrp = serialBlock[Pr7_PlayGrp];
        GvPlayBnk = serialBlock[Pr7_PlayBnk];
        GvPlayPart = serialBlock[Pr7_PlayPart];
        GvPlayPM = serialBlock[Pr7_PlayPM];
        GvPlaySM = serialBlock[Pr7_PlaySM];
        GvPlayCl0 = serialBlock[Pr7_PlayCl0];
        GvPlayCl1 = serialBlock[Pr7_PlayCl1];
        GvPlayCl2 = serialBlock[Pr7_PlayCl2];
        padBKVals[0] = serialBlock[Pr7_BKV0];
        padSMVals[0] = serialBlock[Pr7_SMV0];
        padPMVals[0] = serialBlock[Pr7_PMV0];
        GvPlayTyp = serialBlock[Pr7_PlayTyp];
        studPrefDispPanes = serialBlock[Pr7_PrefDPanes]; studDispPPrev = -1;
        studPrefDispSize = serialBlock[Pr7_PrefDSize];  ui_jGUI_size = 2;
        UplayControl = serialBlock[Pr7_UplayControl];
        padSensShowSiz = serialBlock[Pr7_SensorSize]; setSensorSize(padSensShowSiz);
        MIDI_Sens_mode = serialBlock[Pr7_SensorNum];
        // load partial zero
        memcpy(BKTab, serialBlock+Pr7_Partial0, BKEsize); // currently 12 values
        0 ? (
            b = BKTab;
            sprintf(#s2, "**PL  %d %d %d %d --- %d %d %d %d", b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
            mSL_log(SysLogBox, #s2);
        );

        // Check pannels configurations
        p = serialBlock + Pr7_StudConf;
        ii = 0; loop(8, p[ii] = max(1, min(4, 0|p[ii])); ii+= 1;);
        p = serialBlock + Pr7_StudRat;
        ii = 0; loop(8*4, p[ii] = max(180, min(1800, 0|p[ii])); ii+= 1;);


        define_loaded();

        // Subblock 3
        isidx = Pr7_PadStval;
        memcpy(padStPVals, serialBlock+isidx, padStTotSiz);
        isidx += padStTotSiz;
        memcpy(padStFlags, serialBlock+isidx, padStTotSiz);
        isidx += padStTotSiz;
        memcpy(padStClipsL, serialBlock+isidx, padStTotSiz);
        isidx += padStTotSiz;
        memcpy(padStClipsH, serialBlock+isidx, padStTotSiz);
        isidx += padStTotSiz;
        memset(padStErrors, 0, padStTotSiz);
        memset(padStCells, 0, padStSiz);
        AAAMaxLdIsidix = isidx;

        // checkDispMenus(); // readapt menus...
        uix_jtheme = parV(p_uix_jtheme);
        // Some more values
        SchedActive = parV(p_SchActive);

        // Load (Add) MIDI links
        sj = 0;
        while (sj < 1024) (
            (Pr7_SysLinks[sj] > 0) ? (
                enterLink(Pr7_SysLinks[sj], Pr7_SysLinks[sj+1], Pr7_SysLinks[sj+2], Pr7_SysLinks[sj+3]);
            );
            sj += 4;
        );

        // Rebuild all parameters status
        sj = 0; loop(paramCount,
            pTemp = paramValues[sj];
            paramValues[sj] = Undef;
            parSet(sj, pTemp); // This updates everything...
            sj += 1;
        );

        //Load all saved strings
        sj = 0; loop(K_savedStringsCnt,
            file_string(handle,savedStrings[sj]);
            sj += 1;
        );

        //ShowConfig();mSL_log(SysLogBox, "Before preset load");
        // Strings packed
        (strlen(savedStrings[Pr7_Project_Path]) !== 0) ? strcpy(#D_GM_Project_Path, savedStrings[Pr7_Project_Path]);
        (strlen(savedStrings[Pr7_Project_Name]) !== 0) ? strcpy(#D_GM_Project_Name, savedStrings[Pr7_Project_Name]);
        (strlen(savedStrings[Pr7_Project_SCR]) !== 0) ? strcpy(#D_GM_Project_Path_SCR, savedStrings[Pr7_Project_SCR]);
        (strlen(savedStrings[Pr7_Project_WAV]) !== 0) ? strcpy(#D_GM_Project_Path_WAV, savedStrings[Pr7_Project_WAV]);
        (strlen(savedStrings[Pr7_Project_SNDS]) !== 0) ? strcpy(#D_GM_Project_Path_SNDS, savedStrings[Pr7_Project_SNDS]);
        (strlen(savedStrings[Pr7_Project_FX]) !== 0) ? strcpy(#D_GM_Project_Path_FX, savedStrings[Pr7_Project_FX]);
        (strlen(savedStrings[Pr7_Project_GLib]) !== 0) ? strcpy(#D_GM_Project_Path_GLib, savedStrings[Pr7_Project_GLib]);
        (strlen(savedStrings[Pr7_PlayModes]) !== 0) ? strcpy(#D_PlayModes, savedStrings[Pr7_PlayModes]);
        (strlen(savedStrings[Pr7_SpaceModes]) !== 0) ? strcpy(#D_SpaceModes, savedStrings[Pr7_SpaceModes]);
        (strlen(savedStrings[Pr7_BanksDefs]) !== 0) ? strcpy(#D_BanksDefs, savedStrings[Pr7_BanksDefs]);
        (strlen(savedStrings[Pr7_HPConfigs]) !== 0) ? strcpy(#D_HPConfigs, savedStrings[Pr7_HPConfigs]);
        (strlen(savedStrings[Pr7_ClipsModifiers]) !== 0) ? strcpy(#D_ClipsModifiers, savedStrings[Pr7_ClipsModifiers]);
        (strlen(savedStrings[Pr7_ClipsSets]) !== 0) ? strcpy(#D_ClipSetConf, savedStrings[Pr7_ClipsSets]);
        (strlen(savedStrings[Pr7_InSens_Name]) !== 0) ? strcpy(#D_InSens_Name, savedStrings[Pr7_InSens_Name]);
        (strlen(savedStrings[Pr7_GM_mSL_ini]) !== 0) ? strcpy(#D_GM_mSL_ini, savedStrings[Pr7_GM_mSL_ini]);
        (strlen(savedStrings[Pr7_Script_Name]) !== 0) ? strcpy(#D_Script_Name, savedStrings[Pr7_Script_Name]);
        (strlen(savedStrings[Pr7_clDirectory]) !== 0) ? (
            strcpy(#t, savedStrings[Pr7_clDirectory]);
            strcmp(#D_clDirectory, #t) ? (
                // directory change !
                setClDirectory(#t, 0);
            );
        );

        //ShowConfig();
        //mSL_log(SysLogBox, "After preset load");
        //mSL_log(SysLogBox, #D_GM_Project_Path);
        //mSL_log(SysLogBox, #D_GM_Project_Name);

        //sprintf(#s, "loading Banks: %s", savedStrings[Pr7_BanksDefs]); mSL_log(SysLogBox, #s);
        //sprintf(#s, "Loading %d aliases: from %d strs.", Pr7_FStrAliasesCnt, Pr7_FStrAliasesNum); mSL_log(SysLogBox, #s);
        (TRC & 0x1000) ? (
            sprintf(#s, "[>>>>  %s", savedStrings[K_fileAliases]);
            mSL_log(SysLogBox, #s);
        );
        removeAliases();
        // Get aliases
        sj = K_fileAliases; si = 0; sk = 1;
        while (sk) (
            st = savedStrings[sj];
            ((sk = strlen(st)) != 0) ? (
                aclnAliases[si] = cs = mSL_Str_Alloc("");
                strcpy(cs, savedStrings[sj]);
                si += 1;
            );
            sj += 1;
        );
        //sprintf(#s, "Aliases loaded from  %d to %d.", K_fileAliases, sj); mSL_log(SysLogBox, #s);
        rebuildAllaliases();



        // some parameters need to be reset
        parReset(p_VirtualTime);
        parReset(p_VirtTimSpeed);


        //sprintf(#s, "Preset Loaded, saved — %s", savedStrings[Pr7_Date]); mSL_log(SysLogBox, ""); mSL_log(SysLogBox, #s);
    );

    /*
    (AGMXXX === 0) ? AGMW200 = GMW();
    (AGMXXX === 1) ? AGMW210 = GMW();
    (AGMXXX === 2) ? AGMW220 = GMW();
    (AGMXXX === 3) ? AGMW230 = GMW();
    (AGMXXX === 4) ? AGMW240 = GMW();
    (AGMXXX === 5) ? AGMW250 = GMW();
    */


    after_load_actions();
    delayLoad = -8; // force actions to start ASAP
) : (

    /*
    ===SAVE===
    */
    // First, copy values to preset area

    // Subblocks 0 and 1
    // Individual values
    // From 0 to 128.
    serialBlock[Pr7_pr_vers] = presetVersionCurrent;
    serialBlock[Pr7_pr_check] = presetCheckValue;
    serialBlock[Pr7_PlayGrp] = GvPlayGrp;
    serialBlock[Pr7_PlayBnk] = GvPlayBnk;
    serialBlock[Pr7_PlayPart] = GvPlayPart;
    serialBlock[Pr7_PlayPM] = GvPlayPM;
    serialBlock[Pr7_PlaySM] = GvPlaySM;
    serialBlock[Pr7_PlayCl0] = GvPlayCl0;
    serialBlock[Pr7_PlayCl1] = GvPlayCl1;
    serialBlock[Pr7_PlayCl2] = GvPlayCl2;
    serialBlock[Pr7_BKV0] = padBKVals[0];
    serialBlock[Pr7_SMV0] = padSMVals[0];
    serialBlock[Pr7_PMV0] = padPMVals[0];
    serialBlock[Pr7_PlayTyp] = GvPlayTyp;
    serialBlock[Pr7_PrefDPanes] = studPrefDispPanes;
    serialBlock[Pr7_PrefDSize] = studPrefDispSize;
    serialBlock[Pr7_UplayControl] = UplayControl;
    serialBlock[Pr7_SensorSize] = padSensShowSiz;
    serialBlock[Pr7_SensorNum] = MIDI_Sens_mode;
    // save partial zero
    memcpy(serialBlock+Pr7_Partial0, BKTab, BKEsize);
    // Save strings
    // compute date in a temp
    strcpy(savedStrings[Pr7_Date], nowIs());
    strcpy(savedStrings[Pr7_Project_Path], #D_GM_Project_Path);
    strcpy(savedStrings[Pr7_Project_Name], #D_GM_Project_Name);
    strcpy(savedStrings[Pr7_PlayModes], #D_PlayModes);
    strcpy(savedStrings[Pr7_SpaceModes], #D_SpaceModes);
    strcpy(savedStrings[Pr7_BanksDefs], #D_BanksDefs);
    strcpy(savedStrings[Pr7_HPConfigs], #D_HPConfigs);
    strcpy(savedStrings[Pr7_ClipsModifiers], #D_ClipsModifiers);
    strcpy(savedStrings[Pr7_ClipsSets], #D_ClipSetConf);
    strcpy(savedStrings[Pr7_InSens_Name], #D_InSens_Name);
    strcpy(savedStrings[Pr7_GM_mSL_ini], #D_GM_mSL_ini);
    strcpy(savedStrings[Pr7_Script_Name], #D_Script_Name);
    strcpy(savedStrings[Pr7_clDirectory], #D_clDirectory);
    strcpy(savedStrings[Pr7_Project_SCR], #D_GM_Project_Path_SCR);
    strcpy(savedStrings[Pr7_Project_WAV], #D_GM_Project_Path_WAV);
    strcpy(savedStrings[Pr7_Project_SNDS], #D_GM_Project_Path_SNDS);
    strcpy(savedStrings[Pr7_Project_FX], #D_GM_Project_Path_FX);
    strcpy(savedStrings[Pr7_Project_GLib], #D_GM_Project_Path_GLib);


    // Subblock 2
    isidx = Pr7_PadStval;
    memcpy(serialBlock+isidx, padStPVals, padStTotSiz);
    isidx += padStTotSiz;
    memcpy(serialBlock+isidx, padStFlags, padStTotSiz);
    isidx += padStTotSiz;
    memcpy(serialBlock+isidx, padStClipsL, padStTotSiz);
    isidx += padStTotSiz;
    memcpy(serialBlock+isidx, padStClipsH, padStTotSiz);
    isidx += padStTotSiz;
    AAAMaxSvIsidix = isidx;
    // Some more values
    parSet(p_SchActive, SchedActive);


    // Save ALL MIDI links
    si = sj = 0;
    memset(Pr7_SysLinks, 0, 1024);
    while ((si < Links_TSiz) && (sj < 1024)) (
        (Links_HTab[si] > 0) ? (
            Pr7_SysLinks[sj] = Links_HTab[si]; sj+= 1;
            Pr7_SysLinks[sj] = Links_Actn[si]; sj+= 1;
            Pr7_SysLinks[sj] = Links_Par1[si]; sj+= 1;
            Pr7_SysLinks[sj] = Links_Par2[si]; sj+= 1;
        );
        si += 1;
    );

    // Compact aliases
    recreateAliases();
    Pr7_FStrAliasesNum = aliasesStrCount + 1;
    Pr7_FStrAliasesCnt = aliasesCount;
    //sprintf(#s, "Aliases saved: %d in %d/%d strs.", Pr7_FStrAliasesCnt, Pr7_FStrAliasesNum, K_aclnAliasesCnt); mSL_log(SysLogBox, #s);

    // Install aliases in strings to save
    sj = K_fileAliases; si = 0; loop(K_aclnAliasesCnt,
        st = aclnAliases[si];
        ((st != 0) && (strlen(st) > 0)) ? (
            strcpy(savedStrings[sj], aclnAliases[si]);
            sj += 1;
        );
        si += 1;
    );
    strcpy(savedStrings[sj], ""); // empty string to delimit
    //sprintf(#s, "Aliases strings saved in %d to %d.", K_fileAliases, sj); mSL_log(SysLogBox, #s);

    // Then save preset block...
    file_mem(0, serialBlock, serialSize);


    // Finally, save all presets related strings
    sj = 0; loop(K_savedStringsCnt,
        file_string(0,savedStrings[sj]);
        sj += 1;
    );


    //sprintf(#s, "Preset Saved — %s", savedStrings[Pr7_Date]); mSL_log(SysLogBox, ""); mSL_log(SysLogBox, #s);

    /*
    (AGMXXX === 0) ? AGMW300 = GMW();
    (AGMXXX === 1) ? AGMW310 = GMW();
    (AGMXXX === 2) ? AGMW320 = GMW();
    (AGMXXX === 3) ? AGMW330 = GMW();
    (AGMXXX === 4) ? AGMW340 = GMW();
    (AGMXXX === 5) ? AGMW350 = GMW();
    */

    //sprintf(#s, "saved Banks: %s", savedStrings[Pr7_BanksDefs]); mSL_log(SysLogBox, #s);
    //sprintf(#s, "saved Name:  %s", savedStrings[Pr7_Project_Name]); mSL_log(SysLogBox, #s);
);




AGMXXX += 1;






































































































































































@gfx
gfxStartTime = time_precise() + timeD;
gfxWStat = gfx_getchar(65536);


// Get the keyboard Key input for the current information
function do_ModuleKeyboard()
(
    (Keyed === 0) ? (Keyed = ui_key(); ui_key_next(););
    Keyed;
);

function do_ModuleKeySave()
(
    (KeyedT === 0) ? ( KeyedT = Keyed; Keyed = 0; );
    KeyedT;
);


function do_GenericKeyRead()
(
    (KeyedT === 0) ? (KeyedT = Keyed; Keyed = 0; );
    (KeyedT === 0) ? (KeyedT = ui_key(); );
    (KeyedT > 0) ? AAAA_lastKeyedT = KeyedT;
    KeyedT;
);


function switchAuto()
local (v)
(
    v = paramValues[p_GvAutoMd] ? (
        // clearCmd();
        0;
    ) : (
        BPLSTClear(); 1;
    );
    parSet(p_GvAutoMd, v); //
    GvAutoNxt = Undef;
);



function
do_Generic_Commands()
local (z, SKeyedT)
(
    do_GenericKeyRead();
    AAAA_uix_jmbsel = uix_jmbsel;
    (KeyedT > 0) ? (
        SKeyedT = KeyedT; // Save keyed character
        AAAA_Key40 = KeyedT;
        AAAA_Kmouse_cap2 = Kmouse_cap ;
        AAAA_KcolMouseWasIn = colMouseWasIn;
        AAAA_KstudDispPCnt = studDispPCnt;
        /*
        (KeyedT === '!') ? (
            sprintf(#s, "mouse: %d  %d", mouse_x, mouse_y);
            mSL_log(SysLogBox, #s);
        ) :
        */
        ((KeyedT === 'del')) ? (
            // clearCmd();
            parSet(p_GvAutoMd, 0);
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
        ) :
        ((KeyedT === 144)||(KeyedT === 249)||(KeyedT === 128)) ? ( // ù '☒' ou F17
            SchedAddTask(5, 1|ActFlg1, 1, -1, -1, 0, 0); // Lock all player playing
        ) :
        (KeyedT === '<') ? (
            switchAuto(); ui_GFXdoNow |= 1; ui_GFXReason = 38;
        ) :
        (KeyedT === '>') ? (
            ui_GFXdoNow |= 1; parSet(p_GvAutoMd, 0);
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
        ) :
        (KeyedT === '#') ? (
            ui_GFXdoNow |= 1; ui_GFXReason = 38;
            SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all
        ) :
        ((KeyedT === '@') || (KeyedT === 'à')) ? (
            SchedAddTask(5, 11|ActFlg1, -1, -1, 0, 0, 0); // Lock all
            setPModePause(); // stop replay
            setPlayMark(clESize-1, psKPlaying, recOptMarkReplay ? psKReplaying : 0, 0); // keep the entry in last position
            ui_GFXdoNow |= 1;
        ) :
        ((KeyedT === '&')) ? (
            setPlayMark(-1, psKPlaying, recOptMarkReplay ? psKReplaying : 0, 0); // keep the entry
            ui_GFXdoNow |= 1;
        ) :
        ((KeyedT === '$')) ? (
            setRModeRec();
            ui_GFXdoNow |= 1;
        ) :
        ((KeyedT === ';')) ? (
            DynParamsReset();
        ) :
        ((KeyedT === '\'')) ? (
            setRModeSwitch();
            (recordMode === recModePause) ? (
                setPModePause();
                SchedAddTask(5, 1|ActFlg1, 1, -1, 0, 0, 0); // Lock & unmute all
                parSet(p_GvAutoMd, 0); // and stop playing
            ) : (
                setPModePlay();
            );
        ) :
        ((KeyedT === 'end')) ? (
            Kbtp = cmdClMdBase + GvPlayTypGrLoop;
        ) :
        (KeyedT === '"') ? (
            parSet(p_GvAutoMd, 0);
            // clearCmd();
            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
        ) :
        ((KeyedT === 8)) ? (
            flagStopOne += 1;
        ) :
        ((KeyedT === 127)||(KeyedT === 'f12')) ? (
            studPrefDispPanes = 1 + (studPrefDispPanes % 4) ;
            ui_jGUI_prev = 0;
            ui_GFXdoNow |= 1; ui_GFXReason = 14;
        ) :
        (KeyedT === 'f11') ? (
            uix_switch += 1;
            uix_jG_switchr[uix_switch] < 0 ? uix_switch = 0;
            ui_screen_switch(uix_jG_switchr[uix_switch]);
        ) :
        ((KeyedT === 124)||((KeyedT === 9) && (Kmouse_cap === 8))) ? (
            // switch to previous tabulation
            uix_jmbsel = (uix_jmbsel + dcbTabsCount - 1) % dcbTabsCount;
            ui_screen_switch(uix_jG_menuscr[uix_jmbsel]);
        ) :
        ((KeyedT === 126)||(KeyedT === 1066)||(KeyedT === 9)) ? (
            // switch to next tabulation
            uix_jmbsel = (uix_jmbsel + 1) % dcbTabsCount;
            ui_screen_switch(uix_jG_menuscr[uix_jmbsel]);
        ) :
        ((KeyedT === 125)||(KeyedT === 'f10')) ? (
            // switch tabulations
            z = uix_jmbprv; uix_jmbprv = uix_jmbsel; uix_jmbsel = z;
            ui_screen_switch(uix_jG_menuscr[uix_jmbsel]);
        ) :
        (
            KeyedT = SKeyedT; // restore Keyed character
        ) ;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 15;
    );

    (KeyedT === 0) ? ui_key_next();
);


function
do_GenericTabStart()
(
    ui_jmouse_cap |= mouse_cap;
    KeyedT = Keyed = 0; AAAA_Kmouse_cap = Kmouse_cap = ui_jmouse_cap;
    studio_pad_active = 0;
    do_Generic_Commands();
);

function
do_GenericTabEnd()
(
    //do_Generic_Commands();
    0;
);

/*
(FlagsTbVals[Flgs_GFXTrcs] & 1) ? (
    !uix_latestchar || !uix_char_consumed ? (
        uix_latestchar = gfx_getchar();
        uix_latestchar == -1 ? uix_latestchar = 0;
    );
    uix_char_consumed = 0;
    pmous = cmous;
    cmous = mouse_cap;
    (uix_latestchar != 0) ? (
        sprintf(#sq, "***Key  @  %d  %d    [%d+%d -> '%c']", mouse_x, mouse_y, cmous, uix_latestchar, uix_latestchar);
        mSL_log(SysLogBox, #sq);
    );
);


(FlagsTbVals[Flgs_GFXTrcs] & 2) ? (
    pmous = cmous;
    cmous = mouse_cap;
    (((pmous & 1) === 1) && ((cmous & 1) === 0)) ? ( // left clic released
        sprintf(#sq, "***Mouse @  %d  %d   [%d -> %d]", mouse_x, mouse_y, pmous, cmous);
        mSL_log(SysLogBox, #sq);
    );
);
*/
1 ? (
(strlen(#dbg_trace0) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace0);
    #dbg_trace0 = "";
);
(strlen(#dbg_trace1) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace1);
    #dbg_trace1 = "";
);
(strlen(#dbg_trace2) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace2);
    #dbg_trace2 = "";
);
(strlen(#dbg_trace3) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace3);
    #dbg_trace3 = "";
);
(strlen(#dbg_trace4) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace4);
    #dbg_trace4 = "";
);
(strlen(#dbg_trace5) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace5);
    #dbg_trace5 = "";
);
(strlen(#dbg_trace6) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace6);
    #dbg_trace6 = "";
);
(strlen(#dbg_trace7) != 0) ? (
    mSL_log(SysLogBox, #dbg_trace7);
    #dbg_trace7 = "";
);
);

GMTrack = get_host_placement();
efi = 1; idx = 0;
#audio = "";
while (efi) (
  (efi = gfx_getdropfile(idx, #s)) ? (
    efs = mSL_Str_Tmp(); // get a temporary string
    strcpy(efs, #s);
    dropped_x = mouse_x; dropped_y = mouse_y;
    //
    (FlagsTbVals[Flgs_GFXTrcs] & 2) ? (
        mSL_log(SysLogBox, efs);
        sprintf(#s, "   at: %d  %d    [%x]", dropped_x, dropped_y, mouse_cap); mSL_log(SysLogBox, #s);
    );
    // Try to localize the file in the project
    (strlen(#D_GM_Project_Path_FX) > 0) && match(#D_GM_Project_Path_FX, efs) ? (
        strcpy_from(#s, efs, strlen(#D_GM_Project_Path_FX)-1);
        // strcpy(efs, "./"); strcat(efs, #s);
        strcpy(efs, #s);
        // mSL_log(SysLogBox, efs);
    );
    // mSL_log(SysLogBox, efs);
    ui_GFXdoNow |= 1; // Make sure we react as soon as possible
    // Is this an mSL script ?
    (match ("*mSL", efs) || match ("*txt", efs)) ? (
        //
        sprintf(#s, "*  Compile: %s  (%d)  %d *", efs, strlen(efs), mouse_cap); mSL_log(SysLogBox, #s);
        ((mouse_cap & altCap) || (dropped_y < 32)) ? (
            doMslCompile(efs); // add to compile list
        ) : (
            strcpy(#efs, efs); // save in #efs
            dpi = 1; // an mSL file is available
        );
    ) :
    (match ("*.wav", efs) || match ("*.aif", efs) || match ("*.flac", efs) || match ("*.mp3", efs) || match ("*.aiff", efs) || match ("*.ogg", efs) || match ("*.wmv", efs) || match ("*.mp4", efs) || match ("*.mov", efs)) ? (
        strcpy(#efs, efs); // save in #efs
        dpa = 1; // an audio file is available
        (afs === 0) ? (afs = #afs; strcpy(afs, ""); ); // use a perf string
        // accumulate in afs ; use a dummy clip number for now
        sprintf(#aw, " 10000 %d %s ", strlen(efs), efs);
        strcat(afs, #aw);
        //mSL_log(SysLogBox, "Matching sound file");
    ) :
    (match ("*.RPP", efs)) ? (
        sprintf(#s, "*  Received: %s  (%d)  %d *", efs, strlen(efs), mouse_cap); mSL_log(SysLogBox, #s);
        SetNewProjectPath (efs);
    ) :
    (match ("*WAVES", efs)) ? (
        sprintf(#s, "*  WAVES: %s  (%d)  %d *", efs, strlen(efs), mouse_cap); mSL_log(SysLogBox, #s);
    ) :
    (match ("*Scripts", efs)) ? (
        sprintf(#s, "*  Scripts: %s  (%d)  %d *", efs, strlen(efs), mouse_cap); mSL_log(SysLogBox, #s);
    );
    idx += 1;

  ) : (
    (efs != 0) ? gfx_getdropfile(-1);
  );
);


function ui_dropped_in() (
	// (efs !=0) && dropped_x >= ui_left() && dropped_x < ui_right() && dropped_y >= ui_top() && dropped_y < ui_bottom();
	dropped_x >= ui_left_retina() && dropped_x < ui_right_retina() && dropped_y >= ui_top_retina() && dropped_y < ui_bottom_retina();
);

function doneDroppedFile() (
    dpa = dpi = efs = afs = 0; dropped_x = dropped_y = -1;
);

// Read & Print a text file
function doMslTxtPrint(fname)
local (fhd, lct, el, flg, i1, i2, l1, l2)
(
    // sprintf(#mSLine, "Trying File: \"%s\"", fname);  mSL_log(SysLogBox, #mSLine);
    l1 = SysLogBox[3];
    fhd = GM_file_open(fname, 0); el = lct = 0; flg = 1;
    ((fhd >= 0)) ? (
        i1 = file_text(fhd);
        i2 = file_avail(fhd);
        // sprintf(#mSLine, "Opened File: \"%s\"  %d/%d", #tmpFname, i1, i2); mSL_log(SysLogBox, #mSLine);
        (FlagsTbVals[Flgs_GFXTrcs] & 2) ? (
            sprintf(#mSLine, "File: \"%s\"", #tmpFname); mSL_log(SysLogBox, #mSLine);
        );
        while (flg && (lct < 300)) (
            file_string(fhd, #mSLine); flg = file_avail(fhd);
            mSL_log(SysLogBox, #mSLine);
            (strlen(#mSLine) === 0) ? (el += 1; flg = 0);
            lct += 1;
        );
        file_close(fhd);
    );
    //sprintf(#mSLine, "%d lines, %d empty.%s", lct, el, lct >= 300 ? " (truncated)" : "");mSL_log(SysLogBox, #mSLine);

    l2 = SysLogBox[3];
    mSL_log_reverse(SysLogBox, l1, l2);
);


// Read & Compile a mSL script file
function mSL_load_file_inGFX(fname)
local (fhd, ent, thrd, s, mSL_baseAVars, mSL_baseOVars, mSL_basePVars)
(
    mSL_load_start = gfxStartTime;
    mSL_errX = mSL_errC = 0;
    ent = 0; fhd = -1;
    //(mSL_errC === 0) ? (
    //    SchedListEmpty(SchedInactPts) ? (
    //        mSL_errC = 2406; // can't get a thread
    //    );
    //);

    (FlagsTbVals[Flgs_GFXTrcs] & 4) ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", fname, mSL_errC); mSL_log(SysLogBox, #gfxu););

    (mSL_errC === 0) ? (
        fhd = GM_file_open(fname, 0);
        ((fhd >= 0)) ? (
            (FlagsTbVals[Flgs_Inits] & 2) ? (
                sprintf(#gfxu, "::-> Using \"%s\"", #tmpFname); mSL_log(SysLogBox, #gfxu);
            );
            // get a free thread
            (ent = getNewThread()) ? (
                thrd = SchedThrdPt[ent];
                AAAAAAAA_01_cp_rtc = mSL_compile(fhd, -1, -1, 0); // we add the input in the memory
                0 ? (sprintf(#gfxu, "::-> Compiled: %d lines", mSL_C_numLine); mSL_log(SysLogBox, #gfxu););
                fhd = -1; // file has been closed by the compiler
                (mSL_errC === 0) ? (
                    AAAAAAAA_02_add = mSL_main_cod;
                    // This duplicates the work made in "mSL_init_thread" - TODO!!
                    (mSL_main_cod != 0) ? (
                        (FlagsTbVals[Flgs_Scripts] & 1) ? (
                            sprintf(#gfxu, "SZ(%d) %d, %d, %d", ent, (mSL_gvar+1) & mSL_NumMask, (mSL_ovar+1) & mSL_NumMask, (mSL_pvar+1) & mSL_NumMask);
                            mSL_log(SysLogBox, #gfxu);
                        );
                        // Let's copy appropriate vars tables in the thread references
                        thrd[mSL_THR_baseAVars] = mSL_baseAVars = mSL_main_cod[mSL_CC_GlbTab];
                        thrd[mSL_THR_baseOVars] = mSL_baseOVars = mSL_main_cod[mSL_CC_OwnTab];
                        thrd[mSL_THR_basePVars] = mSL_basePVars = mSL_main_cod[mSL_CC_PtrTab];
                        SchedStatus[ent] |= SchThrUsed;  // now in use
                        AAAAAAAA_ent = ent ;
                        SchedPar1[ent] = mSL_main_cod; // the code
                        // Keep tables info in the main code
                        // sprintf(#gfxu, "TH: %d, %d, [%d, %d, %d]", ent, thrd, mSL_baseAVars, mSL_baseOVars, mSL_basePVars);
                        (FlagsTbVals[Flgs_Scripts] & 1) ? (
                            sprintf(#gfxu, "TH(%d) [%d, %d]", ent, mSL_baseAVars, mSL_baseOVars);
                            mSL_log(SysLogBox, #gfxu);
                        );
                        SchedCode[ent] = KRun_mSL_Thread; // start running a thread
                        mSL_init_thread(ent); // perform initalization
                        // ADump(mSL_main_cod); // just a trace
                        mSL_errX = max(mSL_errX, mSL_errC);
                        (mSL_errX === 0) ? (
                            (FlagsTbVals[Flgs_Scripts] & 1) ? (
                                sprintf(#gfxu, "Load OK - Ent: %d", ent);
                                mSL_log(SysLogBox, #gfxu);
                            );
                        );
                        mSL_High_Stack = mSL_max_TOS = 0;
                    ) : (
                        mSL_errX = 2409; // no code generated
                    );
                );
            ) : (
                mSL_errX = 2410; // no thread available
            );
        ) : (
            mSL_errX = 2405; // can't open
        );
    );

    (mSL_C_fH >= 0) ? (file_close(mSL_C_fH); mSL_C_fH = -1;);
    (fhd >= 0) ? (file_close(fhd); fhd = -1;);
    mSL_errX = max(mSL_errX, mSL_errC);

    (mSL_errX === 0) ? (
        (ent > 0) ? SchedInsertTail(SchedLockdPts, ent, SchETypeThrd);
    ) : (
        SchedFree(ent); // in case of error, free the entry
        ent = 0;
    );

    mSL_load_end = gfxStartTime;
    (FlagsTbVals[Flgs_Scripts] & 1) ? (
        sprintf(#gfxu, "Fread(%d) Err:%d Dur:%.2f ms", ent, mSL_errX,
                        1000 * (mSL_load_end - mSL_load_start));
        mSL_log(SysLogBox, #gfxu);
    );
    flagShowMemory = 1;
    mSL_errX ? (
        sprintf(#gfxu, "ERR: %d    can't compile \"%s\".", mSL_errX, fname);
        mSL_log(SysLogBox, #gfxu);
    );
    ent;
);

mSL_loc_tim = max(mSL_loc_tim - 1, 0);


//============ GC RUN ============
(atomic_get(mSL_Lock) && (mSL_loc_tim <= 0))? (
    // we may have a GC to run
    (gc_run_phaz != 0) ? (
        (gc_run_phaz === 1) ? (
            mSL_loc_tim = max(2, mSL_loc_tim + 2); // no GC for some time
            // Perform a GC
            mSL_gc_start = time_precise() + timeD;
            mSL_errX = mSL_errC = 0;
            gc_start();
            gc_release_unused_thread();
            gc_mark_active();
            // gc_mark(blockUsrDesc); // mark
            gc_mark(0); // make sure the last blocks have been checked
            // execute the sweep phase
            gc_sweep();
            gc_run_phaz = 3; // This is over
            mSL_gc_end = time_precise() + timeD;
            mSL_errX = max(mSL_errX, mSL_errC);
            ((FlagsTbVals[Flgs_GC] & 1) && mSL_errX) ? (
                sprintf(#gfxu, "GC Err: %d - Dur %.2f ms", mSL_errX,
                        1000 * (mSL_gc_end - mSL_gc_start));
                mSL_log(SysLogBox, #gfxu);
            );
            mSL_gc_MaxDur = max(mSL_gc_end - mSL_gc_start, mSL_gc_MaxDur);
        );
    ) ;
    // If we have a func to compile, do it A.S.A.P.
    (uuuMslFn != 0) ? (
        // Do we have enough memory to run a compilation ?
        !((gc_run_phaz > 1) || (mm_bl_huge > 0) || (mm_bl_big > 0) || (mm_bl_large >= 4) || (mm_bl_medium >= 64)) ? (
            // we may need a GC
            gc_run_phaz = 1; // start it
        ) : (
            ((mSL_active_Thread <= 0) && (uuuMslFent === 0)) ? (
                // We are sure there are no active mSL thread...
                // or compiler structure used
                // and none can be started yet...
                // look for a file to compile
                uuuMslFname = 0;
                ig = 0; while ((uuuMslFname === 0) && (ig < uuuMslTSiz)) (
                    (uuuMslFname = uuuMslTabs[ig]) ? (
                        uuuMslTabs[ig] = 0;
                    );
                    ig += 1;
                );
                (uuuMslFname === 0) ? ( // no file found to compile
                    uuuMslTPt = uuuMslFent = uuuMslFn = 0; // reset indicators
                ) : (
                    uuuMslFent = mSL_load_file_inGFX(uuuMslFname);
                );
            );
            mSL_loc_tim += 2; // again save some time
        );
    );
);


logTask ? (
    // a log task is waiting for us
    (logTask === 1) ? (
        // get aux-script status
        // if "ready", start working
        (gmem[versionGMScript] === 0) ? (
            err_sys_rtm = 6001; // no aux. script running.
            logTask = 0;
        ) : (
            logTask = 0;
        );
    ) :
    (
        err_sys_rtm = 6002; //undefined log task number
        logTask = 0;
    );
);



//===== Clips Checking =====
/*
cnt = 40; // max(1, 0|(samplesblock/320));
ClCheckView ? (
    while ((cnt > 0) && (cBk4 <= clInBank)) (
        xNum = (xNum + UClipPrime) % clInBank; cBk4 += 1; zNum = xnum + (slBankset * clBSSize + slGroupNum) * clInBank;
        (ClCheckForce || ((gmem[clClInfos+zNum] === 0) && (gmem[clInfStart+zNum] === 0))) ? (
            checkClip(zNum, ClCheckForce); cnt -= 1;
        );
    );
    (cBk4 >= clInBank) ? (
        0 ? (
            sprintf(#s, "++Done CheckView [%d/%d]", slBankset, slGroupNum);
            mSL_log(SysLogBox, #s);
        );
        ClCheckView = cBk4 = 0;
    );
);
ClCheckFlag ? (
    (ClCheckCnt >= clTSize) ? (
        ClCheckCnt = ClCheckFlag = 0;
        ClCheckForce = 0;
        UClipPrime = gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];
    ) : (
        while ((cnt > 0) && (ClCheckCnt <= clTSize)) (
            ClCheckNum = (ClCheckNum + UClipPrime) % clTSize; ClCheckCnt += 1;
            (ClCheckForce || ((gmem[clClInfos+ClCheckNum] === 0) && (gmem[clInfStart+ClCheckNum] === 0))) ? (
                checkClip(ClCheckNum, ClCheckForce); cnt -= 1;
            );
        );
    );
);
*/


// build a "keyboard command" from mouse click and modifiers
function buildKey(val, mds)
(
    (val === -1) ? (
        (mds & cmdCap) ? ( // "ctrl"
            (mds & 8) ? 'pgup' : '?' // "shift"
        ) : (
            (mds & 8) ? 'up' : 'b' // "shift"
        )
    ) : (
        (mds & cmdCap) ? ( // "ctrl"
            (mds & 8) ? 'pgdn' : '.'
        ) : (
            (mds & 8) ? 'down' : 'n'
        )
    );
);


function keepBlockInfos(bCurrent)
local(i)
(
    blockDesc ? (
        // keep position
        i = 0; loop (dcbMSize - 1,
            (blockDesc[i] === bCurrent) ? (
                blockDesc[i+dcbMSize] = A99PBlock = (ui_top_retina()*10000)+ui_height_retina();
            );
            i += 1;
        );
    );
);





function swtHPDispMode()
(
     // switch display mode
     HPDispMode = (HPDispMode+1) % 2;
     (HPDispMode === 0) ? (
         padHPColrs[1] = Col_InfoC;
         padHPLabs[1] = "Sequence";
     ) : (
         padHPColrs[1] = Col_InfoB;
         padHPLabs[1] = "Positions";
     );
);



function updHPSel(key, val)
local(val, cc, cq, cx, flu, kuz, flk)
(
    HPnumLastM = lastTime; HPnumUnchkd  = 1;
    flu = 0; kuz = 1; cq = 1;
    flk = key > 0; key < 0 ? key = -key;
    // val = padHPVals[0];
    ((key >= '0') && (key <= '9')) ? (
        val = (val % 1000) * 10 + key - '0';
    ) :
    ((key === '%')) ? (
        val = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        val = (val + 1) % HPPSize; // min(1+val, HPPSize-1);
    ) :
    ((key === ':')||(key === '/')) ? (
        val = (val + HPPSize - 1) % HPPSize; //  val = max(0, val-1);
    ) :
    ((key === 'd')||(key === 'm')) ? (
        swtHPDispMode();
    ) :
    ((key === '.')) ? (
        val = val + 10; flu = 1;
    ) :
    ((key === '?')) ? (
        val = val - 10; cq = -1; flu = 1;
    ) :
    ((key === 0)||(key === 1)) ? (
        flu = 1; // just "normalize" the value
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            val = val + cq;
            flu = 1;
        ) :
        ((key === 'down')) ? (
            val = val + 100;
            flu = 1;
        ) :
        ((key === 'up')) ? (
            val = val - 100; cq = -1;  flu = 1;
        ) :
        ((key === 'pgdn')) ? (
            val = val + 20; flu = 1;
        ) :
        ((key === 'pgup')) ? (
            val = val - 20; flu = 1; cq = -1;
        ) :
        ((key === 'home')) ? (
            val = 0;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );

    // has the key been used ?
    (flk && kuz) ? (
        Keyed = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 25;
    );

    flu ? (
        cc = (val + HPPSize) % HPPSize; cx = HPPSize;
        while ((HPPTab[cc] <= 0) && (cx >= 0)) (
            cc = (cc + cq + HPPSize) % HPPSize; cx -= 1;
        );
        val = cc;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 26;
    );

    val;
);








//====== Generators ======

function showGPValue(unit, ubl, num)
local (xx, p, pp, k, m, par, ent, label, fmt, value, ty, fo, e, zPm)
(
    (uix_javail_Bwidth >= uix_req_w && uix_javail_Bheight >= ui_jd_tboxs) ? (
        uix_javail_Bheight -= ui_split_top(ui_jd_tboxs);
            ui_hover() ? (
                xx = control_jmenu(menu_Param_UBD);
                (xx != 0) ? (
                    (xx === 1) ? (
                        // "up move"
                        ((num > Bpl_Sh1) && (num < ubl[Bpl_ShCnt]+Bpl_Sh1-1)) ? (
                            // xch this entry with the previous
                            p = ubl[num]; ubl[num] = ubl[num - 1]; ubl[num - 1] = p;
                        );
                    ) :
                    (xx === 2) ? (
                        // "down move"
                        ((num >= Bpl_Sh1) && (num < ubl[Bpl_ShCnt]+Bpl_Sh1-2)) ? (
                            // xch this entry with the next one
                            p = ubl[num]; ubl[num] = ubl[num + 1]; ubl[num + 1] = p;
                        );
                    ) :
                    (xx === 3) ? (
                        // "left move"
                        ent = num;
                        loop (SGenKmind,
                            ((ent > Bpl_Sh1) && (ent < ubl[Bpl_ShCnt]+Bpl_Sh1-1)) ? (
                                // xch this entry with the previous
                                p = ubl[ent]; ubl[ent] = ubl[ent - 1]; ubl[ent - 1] = p;
                            );
                            ent -= 1;
                        );
                    ) :
                    (xx === 4) ? (
                        // "right move"
                        ent = num;
                        loop (SGenKmind,
                            ((ent >= Bpl_Sh1) && (ent < ubl[Bpl_ShCnt]+Bpl_Sh1-2)) ? (
                                // xch this entry with the next one
                                p = ubl[ent]; ubl[ent] = ubl[ent + 1]; ubl[ent + 1] = p;
                            );
                            ent += 1;
                        );
                    ) :
                    (xx === 5) ? (
                        // blank entry
                        ((num >= Bpl_Sh1) && (num <= ubl[Bpl_ShCnt]+Bpl_Sh1-1)) ? (
                            ubl[num] = -1;
                        );
                    ) :
                    (xx === 6) ? (
                        // clear entry
                        ((num >= Bpl_Sh1) && (num < ubl[Bpl_ShCnt]+Bpl_Sh1-1)) ? (
                            ubl[num] = 0;
                        );
                    ) :
                    (xx === 7) ? (
                        // clear all
                        k = Bpl_Sh1; while (k < ubl[Bpl_ShCnt]+Bpl_Sh1-1) (
                            ubl[k] = 0; k += 1;
                        );
                    ) :
                    (
                        // Changing the displayed control
                        // ubl[num] = xx; // keep the entry
                        ubl[num] = paramUBDsMenuNums[xx];
                        AAAAAA_num = num;
                        AAAAAA_code = ubl[num];
                        AAAAAA_addr = ubl;
                    );
                );
            );
            xx = ubl[num]; // entry number
            ent = -1; k = 6;
            // look for the identification
            while ((ent < 0) && (k < paramUBDsMenuSize)) (
                (xx === paramUBDsMenuNums[k]) ? ent = k;
                k += 1;
            );
            (ent < 0) ? (
                label = par = ent = 0; // entry undefined
            ) : (
                BAA_par = par = paramUBDsMenuNums[ent]; // the parameter
            );
            label = 0;
            (par != 0) ? (
                ty = (par >> 12) & 0xF; // the representation basis
                fo = (par >> 16) & 0x1F; // the string format number for edition
                p = par & 0xfff; // index of value to display
                (ty === 0) ? (
                    // the object is a parameter
                    pp = paramBlock + p * paramEntSize;
                    BAA_type = pp[pp_Type]; ////trace
                    k = BAA_type & 0xfff; // the param number
                    m = BAA_type & i_Ma; // the "mode" mask // used ?
                    BAA_k = k; ////trace
                    (k != 0) ? (
                        BAA_v0 = value = gmem[unit + k];
                    ) : (
                        value = paramValues[p];
                    );
                    // value += (value > 0) ? 0.000001 : (value < 0) ? -0.000001 : 0;
                    label = pp[pp_Name];
                    fmt = pp[pp_SFmt];
                ) :
                (ty === 1) ? (
                    // The object is an entry in the BCB block
                    value = gmem[unit + p];
                    // value += (value > 0) ? 0.000001 : (value < 0) ? -0.000001 : 0;
                    label = paramUBDsMenuNames[ent];
                    fmt = PrintFormats[fo];
                ) :
                (ty === 2) ? (
                    // The object is an entry in memory
                    value = p[0];
                    // value += (value > 0) ? 0.000001 : (value < 0) ? -0.000001 : 0;
                    label = paramUBDsMenuNames[ent];
                    fmt = PrintFormats[fo];
                ) :
                (ty === 3) ? (
                    // The object is an entry in the gmem memory
                    value = gmem[p];
                    // value += (value > 0) ? 0.000001 : (value < 0) ? -0.000001 : 0;
                    label = paramUBDsMenuNames[ent];
                    fmt = PrintFormats[fo];
                ) :
                (ty === 4) ? (
                    // A specific format
                    label = paramUBDsMenuNames[ent];
                    fmt = "%s"; // default
                    (p === 1) ? (
                        // "Status"
                        e = gmem[unit+RCB_cbCKmd];
                        (e === KmdPlay) ? value = "Playing" :
                        (e === KmdLoop) ? value = "Looping" :
                        (e === 0) ? value = "Waiting" :
                        ( fmt = "Kmd: %d" ; value = e; ) ;
                    ) :
                    (p === 2) ? (
                        // "State"
                        e = gmem[unit+RCB_Cl_Flgs];
                        (e === 0) ? value = "Std" :
                        (e === 1) ? value = "Locked" :
                        (e === 2) ? value = "Mute" :
                        (e === 3) ? value = "Locked, Mute" :
                        ( fmt = "%d" ; value = e; ) ;
                    ) :
                    (p === 3) ? (
                        // "Remaining"
                        e = gmem[unit+RCB_cbCKmd];
                        ((e === KmdPlay) || (e === KmdLoop)) ? (
                            value = e ;
                            fmt = "%d s";
                        ) : (
                            value = "Inactive";
                        );
                    ) :
                    (p === 4) ? (
                        // Speed min - from Play Mode
                        zPm = gmem[unit+RCB_CPlMd_nbr];
                        PMAddr = PMTab + zPm * PMEsize;
                        value = PMAddr[idx_Pm_Speed1]; fmt = "%0.4f";
                    ) :
                    (p === 5) ? (
                        // Speed max - from Play Mode
                        zPm = gmem[unit+RCB_CPlMd_nbr];
                        PMAddr = PMTab + zPm * PMEsize;
                        value = PMAddr[idx_Pm_Speed1+1]; fmt = "%0.4f";
                    ) :
                    (p === 6) ? (
                        // tempo
                        value = sysTempo; fmt = "%0.1f";
                    ) :
                    (p === 7) ? (
                        // tempo
                        value = sysPlayState; fmt = "%0.1f";
                    ) :
                    (p === 8) ? (
                        // tempo
                        value = sysBeatPosition; fmt = "%0.1f";
                    ) :
                    (p === 9) ? (
                        // tempo
                        value = sysSampPosition; fmt = "%0.1f";
                    ) : (
                        label = 0; // can't print
                    );
                ) : (
                    label = 0; // can't print
                );
            );
            (label != 0) ? (
                ui_pad(0,1,0,0);
                ui_pcolor(ui_jcolor_text);
                ui_split_leftratio(0.5);
                    ui_pad(3,0);ui_align(0, 0.5);ui_text(label);
                ui_split_next();
                    ui_pcolor(ui_jcolor_border);
                    ui_pad(3,0);
                    ui_border(); ui_align(0.5, 0.5);
                    ui_pcolor(ui_jcolor_text);
                    ui_textnumber(value,fmt);
                ui_pop();
            ) : (
                ui_pad(5,0,0,0); ui_align(0, 0.5);
                ui_pcolor(ui_jcolor_text);
                ui_text((xx === 0) ? " (unset entry) " : "");
            );
        ui_pop();
    );
);

// Used in a displayer
// Purpose : use a "global" parameter to modify a "local" value
// Means: save value, use parameter slider, restore value
function showGControl(unit, ubl, num)
local (xx, k, p, m, flgm, pp, v, s1, s2)
(
    ui_hover() ? (
        xx = control_jmenu(menu_Param_UBS);
        (xx != 0) ? (
            // AAAAAAAA_xx = xx;
            (xx === 1) ? (
                // "up move"
                ((num > Bpl_Sl1) && (num < ubl[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    // xch this entry with the previous
                    p = ubl[num]; ubl[num] = ubl[num - 1]; ubl[num - 1] = p;
                );
            ) :
            (xx === 2) ? (
                // down move
                ((num >= Bpl_Sl1) && (num < ubl[Bpl_SlCnt]+Bpl_Sl1-2)) ? (
                    // xch this entry with the next one
                    p = ubl[num]; ubl[num] = ubl[num + 1]; ubl[num + 1] = p;
                );
            ) :
            (xx === 3) ? (
                // blank entry
                ((num >= Bpl_Sl1) && (num <= ubl[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    ubl[num] = -1;
                );
            ) :
            (xx === 4) ? (
                // clear entry
                ((num >= Bpl_Sl1) && (num < ubl[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    ubl[num] = 0;
                );
            ) :
            (xx === 5) ? (
                // clear all
                k = Bpl_Sl1; while (k < ubl[Bpl_SlCnt]+Bpl_Sl1-1) (
                    ubl[k] = 0; k += 1;
                );
            ) :
            (
                // Changing the displayed control
                ubl[num] = paramUBSLMenuNums[xx];
            )
        );
    );
    BAA_par = p = ubl[num]; // the parameter
    (p >= 1) ? (
        pp = paramBlock + p * paramEntSize;
        BAA_type = pp[pp_Type]; ////trace
        k = BAA_type & 0xfff;
        m = BAA_type & i_Ma;
        BAA_k = k; ////trace
        (k != 0) ? (
            // Save global parameter values
            s1 = paramValues[p];
            s2 = pp[pp_Def];
            BAA_v0 = v = gmem[unit + k];
            parSet(p, v); //
            // Should we modify the "default value ? "
        );
        ui_pcolor(ui_jcolor_text);
        flgm = parCtl(p);
        BAA_flgm = flgm;  ////trace
        BAA_v1 = paramValues[p];  ////trace
        (k != 0) ? (
            (flgm) ? (
                // changing the value
                BAA_v2 = gmem[unit + k] = paramValues[p];
                gmem[unit + RCB_State_Changed] |= m;
                gmem[unit + RCB_Item_Changed] = k;
            );
            // Restore global parameters values
            paramValues[p] = s1;
            pp[pp_Def] = s2;
        );
    ) : (
        ui_pad(5,0,0,0); ui_align(0, 0.5);
        ui_text((p === 0) ? " (unset entry) " : "");
    );
);

/*
    Show the File/Reader interfaces, BplayerA, BplayerB, BplayerC, BplayerD
*/
function
show_Generator(unitbkl, blockN)
local(upla, WUAdd, id, u, uix_jneed, unitmod, uix_jmini, zzmi, h1, h2, h3, ix, v, k, n, d, e, inpl,
    s, str0, str1, str2, str3, xx, zz, zzch, zzent, zzmcl, zzmmd, ktdsp, key)
(
    str0 = #; str1 = #; str2 = #; str3=#;
    // which unit should we show ?
    unitmod = unitbkl[0]; // display mode of the unit
    upla = unitbkl[2]; // player number [in 0 .. readerCount] to show
    unitmod === 2 ? (
        // display last selected
        gDispPlay >= 0 ? (
            unitbkl[2] = upla = gDispPlay; // new player number to show
            gDispPlay = -1;
        );
    );
    id = 0; loop (uCnt,
        u = UGAddr + UCBSize * id;
        ((gmem[u+cbType] === uPlayer) && (upla === gmem[u+cbPlIdt])) ? (
            unitbkl[1] = id; // keep the unit UId
        );
        id += 1;
    );
    WUAdd = UGAddr + UCBSize * unitbkl[1];
    upla = gmem[WUAdd+cbPlIdt];

    ktdsp = max(1,unitbkl[Bpl_ShCnt]);
    SGenKmind = ceil((ktdsp)/4); // height of each column
    h1 = uix_jBoxHeight(1);
    h2 = uix_jBoxHeight(SGenKmind);
    h3 = 0;
    (unitmod === BplEdit) ? (
        // h3 = ui_jd_slidh * 8 + 4; // add some sliders
        (unitbkl[Bpl_CCSlCnt] === 0) ? (
            h3 = ui_jd_slidh * max(1,unitbkl[Bpl_SlCnt]) + 4;
        ) : (
            h3 = ui_jd_slidh * max(1,ceil(unitbkl[Bpl_SlCnt]/2)) + 4;
        );
    );
    uix_jneed = h1 + ui_jd_delta2 + h2 + ui_jd_ctgr + h3;
    uix_jmini = max(h1 + h1 + ui_jd_ctgr, ui_jd_min_block);

    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            keepBlockInfos(blockN);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockN]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            ui_align(0,0);
            ui_split_top(h1);
                ui_new_column(1/4);
                sprintf(#wstr, "Player # %d", 1+gmem[WUAdd+cbPlIdt]);
                ui_show(#wstr);
                ui_pop();

                // ui_new_column(3/4);
                ui_pad(1,0,3,3);
                    // Item 0
                    (unitbkl[0] === 0) ? (
                        padBplColrs[0] = Color_Light_Brownish_Gray;
                        sprintf(str0, "Reader  %d", 1+upla);
                        // padBplLabs[0] = "Reader";
                    ) :
                    (unitbkl[0] === 1) ? (
                        padBplColrs[0] = Color_Brownish_Gray;
                        sprintf(str0, "Last  %d", 1+upla);
                        // padBplLabs[0] = "Last";
                    ) :
                    (unitbkl[0] === 2) ? (
                        padBplColrs[0] = Color_Brownish_Orange;
                        sprintf(str0, "Selected  %d", 1+upla);
                        // padBplLabs[0] = "Selected";
                    ) :
                    (unitbkl[0] === BplEdit) ? (
                        padBplColrs[0] = Color_Fern_Green;
                        sprintf(str0, "Edit  %d", 1+upla);
                        // padBplLabs[0] = "Edit";
                    ) :
                    (
                        padBplColrs[0] = Col_Inactive;
                        str0 = "";
                    );
                    padBplLabs[0] = str0;
                    // Item 1
                    sprintf(str1, "%d", 1+upla); // reader number
                    padBplLabs[1] = str1;
                    (gmem[WUAdd+RCB_cbCKmd] === KmdPlay) ? (
                        padBplColrs[1] = Color_Blue_Green;
                    ) :
                    (gmem[WUAdd+RCB_cbCKmd] === KmdLoop) ? (
                        padBplColrs[1] = Color_Goldenrod;
                    ) : (
                        padBplColrs[1] = Col_Inactive;
                    );
                    // Item 2
                    padBplColrs[2] = Color_Clear_Yellow;
                    sprintf(str2, "%04d", gmem[WUAdd+RCB_ClipDup]);
                    padBplLabs[2] = str2;
                    // Item 3
                    padBplColrs[3] = Color_Dark_Orange;
                    (gmem[WUAdd+RCB_ClipDup] === gmem[WUAdd+RCB_ClipNb]) ? (
                        padBplLabs[3] = "Current";
                    ) : (
                        padBplLabs[3] = "Modified";
                    );
                    // Item 4
                    padBplColrs[4] = Col_InfoC ;
                    sprintf(str3, "%d", gmem[WUAdd+RCB_Channels_cnfDup]);
                    padBplLabs[4] = str3;
                    // Item 5
                    padBplColrs[5] = Color_Dark_Orange;
                    padBplLabs[5] = "Settings";

                    zz = control_jpad(padBplayer);
                    (zz > 0) ? (
                        ui_GFXdoNow |= 1; ui_GFXReason = 40;
                        zzch = padBplayer[ui_jpad_lkey];
                        zzent = padBplayer[ui_jpad_entkey]-1;
                        zzmcl = padBplayer[ui_jpad_last]-1;
                        zzmmd = padBplayer[ui_jpad_lmods];
                        (zz & ui_jpad_ev_key) ? (
                            Keyed = zzch; // keep the char, in case we don't use it
                            (zzent === 0) ? (
                                ((ui_jmouse_cap === 0) && (zzch === 'rght')) ? (
                                    unitbkl[0] = (unitbkl[0] + 1) % 4; // Change mode
                                ) :
                                ((ui_jmouse_cap === 0) && (zzch === 'left')) ? (
                                    unitbkl[0] = (unitbkl[0] - 1 + 4) % 4; // Change mode
                                );
                            ) :
                            (zzent === 1) ? (
                                ((ui_jmouse_cap === 0) && (zzch === 'rght')) ? (
                                    unitbkl[2] = upla = (upla + 1) % readerCount;
                                ) :
                                ((ui_jmouse_cap === 0) && (zzch === 'down')) ? (
                                    unitbkl[2] = upla = (upla + 8) % readerCount;
                                ) :
                                ((ui_jmouse_cap === 0) && (zzch === 'left'))? (
                                    unitbkl[2] = upla = (upla + readerCount - 1) % readerCount;
                                ) :
                                ((ui_jmouse_cap === 0) && (zzch === 'up')) ? (
                                    unitbkl[2] = upla = (upla + readerCount - 8) % readerCount;
                                );
                            ) :
                            (zzent === 2) ? (
                                gmem[WUAdd+RCB_ClipDup] = updClipNumber(gmem[WUAdd+RCB_ClipDup], zzch, 1012);
                            ) :
                            (zzent === 4) ? (
                                padHPVals[0] = gmem[WUAdd+RCB_Channels_cnfDup] = updHPSel(zzch, gmem[WUAdd+RCB_Channels_cnfDup]);
                            );
                        );

                        (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                            (zzmcl === 0) ? (
                                unitbkl[0] = (unitbkl[0] + 1) % 4; // Change mode
                            ) :
                            (zzmcl === 1) ? (
                                unitbkl[2] = upla = (upla + 1) % readerCount;
                            ) :
                            (zzmcl === 2) ? (
                                // update the clip entry
                                // 32 is 'ctrl' key, 8 is 'shift' key
                                key = (zzmmd & cmdCap) ? (
                                        (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                    ) : (
                                        (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                    );
                                gmem[WUAdd+RCB_ClipDup] = updClipNumber(gmem[WUAdd+RCB_ClipDup], - key, 1012);
                            ) :
                            (zzmcl === 4) ? (
                                key = (zzmmd & cmdCap) ? (
                                        (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                    ) : (
                                        (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                    );
                                padHPVals[0] = gmem[WUAdd+RCB_Channels_cnfDup] = updHPSel(- key, gmem[WUAdd+RCB_Channels_cnfDup]);
                            ) :
                            (zzmcl === 5) ? (
                                xx = control_jmenu(bplSLMenu);
                                ((xx >= bplCopy) && (xx <= bplCopyLast)) ? (
                                    // update one block from another
                                    s = (xx - bplCopy) >> 2; d = (xx - bplCopy) & 3;
                                    (s <= 3) ? (d += 4;) ;
                                    // Execute "copy"
                                    memcpy(bplMenuAddrs[d],bplMenuAddrs[s],BCtrlInfoSize);
                                ) :
                                (xx === bplRestartPlay) ? (
                                    gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                    gmem[WUAdd+RCB_Kmd] = KmdPlay;
                                ) :
                                (xx === bplRestartLoop) ? (
                                    gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                    gmem[WUAdd+RCB_Kmd] = KmdLoop;
                                ) :
                                (xx === bplNewPlay) ? (
                                    gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                    gmem[WUAdd+RCB_ClipNb] = gmem[WUAdd+RCB_ClipDup];
                                    gmem[WUAdd+RCB_Kmd] = KmdPlay;
                                ) :
                                (xx === bplNewLoop) ? (
                                    gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                    gmem[WUAdd+RCB_ClipNb] = gmem[WUAdd+RCB_ClipDup];
                                    gmem[WUAdd+RCB_Kmd] = KmdLoop;
                                ) :
                                (xx === bplStop) ? (
                                    gmem[WUAdd+RCB_Kmd] = KmdStop;
                                ) :
                                (xx === bplLock) ? (
                                    // SchedAddTask(5, 3, upla, -1, 0, 0, 0);
                                    gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                ) :
                                (xx === bplDuplicate) ? (
                                    z = findPlayer();
                                    ((z >= UGAddr)) ? (
                                        gmem[WUAdd+RCB_Cl_Flgs] |= 1;
                                        // Copy our entry in the new one
                                        ix =0; loop(RCB_Saved_Size,
                                            gmem[z+ix] = gmem[WUAdd+ix];
                                            ix += 1;
                                        );
                                        // arm the command
                                        gmem[z+RCB_Kmd] = gmem[WUAdd+cbLKmd];
                                    );
                                ) :
                                (xx === bplHPConf) ? (
                                    SMAddr = dSMAddr;
                                    GPlUnit = WUAdd;
                                    dSMAddr[idx_Sm_HPSet1] = gmem[WUAdd+RCB_Channels_cnfDup];
                                    HPInstall();
                                    gmem[WUAdd+RCB_Kmd] = gmem[WUAdd+cbLKmd]; // rearm
                                ) :
                                (xx === bplCopyLast+1) ? (
                                    unitbkl[Bpl_CCSlCnt] = 0;
                                ) :
                                (xx === bplCopyLast+2) ? (
                                    unitbkl[Bpl_CCSlCnt] = 1;
                                );

                            );
                        );
                        (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                            (zzmcl === 0) ? (
                                unitbkl[0] = (unitbkl[0] - 1 + 4) % 4; // Change mode
                            ) :
                            (zzmcl === 1) ? (
                                unitbkl[2] = upla = (upla + readerCount - 1) % readerCount;
                            ) :
                            (zzmcl === 2) ? (
                                key = (zzmmd & cmdCap) ? (
                                        (zzmmd & 8) ? 'pgup' : '?'; // -1000 / -10
                                    ) : (
                                        (zzmmd & 8) ? 'up' : 'b';  // -100 / -1
                                    );
                                gmem[WUAdd+RCB_ClipDup] = updClipNumber(gmem[WUAdd+RCB_ClipDup], - key, 1012);
                            ) :
                            (zzmcl === 4) ? (
                                key = (zzmmd & cmdCap) ? (
                                        (zzmmd & 8) ? 'pgup' : '?'; // -1000 / -10
                                    ) : (
                                        (zzmmd & 8) ? 'up' : 'b';  // -100 / -1
                                    );
                                padHPVals[0] = gmem[WUAdd+RCB_Channels_cnfDup] = updHPSel(- key, gmem[WUAdd+RCB_Channels_cnfDup]);
                            );
                        );
                        (zz & ui_jpad_ev_cmc) ? (  // center mouse clic
                            padHPVals[0] = gmem[WUAdd+RCB_Channels_cnfDup];
                        );
                    );
                // ui_pop();
            ui_pop();

            ui_split_top(h2);
                k = Bpl_Sh1;

                ui_new_column(1/4);
                    loop (SGenKmind,
                        showGPValue(WUAdd, unitbkl, k);
                        k += 1;
                    );

                ui_new_column();
                    loop (SGenKmind,
                        showGPValue(WUAdd, unitbkl, k);
                        k += 1;
                    );

                ui_new_column();
                    loop (SGenKmind,
                        showGPValue(WUAdd, unitbkl, k);
                        k += 1;
                    );

                ui_new_column();
                    loop (SGenKmind,
                        showGPValue(WUAdd, unitbkl, k);
                        k += 1;
                    );

                ui_pop();

                // update displayers
                //// Update next
                k = n = Bpl_Sh1;
                while (k < Bpl_ShLast) (
                    ((e = unitbkl[k]) != 0) ? (
                        unitbkl[n] = e; n += 1;
                    );
                    k += 1;
                );
                unitbkl[Bpl_ShCnt] = n + 1 - Bpl_Sh1;
                while (n < Bpl_ShLast) (
                    unitbkl[n] = 0; n += 1;
                );
                unitbkl[n] = -1;
            ui_pop();

            (h3 != 0) ? (
                ui_pad(0,6,0,0);
                (unitbkl[Bpl_CCSlCnt] === 0) ? (
                    k = Bpl_Sl1; loop (max(1,unitbkl[Bpl_SlCnt]),
                        (ui_height() >= ui_jd_slidh) ? (
                            ui_split_top(ui_jd_slidh);
                                showGControl(WUAdd, unitbkl, k);
                            ui_pop();
                        );
                        k += 1;
                    );
                ) : (
                    k = Bpl_Sl1; loop (max(1,ceil(unitbkl[Bpl_SlCnt]/2)),
                        (ui_height() >= ui_jd_slidh) ? (
                            ui_split_top(ui_jd_slidh);
                                ui_split_leftratio(0.5);
                                    showGControl(WUAdd, unitbkl, k);
                                ui_split_next();
                                    showGControl(WUAdd, unitbkl, k+1);
                                ui_pop();
                            ui_pop();
                        );
                        k += 2;
                    );
                );
                //// Update next
                k = n = Bpl_Sl1;
                while (k < Bpl_SlLast) (
                    ((e = unitbkl[k]) != 0) ? (
                        unitbkl[n] = e; n += 1;
                    );
                    k += 1;
                );
                unitbkl[Bpl_SlCnt] = n + 1 - Bpl_Sl1;
                while (n < Bpl_SlLast) (
                    unitbkl[n] = 0; n += 1;
                );
                unitbkl[n] = -1;
            );

        ui_pop();
    );
);




function
show_Sensors()
local (str, ij, h1, uix_jneed, uix_jmini, color, k, w, r, jmc, zz, zzch, zzent, zzmcl, zzmmd, zzmi)
(
    h1 = uix_jpadHeight(padSensNL); // height
    uix_jneed = uix_jmini = h1+ui_jd_ctgr;
    str = #;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockSensors);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_InSens_Name %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_InSens_Name, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockSensors]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
            w = ui_width();
            r = (w > 4* ui_MinSubColSize) ? 4 : (w > 3* ui_MinSubColSize) ? 3 : 2;

            ui_new_column(1/r);
                ui_pad(0,0,0,2);
                mSL_setStrArray(padSnsKLabs, padSnsKSiz);
                ij = 0; loop(padSnsKSiz,
                    padSnsKColrs[ij] = Col_Inactive;
                    ij += 1;
                );
                // Sensors active/not ?
                (SensorsActive) ? (
                    padSnsKLabs[0] = "Sensors on";
                    padSnsKColrs[0] = Col_Cmnds;
                ) : (
                    padSnsKLabs[0] = "Sensors off";
                    padSnsKColrs[0] = Col_Inactive;
                );
                // Sensors active/not ?
                (UplayControl) ? (
                    padSnsKLabs[1] = "Play Ctl. on";
                    padSnsKColrs[1] = Col_Cmnds;
                ) : (
                    padSnsKLabs[1] = "Play Ctl. off";
                    padSnsKColrs[1] = Col_Inactive;
                );
                padSnsKLabs[2] = "Unlock/Stop";
                padSnsKColrs[2] = Color_Light_Gray;
                // Show infos/errors
                (err_sdfr != 0) ? (
                    padSnsKColrs[4] = padSnsKColrs[5] = Col_Error;
                    sprintf(str, "%d:%d", err_sdfr, MIDISeqPtr);
                ) : (
                    padSnsKColrs[4] = Col_InfoC;
                    sprintf(str, "%d/%d", MIDISeqPtr, MIDISeqSiz);

                    (jmc & cmdCap) ? (
                        padSnsKLabs[5] = "Remove";
                        padSnsKColrs[5] = Color_Std_Orange;
                    ) :
                    (jmc & altCap) ? (
                        padSnsKLabs[5] = "Reset";
                        padSnsKColrs[5] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_InSens_Name) === 0) ? (
                            padSnsKLabs[5] = "Undefined";
                            padSnsKColrs[5] = Color_Dark_Gray;
                        ) : (
                            padSnsKLabs[5] = "Reload";
                            padSnsKColrs[5] = Col_InfoC;
                        );
                    );
                );
                padSnsKLabs[4] = str;

                sprintf(padSnsKLabs[3], "Mode: %d", MIDI_Sens_mode);
                padSnsKColrs[3] = MIDI_Colors_Base[MIDI_Sens_mode % MIDI_Colors_Siz];

                zz = control_jpad(padSnsKmd);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 35;
                    zzch = padSnsKmd[ui_jpad_lkey];
                    zzent = padSnsKmd[ui_jpad_entkey]-1;
                    zzmcl = padSnsKmd[ui_jpad_last]-1;
                    zzmmd = padSnsKmd[ui_jpad_lmods];

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            // flip sensors
                            SensorsActive ? (
                                // clearCmd();
                                doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
                                gmem[APCdispvalue] = 0;
                            );
                            SensorsActive = ! SensorsActive ;
                        ) :
                        (zzmcl === 2) ? (
                            releaseSensors(-1);
                            doActivePlayer(-1, KmdQStop, 0);
                        ) :
                        (zzmcl === 3) ? (
                            // switch MIDI mode
                            MIDI_Sens_mode = (MIDI_Sens_mode+1) % MIDI_States_siz;
                            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
                            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
                        ) :
                        (zzmcl === 5) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_InSens_Name, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std name
                                strcpy(#D_InSens_Name, #Def_InSens_Name);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_InSens_Name, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_Sensrs; // confirm we want to reload the file
                                );
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // flip sensors
                            SensorsActive = ! SensorsActive ;
                            releaseSensors(-1);
                        ) :
                        (zzmcl === 1) ? (
                            // flip play control
                            UplayControl = ! UplayControl ;
                        ) :
                        (zzmcl === 2) ? (
                            releaseSensors(-1);
                        ) :
                        (zzmcl === 3) ? (
                            // switch MIDI mode
                            MIDI_Sens_mode = (MIDI_Sens_mode-1+MIDI_States_siz) % MIDI_States_siz;
                            gmem[sensorsPadState] = MIDI_Sens_mode + 0x100;
                            AddDummyMIDIImm(EnterSens); // for executing "enter" operation
                        ) :
                        (zzmcl === 5) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_InSens_Name, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_InSens_Name, #Def_InSens_Name);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_Sensrs;
                                ); // reset read flag
                                flagSnsrRload = 1; // reload sensors Conf ASAP
                            );
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        ((zzch === '+') || (zzch === '_')) ? (
                            MIDI_Sens_mode += 1;
                        ) :
                        ((zzch === '-') || (zzch === '=')) ? (
                            MIDI_Sens_mode += MIDI_States_siz - 1;
                        ) :
                        ((zzch >= '0') && (zzch <= '9')) ? (
                            MIDI_Sens_mode = (MIDI_Sens_mode * 10) + zzch - '0';
                        ) :
                        (
                            Keyed = zzch;
                        );
                        MIDI_Sens_mode = MIDI_Sens_mode % MIDI_States_siz;
                    );
                    ui_GFXdoNow |= 1;
                    gmem[APCdispvalue] = MIDI_Sens_mode;
                );

            ui_new_column();
                ui_pad(0,0,0,2);
                mSL_setStrArray(padSensLabs, padSensSiz);

                color = MIDI_Colors_Set[MIDI_Sens_mode];

                ij = 0; loop(padSensSiz,
                    sprintf(padSensLabs[ij], "%d", ij+1);
                    padSensInhib[ij] ? (
                        padSensColrs[ij] = Col_Inhibit;
                    ) : (
                        k = 0|min(ui_j_UnixTime - MIDIDates[ij], InSensColorSize-1);
                        padSensColrs[ij] = color[k] ;
                    );
                    ij += 1;
                );

                zz = control_jpad(padSensrs);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 34;
                    zzch = padSensrs[ui_jpad_lkey];
                    zzent = padSensrs[ui_jpad_entkey]-1;
                    zzmcl = padSensrs[ui_jpad_last]-1;
                    zzmmd = padSensrs[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        ((zzmcl >= 0) && (zzmcl <= 8) && (padSensInhib[zzmcl] === 0))? (
                            //Enter a "sensor"
                            MIDI_msg1 = 0x90; // Note ON
                            MIDI_msg2 = zzmcl + 1; // SensMIDIIn expects notes from 1 to N
                            MIDI_msg3 = 0x40;
                            MIDI_msgTim = time_precise() + timeD;
                            SensMIDIIn();
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        ((zzmcl >= 0) && (zzmcl <= 8)) ? (
                            padSensInhib[zzmcl] = ! padSensInhib[zzmcl];
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        ((zzch === '2') || (zzch === '3')) ? setSensorSize(zzch) :
                        (Keyed = zzch;); // keep the char
                    );
                );

            (r > 2) ? (
                ui_new_column();
                ui_show("MIDI mode", MIDI_Sens_mode, "%d");
                ui_show("Last In", zzmcl, "%d");
                ui_show("Last Kom", GlKom, "%d");
            );

            (r > 3) ? (
                ui_new_column();
                ui_show("Ptr:", MIDIIdx, "%d");
            );

            ui_pop();



            do_ModuleKeySave();
        ui_pop();
    );

);


/*
   Display a log/trace
*/
function
show_SysLog(blnb, box)
local (h1, h3, disps, mini, avail, uix_jneed, uix_jmini, ptr, nc, as, fl, flg, zzmi, xx, ig, u_ch, siz, dep, had, thgh)
(
    disps = box[4]; mini = 2;
    h1 = uix_jBoxHeight(mini);
    h3 = uix_jBoxHeight(disps);
    // (box[6] <= 0) ? box[6] = ui_jd_tboxs;
    uix_jneed = h3 + ui_jd_delta2 + ui_jd_ctgr;
    uix_jmini = max(h1 + ui_jd_ctgr, ui_jd_min_block);
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            keepBlockInfos(blnb);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blnb]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
            ui_align(0,0);
            as = box[2]; // array size
            fl = box[1]; // first line
            xx = control_jmenu(menu_uix_jlog);
            (xx > 0) ? (
                (xx === 1) ? (
                    box[5] = 1;
                ) :
                (xx === 2) ? (
                    box[5] = 2;
                ) :
                (xx === 3) ? (
                    box[5] = 3;
                ) :
                (xx === 4) ? (
                    box[5] = 4;
                ) :
                (xx === 5) ? (
                    box[6] = min(20, box[6]+1);
                ) :
                (xx === 6) ? (
                    box[6] = max(0, box[6]-1);
                ) :
                (xx === 7) ? (
                    mSL_log(box, "");
                ) :
                (xx === 8) ? (
                    ig = 0; loop(as,
                        strcpy(fl + ig, ""); ig += 1;
                    );
                );
            );

            (zzmi) ? (
                u_ch = do_GenericKeyRead();
                (u_ch != 0) ? (
                    // sprintf(#gfxu, "Keyed: '%c'", u_ch);
                    // mSL_log(SysLogBox, #gfxu);
                    (FlagsTbVals[Flgs_GFXTrcs] & 1) ? (
                        sprintf(#sq, "***Key  @  %d  %d  %d [%02x+%02x -> '%c']", mouse_x, mouse_y, mouse_cap, mouse_cap, u_ch, u_ch);
                        mSL_log(SysLogBox, #sq);
                    );
                    ui_key_next();
                    Keyed = 0;
                );
                ((u_ch === ' ') || (u_ch ===  0x0d)) ? (mSL_log(box, " ");) :
                (u_ch === 'm') ? (box[6] = min(20, box[6]+1);) :
                (u_ch === 'l') ? (box[6] = max(0, box[6]-1);) :
                (u_ch === 'z') ? (box[7] = 0;) :
                (u_ch === 'k') ? (box[7] = max(0, box[7]-1);) :
                (u_ch === 'j') ? (box[7] = (box[7]+1) % box[2];) :
                (u_ch === 't') ? (nowTime(); mSL_log(SysLogBox, #nowis);) :
                (u_ch === 'v') ? (ShowConfig();) :
                (u_ch === 'up') ? (box[7] = max(0, box[7]-10);) :
                (u_ch === 'down') ? (box[7] = (box[7]+10) % box[2];) :
                ((ui_jmouse_cap === 0) && (u_ch === 'left')) ? (box[7] = 0;) :
                ((ui_jmouse_cap === 0) && (u_ch === 'rght')) ? (box[7] = (box[7]+100) % box[2];) :
                (u_ch === '1') ? (box[5] = 1;) :
                (u_ch === '2') ? (box[5] = 2;) :
                (u_ch === '3') ? (box[5] = 3;) :
                (u_ch === '4') ? (box[5] = 4;) :
                (u_ch === 'p') ? (sysout(SysLogBox);) :
                (Keyed = u_ch;);  // u_ch has not been used
            );
            nc = max(1, min(4, 0|box[5])); // number of columns to show

            ui_jshow_color = ui_jcolor_text;
            siz = box[2];
            dep = siz - 1; had = box[6];
            ptr = (box[3] + dep + 16*siz - box[7]) % siz; // last inserted line
            loop (nc,
                (nc != 0) ? ui_new_column(1/nc) : ui_new_column();
                nc = 0;
                ui_pad(3,0);ui_align(0, 0.5);
                ui_pcolor(ui_jshow_color);
                flg = 1;
                while (flg) (
                    /*
                    ui_jd_tboxh = had + ui_wraptext_height(#txt);
                    #txt = fl + ptr; // line to print
                    twdt = ui_text_width(#txt);
                    (twdt < wdth) ? (
                        (ui_height() >= ui_jd_tboxh) ? (
                            // put the string
                            uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                ui_pcolor(ui_jshow_color);
                                ui_wraptext(#txt);
                            ui_pop();
                            ptr = (ptr + dep) % siz;
                        ) : (
                            flg = 0;
                        );
                    ) : (
                    */
                    // Mono or Multi-line text
                    #txt = fl + ptr; // line to print
                    (strlen(#txt) === 0) ? #txt = " ";
                    thgh = ui_wraptext_height(#txt) + had;
                    (ui_height() >= thgh) ? (
                        // put the string
                        ui_split_top(thgh);
                            // ui_pcolor(ui_jshow_color);
                            ui_wraptext(#txt);
                        ui_pop();
                        ptr = (ptr + dep) % siz;
                    ) : (
                        flg = 0;
                    );
                    /*
                    lg = strlen(#txt);
                    k = max(1,ceil(lg / maxl));
                    (flg = (av = av - k) >= 0) ? (
                        (k === 1) ? (
                            // put the string
                            uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                ui_pcolor(ui_jshow_color);
                                ui_wraptext(#txt);
                            ui_pop();
                        ) : (
                            off = 0; sz = maxl;
                            while (k > 0) (
                                // cut the string in a few parts
                                strcpy_substr(#txt1,#txt, off, sz);
                                // put the string
                                uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                    // ui_pad(0,1,0,0);
                                    ui_pcolor(ui_jshow_color);
                                    ui_wraptext(#txt1);
                                ui_pop();
                                k -=1; off += maxl; sz = min(maxl, lg); lg -= sz;
                            );
                        );
                        ptr = (ptr + dep) % siz;
                    );
                    */
                );
            );
            ui_pop();


        ui_pop();
    );
);


resetTimeOut = 0;
//====== MAIN INFO MODULE ======
function
show_Main_Infos()
local(uix_jneed, uix_jmini, h1, h2, v, w, r, jmc, zzmi)
(
    // We need space for some text boxes and a group name
    h1 = uix_jBoxHeight(1);
    h2 = uix_jBoxHeight(10)+3;
    uix_jneed = h1 + ui_jd_delta2 + h2 + ui_jd_ctgr;
    uix_jmini = max(h1 + h1 + ui_jd_ctgr, ui_jd_min_block);

    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockMainInfos);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                ((jmc === 0x01) && (resetTimeOut < tUnix)) ? (
                    // reset error display
                    GvErr ? (
                        GvErr = 0;
                    ) :
                    err_sys ? (
                        err_sys = 0;
                    );
                    resetTimeOut = tUnix + 15;
                );
            );
            control_group(blockDispNames[blockDispInverts[blockMainInfos]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
            w = ui_width();
            r = (w > 4* ui_MinSubColSize) ? 4 : (w > 3* ui_MinSubColSize) ? 3 : 2;

            ui_align(0,0);

            ui_split_top(h1);
                ui_new_column(1);
                    ui_show(#GMversion);
                ui_pop();
            ui_pop();

            ui_pad(0, ui_jd_delta2, 0, 0);

            ui_new_column(1/r);

                // ui_jshow_color = Color_Chartreuse_Yellow;
                ui_show(#started);
                ui_show(#nowis);
                ui_show("Up time", edTime(tUnix - tStart));
                ui_show("G Volume", gmem[commonGlobalVolume], "%.4f");


                ui_show("Gfx Refresh", ui_GFXReason, "%d");
                ui_show("Gfx Count", ui_GFXCount, "%d");

                ui_show("Mem unused", SharedHighMemorySize, "%d w");
                ui_show("Init 2", tInit2, "%d s");

                ui_show("Last Action", last_op, "%d");
                ui_show("Gfx doN", ui_XGdNCnt, "%d");
                ui_show("Gfx Int", ui_XGIntCnt, "%d");
                /*
                ui_show(0);
                ui_show("MIDI -4", zm4, "%d");

                ui_show("KOM -4", kom4, "%d");
                ui_show("M_r1", zerr1, "%.3f");
                */
            ui_new_column();

                err_sys ? (
                    kerr = err_sys;
                    ui_jshow_color = ui_jcolor_error;
                );
                ui_show("ERROR", kerr, "%04d");
                GvErr ? (
                    gerr = GvErr;
                    ui_jshow_color = ui_jcolor_error;
                );
                sprintf(#str, "%04d | %d | %d", gerr, GvErrP1, GvErrP2);
                ui_show("Play Err", #str);

                v = gmem[versionFReader];
                sprintf(#str, "%d.%d.%d", (v >> 16), (v >> 8) & 0xff, v & 0xff);
                ui_show("File reader", #str);
                sprintf(#str, "%d.%d.%d", 0|(presetVersionCurrent >> 16),
                            (presetVersionCurrent >> 8) & 0xff, presetVersionCurrent & 0xff);
                ui_show("Presets", #str);
                ui_show("GMem avail", 8388608 - gMemFree, "%d w");
                ui_show("Partials", BKDEcnt, "%d");

                ui_show("Sample Rate", srate/1000+0.0001, "%.1f kHz");
                ui_show("Block Size", sysSamplesBlock, "%d");
                ui_show("Block Delay", Curr_Block_Max_Delay * 1000, "%.2f ms");
                ui_show("Serial Count", serial_counter, "%d");


                // ui_show("Gfx Usr", ui_XUsrCnt, "%d");
                // parShow(0);
                // ui_show("Init 1", tInit1, "%d s");
                //
                /*
                ui_show("MIDI mode", MIDI_Sens_mode, "%d");
                ui_show("MIDI -7", zm7, "%d");
                ui_show("MIDI -3", zm3, "%d");

                ui_show("KOM -3", kom3, "%d");
                ui_show("M_r2", zerr2, "%.3f");
                */
            (r > 2) ? (
                ui_new_column();

                ui_show("Playing", gmem[comPlCnt], "%d");
                ui_show("Played", GClipSeq, "%d");
                ui_show("Playtime/m.", 100*statmin, "%d %%");
                // ui_show("");
                ui_show("Players", BPlc, "%d");
                ui_show("Loopers", BLpc, "%d");

                ui_show("Allowed", playAllow, "%d");
                ui_show("Stopped", stopped, "%d");
                ui_show("Protected", protected, "%d");
                ui_show("Loading", FlagsTbVals[Flgs_TblUpd], "%04X");
                ui_show("Ld. Ready", FlagsTbVals[Flgs_ConfLd], "%04X");

                ui_show("Time2", timeFlag2Cnt, "%d");

                /*
                ui_show("allow", playAllow, "%d");
                ui_show("URingPtr", URingPtr, "%d");
                ui_show("MIDI Count", MIDI_Received, "%d");
                ui_show("MIDI Kmd", MIDI_msg1, "%02x");

                ui_show("MIDI p1", MIDI_msg2, "%02x");

                ui_show("MIDI p2", MIDI_msg3, "%02x");

                ui_show("MIDI Offset", Minp, "%d");
                // Compute an acceptable midi offset
                u2 = MIDI_msgTim - floor(MIDI_msgTim);
                u1 = MIDI_msgTim % 60;
                ui_show("MIDI date", u1+u2, "%.3f");
                ui_show("MIDI -6", zm6, "%d");
                ui_show("MIDI -2", zm2, "%d");

                ui_show("KOM -2", kom2, "%d");
                ui_show("M_CC", AAAAAA_cc, "%d");
                */
            );
            (r > 3) ? (
                ui_new_column();

                ui_show("Play State", sysPlayState, "%d");
                ui_show("Play Position", sysPlayPosition, "%.2f s");
                ui_show("Sys. Tempo", sysTempo, "%.1f bpm");
                ui_show("Beat Position", sysBeatPosition, "%.2f");

                ui_show("Bl. mean dur", ubMeanT * 1000, "%.4f ms");
                ui_show("Bl. max. dur", ubXmax * 1000, "%.4f ms");
                ui_show("Bl. CPU %", ubXdur * 100 / blStatSiz, "%.3f %%");

                ui_show("gfx mean dur", gbXdur * 1000 / blStatSiz, "%.4f ms");

                ui_show("gfx max. dur", gbXmax * 1000, "%.4f ms");
                ui_show("gfx CPU %", gbCPU * 100 / 60, "%.3f %%");
                /*
                ui_show("MIDI -5", zm5, "%d");
                ui_show("MIDI -1", zm1, "%d");

                ui_show("KOM -1", kom1, "%d");
                ui_show("MFlag", AAAAAA_flg, "%d");
                */
            );
            ui_pop();

        ui_pop();
    );
);

//====== PLAY MODES ======

function showPModesDef(ent, h2)
local(TT, co)
(
    ui_split_top(h2);
        ui_pad(0,ui_jd_padTBox1,2,ui_jd_padTBox1);
        TT = PMTab + PMEsize * (0|max(0, min(PMEcnt-1, ent)));
        ui_align(0, 0);
        ((ent < 0) || (ent >= PMEcnt) || (TT[idx_Pm_Kmd] === Undef)) ? (
            ui_new_column(1);
            ui_show("Play mode undefined.");
            ui_pop();
        ) : (
            w = ui_width();
            split_leftratio = 0.55; // appropriate for this
            r = (w > 4* ui_MinSubColSize) ? 4 : (w > 3* ui_MinSubColSize) ? 3 : 2;
            ui_new_column(1/r);
                ui_show("PM. num", mSL_edit_value(0, TT[idx_Pm_PmdN], "%d"), "%s");
                co = TT[idx_Pm_Kmd];
                ui_show("Command", (co==KmdPlay) ? "Play" :
                                (co==KmdLoop) ? "Loop" :
                                mSL_edit_value(0, co, "other %d"));
                ui_show("Vol. min", mSL_edit_value(0, TT[idx_Pm_PVol1], "%.1f dB"), "%s");
                ui_show("Vol. max", mSL_edit_value(0, TT[idx_Pm_PVol2], "%.1f dB"), "%s");
                ui_show("Duration min", mSL_edit_value(0, TT[idx_Pm_PDur1], "%.2f s"), "%s");
                ui_show("Duration max", mSL_edit_value(0, TT[idx_Pm_PDur2], "%.2f s"), "%s");
                ui_show("Grain min", mSL_edit_value(0, TT[idx_Pm_Gsize1], "%.3f s"), "%s");
                ui_show("Grain max", mSL_edit_value(0, TT[idx_Pm_Gsize2], "%.3f s"), "%s");
                ui_show("Grain type", mSL_edit_value(0, TT[idx_Pm_GPFdTy], "%d"), "%s");
            ui_new_column();
                ui_show("Speed min", mSL_edit_value(0, TT[idx_Pm_Speed1], "%.3f"), "%s");
                ui_show("Speed max", mSL_edit_value(0, TT[idx_Pm_Speed2], "%.3f"), "%s");
                ui_show("Direction", mSL_edit_value(0, TT[idx_Pm_Speed3], "%.3f"), "%s");
                ui_show("Depth min", mSL_edit_value(0, TT[idx_Pm_GDepth1], "%d"), "%s");
                ui_show("Depth max", mSL_edit_value(0, TT[idx_Pm_GDepth2], "%d"), "%s");
                ui_show("Flags 1", mSL_edit_value(0, TT[idx_Pm_FLM1], "%05X"), "%s");
                ui_show("Flags 2", mSL_edit_value(0, TT[idx_Pm_FLM2], "%05X"), "%s");
                ui_show("Chan. min", mSL_edit_value(0, TT[idx_Pm_ChCnt1], "%d"), "%s");
                ui_show("Chan. max", mSL_edit_value(0, TT[idx_Pm_ChCnt2], "%d"), "%s");
            (r > 2) ? (
            ui_new_column();
                ui_show("Pl.Fd.In min", mSL_edit_value(0, TT[idx_Pm_PFdIn1], "%.1f ms"), "%s");
                ui_show("Pl.Fd.In max", mSL_edit_value(0, TT[idx_Pm_PFdIn2], "%.1f ms"), "%s");
                ui_show("Pl.Fd.Out min", mSL_edit_value(0, TT[idx_Pm_PFdOut1], "%.1f ms"), "%s");
                ui_show("Pl.Fd.Out max", mSL_edit_value(0, TT[idx_Pm_PFdOut2], "%.1f ms"), "%s");
                ui_show("Gr.Fd.In min", mSL_edit_value(0, TT[idx_Pm_GPFdIn1], "%.1f ms"), "%s");
                ui_show("Gr.Fd.In max", mSL_edit_value(0, TT[idx_Pm_GPFdIn2], "%.1f ms"), "%s");
                ui_show("Gr.Fd.Out min", mSL_edit_value(0, TT[idx_Pm_GPFdOut1], "%.1f ms"), "%s");
                ui_show("Gr.Fd.Out max", mSL_edit_value(0, TT[idx_Pm_GPFdOut2], "%.1f ms"), "%s");
                ui_show("Spec.Mods", mSL_edit_value(0, TT[idx_Pm_Spec0], "%5X"), "%s");
            );
            (r > 3) ? (
            ui_new_column();
                ui_show("FX1. min", mSL_edit_value(0, TT[idx_Pm_FX1], "%.1f dB"), "%s");
                ui_show("FX1. max", mSL_edit_value(0, TT[idx_Pm_FX1+1], "%.1f dB"), "%s");
                ui_show("FX2. min", mSL_edit_value(0, TT[idx_Pm_FX2], "%.1f dB"), "%s");
                ui_show("FX2. max", mSL_edit_value(0, TT[idx_Pm_FX2+1], "%.1f dB"), "%s");
                ui_show("Spec. 1", mSL_edit_value(0, TT[idx_Pm_Spec0+1], "%5X"), "%s");
                ui_show("Spec. 2", mSL_edit_value(0, TT[idx_Pm_Spec0+2], "%5X"), "%s");
                ui_show("Spec. 3", mSL_edit_value(0, TT[idx_Pm_Spec0+3], "%5X"), "%s");
                ui_show("Spec. 4", mSL_edit_value(0, TT[idx_Pm_Spec0+4], "%5X"), "%s");
                ui_show("Spec. 5", mSL_edit_value(0, TT[idx_Pm_Spec0+5], "%5X"), "%s");
            );
            ui_pop();
        );
    ui_pop();
);




function
show_Play_Modes()
local(str, str2, zz, zzch, zzent, zzmcl, zzc, zzmi, zzmmd, key, jmc, xx, co, TT, h1, h2, uix_jneed, uix_jmini)
(
    // Height of the inner graphics items
    h1 = uix_jpadHeight(1); // first block height : one pad
    h2 = uix_jBoxHeight(9) + 3; // second block height
    uix_jneed = h1+h2+ui_jd_ctgr; // needed size
    uix_jmini = max(h1+ui_jd_ctgr, ui_jd_min_block); // min. size

    (ui_height() > uix_jmini) ? (
        ui_split_top(uix_jneed);
            // define the actual module rectangle
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();  // true if we are "in the module"
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockPlayModes);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_PlayModes %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_PlayModes, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockPlayModes]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            str = #;
            str2 = #;
            ui_split_top(h1);
                // first graphic item : the pad
                (err_fplm != 0) ? (
                    padPMColrs[PMpVer] = padPMColrs[PMpMsg] = padPMColrs[PMpRld] = Col_Error;
                    sprintf(str, "%d:%d", err_fplm, PEntry);
                    str2 = "";
                ) : (
                    padPMColrs[PMpVer] = padPMColrs[PMpMsg] = padPMColrs[PMpRld] = Col_InfoC;
                    sprintf(str, "%d/%d", PMDEcnt, PMEcnt);
                    sprintf(str2, "v-%d.%d.%d", 0|(PlayModesVersion/10000), (PlayModesVersion/100)%100, PlayModesVersion%100);
                    (jmc & cmdCap) ? (
                        padPMLabs[PMpRld] = "Remove";
                        padPMColrs[PMpRld] = Color_Std_Orange;
                    ) :
                    (jmc & altCap) ? (
                        padPMLabs[PMpRld] = "Reset";
                        padPMColrs[PMpRld] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_PlayModes) === 0) ? (
                            padPMLabs[PMpRld] = "Undefined";
                            padPMColrs[PMpRld] = Color_Dark_Gray;
                        ) : (
                            padPMLabs[PMpRld] = "Reload";
                            padPMColrs[PMpRld] = Col_InfoC;
                        );
                    );
                );
                padPMLabs[PMpMsg] = str;
                padPMLabs[PMpVer] = str2;


                ui_pad(2,2,6,2);


                zz = control_jpad(padPModes);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 16;
                    PMnumLastM = lastTime; PMnumUnchkd  = 1;
                    zzch = padPModes[ui_jpad_lkey];
                    zzent = padPModes[ui_jpad_entkey]-1;
                    zzmcl = padPModes[ui_jpad_last]-1;
                    zzc = padPMCells[zzmcl];
                    zzmmd = padPModes[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char, in case we don't use it
                        // AAAA_Key30 = Keyed;
                        AAAA_lastKeyedT = zzch;
                        padPMVals[0] = updPlMdNumber(padPMVals[0], Keyed);
                        // AAAA_Key31 = Keyed;
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            // update the play mode number entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                ) : (
                                    (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                );
                            // 32 is 'ctrl' key, 8 is 'shift' key
                            padPMVals[0] = updPlMdNumber(padPMVals[0], - key);
                        ) :
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_PlayModes, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std name
                                strcpy(#D_PlayModes, #Def_PlayModes);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_PlayModes, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_PlMd; // confirm we want to reload the file
                                );
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 4) ? 'pgup' : '?'; // -1000 / -10
                                ) : (
                                    (zzmmd & 4) ? 'up' : 'b';  // -100 / -1
                                );
                            // 32 is 'ctrl' key, 8 is 'cmd' key
                            padPMVals[0] = updPlMdNumber(padPMVals[0], - key);
                        ) :
                        // Reload clicked ?
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_PlayModes, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_PlayModes, #Def_PlayModes);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_PlMd;
                                ); // reset read flag
                                flagPMRload = 1; // reload playmode Conf ASAP
                            );
                        );
                    );
                );
            ui_pop();  // Pad closing

            showPModesDef(padPMVals[0], h2);

            // AAAA_Key32 = Keyed;
            // Local interaction in the module ?
            (zzmi && do_ModuleKeyboard()) ? (
                PMnumLastM = lastTime; PMnumUnchkd  = 1; ui_GFXdoNow |= 1; ui_GFXReason = 17;
                // AAAA_Key33 = Keyed;
                padPMVals[0] = updPlMdNumber(padPMVals[0], Keyed);
                // AAAA_Key34 = Keyed;
            );

            do_ModuleKeySave() ? (
                // AAAA_Key35 = Keyed;
                AAAA_Key36 = KeyedT;
            );

        ui_pop();  // Module closing
    );
);

//====== CLIPS ======
function doClRdKeyboard() local(k)
(
    k = (KeyedT > 0) ? KeyedT : ui_key();
    KeyedT = Keyed = 0;
    (k > 0) ? (
        AAAA_lastKeyedT = k;
        ((k=='+') || (k=='=') || (k==':')
             || (k==',') || (k=='?') || (k==';') || (k=='.')
             || (k=='/') || (k=='n') || (k=='p') || (k=='b') || (k=='%')
             || ((k >= '0') && (k <= '9'))
        ) || (
            ((ui_jmouse_cap === 0) && ((k=='rght') || (k=='left') || (k=='up') || (k=='down')
            || (k=='pgup') || (k=='pgdn') || (k=='home')))
        ) ? (
            KeyedT = k;
            ui_key_next();
        );
    );
);

function
show_Clips_Settings()
local(str, str2, uix_jneed, uix_jmini, key, jmc, val, zz, zzch, zzent, zzmcl, zzmi, h1,
    cc, cq, cx, cn, ux, sr, ff, xx, dm, ds, zzmmd)
(
    uix_jmini = uix_jneed = (h1 = uix_jpadHeight(1)) + ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();  // true if we are "in the module"
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockClipsSettings);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_ClipsModifiers %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_ClipsModifiers, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockClipsSettings]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);


            str = #; str2 = #;

            ui_split_top(h1);
                cn = padVlcVals[0];  // clip number

                (err_fclp != 0) ? (
                    padVlclrs[VlpVer] = padVlclrs[VlpMsg] = padVlclrs[VlpRld] = Col_Error;
                    sprintf(str, "%d:%d", err_fclp, ClLEntry);
                    str2 = "";
                ) : (
                    padVlclrs[VlpVer] = padVlclrs[VlpMsg] = padVlclrs[VlpRld] = Col_InfoC;
                    sprintf(str, "%d/%d", ClMEntries, clTSize);
                    sprintf(str2, "v-%d.%d.%d", 0|(ClipConfigVersion/10000), (ClipConfigVersion/100)%100, ClipConfigVersion%100);
                    (jmc & cmdCap) ? (
                        padVllabs[VlpRld] = "Remove";
                        padVlclrs[VlpRld] = Color_Std_Orange;
                    ) :
                    (jmc & altCap) ? (
                        padVllabs[VlpRld] = "Reset";
                        padVlclrs[VlpRld] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_ClipsModifiers) === 0) ? (
                            padVllabs[VlpRld] = "Undefined";
                            padVlclrs[VlpRld] = Color_Dark_Gray;
                        ) : (
                            padVllabs[VlpRld] = "Reload";
                            padVlclrs[VlpRld] = Col_InfoC;
                        );
                    );
                );
                padVllabs[VlpMsg] = str;
                padVllabs[VlpVer] = str2;

                // Show associated volume
                sprintf(#strZ1, "%.1f dB", (gmem[clClVolumes+cn] & clVolumeMask) - clVolumeBias);
                padVllabs[1] = #strZ1;

                // Show other infos
                ((cx = gmem[clClInfos+cn]) != 0) ? (
                    ux = gmem[clClSizes+cn]; // sample count
                    sr = max(1000,cx >> 12); // record freq.
                    cc = max(1, cx & 0xff); // chan. count
                    ff = (cx >> 8) & 0xf; // file format
                    ds = ux/sr/cc; dm = 0|(ds/60); ds = ds-dm*60;
                    sprintf(#strZ2, "%d ch, %d'%04.1f\"",  (cx & 0xff), dm, ds);
                    sprintf(#strZ3, "%s @ %.1f kHz", fFormats[ff], (sr)/1000+GvEps);
                    padVlclrs[2] = Col_ClVCl; padVllabs[2] = #strZ2;
                    padVlclrs[3] = Col_ClVCl; padVllabs[3] = #strZ3;
                ) : (
                    padVlclrs[2] = padVlclrs[3] = Col_Inactive;
                    padVllabs[2] = padVllabs[3] = "";
                );

                // Directory entry
                padVllabs[4] = #D_clDirectory;
                padVlclrs[4] = Col_InfoC;


                ui_pad(0,2,4,2);
                zz = control_jpad(padVlClips);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 18;
                    VlCnumLastM = lastTime; VlCnumUnchkd  = 1;
                    zzch = padVlClips[ui_jpad_lkey];
                    zzent = padVlClips[ui_jpad_entkey]-1;
                    zzmcl = padVlClips[ui_jpad_last]-1;
                    zzmmd = padVlClips[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char, in case we don't use it
                        AAAA_lastKeyedT = zzch;
                        padVlcVals[0] = updClipNumber(padVlcVals[0], zzch, 1003);
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                ) : (
                                    (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                );
                            // 32 is 'ctrl' key, 8 is 'shift' key
                            padVlcVals[0] = updClipNumber(padVlcVals[0], - key, 1004);
                        ) :
                        (zzmcl === 4) ? (
                            // Chose a new directory
                            xx = control_jmenu(menu_Config);
                            (xx != 0) ? (
                                strcpy(#s2, configs_tab[xx-1]);
                                strcmp(#D_clDirectory, #s2) ? (
                                    setClDirectory(#s2, 0);
                                );
                            );
                        ) :
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_ClipsModifiers, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_ClipsModifiers, #Def_ClipsModifiers);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_ClipsModifiers, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_Clips; // confirm we want to reload the file
                                );
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = ((zzmmd & cmdCap) ? (
                                    (zzmmd & 4) ? 'pgup' : '?'; // -1000 / -10
                                ) : (
                                    (zzmmd & 4) ? 'up' : 'b';  // -100 / -1
                                ));
                            padVlcVals[0] = updClipNumber(padVlcVals[0], - key, 1005);
                        ) :
                        // Reload clicked ?
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_ClipsModifiers, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_ClipsModifiers, #Def_HPConfigs);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_Clips;
                                ); // reset read flag
                                flagClVRload = 1; // reload clips Conf ASAP
                            )
                        );
                    );
                );
            ui_pop(); // Pad closing

            // Local interaction in the module ?
            (zzmi && do_ModuleKeyboard()) ? (
                VlCnumLastM = lastTime; VlCnumUnchkd  = 1; ui_GFXdoNow |= 1; ui_GFXReason = 19;
                padVlcVals[0] = updClipNumber(padVlcVals[0], Keyed, 1006);
            );
            do_ModuleKeySave();

        ui_pop(); // Module closing
    );
);


function
show_Clips_Selection()
local(iw, ix, iy, iz, str, uv, uw, ux, zz, zzmi, m, mcc, r, cc, sr, ds, dm, curB, emin, emax, cnt, rerun,
      nli, lx, cx, nc, jmc, ent, ezer, epos, eneg, elcnt, ehcnt, h1, h2, h3, j4, xcell, uix_jneed)
(
    // restHfact = 0.88;
    restHfact = 1;
    h1 = ui_jd_slidh * 2;
    h2 = restHfact * uix_jpadHeight(1);
    h3 = restHfact * uix_jpadHeight(10);
    j4 = 4;

    uix_jneed = h1 + h2 + ui_jd_ctgr + h3 + ui_jd_vtext * 3 + j4;

    // Update banks count as a remanent task
    (cBk2 < clNBanks) ? (
        updClBk(cBk2); cBk2 = cBk2 + 1;
    );


    (ui_height() > uix_jneed) ? (

        str = #; str2 = #;
        ui_split_top(uix_jneed); // sliders + ctrl group
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockClips);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );

            control_group(blockDispNames[blockDispInverts[blockClips]]);
            ui_pad(0,ui_cg_pad_top+2,0,ui_cg_pad_bottom);



            //
            //  SLIDERS
            //
            ui_split_top(h1);
                ui_pad(8,0,0,0);
                r = slider_ctl("%d000", slBankset, 0, 9, 0, 1, 1);
                r ? (slBankset = uix_jsl_val; rerun = 1;);
                r = slider_ctl("0%d00", slGroupNum, 0, 9, 0, 1, 1);
                r ? (slGroupNum = uix_jsl_val; rerun = 1; );
            ui_pop();

            // Update the displayed pad
            (cBk3 != slGroupNum) ? updClBk(slBankset * clBSSize + slGroupNum);
            updClBk(slBankset * clBSSize + cBk3);
            cBk3 = (cBk3 + 1) % clBSCount;



            //
            //  HEADER
            //
            ui_split_top(h2);
                ui_pad(2,3);
                iz = 0; loop(clBSCount,
                    uv = slBankset * clBSSize + iz;
                    padBclrs[iz] =
                        ((aclnBused[uv] === 0) && (aclnBunav[uv] === 0)) ? (Color_Goldenrod) :
                        (aclnBunav[uv] === clInBank) ? (Col_Inactive) :
                        ((aclnBunav[uv] > 0) && (aclnBused[uv] === 0)) ? (Color_Grayish_Brown) :
                        (aclnBused[uv] + aclnBunav[uv] < clInBank) ? (Color_Dark_Olive_Green) :
                        (Color_Olive_Green);
                    padBvals[iz] = aclnBplyd[uv];
                    padBCells[iz] &= ui_jpad_ct_UNselec;
                    iz += 1;
                );
                padBCells[slGroupNum] |= ui_jpad_ct_selec;
                zz = control_jpad(padbanks);
                (zz > 0) ? (
                    rerun = 1;
                    ui_GFXdoNow |= 1; ui_GFXReason = 20;

                    ((zz & ui_jpad_ev_lmc) || (zz & ui_jpad_ev_rmc)) ? (
                        ((jmc === 0x20) || (jmc === 0x30)) ? ( // clic and ctrl / ctrl + alt
                            // Start smooth rechecking the clips
                            ClCheckCnt = 0;
                            ClCheckFlag = 1;
                            (jmc & 0x10) ? ClCheckForce = 1; // hard reset
                        ) : (
                            slGroupNum = padbanks[ui_jpad_last]-1;
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        zzch = padbanks[ui_jpad_lkey];
                        ((ui_jmouse_cap === 0) && (zzch === 'rght')) ? (
                            slGroupNum = (slGroupNum + 1) % 10;
                        ) :
                        ((ui_jmouse_cap === 0) && (zzch === 'left')) ? (
                            slGroupNum = (slGroupNum + 10 - 1) % 10;
                        ) :
                        ((ui_jmouse_cap === 0) && (zzch === 'down')) ? (
                            slBankset = (slBankset + 10 - 1) % 10;
                        ) :
                        ((ui_jmouse_cap === 0) && (zzch === 'up')) ? (
                            slBankset = (slBankset + 1) % 10;
                        ) :
                        ((ui_jmouse_cap === 0) && (zzch === 'home')) ? (
                            slBankset = slGroupNum = 0;
                        ) :
                        (
                            Keyed = zzch;
                        );
                    );
                );
            ui_pop();



            //
            //  CLIPS
            //
            ui_split_top(h3);
                (zzicl = ui_hover()) ? (
                    ui_push();
                        ui_color(Col_SubFrame);
                        ui_border();
                    ui_pop();
                    // locate mouse in pad.
                    nli = padclips[ui_jpad_nli]; nco = padclips[ui_jpad_nco];
                    lx = 0 | (nli * (mouse_y - ui_top_retina()) / (ui_bottom_retina() - ui_top_retina()));
                    cx = 0 | (nco * (mouse_x - ui_left_retina()) / (ui_right_retina() - ui_left_retina()));
                    nc = cx + nco * lx; clpn = curB + nc;
                );
                ui_pad(2,2);
                curB = ((slBankset) * clBSSize + slGroupNum)*clInBank;
                // Are we dropping some sound files ?
                (dpa && zzicl && ui_dropped_in()) ? (
                    nA = mSL_Str_Tmp();
                    (TRC & 0x1000) ? (
                        sprintf(#s, "** Dropped in clip ** %d %d %d %d %d -> %04d", nli, nco, lx, cx, nc, clpn);
                        mSL_log(SysLogBox, #s);
                        sprintf(nA, "%04d  =>  (%s)", clpn, afs);
                        mSL_log(SysLogBox, nA);
                    );
                    installClipSet(clpn, afs);
                    doneDroppedFile();
                );
                // Update cells display
                iz = 0; loop(clInBank,
                    padVCells[iz] &= ui_jpad_ct_UNselec;
                    iz += 1;
                );
                ((cellAlt >= curB) && (cellAlt < curB+clInBank)) ? (
                    padVCells[cellAlt-curB] |= ui_jpad_ct_selec;
                );
                ezer = epos = eneg = 0;
                emin = 9999999; emax = 0; ecnt = 0;
                ix = 0; loop(clInBank,
                    uv = gmem[clInfStart+ix+curB];
                    uw = gmem[clClInfos+ix+curB];
                    ((uv === 0) && (uw === 0)) ? (
                        ezer += 1;
                    ) :
                    ((uv > 0) || ((uv === 0) && (uw != 0))) ? (
                        epos +=1; uv > emax ? emax = uv; uv < emin ? emin = uv;
                        ecnt += uv;
                    ) : (
                        eneg += 1;
                    );
                    ix +=1;
                );
                elcnt = ehcnt = 0;
                ix = 0; loop(clInBank,
                    ic = ix+curB;
                    uv = gmem[clInfStart+ic];
                    uw = gmem[clClInfos+ic];
                    (uv < -10000) ? uv = -999;
                    showSel = ((jmc & 0x04) ? 1 : showClNbrs);
                    (showSel === 0) ? (
                        padValues[ix] = (uv>=0) ? uv : -uv;
                        padclips[ui_jpad_fmts] = "%d";
                    ) :
                    (showSel === 1) ? (
                        padValues[ix] = ic; // clip #
                        padclips[ui_jpad_fmts] = "%d";
                    ) :
                    (showSel === 2) ? (
                        padValues[ix] = (gmem[clClVolumes+ic] & clVolumeMask) - clVolumeBias;
                        padclips[ui_jpad_fmts] = "%.1f dB";
                    ) : (
                        padValues[ix] = gmem[clClDurations+ic];
                        padclips[ui_jpad_fmts] = "%.3f s";
                    );
                    padXclrs[ix] = ((uv === 0) && (uw === 0)) ? Color_Goldenrod :
                                ((uv === 0) && (uw > 0)) ? Color_Clear_Yellow :
                                (uv === 1) ? (((emin === 1) ? elcnt +=1 ;);
                                        ((emax === 1) ? ehcnt += 1;); Color_Bright_Green) :
                                (uv === emin) ? (elcnt +=1; Color_Yellow_Green) :
                                (uv === emax) ? (ehcnt +=1; Color_Dark_Olive_Green) :
                                (uv > 1) ? Color_Olive_Green :
                                (uv === -404) ? Col_Inactive :
                                (uv === -499) ? Color_Dark_Orange : Color_Deep_Red;
                    ix +=1;
                );
                emin === 9999999 ? emin = 0;
                emin === emax ? ehcnt = elcnt;

                zz = control_jpad(padclips);
                (zz > 0) ? (
                    rerun = 1;
                    ui_GFXdoNow |= 1; ui_GFXReason = 21;
                    ent = padclips[ui_jpad_last]-1; // cell # in [0 .. 99]
                    xcell = curB+ent; // clip # in [0 .. 9999]

                    (zz & ui_jpad_ev_key) ? (
                        zzch = padclips[ui_jpad_lkey];
                        mcc = ui_jmouse_cap & 0xF8; // remove cmd key
                        (FlagsTbVals[Flgs_GFXTrcs] & 1) ? (
                            sprintf(#sq, "***Key  @  %d  %d  %d %d [%02x+%02x -> '%c']", mouse_x, mouse_y, xcell, mouse_cap, mcc, zzch, zzch);
                            mSL_log(SysLogBox, #sq);
                        );
                        (mcc === 0) ? (  // no modifiers
                            ((zzch === ' ') || (zzch === 0x0d)) ? ( // play
                                GvPlayCl3 = cellAlt;
                                Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay;
                            ) :
                            ((zzch >= '0') && (zzch <= '9')) ? ( // play clip with partial 1
                                PlayRelay = zzch & 0xf; PlayCell = cellAlt;
                            ) :
                            ((zzch >= 'a') && (zzch <= 'z')) ? ( // play clip with partial 10 - N
                                PlayRelay = zzch - 'a' + 10; PlayCell = cellAlt;
                            ) :
                            (zzch === ':') ? ( // clear the entry
                                gmem[clInfStart+xcell] = 0;
                                gmem[clClInfos+xcell] = 0;
                                gmem[clClDurations+xcell] = 0;
                            ) :
                            (zzch === '!') ? ( // remove the alias and clear the entry
                                gmem[clClAlias+xcell] = 0;
                                gmem[clInfStart+xcell] = 0;
                                gmem[clClInfos+xcell] = 0;
                                gmem[clClDurations+xcell] = 0;
                            ) :
                            (zzch === '=') ? (  // (un)validate the entry
                                (gmem[clInfStart+xcell] < -10000) ? (
                                    gmem[clInfStart+xcell] += 20000;
                                ) : (
                                    gmem[clInfStart+xcell] -= 20000;
                                );
                            ) :
                            (zzch === 'rght') ? (
                                    cellAlt = curB + (cellAlt + 1) % 100;
                            ) :
                            (zzch === 'left') ? (
                                    cellAlt = curB + (cellAlt + 100 - 1) % 100;
                            ) :
                            (zzch === 'down') ? (
                                    cellAlt = curB + (cellAlt + 10) % 100;
                            ) :
                            (zzch === 'up') ? (
                                    cellAlt = curB + (cellAlt + 100 - 10) % 100;
                            ) :
                            (zzch === 'home') ? (
                                cellAlt = curB;
                            ) :
                            (
                                Keyed = zzch;
                            );
                        ) :
                        (mcc === 8) ? (  // Shift
                            ((zzch === ' ') || (zzch === 0x0d)) ? ( // play
                                GvPlayCl3 = cellAlt;
                                Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay;
                            ) :
                            ((zzch >= '0') && (zzch <= '9')) ? ( // play clip with partial 0 - 9
                                PlayRelay = zzch & 0xf; PlayCell = cellAlt;
                            ) :
                            ((zzch >= 'A') && (zzch <= 'Z')) ? ( // play clip with partial 10 - N
                                PlayRelay = zzch - 'A' + 36; PlayCell = cellAlt;
                            ) :
                            (zzch === '/') ? ( // clear all entries
                                i = curB; loop(100,
                                    gmem[clInfStart+i] = 0;
                                    gmem[clClInfos+i] = 0;
                                    gmem[clClDurations+i] = 0;
                                    i += 1;
                                );
                            ) :
                            (zzch === '+') ? ( // validate/unvalidate all entries
                                (gmem[clInfStart+xcell] < -10000) ? (
                                    i = curB; loop(100,
                                        (gmem[clInfStart+i] < -10000) ? gmem[clInfStart+i] += 20000;
                                        i += 1;
                                    );
                                ) : (
                                    i = curB; loop(100,
                                        (gmem[clInfStart+i] > -10000) ? gmem[clInfStart+i] -= 20000;
                                        i += 1;
                                    );
                                );
                            ) :
                            (zzch === 'down') ? (
                                showClNbrs = (showClNbrs - 1 + showStates) % showStates ; // shift down
                            ) :
                            (zzch === 'up') ? (
                                showClNbrs = (showClNbrs + 1) % showStates ; // shift up
                            ) :
                            (
                                Keyed = zzch;
                            );
                        ) :
                        (mcc === 0x10) ? (  //alt key
                            (zzch === 0xA0) ? ( // alt+' '  => play
                                GvPlayCl3 = cellAlt;
                                Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay;
                            ) :
                            (zzch === 'rght') ? (
                                    slGroupNum = (slGroupNum + 1) % 10;
                            ) :
                            (zzch === 'left') ? (
                                    slGroupNum = (slGroupNum + 10 - 1) % 10;
                            ) :
                            (zzch === 'down') ? (
                                    slBankset = (slBankset + 10 - 1) % 10;
                            ) :
                            (zzch === 'up') ? (
                                    slBankset = (slBankset + 1) % 10;
                            ) :
                            (
                                Keyed = zzch;
                            );
                        ) :
                        (mcc === 0x20) ? (  // control
                            (zzch === 0x03) ? ( // ^C
                                i = curB; loop(100,
                                    gmem[clInfStart+i] = 0;
                                    gmem[clClInfos+i] = 0;
                                    gmem[clClDurations+i] = 0;
                                    i += 1;
                                );
                            ) :
                            (zzch === 0x1A) ? (
                                (gmem[clInfStart+xcell] < -10000) ? (
                                    i = curB; loop(100,
                                        (gmem[clInfStart+i] < -10000) ? gmem[clInfStart+i] += 20000;
                                        i += 1;
                                    );
                                ) : (
                                    i = curB; loop(100,
                                        (gmem[clInfStart+i] > -10000) ? gmem[clInfStart+i] -= 20000;
                                        i += 1;
                                    );
                                );
                            ) :
                            (
                                Keyed = zzch;
                            );
                        ) :
                        (
                            Keyed = zzch;
                        );
                    );

                    (zz & ui_jpad_ev_cclk) ? (
                        m = padclips[ui_jpad_lmods] & 0x3F;
                        (zz & ui_jpad_ev_lmc) ? (m |= 1);
                        (zz & ui_jpad_ev_rmc) ? (m |= 2);
                        (zz & ui_jpad_ev_cmc) ? (m |= 0x40);
                        AAm = m ; AAcellAlt = cellAlt;
                        //============================  Left click
                        (m === 0x01) ? (  // clic gauche : play
                            GvPlayCl3 = cellAlt = xcell;
                            Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay;
                        ) :
                        (m === 0x11) ? ( // clic gauche + alt
                            // Stop others, play
                            parSet(p_GvAutoMd, 0); // Auto Play off
                            doActivePlayer(-1, KmdQStop, 0); // stop all players
                            GvPlayCl3 = cellAlt = xcell; // select this clip
                            Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay;
                        ) :
                        (m === 0x21) ? ( // clic gauche + ctrl
                            // Lock and play
                            GvPlayCl3 = cellAlt = xcell;
                            Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay | FLdoForceLock;
                        ) :
                        (m === 0x31) ? ( // clic gauche + ctrl + alt
                            // Stop others, play and lock
                            parSet(p_GvAutoMd, 0); // Auto Play off
                            doActivePlayer(-1, KmdQStop, 0); // stop all players
                            GvPlayCl3 = cellAlt = xcell;
                            Kbtp = cmdClMdBase | GvPlayClipClicked | FLdoForcePlay | FLdoForceLock;
                        ) :
                        (m === 0x09) ? (  // clic gauche + shift : reset this entry
                            gmem[clInfStart+xcell] = 0;
                            gmem[clClInfos+xcell] = 0;
                            gmem[clClDurations+xcell] = 0;
                            cellAlt = xcell; // note the position
                        ) :
                        (m === 0x19) ? ( // clic gauche + alt + shift
                            // reset all enties between here and previously selected one
                            ((cellAlt >= 0) && (cellAlt < clTSize)) ? (
                                ix = max(0, min(clTSize-1, min(cellAlt, xcell)));
                                iy = max(0, min(clTSize-1, max(cellAlt, xcell)));
                                loop (iy-ix+1,
                                    gmem[clInfStart+ix] = 0;
                                    gmem[clClInfos+ix] = 0;
                                    gmem[clClDurations+ix] = 0;
                                    ix += 1;
                                );
                            );
                            cellAlt = xcell; // note the position
                        ) :
                        (m === 0x29) ? ( // clic gauche + ctrl + shift
                            //  validate/unvalidate the entry
                            (gmem[clInfStart+xcell] < -10000) ? (
                                gmem[clInfStart+xcell] += 20000;
                            ) : (
                                gmem[clInfStart+xcell] -= 20000;
                            );
                            cellAlt = xcell; // keep position
                        ) :
                        //============================ Right click
                        (m === 0x02) ? (  // click droit : select
                            cellAlt = xcell; //
                        ) :
                        ((m === 0x6)) ? ( // clic droit  + Cmd
                            ((cellAlt >= 0) && (cellAlt < clTSize)) ? (
                                iw = gmem[clInfStart+cellAlt] < -10000;
                                ix = max(0, min(clTSize-1, min(cellAlt, xcell)));
                                iy = max(0, min(clTSize-1, max(cellAlt, xcell)));
                                loop (iy-ix+1,
                                    iw ? ((gmem[clInfStart+ix] >= -10000) ? gmem[clInfStart+ix] -= 20000)
                                    : ((gmem[clInfStart+ix] < -10000) ? gmem[clInfStart+ix] += 20000);
                                    ix += 1;
                                );
                            );
                            cellAlt = xcell; // note the position
                        ) :
                        (m === 0x12) ? ( // clic droit + alt
                            ((cellAlt >= 0) && (cellAlt < clTSize)) ? (
                                ix = max(0, min(clTSize-1, min(cellAlt, xcell)));
                                iy = max(0, min(clTSize-1, max(cellAlt, xcell)));
                                loop (iy-ix+1,
                                    (gmem[clInfStart+ix] < -10000) ? (
                                        gmem[clInfStart+ix] = 0;
                                        gmem[clClInfos+ix] = 0;
                                    ) ;
                                    ix += 1;
                                );
                            );
                            cellAlt = xcell; // note the position
                        ) :
                        (m === 0x2A) ? ( // clic droit + ctrl + shift
                            /*
                            ix = 0;           // Reexplore this set
                            loop(clInBank,
                                (gmem[clInfStart+curB+ix] < 0) ?
                                    gmem[clInfStart+curB+ix] = 0;
                                    gmem[clClDurations+curB+ix] = 0;
                                ix += 1;
                            );
                            cellAlt = -1;
                            */
                            ((cellAlt >= 0) && (cellAlt < clTSize)) ? (
                                ix = max(0, min(clTSize-1, min(cellAlt, xcell)));
                                iy = max(0, min(clTSize-1, max(cellAlt, xcell)));
                                loop (iy-ix+1,
                                    gmem[clClAlias+ix] = 0;
                                    gmem[clInfStart+ix] = 0;
                                    gmem[clClInfos+ix] = 0;
                                    gmem[clClVolumes+ix] = clVolumeBias;
                                    gmem[clClDurations+ix] = 0;
                                    checkClip(ix, 0);
                                    ix += 1;
                                );
                            );
                            cellAlt = xcell; // note the position
                        ) :
                        (m === 0x3A) ? ( // clic droit + ctrl + alt + shift
                            // restart exploring
                            // AKA hard rechecking the clips
                            ix =0; loop (clTSize,
                                gmem[clInfStart+ix] = 0;
                                gmem[clClInfos+ix] = 0;
                                gmem[clClDurations+ix] = 0;
                                ix += 1;
                            );
                            cellAlt = -1;
                            ClCheckCnt = 0;
                            ClCheckForce = 1;
                            ClCheckFlag = 1;
                        ) :
                        //============================
                        (
                            cellAlt = xcell;
                        );
                    );
                );
            ui_pop();


            ui_split_top(ui_jd_vtext);
                ui_align(0, 0.5); ui_pad(8,0,0,0);
                (ezer === clInBank) ? (
                    sprintf(str, "Range [%d - %d]:  unused", slGroupNum*100+slBankset*1000,
                        slGroupNum*100+slBankset*1000+99);
                ) :
                (eneg === clInBank) ? (
                    sprintf(str, "Range [%d - %d]:  empty",  slGroupNum*100+slBankset*1000,
                        slGroupNum*100+slBankset*1000+99);
                ) :
                (ezer === 0) ? (
                    sprintf(str, "Range [%d - %d]:  used: %d, played: %d, range:[%d(%d) _ %d(%d)], unavailable: %d",
                        slGroupNum*100+slBankset*1000, slGroupNum*100+slBankset*1000+99,
                        epos, ecnt, emin, elcnt, emax, ehcnt, eneg);
                ) : (
                    sprintf(str, "Range [%d - %d]:  used: %d, played: %d, range:[%d(%d) _ %d(%d)], unavailable: %d, unchecked: %d",
                        slGroupNum*100+slBankset*1000, slGroupNum*100+slBankset*1000+99,
                        epos, ecnt, emin, elcnt, emax, ehcnt, eneg, ezer);
                );
                sprintf(str2,"[%d%%]  %s", 100*ClCheckCnt/clTSize, str);
                ui_text(str2);
            ui_pop();


            ui_split_top(ui_jd_vtext);
                ui_align(0, 0.5); ui_pad(8,0,0,0);
                cnt = clipHigh - clipLow + 1;
                updClSel(clipLow, cnt);
                ezer = cnt - clipsUnAvail - clipsUsed;
                (ezer === cnt) ? (
                    sprintf(str, "[All clips]:  range unused");
                ) :
                (clipsUnAvail === cnt) ? (
                    sprintf(str, "[All clips]:  range empty");
                ) :
                (ezer === 0) ? (
                    sprintf(str, "[All clips]:  used: %d, played: %d, unavailable: %d",
                        clipsUsed, clipsPlyd, clipsUnAvail);
                ) : (
                    sprintf(str, "[All clips]:  used: %d, played: %d, unavailable: %d, unplayed: %d",
                        clipsUsed, clipsPlyd, clipsUnAvail, ezer);
                );
                ui_text(str);
            ui_pop();


            ui_split_top(ui_jd_vtext+10);
                ui_align(0, 0.5); ui_pad(8,0,0,0);
                uv = gmem[clInfStart+clpn];
                uw = gmem[clClInfos+clpn];
                ux = gmem[clClSizes+clpn];
                ds = (uw >> 8) & 0xf;
                getClipName(clpn, aclnAliases);
                (strlen(#fname) != 0) ? (
                    //sprintf(str, "%04d:%s", clpn, #fname);
                    strcpy(str, #fname);
                ) : (
                    sprintf(str, #D_clNameFormat, clpn, fFormats[ds]);
                );
                iz = #;
                ((uv === 0) && (uw === 0)) ? (
                    sprintf(iz, "%s : Status unknown.", str);
                ) :
                ((uv > 0) || ((uv === 0) && (uw > 0)) || (uv === -499)) ? (
                    cc = max(1, uw & 0xff); // chan. count
                    sr = max(1000, uw >> 12); ds = ux/sr/cc; dm = 0|(ds/60); ds = ds-dm*60;
                    sprintf(iz, "%s : %d ch., %.1f kHz, %d'%06.3f\"%s",
                                str, cc, (sr)/1000+GvEps, dm, ds,
                                ((uv === -499) ? "  [499]" : ""));
                ) : (
                    sprintf(iz, "%s : Error %d", str, min(999,-uv));
                );
                // ui_text(iz);ui_wraptext(iz);
                sprintf(str, "%04d:%s", clpn, iz);
                ui_wraptext(str);
            ui_pop();

            (zzmi && do_ModuleKeyboard()) ? (
                ui_GFXdoNow |= 1;
                ui_GFXReason = 22;
            );
            do_ModuleKeySave();

        ui_pop();
    );
    rerun ? (
        cBk2 = rerun = 0;
        ClCheckView = 1; cBk4 = 0;
        ui_GFXdoNow |= 1;
    );
);// show_Clips_Selection()


//====== UNITS ======
function
select_unit(Un)
(
    // save previous values
    currclipPrev = currclip;
    currpmodePrev = currpmode;
    currclcntPrev = currclcnt;
    currUAddPrev = currUAdd;
    currDParsPrev = currDPars;
    currplayerPrev = currplayer;
    // set new values
    currclip = gmem[Un+RCB_ClipNb];
    currpmode = gmem[Un+RCB_cbCKmd];
    currclcnt = gmem[Un+cbClipCnt];
    currUAdd = Un;
    currDPars = - (Un + RCB_DynPar);
    currplayer = -gmem[Un+cbPlIdt] -1;
    currUpdt = 1; // some change has occured
    //
    lstPlyCell = Un;
    lstPlyDate = tUnix;
);

function
show_Units(flg)
local(pid, uid, pid, cidUn, str, tmp, ty, c, r, w, rd, st, Un, zz, zzmd, zzch, h1, uix_jneed, uix_jmini, pm, cn, wg, jmc, zzmi)
(
    str = #;
    h1 = uix_jpadHeight(padcNl_Units) ;
    uix_jmini = uix_jneed = h1 + ui_jd_ctgr;

    (ui_height() > uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();  // true if we are "in the module"
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockUnits);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockUnits]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            ui_split_top(h1);
                ui_pad(0,2,2,2);
                mSL_setStrArray(padUlabs, uCnt);
                uid = 0; uAcnt = 0; loop (uCnt,
                    strcpy(padUlabs[uid], "");
                    padUclrs[uid] = padUAclrs[uid] = U0; padUNAddr[uid] = 0;
                    Un = UGAddr + UCBSize * uid;
                    ty = gmem[Un+cbType];
                    (ty != 0) ? uAcnt += 1;
                    uid+= 1;
                );
                pid = 0; uid = 0;
                (lmode) ? (
                    lsiz = SUTrASize;
                ) : (
                    lsiz = uCnt;
                );
                loop (lsiz,
                    lmode ? (
                        Un = SUTrAddr[uid];
                        (Un >= UGAddr) ? (
                            ty = gmem[Un+cbType];
                            st = gmem[Un+cbStat];
                        ) : (
                            ty = st = 0;
                        );
                    ) : (
                        Un = UGAddr + UCBSize * uid;
                        ty = gmem[Un+cbType];
                        st = gmem[Un+cbStat];
                    );
                    (ty === uPlayer) ? (
                        // str = pid + 2; // use string array at "0+2"
                        str = padUlabs[pid];
                        padUNAddr[pid] = Un; // keep unit addr.
                        padUclrs[pid] = U1_0;
                        pm = gmem[Un+RCB_cbCKmd]; // Last command
                        cn = gmem[Un+RCB_ClipNb];
                        // gmem[Un+cbPadUnitIdt] = pid; // keep associated PAD
                        qmode ? (
                            sprintf(str,"Clip:%04d", gmem[Un+RCB_ClipNb]);q
                        ) : (
                            lmode ? (
                                sprintf(str,"Track %d", gmem[Un+RCB_My_Track]);
                            ) : (
                                sprintf(str,"Player %d", pid+1);
                            );
                        );
                        (st === uSReady) ? (
                            0 ? sprintf(#dbg_trace4, "Ready pid:%d PlyC:%d", pid, lstPlyCell);
                            padUclrs[pid] = gmem[Un+RCB_Color]; //  U1_1 ;
                            padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                            (lstPlyCell === Un) ? (
                                (pm === KmdPlay) ? (
                                    sprintf(str, "Play:%04d", cn);
                                ) :
                                (pm === KmdLoop) ? (
                                    sprintf(str, "Loop:%04d", cn);
                                );
                                padUAclrs[pid] = padUclrs[pid] = Color_Light_Steel_Blue ;
                            );
                        ) :
                        // ((st === uSBusy) || (st === uSHalting) || (st === uSEditing) || (st === uSSaving)) ? (
                        (st & uSWorking) ? (
                            padUclrs[pid] = U1_2 ;
                            wg = gmem[Un+RCB_Cl_Flgs];
                            (wg & 1) ? (
                                padUCells[pid] |= ui_jpad_ct_selec;
                            ) : (
                                padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                            );
                            (pm === KmdPlay) ? (
                                sprintf(str, "Play:%04d", cn);
                                    padUclrs[pid] = (wg & 2) ? U4_8 : U4_0;
                                    padUAclrs[pid] = (wg & 2) ? U4_8 : U4_16;
                            ) :
                            (pm === KmdLoop) ? (
                                sprintf(str, "Loop:%04d", cn);
                                    padUclrs[pid] = (wg & 2) ? U5_4 : U5_0;
                                    padUAclrs[pid] = (wg & 2) ? U5_4 : U5_16;
                            ) :
                            // (((pm === KmdStop) || (pm === KmdQStop))) ? (
                            (st === uSHalting) ? (
                                sprintf(str, "Stop:%04d", cn);
                                padUclrs[pid] = padUAclrs[pid] = Color_Bronze;
                            ) :
                            (
                                sprintf(str, "Busy");
                            );
                            // Change color...
                            (st === uSEditing) ? (
                                sprintf(str, "Edit:%04d", cn);
                                padUAclrs[pid] = padUclrs[pid] = Color_Cerulean_Blue ;
                            ) :
                            (st === uSSaving) ? (
                                sprintf(str, "Save:%04d", cn);
                                padUAclrs[pid] = padUclrs[pid] = Color_Cornflower_Blue ;
                            );
                        ) :
                        (st === uSStarting) ? (
                            padUclrs[pid] = Color_Blue_Bell ;
                        ) :
                        (st === uSReserved) ? (
                            padUclrs[pid] = Color_Amethyst ;
                        ) :
                        (st === uSUnused) ? (
                            padUclrs[pid] = U1_0 ;
                            padUCells[pid] &= -1 ~ ui_jpad_ct_selec;
                        ) :
                        (st === uSSError) ? (
                            padUclrs[pid] = Color_Light_Reddish_Brown ;
                        ) :
                        (st === uSError) ? (
                            padUclrs[pid] = Color_Light_Reddish_Brown ;
                        ) :
                        (st === uSUnreachable) ? (
                            padUclrs[pid] = Color_Blue_Violet ;
                        );
                        // padUlabs[pid] = str;
                        pid += 1;
                    ) :
                    (flg && (ty != uPlayer) && (ty != 0)) ? (
                        padUNAddr[pid] = Un; // keep unit addr.
                        gmem[Un+cbPlIdt] = -2; // not a player
                        // gmem[Un+cbPadUnitIdt] = pid; // keep associated PAD
                        // Show also other units
                        (ty === uMainMixer) ? (
                            padUlabs[pid] = "Mixer"; padUclrs[pid] = U3;
                        ) :
                        (ty === uMIDI_In) ? (
                            padUlabs[pid] = "MIDI In"; padUclrs[pid] = U7;
                        ) :
                        (ty === uMIDI_Out) ? (
                            padUlabs[pid] = "MIDI Out"; padUclrs[pid] = U7;
                        ) :
                        (ty === uDetector) ? (
                            padUlabs[pid] = "Sm. Detect."; padUclrs[pid] = U4;
                        ) :
                        (ty === uCalibrator) ? (
                            padUlabs[pid] = "Callibr."; padUclrs[pid] = U5;
                        ) :
                        (ty === uTracer) ? (
                            padUlabs[pid] = "M. Tracer"; padUclrs[pid] = U6;
                        ) :
                        (ty === uSoundGen) ? (
                            padUlabs[pid] = "Generator"; padUclrs[pid] = U7;
                        ) :
                        (ty === uAPCmini_In) ? (
                            padUlabs[pid] = "APCmini In"; padUclrs[pid] = Color_Amethyst;
                        ) :
                        (ty === uAPCmini_Out) ? (
                            padUlabs[pid] = "APCmini Out"; padUclrs[pid] = Color_Peach_Yellow;
                        ) :
                        (ty === nanoPAD2_In) ? (
                            padUlabs[pid] = "nanoPAD2 In"; padUclrs[pid] = Color_Blaze_Orange;
                        ) :
                        (ty === nanoPAD2_Out) ? (
                            padUlabs[pid] = "nanoPAD2 Out"; padUclrs[pid] = Color_Bright_Turquoise;
                        ) :
                        (ty != 0) ? (
                            sprintf(#str, "Ty: %i", ty);
                            padUlabs[pid] = #str;
                            padUclrs[pid] = U8;
                        );
                        pid += 1;
                    );
                    uid += 1;
                );

                w = ui_width(); c = 8;
                (w < ui_jpad_cl_minWidth * padunits[ui_jpad_nco]) ? (
                    c = 0|(w/ui_jpad_cl_minWidth);
                );
                padcNl_Units = max(1, 0|((pid + c -1)/c));

                zz = control_jpad(padunits, padcNl_Units, c, 3);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 23;
                    uid = padunits[ui_jpad_last]-1;  // cell clicked
                    zzmd = padunits[ui_jpad_lmods];
                    cid = padunits[ui_jpad_entkey] - 1;  // char entered with mouse over this cell
                    Un = padUNAddr[uid]; // valid in all cases
                    st = gmem[Un+cbStat];

                    (zz & ui_jpad_ev_key) ? (
                        ((Un >= UGAddr) && (Un < UGAddrLast)) ? (
                            AAAAAAAA_rd = rd = gmem[Un+cbPlIdt];
                            AAAAAAAA_uzzch = zzch = padunits[ui_jpad_lkey];
                            (zzch === 'm') ? (
                                SchedAddTask(5, 6, rd, -1, 0, 0, 0); // mute/unmute current
                                gDispPlay = rd;
                            ) :
                            (zzch === 's') ? (
                                SchedAddTask(5, 5|ActFlg1, rd, -1, 0, 0, 0); // solo current
                                //padUCells[0] |= ui_jpad_ct_selec;
                                gDispPlay = rd; // gmem[Un+cbPlIdt];
                                BplayerA[2] = rd; //  display in gen A, edit
                                BplayerA[0] = BplEdit;
                                select_unit(Un); // and select this a "current unit"
                            ) :
                            (zzch === 'z') ? (
                                SchedAddTask(5, 1|ActFlg1, 3, -1, 0, 0, 0); // Lock & mute all
                            ) :
                            (zzch === 'u') ? (
                                SchedAddTask(5, 1, 1, -1, 0, 0, 0); // Lock & unmute all
                            ) :
                            (zzch === 'l') ? (
                                SchedAddTask(5, 1|ActFlg1, 1, -1, 0, 0, 0); // Lock & unmute all
                            ) :
                            (zzch === 'g') ? (
                                parSet(p_GvAutoMd, ! paramValues[p_GvAutoMd]); //  Toggle autoplay
                            ) :
                            (zzch === 'a') ? (
                                BplayerA[2] = rd; //  display in gen A, edit
                                BplayerA[0] = BplEdit;
                            ) :
                            (zzch === 'b') ? (
                                BplayerB[2] = rd; //  display in gen B
                                BplayerB[0] = BplEdit;
                            ) :
                            (zzch === 'c') ? (
                                BplayerC[2] = rd; //  display in gen C
                                BplayerC[0] = BplEdit;
                            ) :
                            (zzch === 'd') ? (
                                BplayerD[2] = rd; //  display in gen D
                                BplayerD[0] = BplEdit;
                            ) :
                            ((zzch === 'e') || (zzch === 'E')) ? (
                                gmem[Un+RCB_State_Changed] |= i_M_Rst;
                                gDispPlay = rd;
                                (zzch === 'E') ? ( // also Lock entry
                                    gmem[Un+RCB_Cl_Flgs] = 1;
                                    padUCells[uid] |= ui_jpad_ct_selec;
                                );
                                select_unit(Un);
                            ) :
                            (zzch === 'f') ? (
                                SchedAddTask(5, 8, -1, -1, 1, 0, 0); // full volume play
                            ) :
                            (zzch === 'h') ? (
                                SchedAddTask(5, 8, -1, -1, 0.20, 0, 0); // reduced volume play
                            ) :
                            (zzch === 'k') ? (
                                SchedAddTask(5, 7, rd, -1, 0, 0, 0); // kill player task
                            ) :
                            (zzch === 't') ? (
                                SchedAddTask(5, 3, rd, -1, 0, 0, 0); // toggle lock/unlock player
                                gDispPlay = rd;
                            ) :
                            (zzch === 'v') ? (
                                gDispPlay = rd;
                            ) :
                            (zzch === '!') ? (
                                SchedAddTask(5, 9, -1, -1, 2.5, 0, 0); // very fast volume transition,
                            ) :
                            (zzch === 'i') ? (
                                SchedAddTask(5, 9, -1, -1, 3.5, 0, 0); // fast volume transition,
                            ) :
                            (zzch === 'n') ? (
                                lmode = ! lmode ; // toggle player # / track #
                            ) :
                            (zzch === 'q') ? (
                                qmode = ! qmode ;  // show clip #
                            ) :
                            (zzch === 'o') ? (
                                SchedAddTask(5, 9, -1, -1, 5, 0, 0); // normal volume transition,
                            ) :
                            (zzch === 'p') ? (
                                SchedAddTask(5, 9, -1, -1, 8, 0, 0); // very slow volume transition,
                            ) :
                            (zzch === 'r') ? (
                                SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all
                                parSet(p_GvAutoMd, 1); // and restart auto play
                            ) :
                            (zzch === 'w') ? (
                                SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all
                            ) :
                            (zzch === 'j') ? (
                                Kbtp = cmdClMdBase + GvPlayTypGrLoop;
                            ) : (
                                Keyed = zzch; // keep the char
                            );
                            zzch = 0; // delete the char
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (
                        AAAAAAAA_zzmd = zzmd;
                        ((Un >= UGAddr) && (Un < UGAddrLast)) ? (
                            rd = gmem[Un+cbPlIdt];
                            (zzmd === 0x28) ? ( // CTRL + Shift + left
                                // UnLock all
                                SchedAddTask(5, 2, -1, -1, 0, 0, 0);
                            ) :
                            (zzmd === 0x20) ? ( // CTRL + left
                                // Lock all
                                SchedAddTask(5, 1|ActFlg1, 1, -1, -1, 0, 0);
                            ) :
                            (zzmd === 0x08) ? ( // Shift + left
                                // Unlock entry
                                SchedAddTask(5, 3, rd, -1, 0, 0, 0);
                                gDispPlay = rd;
                            ) :
                            (zzmd === 0x00) ? ( // left
                                (st & uSWorking) ? (
                                    // Lock entry
                                    SchedAddTask(5, 10, rd, -1, 0, 0, 0);
                                    gDispPlay = rd;
                                );
                                // In both cases, select unit
                                select_unit(Un);
                            );
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? ( // right mouse clic
                        ((Un >= UGAddr) && (Un < UGAddrLast)) ? (
                            rd = gmem[Un+cbPlIdt];
                            (zzmd === 0x20) ? ( // CTRL + right
                                (st & uSWorking) ? (
                                    // stop the player
                                    SchedAddTask(5, 7, rd, -1, 0, 0, 0);
                                ) : (
                                    // restartplaying
                                    gmem[Un+RCB_State_Changed] |= i_M_Rst;
                                    gDispPlay = rd;
                                    // also Lock entry
                                    gmem[Un+RCB_Cl_Flgs] = 1;
                                    padUCells[uid] |= ui_jpad_ct_selec;
                                    select_unit(Un);
                                );
                            ) :
                            (zzmd === 0x00) ? ( // right
                                (st & uSWorking) ? (
                                    // mute/unmute entry
                                    SchedAddTask(5, 6, rd, -1, 0, 0, 0);
                                    gDispPlay = rd;
                                ) : (
                                    // restartplaying
                                    gmem[Un+RCB_State_Changed] |= i_M_Rst;
                                    gDispPlay = rd;
                                );
                                select_unit(Un);
                            );
                        );
                    );

                    (zz & ui_jpad_ev_cmc) ? (  // center mouse clic
                        ((Un >= UGAddr) && (Un < UGAddrLast)) ? (
                            rd = gmem[Un+cbPlIdt];
                            SchedAddTask(5, 5|ActFlg1, rd, -1, 0, 0, 0); // solo current
                            gDispPlay = rd;
                            BplayerA[2] = rd; //  display in gen A, edit
                            BplayerA[0] = BplEdit;
                        );
                    );


                    // keep player id corresponding to this cell
                    /*
                    ((Un >= UGAddr) && (Un < UGAddrLast)) ? (
                        lstPlyCell = Un;
                        lstPlyDate = tUnix;
                    );
                    */
                    ui_GFXdoNow |= 1;


                    (zz & ui_jpad_ev_mov) ? (  // mouse hover
                        0 ? sprintf(#dbg_trace5, "mouse on %d", lstPlyCell);
                        // ui_GFXdoNow = 0;
                    );



                ) : (
                    (tUnix > lstPlyDate + 30) ? (
                        lstPlyCell = -1;
                    );
                );

            ui_pop();

            (zzmi && do_ModuleKeyboard()) ? (
                ui_GFXdoNow |= 1;
                ui_GFXReason = 24;
            );
            do_ModuleKeySave();

        ui_pop();
    );
);
//// pid ////

//====== HP CONFIGURATIONS ======



function
show_HP_Configuration()
local(str, str2, zz, zzch, zzent, zzmcl, zzmi, zzmmd, nhp, pcf, pcfsiz, ig, ih, jmc, cc, cq, h1, h2,
     uix_jneed, uix_jmini, Hty, cn, cp)
(
    h1 = uix_jpadHeight(1);
    h2 = uix_jpadHeight(padHPSNl);

    uix_jneed = h1+h2+ui_jd_ctgr; // needed size
    uix_jmini = max(h1+ui_jd_ctgr, ui_jd_min_block); // min. size
    Hty = 0;

    (ui_height() > uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();  // true if we are "in the module"
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockHPConfig);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_HPConfigs %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_HPConfigs, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockHPConfig]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            ui_split_top(h1);

                str = #; str2 = #;

                ui_pad(0,2,2,2);

                cn = padHPVals[0];
                ((cn > 0) && (cn < HPPSize)) ? (
                    cp = HPPTab[cn]; // pointer in HPATab
                    ((cp > HPATab) && (cp < HPPTab + HPASize)) ? (
                        (Hty = (cp[-1] < 0)) ? (
                            padHPColrs[0] = Color_Medium_Spring_Green; // Color_Blaze_Orange;
                        ) : (
                            padHPColrs[0] = Col_HPSel;
                        );
                    );
                );

                (err_fhpc != 0) ? (
                    padHPColrs[HPpVer] = padHPColrs[HPpMsg] = padHPColrs[HPpRld] = Col_Error;
                    sprintf(str, "%d:%d", err_fhpc, HPCurrCDef);
                    str2 = "";
                ) : (
                    padHPColrs[HPpVer] = padHPColrs[HPpMsg] = Col_InfoC;
                    sprintf(str, "%d ➤ %d", HPInstCnt, HPCntDef);
                    sprintf(str2, "v-%d.%d.%d", 0|(HPConfigVersion/10000), (HPConfigVersion/100)%100, HPConfigVersion%100);
                    (jmc & cmdCap) ? (
                        padHPLabs[HPpRld] = "Remove";
                        padHPColrs[HPpRld] = Color_Std_Orange;
                    ) :
                    (jmc & altCap) ? (
                        padHPLabs[HPpRld] = "Reset";
                        padHPColrs[HPpRld] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_HPConfigs) === 0) ? (
                            padHPLabs[HPpRld] = "Undefined";
                            padHPColrs[HPpRld] = Color_Dark_Gray;
                        ) : (
                            padHPLabs[HPpRld] = "Reload";
                            padHPColrs[HPpRld] = Col_InfoC;
                        );
                    );
                );
                padHPLabs[HPpMsg] = str;
                padHPLabs[HPpVer] = str2;

                zz = control_jpad(padHPModes);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 27;
                    zzch = padHPModes[ui_jpad_lkey];
                    zzent = padHPModes[ui_jpad_entkey]-1;
                    zzmcl = padHPModes[ui_jpad_last]-1;
                    zzmmd = padHPModes[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char
                        // Number changed ?
                        padHPVals[0] = updHPSel(zzch, padHPVals[0]);
                        AAAA_lastKeyedT = zzch;
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            padHPVals[0] = updHPSel( - buildKey(1, zzmmd), padHPVals[0]);
                        ) :
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_HPConfigs, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std name
                                strcpy(#D_HPConfigs, #Def_HPConfigs);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_HPConfigs, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_HPC; // confirm we want to reload the file
                                );
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            padHPVals[0] = updHPSel( - buildKey(-1, zzmmd), padHPVals[0]);
                        ) :
                        (zzmcl === 1) ? (
                            swtHPDispMode();
                        ) :
                        // Reload clicked ?
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_HPConfigs, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_HPConfigs, #Def_HPConfigs);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_HPC;
                                ); // reset read flag
                                flagHPCRload = 1; // reload HP Conf ASAP
                            );
                        );
                    );
                );
            ui_pop();

            ui_split_top(h2);
                ui_pad(0,2,2,2);
                cc = max(0, min(HPPSize-1, padHPVals[0]));
                pcf = HPPTab[cc];
                (pcf > 0) ? (
                    // we have a conf
                    pcfsiz = pcf[0];
                    ((HPDispMode === 0) || Hty ) ? (
                        // Display as sequence
                        ig = 0; loop (padHPSSiz,
                            padHPSCells[ig] = ui_jpad_ct_cclear;
                            padHPSColrs[ig] = Col_Inactive;
                            ig +=1;
                        );
                        ig = 1; ih = 0; loop(pcfsiz,
                            nhp = pcf[ig];
                            padHPSCells[ih] = 0;
                            padHPSColrs[ih] = Hty ? Col_HPSel :
                                (nhp <= HPlev0) ? HPCDown : (nhp <= HPlev1) ? HPCMidd : HPCUp;
                            padHPSVals[ih] = nhp;
                            ig +=1; ih += 1;
                        );
                    ) : (
                        // display as position
                        ig = 0; loop (padHPSSiz,
                            padHPSCells[ig] = 0;
                            padHPSColrs[ig] = Col_Inactive;
                            padHPSVals[ig] = ig+1;
                            ig +=1;
                        );
                        ig = 1; loop (pcfsiz,
                            nhp = pcf[ig];
                            ((Hty === 0) && (nhp > 0) && (nhp <= padHPSSiz)) ? (
                                padHPSCells[nhp-1] = 0;
                                padHPSColrs[nhp-1] = (nhp <= HPlev0) ? HPCDown : (nhp <= HPlev1) ? HPCMidd : HPCUp;
                                padHPSVals[nhp-1] = nhp;
                            );
                            ig += 1;
                        );
                    );
                ) : (
                    pcfsiz = 0;
                    ig = 0; loop (padHPSSiz,
                        padHPSCells[ig] = ui_jpad_ct_cclear;
                        padHPSColrs[ig] = Col_Inactive;
                        ig +=1;
                    );
                );
                (pcfsiz === 0) ? (
                    padHPCells[2] = 0;
                    padHPColrs[2] = Col_Inactive;
                ) : (
                    padHPCells[2] |= ui_jpad_ct_showval;
                    padHPVals[2] = pcfsiz; // default HP conf.
                    padHPColrs[2] = Col_InfoC;
                );

                zz = control_jpad(padHPSets);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 28;
                    (zz & ui_jpad_ev_cclk) ? (
                        zzmcl = padHPSets[ui_jpad_last];
                        padHPVals[0] = (0|(padHPVals[0]/100)) * 100 + zzmcl;
                    );
                    (zz & ui_jpad_ev_key) ? (
                        zzch = padHPSets[ui_jpad_lkey];
                        Keyed = zzch; // keep the char
                        padHPVals[0] = updHPSel(zzch, padHPVals[0]);
                        AAAA_lastKeyedT = zzch;
                    );
                );
            ui_pop();

            (zzmi && do_ModuleKeyboard()) ? (
                padHPVals[0] = updHPSel(Keyed, padHPVals[0]);
            );
            do_ModuleKeySave();

        ui_pop();
    );
);


//====== SPACE MODES ======
function doSpacesKeyboard() local (k)
(
    k = (KeyedT > 0) ? KeyedT : ui_key();
    KeyedT = 0;
    (k > 0) ? (         AAAA_lastKeyedT = k;
        ((k=='+') || (k=='=') || (k==':')
             || (k==',') || (k=='?') || (k==';') || (k=='.')
             || (k=='/') || (k=='n') || (k=='p') || (k=='b') || (k=='%')
             || ((k >= '0') && (k <= '9'))
        ) || (
            (ui_jmouse_cap === 0) && ((k=='rght') || (k=='left') || (k=='up') || (k=='down') ||
            (k=='pgup') || (k=='pgdn') || (k=='home'))
        ) ? (
            KeyedT = k;
            ui_key_next();
        );
    );
);


function showSpacesCurr(ent, h2) local(k, TT, w, r)
(
    ui_split_top(h2);  // Second block, 2 lines
        ui_pad(0,ui_jd_padTBox1,2,ui_jd_padTBox1);
        TT = SMTab + SMEsize * (0|max(0, min(SMEcnt-1, ent)));
        ui_align(0, 0);
        ((ent < 0) || (ent >= SMEcnt) || (TT[k = idx_Sm_HPSet1]  === Undef)) ? (
            ui_new_column(1);
                ui_show("Space mode undefined.");
            ui_pop();
        ) : (
            w = ui_width();
            split_leftratio = 0.55; // appropriate for this
            r = (w > 4* ui_MinSubColSize) ? 4 : (w > 3* ui_MinSubColSize) ? 3 : 2;
            ui_new_column(1/r);
                ui_show("SM. num", mSL_edit_value(0, TT[idx_Sm_sMnum], "%d"), "%s");
                ui_show("SM Algo", mSL_edit_value(0, TT[idx_Sm_Algo], "%d"), "%s");
                ui_show("SM Aux", mSL_edit_value(0, TT[idx_Sm_Aux], "%d"), "%s");
                ui_show("HP# min", mSL_edit_value(0, TT[idx_Sm_HPCnt1], "%d"), "%s");
                ui_show("HP# max", mSL_edit_value(0, TT[idx_Sm_HPCnt2], "%d"), "%s");
            ui_new_column();
                ui_show("HP Flags", mSL_edit_value(0, TT[idx_Sm_HPFlags], "%d"), "%s");
                ui_show("HP Set 1", mSL_edit_value(0, TT[idx_Sm_HPSet1], "%d"), "%s");
                ui_show("HP Set 2", mSL_edit_value(0, TT[idx_Sm_HPSet2], "%d"), "%s");
                ui_show("HP Set 3", mSL_edit_value(0, TT[idx_Sm_HPSet3], "%d"), "%s");
                ui_show("HP Set 4", mSL_edit_value(0, TT[idx_Sm_HPSet4], "%d"), "%s");
            (r > 2) ? (
            ui_new_column();
                ui_show("SP Evt 1", mSL_edit_value(0, TT[idx_Sm_HPEv], "%d"), "%s");
                ui_show("SP Evt 2", mSL_edit_value(0, TT[idx_Sm_HPEv+1], "%d"), "%s");
                ui_show("SP Evt 3", mSL_edit_value(0, TT[idx_Sm_HPEv+2], "%d"), "%s");
                ui_show("SP Evt 4", mSL_edit_value(0, TT[idx_Sm_HPEv+3], "%d"), "%s");
                ui_show("SP Par 1", mSL_edit_value(0, TT[idx_Sm_Pars], "%d"), "%s");
            );
            (r > 3) ? (
            ui_new_column();
                ui_show("SP Par 2", mSL_edit_value(0, TT[idx_Sm_Pars+1], "%d"), "%s");
                ui_show("SP Par 3", mSL_edit_value(0, TT[idx_Sm_Pars+2], "%d"), "%s");
                ui_show("SP Par 4", mSL_edit_value(0, TT[idx_Sm_Pars+3], "%d"), "%s");
                ui_show("SP Par 5", mSL_edit_value(0, TT[idx_Sm_Pars+4], "%d"), "%s");
                ui_show("SP Par 6", mSL_edit_value(0, TT[idx_Sm_Pars+5], "%d"), "%s");
            );
            ui_pop();
        );
    ui_pop();
);


function
show_Space_Modes()
local(str, str2, key, val, xx, zz, cc, cq, cx, zzch, zzent, zzmcl, zzmi, jmc, TT, h1, h2, uix_jneed, uix_jmini)
(
    // Height of the inner graphics items
    h1 = uix_jpadHeight(1); // first block height
    h2 = uix_jBoxHeight(5)+3; // second block height
    uix_jneed = h1+h2+ui_jd_ctgr;
    uix_jmini = max(h1+ui_jd_ctgr, ui_jd_min_block); // min. size

    (ui_height() > uix_jmini) ? (
        ui_split_top(uix_jneed);
            // define the actual module rectangle
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            // ui_set_rect_retina(ui_left_retina(), ui_top_retina(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width_retina())), ui_height_retina());
            zzmi = ui_hover(); // true if we are "in the module" ? doSpacesKeyboard();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockSpaceModes);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_SpaceModes %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_SpaceModes, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockSpaceModes]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            str = #;
            str2 = #;

            ui_split_top(h1); // First block

                (err_fspm != 0) ? (
                    padSMColrs[SMpVer] = padSMColrs[SMpMsg] = padSMColrs[SMpRld] = Col_Error;
                    sprintf(str, "%d:%d", err_fspm, SEntry);
                    str2 = "";
                ) : (
                    padSMColrs[SMpVer] = padSMColrs[SMpMsg] = padSMColrs[SMpRld] = Col_InfoC;
                    sprintf(str, "%d/%d", SMDEcnt, SMEcnt);
                    sprintf(str2, "v-%d.%d.%d", 0|(SpaceModesVersion/10000), (SpaceModesVersion/100)%100, SpaceModesVersion%100);
                    (jmc & cmdCap) ? (
                        padSMLabs[SMpRld] = "Remove";
                        padSMColrs[SMpRld] = Color_Std_Orange;
                    ) :
                    (jmc & altCap) ? (
                        padSMLabs[SMpRld] = "Reset";
                        padSMColrs[SMpRld] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_SpaceModes) === 0) ? (
                            padSMLabs[SMpRld] = "Undefined";
                            padSMColrs[SMpRld] = Color_Dark_Gray;
                        ) : (
                            padSMLabs[SMpRld] = "Reload";
                            padSMColrs[SMpRld] = Col_InfoC;
                        );
                    );
                );
                padSMLabs[SMpMsg] = str;
                padSMLabs[SMpVer] = str2;


                ui_pad(2,2,6,2);
                zz = control_jpad(padSModes);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 30;
                    SMnumLastM = lastTime; SMnumUnchkd  = 1;
                    zzch = padSModes[ui_jpad_lkey];
                    zzent = padSModes[ui_jpad_entkey]-1;
                    zzmcl = padSModes[ui_jpad_last]-1;
                    zzmmd = padPModes[ui_jpad_lmods];

                    //        str3 = #;
                    //        sprintf(str3, "%x/%x/%x", zz, zzmmd, zzmcl); mSL_log(SysLogBox, str3);

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char, in case we don't use it
                        AAAA_lastKeyedT = zzch;
                        padSMVals[0] = updSpMdNumber(padSMVals[0], Keyed);
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            // update the space mode
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                ) : (
                                    (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                );
                            // 32 is 'ctrl' key, 8 is 'shift' key
                            padSMVals[0] = updSpMdNumber(padSMVals[0], - key);
                        );
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_SpaceModes, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_SpaceModes, #Def_SpaceModes);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_SpaceModes, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_SpMd; // confirm we want to reload the file
                                );
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 4) ? 'pgup' : '?'; // -1000 / -10
                                ) : (
                                    (zzmmd & 4) ? 'up' : 'b';  // -100 / -1
                                );
                            padSMVals[0] = updSpMdNumber(padSMVals[0], - key);
                        ) :
                        // Reload clicked ?
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_SpaceModes, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_SpaceModes, #Def_SpaceModes);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_SpMd;
                                ); // reset read flag
                                flagSPRload = 1; // reload spacemodes ASAP
                            );
                        );
                    );
                );
            ui_pop();

            showSpacesCurr(padSMVals[0], h2);

            (zzmi && do_ModuleKeyboard()) ? (
                SMnumLastM = lastTime; SMnumUnchkd  = 1; ui_GFXdoNow |= 1; ui_GFXReason = 31;
                padSMVals[0] = updSpMdNumber(padSMVals[0], Keyed);
            );

            do_ModuleKeySave();

        ui_pop();
    );
);


//====== BANKS DEFINITIONS ======
function BnkGrpLock()
(
    (BGrpSelect = ! BGrpSelect) ? (
        padBKCells[1] = padBKCells[1] | ui_jpad_ct_selec;
    ) : (
        padBKCells[1] = padBKCells[1] ~ ui_jpad_ct_selec;
    );
);



function doBanksInteract(inKey)
(
    BKnumLastM = lastTime; BKnumUnchkd  = 1; ui_GFXdoNow |= 1; ui_GFXReason =  32;

    (inKey === 'g') ? (
        BnkGrpLock();
    ) : (
        padBKVals[BShowEntry] = updPartNumber(padBKVals[BShowEntry], inKey);
    );

    BNumEntry = padBKVals[BShowEntry];
);


function
show_Banks_Definitions()
local(str, str2, zz, key, val, xx, zz, zzch, zzent, zzmcl, zzmmd, ce, cc, cq, cl, ch, jmc,
 pmN, smN, h1, h2, h3, uix_jneed, uix_jmini, zzmi)
(
    h1 = uix_jpadHeight(2); // First block, a 2 line Pad
    h2 = uix_jBoxHeight(9) + 2; // play mode block height
    h3 = uix_jBoxHeight(5) + 2; // space modes block height
    uix_jneed = h1+h2+h3+ui_jd_ctgr;
    uix_jmini = max(ui_jd_min_block, h1+ui_jd_ctgr);

    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();  // true if we are "in the module"   ? doBanksKeyboard();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockBanksDef);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                dpi ? (
                    sprintf(#s, "Keeping %d #D_BanksDefs %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_BanksDefs, #efs); // keep name
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockBanksDef]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);


            pmN = smN = -1;
            str = #; str2 = #;
            // Some input keyboard to use ?

            ui_split_top(h1);
                // (KeyedT > 0) ? (doBanksInteract(KeyedT); KeyedT = 0;);
                ui_pad(0,2,2,2);
                /// 7 and 8
                (err_fbnk != 0) ? (
                    padBKColrs[BKpVer] = padBKColrs[BKpMsg] = padBKColrs[BKpRld] = Col_Error;
                    sprintf(str, "%d:%d", err_fbnk, BKDEcnt);
                    str2 = "";
                ) : (
                    padBKColrs[BKpVer] = padBKColrs[BKpMsg] = padBKColrs[BKpRld] = Col_InfoC;
                    sprintf(str, "%d/%d", BKDEcnt, BKEcnt);
                    sprintf(str2, "v-%d.%d.%d", 0|(BanksDefsVersion/10000), (BanksDefsVersion/100)%100, BanksDefsVersion%100);

                    ((jmc & 0x30) === 0x20) ? (
                        padBKLabs[BKpRld] = "Remove";
                        padBKColrs[BKpRld] = Color_Std_Orange;
                    ) :
                    ((jmc & 0x30) === 0x30) ? (
                        padBKLabs[BKpRld] = "Clear";
                        padBKColrs[BKpRld] = Color_Std_Orange;
                    ) :
                    ((jmc & 0x30) === 0x10) ? (
                        padBKLabs[BKpRld] = "Reset";
                        padBKColrs[BKpRld] = Color_Goldenrod;
                    ) : (
                        (strlen(#D_BanksDefs) === 0) ? (
                            padBKLabs[BKpRld] = "Undefined";
                            padBKColrs[BKpRld] = Color_Dark_Gray;
                        ) : (
                            padBKLabs[BKpRld] = "Reload";
                            padBKColrs[BKpRld] = Col_InfoC;
                        );
                    );
                );
                padBKLabs[BKpMsg] = str;
                padBKLabs[BKpVer] = str2;
                padBKColrs[0] = Col_Partial;
                padBKColrs[1] = Col_Group;
                padBKColrs[2] = Col_Bank;
                padBKColrs[3] = Col_InfoD;

                /// 2
                (BGrpSelect) ? (
                    padBKColrs[1] = Col_InfoB;
                    BGrpLow = BGrpHigh = BgrpCurr;
                ) : (
                    padBKColrs[1] = Col_Group;
                    BGrpLow = 0; BGrpHigh = BKEcnt-1;
                );

                /// 1
                // Find a partial to show - we start from padBKVals[0]
                ce = max(0, padBKVals[0]); //
                (ce >= BKDEcnt) ? ce = 0;
                padBKVals[0] = ce;
                sprintf(#strZ0, "Partial: %04d",  ce);
                padBKLabs[0] = #strZ0;
                ((BKTab[ce*BKEsize+idx_Pa_Clps] != Undef)) ? (
                    sprintf(#strZ1, "Group: %d",  BKTab[ce*BKEsize+idx_Pa_Grp]);
                    padBKLabs[1] = #strZ1;
                    sprintf(#strZ2, "Bank: %d",  BKTab[ce*BKEsize+idx_Pa_Bnk]);
                    padBKLabs[2] = #strZ2;
                    sprintf(#strZ3, "Partial #: %d",  BKTab[ce*BKEsize+11]);
                    padBKLabs[3] = #strZ3;
                    //
                    cl = BKTab[ce*BKEsize+idx_Pa_Clps];
                    ch = BKTab[ce*BKEsize+idx_Pa_Clps+1];
                    (cl >= 0) ? (
                        padBKColrs[8] = padBKColrs[9] = Col_ClRange ;
                        sprintf(#strZ8, "Cl.low: %04d", cl);
                        padBKLabs[8] = #strZ8;
                        sprintf(#strZ9, "Cl.high: %04d", ch);
                        padBKLabs[9] = #strZ9;
                        //
                        // Count existing clips in the range
                        cc=0; loop (ch-cl+1,
                            (gmem[clClInfos+cl] != 0) ? cc += 1;
                            cl += 1;
                        );
                    ) : (
                        padBKColrs[8] = padBKColrs[9] = Color_Peach_Yellow;
                        sprintf(#strZ8, "Cl. Set: %d", ch);
                        padBKLabs[8] = #strZ8;
                        ps = ClSetPtr[ch];
                        cc = ps[ClSet_cnt];
                        sprintf(#strZ9, "Set.Type: %03X", ps[ClSet_Algo]);
                        padBKLabs[9] = #strZ9;
                    );
                    // Show clip count
                    cc ? (
                        padBKColrs[4] = Col_ClUniq;
                        sprintf(#strZ4, "Cl.Cnt: %d", cc);
                    ) : (
                        padBKColrs[4] = Col_Inactive;
                        #strZ4 = "Range Empty";
                    );
                    padBKLabs[4] = #strZ4;
                    //
                    padBKColrs[10] = Col_PlMode ;
                    sprintf(#strZA, "P.Mode: %d", (pmN = BKTab[ce*BKEsize+idx_Pa_PlM]));
                    padBKLabs[10] = #strZA;
                    padBKColrs[11] = Col_SpMode ;
                    sprintf(#strZB, "S.Mode: %d", (smN = BKTab[ce*BKEsize+idx_Pa_SpM]));
                    padBKLabs[11] = #strZB;
                    //
                    padBKColrs[12] = Col_InfoD ;
                    sprintf(#strZC, "Weight: %.2f", BKTab[ce*BKEsize+idx_Pa_PWeight]+GvEps);
                    padBKLabs[12] = #strZC;
                    padBKColrs[13] = Col_InfoD ;
                    sprintf(#strZD, "Flags: %x", BKTab[ce*BKEsize+idx_Pa_PBFlgs]);
                    padBKLabs[13] = #strZD;
                    //
                    padBKColrs[14] = padBKColrs[15] = Col_VolMax ;
                    sprintf(#strZE, "Vol min: %.1f dB", BKTab[ce*BKEsize+idx_Pa_prVol]);
                    padBKLabs[14] = #strZE;
                    sprintf(#strZF, "Vol max: %.1f dB", BKTab[ce*BKEsize+idx_Pa_prVol+1]);
                    padBKLabs[15] = #strZF;
                ) : (
                    padBKLabs[1] = ""; padBKLabs[2] = ""; padBKLabs[3] = "";
                    padBKLabs[4] = "";
                    padBKColrs[8] = padBKColrs[9] = Col_Inactive;
                    padBKLabs[8] = ""; padBKLabs[9] = "";
                    padBKColrs[10] = padBKColrs[11] = Col_Inactive;
                    padBKLabs[10] = ""; padBKLabs[11] = "";
                    padBKColrs[12] = padBKColrs[13] = Col_Inactive;
                    padBKLabs[12] = ""; padBKLabs[13] = "";
                    padBKColrs[14] = padBKColrs[15] = Col_Inactive;
                    padBKLabs[14] = ""; padBKLabs[15] = "";
                );

                zz = control_jpad(padBKSets);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 33;
                    zzch = padBKSets[ui_jpad_lkey];
                    zzent = padBKSets[ui_jpad_entkey]-1;
                    zzmcl = padBKSets[ui_jpad_last]-1;
                    zzmmd = padBKSets[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char, in case we don't use it
                        doBanksInteract(zzch);
                        AAAA_lastKeyedT = zzch;
                    );


                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 8) ? 'pgdn' : '.';  // +1000 / +10
                                ) : (
                                    (zzmmd & 8) ? 'down' : 'n';  // +100 / +1
                                );
                            doBanksInteract(- key);
                        );
                        (zzmcl === 7) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_BanksDefs, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std file
                                strcpy(#D_BanksDefs, #Def_BanksDefs);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_BanksDefs, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_Bnks; // confirm we want to reload the file
                                );
                            );
                        );
                    );


                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // update the clip entry
                            key = (zzmmd & cmdCap) ? (
                                    (zzmmd & 4) ? 'pgup' : '?'; // -1000 / -10
                                ) : (
                                    (zzmmd & 4) ? 'up' : 'b';  // -100 / -1
                                );
                            doBanksInteract(- key);
                        ) :
                        (zzmcl === 10) ? (
                            padPMVals[0] = pmN;
                        ) :
                        (zzmcl === 11) ? (
                            padSMVals[0] = smN;
                        ) :
                        // Reload clicked ?
                        (zzmcl === 7) ? (
                            ((jmc & 0x30) === 0x20) ? (
                                // remove file
                                strcpy(#D_BanksDefs, "");
                            ) :
                            ((jmc & 0x30) === 0x30) ? (
                                // clear bank
                                defBankInit();
                            ) :
                            ((jmc & 0x30) === 0x10) ? (
                                // reset file to std file
                                strcpy(#D_BanksDefs, #Def_BanksDefs);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_Bnks;
                                ); // reset read flag
                                flagBKRload = 1; // reload banks Conf ASAP
                                0 ? mSL_log(SysLogBox, "Set flagBKRload in show_Banks_Definitions()");
                            )
                        );
                    );


                    (zz & ui_jpad_ev_cclk) ? (
                        ((zzmcl >= 0) && (zzmcl <= 3)) ? (
                            BShowEntry = 0;
                            (zzmcl === 1) ? BnkGrpLock();
                        );
                    );

                );
            ui_pop();

            showPModesDef(pmN, h2);

            showSpacesCurr(smN, h3);

            (zzmi && do_ModuleKeyboard()) ? (
                doBanksInteract(Keyed);
            );
            do_ModuleKeySave();


        ui_pop();
    );
);




//====== Settings ======
function
show_Scripts()
local (h1, h2, uix_jneed, uix_jmini, ig, u, v, ifg, jmc, zz, zzch, zzent, zzmcl, zzmmd, zzmi, ssnd)
(
    h1 = uix_jpadHeight(padSettingsNL); // height padSettings
    h2 = uix_jpadHeight(padSScriptsNL); // height padSScripts
    uix_jneed = uix_jmini = h1+h2+ui_jd_ctgr;
    ssnd = 0;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockScripts);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                0 && dpi ? (
                    sprintf(#s, "Dropped in settings %d ** %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    doneDroppedFile();
                );
            );
            control_group(blockDispNames[blockDispInverts[blockScripts]]);
            //ui_pad(1,2,3,2);
            ui_pad(1,1,3,2);
            ui_split_top(h1);
                //ui_pad(0,1,0,0);

                (dpi && zzmi && ui_dropped_in()) ? (
                    sprintf(#s, "Keeping %d #D_GM_mSL_ini %s", efs, #efs);
                    mSL_log(SysLogBox, #s);
                    strcpy(#D_GM_mSL_ini, #efs); // keep name
                    doneDroppedFile();
                );

                mSL_setStrArray(padSettingsLabs, padSettingsSiz);
                ig = 0; loop(padSettingsSiz,
                    padSettingsColrs[ig] = Col_Inactive;
                    ig+=1;
                );
                (jmc & cmdCap) ? (
                    padSettingsLabs[0] = "Reset";
                    padSettingsColrs[0] = Color_Goldenrod;
                ) : (
                    padSettingsLabs[0] = "Refresh";
                    padSettingsColrs[0] = Col_Cmnds;
                );

                flagDoLoadScripts ? (
                    padSettingsLabs[1] = "Load script";
                    padSettingsColrs[1] = Color_Clear_Yellow;
                ) : (
                    padSettingsLabs[1] = "Load no script";
                    padSettingsColrs[1] = Color_Std_Orange;
                );

                (jmc & cmdCap) ? (
                    padSettingsLabs[2] = "Kill Scripts";
                    padSettingsColrs[2] = Color_Deep_Cadmium_Red;
                ) : (
                    padSettingsLabs[2] = "Scripts";
                    padSettingsColrs[2] = Color_Peach_Yellow;
                );


                (jmc & cmdCap) ? (
                    padSettingsLabs[3] = "Remove\nProfile";
                    padSettingsColrs[3] = Color_Std_Orange;
                ) :
                (jmc & altCap) ? (
                    padSettingsLabs[3] = "Reset\nProfile";
                    padSettingsColrs[3] = Color_Goldenrod;
                ) : (
                    (strlen(#D_GM_mSL_ini) === 0) ? (
                        padSettingsLabs[3] = "Profile\nundefined";
                        padSettingsColrs[3] = Color_Dark_Gray;
                    ) : (
                        padSettingsLabs[3] = "Profile";
                        padSettingsColrs[3] = Color_Clear_Yellow;
                    );
                );

                padSettingsLabs[4] = "Configuration";
                padSettingsColrs[4] = Color_Peach_Yellow;


                padSettingsLabs[5] = "Aux. Script";
                (gmem[versionGMScript] != 0) ? (
                    (jmc & cmdCap) ? (
                        padSettingsLabs[5] = "Stop\nAux. Script";
                        padSettingsColrs[5] = Color_Deep_Cadmium_Red;
                    ) :
                    (((pTBlockStart - gmem[lastScRun]) > 2 ) || ((gmem[dateStrt] - gmem[dateDone]) > 5 )) ? (
                        padSettingsColrs[5] = Color_Brownish_Orange;
                        ((pTBlockStart - gmem[lastScRun]) > 120 ) ? (
                            // reset script data
                            gmem[dateRqst] = gmem[dateCfrm] = gmem[versionGMScript] = 0;
                            gmem[dateStrt] = gmem[dateDone] = pTBlockStart;
                            gmem[cmndKode] = gmem[cmndPar1] = gmem[cmndPar2] = gmem[cmndPar3] = 0;
                        );
                    ) : (
                        padSettingsColrs[5] = Col_Cmnds;
                    );
                ) : (
                    padSettingsColrs[5] = Col_Inactive;
                );


                padSettingsLabs[6] = FlagsTbNames[Settings_F_Sel];
                padSettingsColrs[6] = Col_Cmnds;
                v = FlagsTbVals[FlagsTbNums[Settings_F_Sel]];
                padSettingC7fmt ? (
                    // Format as decimal
                    padSettingsColrs[7] = Col_InfoC;
                    sprintf(padSettingsLabs[7], (v === 0|v) ? "%d" : "%f", v);
                ) : (
                    // Format as hexadecimal
                    padSettingsColrs[7] = Color_Azure;
                    sprintf(padSettingsLabs[7], "0x%X", v);
                );

                zz = control_jpad(padSettingsp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    zzch = padSettingsp[ui_jpad_lkey];
                    zzent = padSettingsp[ui_jpad_entkey]-1;
                    zzmcl = padSettingsp[ui_jpad_last]-1;
                    zzmmd = padSettingsp[ui_jpad_lmods];
                    u = ((padSettingC7fmt === 0) ? Max_Flags : 1000000000);

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            (jmc & cmdCap) ? (
                                // Reset all files
                                #D_GM_mSL_ini  = #Def_GM_mSL_ini;
                                #D_BanksDefs = #Def_BanksDefs;
                                #D_HPConfigs = #Def_HPConfigs;
                                #D_SpaceModes = #Def_SpaceModes;
                                #D_PlayModes = #Def_PlayModes;
                                #D_ClipsModifiers = #Def_ClipsModifiers;
                                #D_ClipSetConf = #Def_ClipSetConf;
                                #D_InSens_Name = #Def_InSens_Name;
                                FlagsTbVals[Flgs_ConfLd] |= flag_ld_PlMd | flag_ld_SpMd | flag_ld_Bnks | flag_ld_HPC
                                        | flag_ld_Clips | flag_ld_ClSets | flag_ld_Sensrs | flag_ld_Profile;
                                0 ? (
                                    sprintf(#gfxu, "::reset: %04x %04x", FlagsTbVals[Flgs_ConfLd] , FlagsTbVals[Flgs_TblUpd]);
                                    mSL_log(SysLogBox, #gfxu);
                                );
                            ) : (
                                // Reload all files
                                flagHPCRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_HPC;
                                flagPMRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_PlMd;
                                flagSPRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_SpMd;
                                flagBKRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Bnks;
                                0 ? mSL_log(SysLogBox, "Set flagBKRload in show_Scripts()");
                                flagClVRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Clips;
                                flagClSetload = FlagsTbVals[Flgs_TblUpd] & flag_ld_ClSets;
                                flagSnsrRload = FlagsTbVals[Flgs_TblUpd] & flag_ld_Sensrs;
                                flagGM_mSL_ini = FlagsTbVals[Flgs_TblUpd] & flag_ld_Profile;
                                // Recheck all clips
                                ig = 0;
                                loop(clDataSize5,
                                    gmem[clInfStart + ig] = 0;
                                    ig += 1;
                                );
                                0 ? (
                                    sprintf(#gfxu, "::refresh: %04x", flagPMRload | flagSPRload| flagBKRload| flagHPCRload
                                        | flagClVRload | flagSnsrRload| flagClSetload | flagGM_mSL_ini) ;
                                    mSL_log(SysLogBox, #gfxu);
                                );
                                ClCheckFlag = 1; rerun = 1;
                                ClCheckCnt = 0;
                                0 ? (
                                    sprintf(#gfxu, "::Clip Dir: %s", #D_clDirectory);
                                    mSL_log(SysLogBox, #gfxu);
                                );
                            );
                            delayLoad = 0;
                        ) :
                        (zzmcl === 1) ? (
                            flagDoLoadScripts = ! flagDoLoadScripts;
                        ) :
                        (zzmcl === 2) ? (
                            (jmc & cmdCap) ? flagKillAllThreads = 1;
                        ) :
                        (zzmcl === 3) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_GM_mSL_ini, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std name
                                strcpy(#D_GM_mSL_ini, #Def_GM_mSL_ini);
                            ) : (
                                (zzmmd & 8) ? (
                                    FlagsTbVals[Flgs_ConfLd] &= 0xFFFFFF ~ flag_ld_Profile;
                                ); // reset read flag
                                flagGM_mSL_ini = 1; // reload profile ASAP
                            );
                        ) :
                        (zzmcl === 4) ? (
                            ShowConfig();
                        ) :
                        (zzmcl === 5) ? (
                            ssnd = 1;
                        ) :
                        (zzmcl === 7) ? (
                            FlagsTbVals[FlagsTbNums[Settings_F_Sel]] = (FlagsTbVals[FlagsTbNums[Settings_F_Sel]] + u - 1) % u;
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        ((zzmcl === 1) || (zzmcl === 3)) ? (
                            xx = control_jmenu(menu_Scripts);
                            (xx != 0) ? (
                                ifg = scripts_tab[xx-1];
                                doMslCompile(ifg);
                            );
                        ):
                        (zzmcl === 3) ? (
                            (jmc & cmdCap) ? (
                                // remove file
                                strcpy(#D_GM_mSL_ini, "");
                            ) :
                            (jmc & altCap) ? (
                                // reset file to std name
                                strcpy(#D_GM_mSL_ini, #Def_GM_mSL_ini);
                            ) : (
                                // choose a new file
                                xx = control_jmenu(menu_Config);
                                (xx != 0) ? (
                                    strcpy(#D_GM_mSL_ini, configs_tab[xx-1]); // keep name
                                    FlagsTbVals[Flgs_ConfLd] |= flag_ld_Profile; // confirm we want to reload the file
                                );
                            );
                        ) :
                        (zzmcl === 4) ? (
                            // Dialog test
                                ui_screen_open("control.prompt");
                                ui_screen_arg(0, #aentered_text);
                                ui_screen_arg(1, "Prompt title");
                        ) :
                        (zzmcl === 6) ? (
                            xx = control_jmenu(menu_Flags);
                            (xx > 0) ? (
                                // s_Settings
                                Settings_F_Sel = xx - 1;
                            );
                        ) :
                        (zzmcl === 7) ? (
                            FlagsTbVals[FlagsTbNums[Settings_F_Sel]] = (FlagsTbVals[FlagsTbNums[Settings_F_Sel]] + 1) % u;
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        ((zzent === 6) || (zzent === 7)) ? (
                            v = FlagsTbVals[FlagsTbNums[Settings_F_Sel]];
                            ((padSettingC7fmt === 0) && (zzch >= '0') && (zzch <= '9')) ? (
                                v = v * 16 + zzch - '0';
                            ) :
                            ((padSettingC7fmt === 1) && (zzch >= '0') && (zzch <= '9')) ? (
                                v = v * 10 + zzch - '0';
                            ) :
                            ((padSettingC7fmt === 0) && (zzch >= 'a') && (zzch <= 'f')) ? (
                                v = v * 16 + zzch - 'a' + 10;
                            ) :
                            ((padSettingC7fmt === 0) && (zzch >= 'A') && (zzch <= 'F')) ? (
                                v = v * 16 + zzch - 'A' + 10;
                            ) :
                            ((zzch === 'z') || (zzch === 'Z')) ? (
                                v = 0;
                            ) :
                            ((zzch === 'x') || (zzch === 'X')) ? (
                                padSettingC7fmt = padSettingC7fmt === 0;
                            ) :
                            ((zzch === '+') || (zzch === '=')) ? (
                                v = v + 1;
                            ) :
                            ((zzch === '-') || (zzch === '_')) ? (
                                v = v + u - 1;
                            ) :
                            ((ui_jmouse_cap === 0) && (zzch === 'left')) ? (
                                v = (padSettingC7fmt === 0) ? v << 4 : v * 10;
                            ) :
                            ((ui_jmouse_cap === 0) && (zzch === 'rght') )? (
                                v = (padSettingC7fmt === 0) ? v >> 4 : (v / 10);
                            ) :
                            (zzch === 8) ? ( // backspace
                                (v !== 0|v) ? (
                                    v = 0|v;
                                ) : (
                                    v = (padSettingC7fmt === 0) ? v >> 4 : 0|(v / 10);
                                );
                            ) ;
                            (padSettingC7fmt === 0) ? (
                                v = v % u;
                            ) : (
                                v > u ? v = v%u;
                            );
                            FlagsTbVals[FlagsTbNums[Settings_F_Sel]] = v;
                            (zzch === 'down') ? (
                                Settings_F_Sel = (Settings_F_Sel + 1) % FlagsCount;
                            ) :
                            (zzch === 'up') ? (
                                Settings_F_Sel = (Settings_F_Sel - 1 + FlagsCount) % FlagsCount;
                            ) :
                            (zzch === '$') ? (
                                ssnd = 1; // will send to the script
                            ) :
                            (Keyed = zzch;);  // zzch has not been used
                        ) : (
                            Keyed = zzch;
                        );
                    );

                    // Should we send the command to the script ?
                    ssnd ? (
                        gmem[cmndKode] = (jmc & cmdCap) ? 0x7E : FlagsTbVals[Flgs_AuxS] - 110;
                        gmem[cmndPar1] = FlagsTbVals[Flgs_AuxP1];
                        gmem[cmndPar2] = FlagsTbVals[Flgs_AuxP2];
                        gmem[cmndPar3] = FlagsTbVals[Flgs_AuxP3];
                        gmem[dateRqst] = gmem[dateCfrm] = gfxStartTime;
                    );

                    ui_GFXdoNow |= 1;

                );

            ui_pop();

            ui_split_top(h2);
                ig = 0; loop(K_padSScriptsSiz,
                    (jmc & cmdCap) ? (
                        padSScriptsColrs[ig] = Color_Std_Orange;
                        padSScriptsLabs[ig] = namScriptfiles[ig];
                    ) :
                    (jmc & altCap) ? (
                        padSScriptsColrs[ig] = Color_Goldenrod;
                        padSScriptsLabs[ig] = namScriptfiles[ig];
                    ) : (
                        padSScriptsColrs[ig] = Color_Clear_Yellow;
                        padSScriptsLabs[ig] = shortScriptfiles[ig];
                    );
                    ig+=1;
                );
                // padSScriptsLabs[0] = "Refresh";
                // padSScriptsColrs[0] = Color_Darker_Gray;
                0 && dpi ? (
                    sprintf(#s, "** Dropped in ==>  %d zzmi: %d dropped: %d", dpi, zzmi, ui_dropped_in());
                    mSL_log(SysLogBox, #s);
                    sprintf(#s, "** Bounds %d %d [%d %d / %d %d]", dropped_x, dropped_y,
                    ui_left_retina(), ui_right_retina(), ui_top_retina(), ui_bottom_retina());
                    mSL_log(SysLogBox, #s);
                    doneDroppedFile();
                );
                (dpi && zzmi && ui_dropped_in()) ? (
                    // locate mouse in pad.
                    nli = padSScriptsp[ui_jpad_nli]; nco = padSScriptsp[ui_jpad_nco];
                    lx = 0 | (nli * (dropped_y - ui_top_retina()) / (ui_bottom_retina() - ui_top_retina()));
                    cx = 0 | (nco * (dropped_x - ui_left_retina()) / (ui_right_retina() - ui_left_retina()));
                    nc = cx + nco * lx;
                    ((nc >= 0) && (nc < K_padSScriptsSiz)) ? (
                        strcpy(namScriptfiles[nc], #efs); // keep name
                        updScriptfiles = 1;
                    );
                    0 ? (
                        sprintf(#s, "** Dropped in files settings ** %d %d %d %d %d -> %d", nli, nco, lx, cx, nc, updScriptfiles);
                        mSL_log(SysLogBox, #s);
                    );
                    doneDroppedFile();
                );

                zz = control_jpad(padSScriptsp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    zzch = padSScriptsp[ui_jpad_lkey];
                    zzent = padSScriptsp[ui_jpad_entkey]-1;
                    zzmcl = padSScriptsp[ui_jpad_last]-1;
                    zzmmd = padSScriptsp[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        //sprintf(#s, "   ++ Click %d : \"%s\"", zzmcl, namScriptfiles[zzmcl]); mSL_log(SysLogBox, #s);
                        (jmc & cmdCap) ? (
                            strcpy(namScriptfiles[zzmcl], "");
                        ) :
                        (jmc & altCap) ? (
                            (strlen(namScriptfiles[zzmcl]) != 0) ? (
                                doMslTxtPrint(namScriptfiles[zzmcl]);
                            );
                        ) : (
                            (strlen(namScriptfiles[zzmcl]) != 0) ? (
                                doMslCompile(namScriptfiles[zzmcl]);
                            );
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        xx = control_jmenu(menu_Scripts);
                        (xx != 0) ? (
                            strcpy(namScriptfiles[zzmcl], scripts_tab[xx-1]); // keep name we want to reload the file
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // we don't use the key
                    );

                    updScriptfiles = 1;
                );

            ui_pop();
            do_ModuleKeySave();
        ui_pop();
    );
);





function
show_PlayLog()
local (h1, h2, h3, h3min, uix_jneed, uix_jmini, da, dl, elc, flPl, ig, ij, is, it, jmc, pq, xx, r, td, u,
    k, kit, val, inc, ivs, nv, alt, zz, zzch, zzent, zzmcl, zzmmd, zzmi, axion)
(
    h1 = uix_jpadHeight(1); // height
    h2 = ui_jd_slidh * 2 + 4;
    h3 = uix_jpadHeight(padPlayStoreNL); // height
    h3min = uix_jpadHeight(2); // height min
    uix_jneed = h2+h1+h3+ui_jd_ctgr +2;
    uix_jmini = h2+h1+h3min+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockPlayLog);

            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockPlayLog]]);
            axion = 0;

            ((playMarkDelete > 0) && (playMarkDelete != playMarkCopy)) ? (
                freeLstBlock(playMarkDelete); playMarkDelete = 0;
            );

            ui_split_top(h1);
                ui_pad(0,1,0,0);
                mSL_setStrArray(padPlayLogLabs, padPlayLogSiz);
                ig = 0; loop(padPlayLogSiz,
                    padPlayLogColrs[ig] = Col_Inactive;
                    ig+=1;
                );

               (recordMode === recModeOn) ? (
                    padPlayLogLabs[0] = "Recording";
                    padPlayLogColrs[0] = Color_Light_Red;
                ) :
                (recordMode === recModePause) ? (
                    padPlayLogLabs[0] = "Paused";
                    padPlayLogColrs[0] = Color_Brownish_Orange;
                ) :
                (
                    padPlayLogLabs[0] = "Stopped";
                    padPlayLogColrs[0] = Col_Inactive;
                );



                (pTDispF === 0) ? (
                    edTimeMs(pRecTimeCurrent, 0x12);
                    strcpy(padPlayLogLabs[1], #edt);
                    padPlayLogColrs[1] = recOptLockSnds ? Color_Dark_Orange : Color_Light_Red;
                ) : (
                    sprintf(padPlayLogLabs[1], "%.3f", pRecTimeCurrent);
                    padPlayLogColrs[1] = recOptLockSnds ? Color_Azure : Color_Barley_White;
                );

                sprintf(padPlayLogLabs[2], "%d", gmem[recLogCnt]);
                padPlayLogColrs[2] = recOptRecReplay ? Color_Dark_Orange : Color_Light_Red;



                (paramValues[p_GvAutoMd]) ? (
                    (jmc === 0x04) ? (
                        padPlayLogLabs[3] =  "Stop Play";
                        padPlayLogColrs[3] = Col_CmdStp;
                    ) : (
                        padPlayLogLabs[3] = "Auto-play (on)";
                        padPlayLogColrs[3] = Col_Cmnds;
                    );
                ) : (
                    padPlayLogLabs[3] = "Auto-play (off)";
                    padPlayLogColrs[3] = Col_Inactive;
                );

                (replayMode === replayModeOn) ? (
                    padPlayLogLabs[4] = "Replaying";
                    padPlayLogColrs[4] = lppLoopMd ? (playJmpLoop ? Color_Cadet_Blue : Color_Light_Blue) : Color_Blue_Green;
                ) :
                (replayMode === replayModePause) ? (
                    padPlayLogLabs[4] = "Paused";
                    padPlayLogColrs[4] =  playModeStep ? Color_Azure :  lppLoopMd ? Color_Light_Blue : Color_Light_Steel_Blue;
                ) :
                (
                    padPlayLogLabs[4] = "Stopped";
                    padPlayLogColrs[4] = Col_Inactive;
                );

                (pTDispF === 0) ? (
                    edTimeMs(gmem[playLogDate], 0x12);
                    strcpy(padPlayLogLabs[5], #edt);
                    padPlayLogColrs[5] = playRepeatMd ? Color_Light_Blue : Color_Blue_Green;
                ) : (
                    sprintf(padPlayLogLabs[5], "%.3f", gmem[playLogDate]);
                    padPlayLogColrs[5] = playRepeatMd ? Color_Azure : Color_Barley_White;
                );

                sprintf(padPlayLogLabs[6], "%d", gmem[playLogRef]);
                padPlayLogColrs[6] = recOptMarkReplay ? Color_Light_Blue : Color_Blue_Green;

                (pTDispF === 0) ? (
                    edTimeMs(max(0,playTime2Next), 0x12);
                    strcpy(padPlayLogLabs[7], #edt);
                    padPlayLogColrs[7] = UplayControl ? Color_Yellow_Green : Color_Blue_Green;
                ) : (
                    sprintf(padPlayLogLabs[7], "%.3f", max(0,playTime2Next));
                    padPlayLogColrs[7] = UplayControl ? Color_Azure : Color_Barley_White;
                );
                !replayUnMute ? (padPlayLogColrs[7] = Color_Brownish_Orange;);

                zz = control_jpad(padPlayLogp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 40;
                    AAAAzz = zz; AAAAzz1 = 0; AAAAzz2 = recordMode;
                    zzch = padPlayLogp[ui_jpad_lkey];
                    zzent = padPlayLogp[ui_jpad_entkey]-1;
                    zzmcl = padPlayLogp[ui_jpad_last]-1;
                    zzmmd = padPlayLogp[ui_jpad_lmods];


                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char, we do not use it
                    );


                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        AAAAzz1 = 1;
                        (zzmcl === 0) ? (
                            // Prepare the menu
                            ui_menu_tick(menu_plrec, jmenu_item2res(menu_plrec, plgRecLOnPause), recOptLockSnds);
                            ui_menu_tick(menu_plrec, jmenu_item2res(menu_plrec, plgRecRecReplay), recOptRecReplay);
                            xx = control_jmenu(menu_plrec);
                            (xx > 0) ? (
                                kit = jmenu_res2item(menu_plrec, xx);
                                (kit === 0) ? ( // Stop
                                    setRModeStop();
                                ) :
                                (kit === 1) ? ( // Record
                                    setRModeRec();
                                    (jmc === 0x04) ? setPModePlay();
                                ) :
                                (kit === 2) ? (  // Record Pause
                                    setRModePause();
                                    (jmc === 0x04) ? setPModePause();
                                ) :
                                (kit === plgRecLOnPause) ? ( // Replay
                                    recOptLockSnds = ! recOptLockSnds ;
                                ) :
                                (kit === plgRecRecReplay) ? ( // Wait
                                    recOptRecReplay = ! recOptRecReplay ;
                                ) :
                                (
                                    setRModeStop();
                                );
                            );
                        ) :
                        (zzmcl === 1) ? (
                            recOptLockSnds = ! recOptLockSnds ;
                        ) :
                        (zzmcl === 2) ? (
                            recOptRecReplay = ! recOptRecReplay ;
                        ) :
                        (zzmcl === 3) ? (
                            parSet(p_GvAutoMd, 0);
                            doActivePlayer(-1, KmdStop, 0);
                        ) :
                        (zzmcl === 4) ? (
                            // Prepare the menu
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplAStop), playAutoStop);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplLPause), playAndStop);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplPLock), playAndLock);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplUnPLock), playAndUnLock);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplMute), (1 - replayUnMute));
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplMIRC), recOptMarkReplay);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgReplStep), playModeStep);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgRepLoop), playRepeatMd);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgSkipSlnc), playSkipSlnc);
                            ui_menu_tick(menu_plrepl, jmenu_item2res(menu_plrepl, plgJmpLoop), playJmpLoop);
                            xx = control_jmenu(menu_plrepl);
                            (xx > 0) ? (
                                kit = jmenu_res2item(menu_plrepl, xx);
                                0 ? (sprintf(#s, "xx = %d  kit = %d", xx, kit); mSL_log(SysLogBox, #s););
                                (kit === 0) ? ( // Stop
                                    replayMode = replayModeOff;
                                ) :
                                (kit === 1) ? ( // Play
                                    setPModePlay();
                                ) :
                                (kit === 2) ? (  // Replay Pause
                                    setPModePause();
                                ) :
                                (kit === 3) ? ( //  Rewind
                                    playRewind();
                                ) :
                                (kit === plgReplAStop) ? (
                                    playAutoStop = ! playAutoStop ;
                                ) :
                                (kit === plgReplLPause) ? (
                                    playAndStop = ! playAndStop ;
                                ) :
                                (kit === plgReplPLock) ? (
                                    playAndLock = ! playAndLock ;
                                ) :
                                (kit === plgReplPUnLock) ? (
                                    playAndUnLock = ! playAndUnLock ;
                                ) :
                                (kit === plgReplMute) ? (
                                    replayUnMute = ! replayUnMute ;
                                ) :
                                (kit === plgReplMIRC) ? (
                                    recOptMarkReplay = ! recOptMarkReplay ;
                                ) :
                                (kit === plgReplStep) ? (
                                    playModeStep = ! playModeStep ;
                                ) :
                                (kit === plgSkipSlnc) ? (
                                    playSkipSlnc = ! playSkipSlnc ;
                                ) :
                                (kit === plgJmpLoop) ? (
                                    playJmpLoop = ! playJmpLoop ;
                                ) :
                                (kit === plgRepLoop) ? (
                                    playRepeatMd = ! playRepeatMd ;
                                ) :
                                (
                                    setPModeStop(); // default
                                );
                            );
                        ) :
                        (zzmcl === 5) ? (
                            // flip reapeat mode
                            playRepeatMd = ! playRepeatMd ;
                        ) :
                        (zzmcl === 6) ? (
                            // flip markers include played sounds
                            recOptMarkReplay = ! recOptMarkReplay ;
                        ) :
                        (zzmcl === 7) ? (
                            // flip play control
                            UplayControl = ! UplayControl;
                            replayUnMute = 1; // and unmute
                        );

                    );


                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            setRModeSwitch();
                            (jmc === 0x04) ? (
                                (recordMode === recModePause) ? setPModePause() : setPModePlay();
                            );
                        ) :
                        (zzmcl === 3) ? (
                            (jmc === 0x04) ? (
                                doActivePlayer(-1, KmdStop, 0);
                            ) : (
                                switchAuto();
                                // parSet(p_Vol_Global, 0);
                            );
                        ) :
                        (zzmcl === 4) ? (
                            setPModeSwitch();
                        ) :
                        ((zzmcl === 1) || (zzmcl === 5) || (zzmcl === 7)) ? (
                            pTDispF = ! pTDispF ;
                        );
                    );
                );

            ui_pop();


            // Sliders
            ui_split_top(h2);
                zzmx = ui_hover();
                (xstoppl = zzmx && (((jmc & 0x18) === 0x18) || (jmc & 0x08) === 0x08))  ?  jmc = jmc & 0xE7;
                ui_pad(1,3,1,0);
                is = pPlayTimeCurrent = parV(p_VirtualTime);
                it = playModeSpeed = parV(p_VirtTimSpeed);
                r = parCtl(p_VirtualTime);
                (r != 0) ? (
                    u = (jmc === 0x24) ? 0.1 : (jmc === 0x20) ? 1 : (jmc === 0x04) ? 60 : 10;
                    pPlayTimeCurrent = parV(p_VirtualTime);
                    (r === 4) ? (
                        pPlayTimeCurrent = max(ppb_VirtualTime[pp_Min], (-1 + (0|(pTEpsilon + pPlayTimeCurrent / u))) * u); // pp_Min
                    ) :
                    (r === 8) ? (
                        pPlayTimeCurrent = min(ppb_VirtualTime[pp_Max], (1 + (0|(pTEpsilon + pPlayTimeCurrent / u))) * u); // pp_Max
                    );
                    gmem[playLogDate] = pPlayTimeCurrent = parSet(p_VirtualTime, pPlayTimeCurrent);;
                );
                s = parCtl(p_VirtTimSpeed);
                (s != 0) ? (
                    playModeSpeed = parV(p_VirtTimSpeed);
                    v = pTEpsilon * sign(playModeSpeed);
                    (s === 4) ? ( // clic gauche
                        (jmc === 0x24) ? playModeSpeed = ((playModeSpeed === -1) ? -0.5 : -1;) :
                        (jmc === 0x20) ? playModeSpeed = max(ppb_VirtTimSpeed[pp_Min], playModeSpeed - 0.001) :
                        (jmc === 0x14) ? playModeSpeed = max(ppb_VirtTimSpeed[pp_Min], playModeSpeed - 0.01) :
                        (jmc === 0x04) ? playModeSpeed = max(ppb_VirtTimSpeed[pp_Min], playModeSpeed - 0.1) :
                                         playModeSpeed = max(ppb_VirtTimSpeed[pp_Min], playModeSpeed - 1) ; // pp_Min
                    ) :
                    (s === 8) ? ( // clic droit
                        (jmc === 0x24) ? playModeSpeed = ((playModeSpeed === 1) ? 0.5 :  1;) :
                        (jmc === 0x20) ? playModeSpeed = min(ppb_VirtTimSpeed[pp_Max], playModeSpeed + 0.001) :
                        (jmc === 0x14) ? playModeSpeed = min(ppb_VirtTimSpeed[pp_Max], playModeSpeed + 0.01) :
                        (jmc === 0x04) ? playModeSpeed = min(ppb_VirtTimSpeed[pp_Max], playModeSpeed + 0.1) :
                                         playModeSpeed = min(ppb_VirtTimSpeed[pp_Max], playModeSpeed + 1) ; // pp_Max
                    );
                    playModeSpeed = parSet(p_VirtTimSpeed, playModeSpeed);
                );
                ((r != 0) || (s != 0)) ? (
                    xstoppl ? (  // should we stop playing ?
                        parSet(p_GvAutoMd, 0);
                        doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
                    );
                    playReeval = 1;
                    0 ? (sprintf(#sfc, " r -> %d  [%.2f  =>  %.2f]   s -> %d  [%.2f  =>  %.2f]", r, is, pPlayTimeCurrent, s, it, playModeSpeed); mSL_log(SysLogBox, #sfc););
                );
            ui_pop();


            // Mark Pad
            ui_split_top(h3);
                zzmx = ui_hover();
                ui_pad(0,1,0,0);
                mSL_setStrArray(padPlayStoreLabs, padPlayStoreSiz);
                (xstoppl = zzmx && (((jmc & 0x18) === 0x18)))  ?  jmc = jmc & 0xF7;
                ig = 0; loop(padPlayStoreSiz,
                    da = clTabE[ig];
                    (da > 0) ? (
                        (jmc === 0x20) ? (
                            padPlayStoreColrs[ig] = Color_Light_Red;
                        ) :
                        (jmc === 0x30) ? (
                            padPlayStoreColrs[ig] = Color_Blaze_Orange;
                        ) :
                        (jmc === 0x04) ? (
                            padPlayStoreColrs[ig] = Color_Light_Green;
                        ) :
                        (
                            s = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType];
                            padPlayStoreColrs[ig] = menu_Pad_clrs[s];
                        );
                        // What date value should we display ?
                        s = markerDate(da);
                        ((f = (ig === padPlayStoreMod))) ? (
                            (padPlayStoreMDate >= pTBlockStart) ? (
                                padPlayStoreColrs[ig] = Color_Std_Cyan;
                            ) : (
                                padPlayStoreMod = -1; f = 0;
                            );
                        );
                        (pTDispF === 0) ? (
                            strcpy(padPlayStoreLabs[ig], edTimeMs(s, f ? 0x13 : 0x12));
                        ) : (
                            sprintf(padPlayStoreLabs[ig],  f ? "%.3f" : "%.1f", s);
                        );
                    ) : (
                        padPlayStoreColrs[ig] = Col_Inactive;
                    );
                    ((ig != lppLoop1) && (ig != lppLoop2)) ? (
                        padPlayStoreCells[ig] &= -1 ~ ui_jpad_ct_selec;
                    ) : (
                        padPlayStoreCells[ig] |= ui_jpad_ct_selec;
                        padPlayStoreColrs[ig] = Color_Forest_Green;
                    );
                    ig+=1;
                );


                // Log Play Pad Interaction
                zz = control_jpad(padPlayStorep);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 40;
                    zzch = padPlayStorep[ui_jpad_lkey];
                    zzent = padPlayStorep[ui_jpad_entkey]-1;
                    zzmcl = padPlayStorep[ui_jpad_last]-1;
                    zzmmd = padPlayStorep[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        ((da = clTabE[zzent]) > 0) ? (
                            padPlayStoreMod = zzent;
                            padPlayStoreMDate = pTBlockStart + 16; //
                            value = da[lppEDate];
                            da[lppEFlgs] = (da[lppEFlgs] & 0x7FFFFFF0); // reset "mark date"

                            inc = 0;
                            (zzch === 'left') ? (
                                inc = (jmc === 0x00) ? -1 : (jmc === 0x04) ? -0.1 : (jmc === 0x10) ? -0.01 : (jmc === 0x14) ? -0.001 : 0;
                            ) :
                            (zzch === 'rght') ? (
                                inc = (jmc === 0x00) ? 1 : (jmc === 0x04) ? 0.1 : (jmc === 0x10) ? 0.01 : (jmc === 0x14) ? 0.001 : 0;
                            ) :
                            (zzch === 'up') ? (
                                inc = (jmc === 0x00) ? 10 : (jmc === 0x04) ? 60 : (jmc === 0x10) ? 300 : (jmc === 0x14) ? 1800 : 0;
                            ) :
                            (zzch === 'down') ? (
                                inc = (jmc === 0x00) ? -10 : (jmc === 0x04) ? -60 : (jmc === 0x10) ? -300 : (jmc === 0x14) ? -1800 : 0;
                            ) :
                            (zzch === '=') ? (
                                ivs = (jmc === 0x00) ? 1 : (jmc === 0x04) ? 0.1 : (jmc === 0x10) ? 0.01 : (jmc === 0x14) ? 0.001 : 0.0001;
                                value = (0|((value+ivs/2) / ivs)) * ivs;
                            ) :
                            (zzch === ':') ? (
                                ivs = (jmc === 0x00) ? 10 : (jmc === 0x04) ? 60 : (jmc === 0x10) ? 300 : (jmc === 0x14) ? 1800 : 0.0001;
                                value = (0|((value+ivs/2) / ivs)) * ivs;
                            ) :
                            (zzch === 'c') ? (
                                // copy
                                playMarkCopy = da;
                            ) :
                            (zzch === 'd') ? (
                                // duplicate
                                playMarkCopy = da;
                                is = zzent; it = 0; while (it <= padPlayStoreSiz) (
                                    (clTabE[is] <= 0) ? (
                                        clTabE[is] = copyBlock(playMarkCopy);
                                        it = padPlayStoreSiz;
                                        padPlayStoreMod = is;
                                    );  is = (is + 1) % padPlayStoreSiz; it = it + 1;
                                );
                            ) :
                            (zzch === 'b') ? (
                                // unmask
                                da[lppEFlgs] &= -1 ~ lppEFlgInact;
                                (da[lppEType] === 0) ? da[lppEType] = 1;
                                padPlayStoreMDate = 0;
                            ) :
                            (zzch === 'n') ? (
                                // toggle active/inactive...
                                (da[lppEFlgs] & lppEFlgInact) ? (
                                    da[lppEFlgs] &= -1 ~ lppEFlgInact;
                                    (da[lppEType] === 0) ? da[lppEType] = 1;
                                ) : (
                                    da[lppEFlgs] |= lppEFlgInact;
                                );
                                padPlayStoreMDate = 0;
                            ) :
                            (zzch === 'x') ? (
                                // delete
                                (playMarkDelete > 0) ? (
                                    freeLstBlock(playMarkDelete);
                                );
                                playMarkDelete = playMarkCopy = da;
                                clTabE[zzent] = -1;
                            ) :
                            (zzch === 'f') ? (
                                (lppLoop1 === zzent) ? ( lppLoop1 = - 1; ) :
                                (lppLoop2 === zzent) ? ( lppLoop2 = - 1; ) :
                                ( (lppLoop1 < 0) ? (lppLoop1 = zzent) : (lppLoop2 = lppLoop1; lppLoop1 = zzent;) ; );
                            ) :
                            (zzch === 'y') ? (
                                da[lppEFlgs] &= -1 ~ lppEFlgInact; // untoggle "inactive"
                                da[lppEType] = (da[lppEType] + 1) % 7 ;
                                padPlayStoreMDate = 0;
                            ) :
                            (
                                Keyed = zzch; // keep the char, we don't use it
                            );
                            da[lppEDate] = max(0, min(value+inc, playTimeMax));
                        ) : (
                            (zzch === 'v') ? (
                                // paste ?
                                (playMarkCopy > 0) ? (
                                    clTabE[zzent] = ent = copyBlock(playMarkCopy);
                                    0 ? (
                                        sprintf(#dbg_trace3, "copyBlock(%d) => (%d), k = %d  %s  //  %d  %s", playMarkCopy, ent,
                                        0 | (playMarkCopy[2] / twoPow32), mSL_edit_value(#s, playMarkCopy[2]%twoPow32),
                                        0 | (ent[2] / twoPow32), mSL_edit_value(#t, ent[2]%twoPow32));
                                        s = playMarkCopy;
                                        sprintf(#dbg_trace4, "DA: %d %d %d %d %d %.3f %.3f %.3f %.3f %.3f %d %d",
                                        s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
                                        s = ent;
                                        sprintf(#dbg_trace5, "CP: %d %d %d %d %d %.3f %.3f %.3f %.3f %.3f %d %d",
                                        s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
                                    );
                                );
                            ) :
                            (
                                Keyed = zzch; // keep the char, we don't use it
                            )
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        da = clTabE[zzmcl];
                        padPlayStoreMod = zzmcl;
                        0 ? (sprintf(#sfc, "idx = %d   ent = %d   jmc = %x   lppts = %d, %d", zzmcl, da, jmc, lppLoop1, lppLoop2); mSL_log(SysLogBox, #sfc););
                        xstoppl ? (
                            parSet(p_GvAutoMd, 0);
                            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
                        );
                        (((da <= 0) && ((jmc === 0x00) || (jmc === 0x04))) || (jmc === 0x20)) ? ( // control - or entry is free
                            setPlayMark(zzmcl, psKPlaying, recOptMarkReplay ? psKReplaying : 0, (jmc === 0x04)); // keep the entry
                        ) :
                        ((da > 0) && (jmc === 0x30)) ? ( // control+option  : free the entry
                            (playMarkDelete > 0) ? (
                                freeLstBlock(playMarkDelete);
                            );
                            playMarkDelete = playMarkCopy = da;
                            clTabE[zzmcl] = -1;
                            zzmcl === lppLoop1 ? lppLoop1 = -1;
                            zzmcl === lppLoop2 ? lppLoop2 = -1;
                        ) :
                        ((da > 0))  ? (
                            // First case : a jump to position
                            ty = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType]; // type of entry OR inactive
                            ((jmc === 0x14) && (zzmcl === lppLoop1)) ? (
                                // unmark the entry
                                lppLoop1 = -1;
                            ) :
                            ((jmc === 0x14) && (zzmcl === lppLoop2)) ? (
                                // unmark the entry
                                lppLoop2 = -1;
                            ) :
                            (jmc === 0x14) ? (
                                // mark the entry as loop point
                                (lppLoop1 < 0) ? (lppLoop1 = zzmcl) : (lppLoop2 = lppLoop1; lppLoop1 = zzmcl;) ;
                            ) :
                            ((ty === 1) || (jmc === 0x04)) ? (
                                // go to the corresponding date
                                replayJumpTo(PlLogCurrent, markerDate(da), playModeSpeed);
                                (jmc === 0x04) ? (setPModePlay(););
                            ) :
                            (ty > 1) ? (
                                // Already marked, play it.
                                xstoppl ? (jmc &= 0xEF;); // reset bit alt
                                // Add a task to play the sound
                                it = SchedAddTask(13, da, 1, gfxStartTime, 0, jmc, zzmcl); // 1 is for "init"
                                0 ? (
                                    sprintf(#sfc, "run = %d  ->  Item = %d [%d  %.3f  - %d -  %.3f]", it, zzmcl, da, da[lppEDate], da[lppEElct], da[lppED1st]); mSL_log(SysLogBox, #sfc);
                                );
                            );
                        ) :
                        ((da <= 0) && (jmc === 0x14)) ? (
                            // unmark loop points
                            lppLoop1 = lppLoop2 = -1;
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        xstoppl ? (
                            parSet(p_GvAutoMd, 0);
                            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
                        );
                        ((da = clTabE[zzmcl]) > 0) ? (
                            padPlayStoreMod = zzmcl;
                            (jmc === 0x00) ? (
                                // Prepare the menu
                                ix = 0; loop (jmenu_item2res(menu_Pad_psm, psmMenuITC)-1,  ui_menu_tick(menu_Pad_psm, ix, 0); ix += 1; );
                                ui_menu_tick(menu_Pad_psm, jmenu_item2res(menu_Pad_psm, da[lppEType] + psmMEnt0), 1);
                                ui_menu_tick(menu_Pad_psm, jmenu_item2res(menu_Pad_psm, (da[lppEFlgs] & 0xF) + psmMMarker), 1);
                                //ui_menu_tick(menu_Pad_psm, jmenu_item2res(menu_Pad_psm, da[lppEMetro] + psmMSyncNo), 1);
                                ui_menu_tick(menu_Pad_psm, jmenu_item2res(menu_Pad_psm, psmOptInact), ((da[lppEFlgs] & lppEFlgInact) != 0));
                                ui_menu_tick(menu_Pad_psm, jmenu_item2res(menu_Pad_psm, psmOptLppnt), ((lppLoop1 === zzmcl) || (lppLoop2 === zzmcl)));
                                inc = ivs = 0;
                                xx = control_jmenu(menu_Pad_psm);
                                xx ? (
                                    //da[lppEFlgs] &= -1 ~ lppEFlgInact; // reset inactive bit
                                    kit = jmenu_res2item(menu_Pad_psm, xx);
                                    alt = alt1 = alt2 = -1;
                                    1 ? (
                                        yy = ui_menu_ent(menu_Pad_psm, xx);
                                        y1 = jmenu_item2res(menu_Pad_psm, psmMEnt0);
                                        y2 = jmenu_item2res(menu_Pad_psm, psmMMVLeft);
                                        y3 = jmenu_item2res(menu_Pad_psm, psmMSyncNo);
                                        0 ? (sprintf(#sfc, "right clic (%d/%d)  [kit: %d => %d] (%d->%d,%d->%d,%d->%d)", zzmcl, da, kit, yy, psmMEnt0, y1, psmMMVLeft, y2, psmMSyncNo, y3); mSL_log(SysLogBox, #sfc);
                                        );
                                    );
                                    ((kit >= psmMEnt0) && (kit < psmMenuTypeEnd)) ? (
                                        //  change point type
                                        da[lppEType] = kit - psmMEnt0;
                                        //  remove "toggle inactive"
                                        da[lppEFlgs] &= -1 ~ lppEFlgInact;
                                    ) :
                                    ((kit >= psmMMarker) && (kit < psmMenuMarkerEnd)) ? (
                                        da[lppEFlgs] = (da[lppEFlgs] & 0x7FFFFFF0) + kit - psmMMarker;
                                    ) :
                                    /*
                                    ((kit >= psmMSyncNo) && (kit < psmMenuSynchroEnd)) ? (
                                        da[lppEMetro] = kit - psmMSyncNo;
                                    ) :
                                    */
                                    (kit === psmMMVLeft) ? (
                                        // move left the cell
                                        alt = (zzmcl + clESize - 1) % clESize;
                                        zzmcl === lppLoop1 ? alt1 = alt;
                                        zzmcl === lppLoop2 ? alt2 = alt;
                                        alt === lppLoop2 ? alt2 = zzmcl;
                                        alt === lppLoop1 ? alt1 = zzmcl;
                                        it = clTabE[zzmcl]; clTabE[zzmcl] = clTabE[alt]; clTabE[alt] = it;
                                    ) :
                                    (kit === psmMMVRight) ? (
                                        // move right the cell
                                        alt = (zzmcl + 1) % clESize;
                                        zzmcl === lppLoop1 ? alt1 = alt;
                                        zzmcl === lppLoop2 ? alt2 = alt;
                                        alt === lppLoop2 ? alt2 = zzmcl;
                                        alt === lppLoop1 ? alt1 = zzmcl;
                                        it = clTabE[zzmcl]; clTabE[zzmcl] = clTabE[alt]; clTabE[alt] = it;
                                    ) :
                                    (kit === psmMMVUp) ? (
                                        // move up the cell
                                        alt = (zzmcl + clESize - padPlayStoreNC) % clESize;
                                        zzmcl === lppLoop1 ? alt1 = alt;
                                        zzmcl === lppLoop2 ? alt2 = alt;
                                        alt === lppLoop2 ? alt2 = zzmcl;
                                        alt === lppLoop1 ? alt1 = zzmcl;
                                        it = clTabE[zzmcl]; clTabE[zzmcl] = clTabE[alt]; clTabE[alt] = it;
                                    ) :
                                    (kit === psmMMVDown) ? (
                                        // move up the cell
                                        alt = (zzmcl + padPlayStoreNC) % clESize;
                                        zzmcl === lppLoop1 ? alt1 = alt;
                                        zzmcl === lppLoop2 ? alt2 = alt;
                                        alt === lppLoop2 ? alt2 = zzmcl;
                                        alt === lppLoop1 ? alt1 = zzmcl;
                                        it = clTabE[zzmcl]; clTabE[zzmcl] = clTabE[alt]; clTabE[alt] = it;
                                    ) :
                                    ((k = (kit === psmMPshLeft)) || (kit === psmMPshRight)) ? (
                                        // push the cell left or right
                                        inc = k ? -1 : 1; i = zzmcl;
                                        val = clTabE[i]; clTabE[i] = -1;
                                        while (val >= 0) (
                                            k = (i + inc + clESize) % clESize;
                                            i === lppLoop1 ? alt1 = k;
                                            i === lppLoop2 ? alt2 = k;
                                            nv = clTabE[k]; clTabE[k] = val; val = nv; i = k;
                                        );
                                    ) :
                                    (kit === psmOptInact) ? (
                                        // toggle active/inactive...
                                        it = da[lppEFlgs];
                                        (da[lppEFlgs] & lppEFlgInact) ? (
                                            da[lppEFlgs] &= -1 ~ lppEFlgInact;
                                            (da[lppEType] === 0) ? da[lppEType] = 1;
                                        ) : (
                                            da[lppEFlgs] |= lppEFlgInact;
                                        );
                                        padPlayStoreMDate = 0;
                                        yy = ui_menu_ent(menu_Pad_psm, xx);
                                        0 ? (
                                            sprintf(#sfc, "(in)active (%d/%d)  [kit: %d => %d]  %x => %x", zzmcl, da, kit, yy, it, da[lppEFlgs]);
                                            mSL_log(SysLogBox, #sfc);
                                        );
                                    ) :
                                    (kit === psmOptLppnt) ? (
                                        (lppLoop1 === zzmcl) ? ( lppLoop1 = - 1; ) :
                                        (lppLoop2 === zzmcl) ? ( lppLoop2 = - 1; ) :
                                        ( (lppLoop1 < 0) ? (lppLoop1 = zzmcl) : (lppLoop2 = lppLoop1; lppLoop1 = zzmcl;) ; );
                                    ) :
                                    (kit === psmMenuTypeEnd) ? (
                                        da[lppEType] = (da[lppEType] + 1) % 7 ;
                                        da[lppEFlgs] &= -1 ~ lppEFlgInact; // untoggle "inactive"
                                    ) :
                                    (kit === psmLOCpy) ? (
                                        // copy
                                        playMarkCopy = da;
                                    ) :
                                    (kit === psmLODup) ? (
                                        // duplicate
                                        playMarkCopy = da;
                                        is = zzmcl; it = 0; while (it <= padPlayStoreSiz) (
                                            (clTabE[is] <= 0) ? (
                                                clTabE[is] = copyBlock(playMarkCopy);
                                                it = padPlayStoreSiz;
                                                padPlayStoreMod = is;
                                            );  is = (is + 1) % padPlayStoreSiz; it = it + 1;
                                        );
                                    ) :
                                    (kit === psmLOCut) ? (
                                        // cut
                                        (playMarkDelete > 0) ? (
                                            freeLstBlock(playMarkDelete);
                                        );
                                        playMarkDelete = playMarkCopy = da;
                                        clTabE[zzmcl] = -1;
                                    ) :
                                    (kit === psmLOPst) ? (
                                        // paste ?
                                        (playMarkCopy > 0) ? (
                                            (playMarkDelete > 0) ? (
                                                freeLstBlock(playMarkDelete);
                                            );
                                            playMarkDelete = clTabE[zzmcl];
                                            clTabE[zzmcl] = ent = copyBlock(playMarkCopy);
                                            0 ? (
                                                sprintf(#dbg_trace3, "copyBlock(%d) => (%d), k = %d  %s  //  %d  %s", playMarkCopy, ent,
                                                0 | (playMarkCopy[2] / twoPow32), mSL_edit_value(#s, playMarkCopy[2]%twoPow32),
                                                0 | (ent[2] / twoPow32), mSL_edit_value(#t, ent[2]%twoPow32));
                                                s = playMarkCopy;
                                                sprintf(#dbg_trace4, "DA: %d %d %d %d %d %.3f %.3f %.3f %.3f %.3f %d %d",
                                                s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
                                                s = ent;
                                                sprintf(#dbg_trace5, "CP: %d %d %d %d %d %.3f %.3f %.3f %.3f %.3f %d %d",
                                                s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
                                            );
                                        );
                                    ) :
                                    (kit === psmEdit0) ? (
                                        inc = 0.001;
                                    ) :
                                    (kit === psmEdit1) ? (
                                        inc = 0.01;
                                    ) :
                                    (kit === psmEdit2) ? (
                                        inc = 0.1;
                                    ) :
                                    (kit === psmEdit3) ? (
                                        inc = 1;
                                    ) :
                                    (kit === psmEdit4) ? (
                                        inc = 10;
                                    ) :
                                    (kit === psmEdit5) ? (
                                        inc = 60;
                                    ) :
                                    (kit === psmEdit6) ? (
                                        inc = 300;
                                    ) :
                                    (kit === psmEdit7) ? (
                                        inc = 1800;
                                    ) :
                                    (kit === psmEdit8) ? (
                                        inc = -0.001;
                                    ) :
                                    (kit === psmEdit9) ? (
                                        inc = -0.01;
                                    ) :
                                    (kit === psmEdit10) ? (
                                        inc = -0.1;
                                    ) :
                                    (kit === psmEdit11) ? (
                                        inc = -1;
                                    ) :
                                    (kit === psmEdit12) ? (
                                        inc = -10;
                                    ) :
                                    (kit === psmEdit13) ? (
                                        inc = -60;
                                    ) :
                                    (kit === psmEdit14) ? (
                                        inc = -300;
                                    ) :
                                    (kit === psmEdit15) ? (
                                        inc = -1800;
                                    ) :
                                    (kit === psmEdit16) ? (
                                        ivs = 0.001;
                                    ) :
                                    (kit === psmEdit17) ? (
                                        ivs = 0.01;
                                    ) :
                                    (kit === psmEdit18) ? (
                                        ivs = 0.1;
                                    ) :
                                    (kit === psmEdit19) ? (
                                        ivs = 1;
                                    ) :
                                    (kit === psmEdit20) ? (
                                        ivs = 10;
                                    ) :
                                    (kit === psmEdit21) ? (
                                        ivs = 60;
                                    ) :
                                    (kit === psmEdit22) ? (
                                        ivs = 300;
                                    ) :
                                    (kit === psmEdit23) ? (
                                        ivs = 1800;
                                    ) :
                                    (alt1 >= 0) ? lppLoop1 = alt1;
                                    (alt2 >= 0) ? lppLoop2 = alt2;
                                    (inc != 0) ? (
                                        da[lppEDate] = max(0, min(da[lppEDate]+inc, playTimeMax));
                                        padPlayStoreMDate = pTBlockStart + 16;
                                    );
                                    (ivs != 0) ? (
                                        da[lppEDate] = (0|((da[lppEDate]+ivs/2) / ivs)) * ivs;
                                        padPlayStoreMDate = pTBlockStart + 16;
                                    );
                                );
                            ) : (
                                xpos = -1; is = zzmcl;
                                (jmc === 0x10) ? (
                                    axion = is+1;
                                    /*
                                    // play a vertical sequence
                                    while ((da > 0) && (is < clESize)) (
                                        ty = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType]; // type of entry OR inactive
                                        ((ty === 1) && (xpos < 0)) ? xpos = da;
                                        ((ty > 1) && (ty <= 8)) ? (
                                            SchedAddTask(13, da, 1, gfxStartTime, 0, 0, zzmcl); // 1 is for "init"
                                        );
                                        is += padPlayStoreNL;
                                        da = (is < clESize) ? clTabE[is] : 0;
                                    );
                                    (xpos > 0) ? (replayEntry = 0; pPlayTimeCurrent = markerDate(xpos); setPModePlay(););
                                    */
                                ) :
                                (jmc === 0x04) ? (
                                    axion = is+1;
                                    /*
                                    // play an horizontal sequence
                                    it = 1;
                                    while ((da > 0) && (it !== 0)) (
                                        ty = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType]; // type of entry OR inactive
                                        ((ty === 1) && (xpos < 0)) ? xpos = da;
                                        ((ty > 1) && (ty <= 8)) ? (
                                            SchedAddTask(13, da, 1, gfxStartTime, 0, 0, zzmcl); // 1 is for "init"
                                        );
                                        is += 1; it = is % padPlayStoreNC;
                                        da = (is < clESize) ? clTabE[is] : 0;
                                    );
                                    (xpos > 0) ? (replayEntry = 0; pPlayTimeCurrent = markerDate(xpos); setPModePlay(););
                                    */
                                );
                            );
                        ) : (
                            (jmc === 0x20) ? (
                                // cmd-alt-cd = invert read direction first
                                playModeSpeed = parSet(p_VirtTimSpeed, -playModeSpeed);
                                playReeval = 1;
                            );
                            // cd : toggle play mode
                            setPModeSwitch();
                        );
                    );

                );



                (zzmi) ? (
                    inc = 0;
                    (zzch = do_GenericKeyRead()) ? (
                        (zzch === 'p') ? (
                            setPModeSwitch();
                        ) :
                        (zzch === 'q') ? (
                            playReeval = 1;
                            setPModeSwitch();
                        ) :
                        (zzch === 'a') ? (
                            parSet(p_GvAutoMd, ! paramValues[p_GvAutoMd]); // and stop playing
                        ) :
                        (zzch === 'r') ? (
                            setRModeSwitch();
                        ) :
                        (zzch === 'k') ? (
                            playAndLock ? SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all;
                            playAndLock = ! playAndLock ;
                        ) :
                        (zzch === 'u') ? (
                            playAndUnLock = ! playAndUnLock ;
                            playAndUnLock ? SchedAddTask(5, 2, -1, -1, 0, 0, 0); // unLock all;
                        ) :
                        (zzch === 'j') ? (
                            playJmpLoop = ! playJmpLoop ;
                        ) :
                        (zzch === 'l') ? (
                            playRepeatMd = ! playRepeatMd ;
                        ) :
                        (zzch === 'g') ? (
                            recOptMarkReplay = ! recOptMarkReplay ;
                        ) :
                        (zzch === 'i') ? (
                            // invert read direction
                            playModeSpeed = parSet(p_VirtTimSpeed, -playModeSpeed);
                            playReeval = 1;
                        ) :
                        (zzch === 'w') ? (
                            // various play speed
                            playModeSpeed = parSet(p_VirtTimSpeed, playSpeedVals[playSpeedPtr = (playSpeedPtr + 1) % 11]);
                            playReeval = 1;
                        ) :
                        (zzch === 's') ? (
                            playModeStep = ! playModeStep ;
                            playReeval = 1;
                        ) :
                        (zzch === 't') ? (
                            recOptRecReplay = ! recOptRecReplay ;
                        ) :
                        (zzch === 'h') ? (
                            setRModeStop();
                            setPModeStop();
                        ) :
                        (zzch === 'm') ? (
                            replayUnMute = ! replayUnMute;
                        ) :
                        (zzch === 'o') ? (
                            recOptLockSnds = ! recOptLockSnds;
                        ) :
                        (zzch === 'z') ? (
                            parSet(p_GvAutoMd, 0);
                            doActivePlayer(-1, KmdQStop, 0); BPLSTClear();
                            setPModeStop();
                        ) :
                        (zzch === 'e') ? (
                            playSkipSlnc = ! playSkipSlnc ;
                        ) :
                        ((zzch >= '0') && (zzch <= '9')) ? (
                            // goto marker "n"
                            axion = zzch - '0' + 1; // 1 to 10
                        ) :
                        (zzch === 'left') ? (
                            inc = (jmc === 0x00) ? -1 : (jmc === 0x04) ? -0.1 : (jmc === 0x10) ? -0.01 : (jmc === 0x14) ? -0.001 : -1 ;
                        ) :
                        (zzch === 'rght') ? (
                            inc = (jmc === 0x00) ? 1 : (jmc === 0x04) ? 0.1 : (jmc === 0x10) ? 0.01 : (jmc === 0x14) ? 0.001 : 0;
                        ) :
                        (zzch === 'up') ? (
                            inc = (jmc === 0x00) ? 10 : (jmc === 0x04) ? 60 : (jmc === 0x10) ? 300 : (jmc === 0x14) ? 1800 : 0;
                        ) :
                        (zzch === 'down') ? (
                            inc = (jmc === 0x00) ? -10 : (jmc === 0x04) ? -60 : (jmc === 0x10) ? -300 : (jmc === 0x14) ? -1800 : 0;
                        ) :
                        (
                            Keyed = zzch; // keep the char, we didn't use it
                        );
                        (inc != 0) ? (
                            gmem[playLogDate] = pPlayTimeCurrent = parSet(p_VirtualTime, max(ppb_VirtualTime[pp_Min], min(ppb_VirtualTime[pp_Max], pPlayTimeCurrent + inc)));
                            playReeval = 1;
                        );
                    );
                );

                axion ? (
                    ((axion > 0) && (axion <= clESize)) ? (
                        da = clTabE[is = axion - 1];
                        xpos = -1;
                        ((jmc & 0x14) === 0x14) ? (
                            // play an horizontal sequence
                            it = 1;
                            while ((da > 0) && (it !== 0)) (
                                ty = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType]; // type of entry OR inactive
                                ((ty === 1) && (xpos < 0)) ? xpos = da;
                                ((ty > 1) && (ty <= 8)) ? (
                                    SchedAddTask(13, da, 1, gfxStartTime, 0, 0, zzmcl); // 1 is for "init"
                                );
                                is += 1; it = is % padPlayStoreNC;
                                da = (is < clESize) ? clTabE[is] : 0;
                            );
                            (xpos > 0) ? (replayEntry = 0; pPlayTimeCurrent = markerDate(xpos); setPModePlay(););
                        ) :
                        ((jmc & 0x14) === 0x10) ? (
                            // play a vertical sequence
                            while ((da > 0) && (is < clESize)) (
                                ty = (da[lppEFlgs] & lppEFlgInact) ? 0 : da[lppEType]; // type of entry OR inactive
                                ((ty === 1) && (xpos < 0)) ? xpos = da;
                                ((ty > 1) && (ty <= 8)) ? (
                                    SchedAddTask(13, da, 1, gfxStartTime, 0, 0, zzmcl); // 1 is for "init"
                                );
                                is += padPlayStoreNL;
                                da = (is < clESize) ? clTabE[is] : 0;
                            );
                            (xpos > 0) ? (replayEntry = 0; pPlayTimeCurrent = markerDate(xpos); setPModePlay(););
                        ) : (
                            ((jmc & 0x14) === 0x04) ? (
                                da = clTabE[is = (axion - 1) * padPlayStoreNC];
                            );
                            // go to a specific position
                            (da > 0) ? (
                                ty = da[lppEType]; // type of entry
                                (ty === 1) ? (
                                    replayJumpTo(PlLogCurrent, markerDate(da), playModeSpeed);
                                    setPModePlay();
                                ) :
                                (ty > 1 ) ? (
                                    SchedAddTask(13, da, 1, gfxStartTime, 0, jmc, zzmcl); // 1 is for "init"
                                );
                            );
                        );
                    );
                );



            ui_pop();

            do_ModuleKeySave();

        ui_pop();
    );
);



function show_Presets()
local (h1, h2, h3, uix_jneed, uix_jmini, ig, jmc, zz, zzmi)
(
    h1 = uix_jpadHeight(1); // height
    uix_jneed = uix_jmini = h1+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockPreset);

            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockPreset]]);

            ui_pad(1,1,3,2);
            ui_split_top(h1);
                ui_pad(0,1,0,0);
                mSL_setStrArray(padPresetsLabs, padPresetsSiz);
                ig = 0; loop(padPresetsSiz,
                    padPresetsColrs[ig] = Col_Inactive;
                    ig+=1;
                );

                padPresetsLabs[0] = "Save Mode";
                padPresetsColrs[0] = Col_Cmnds;

                padPresetsLabs[1] = "Standard";
                padPresetsColrs[1] = Color_Clear_Yellow;

                zz = control_jpad(padPresetsp);
                zz ? (
                    ui_GFXdoNow |= 1;
                );

            ui_pop();
            do_ModuleKeySave();
        ui_pop();
    );
);



<? include("GM-Libs/mSL_Dbg_Memory.jsfx-inc"); ?>

function dyn_get_par(pad, pn)
(
    (pad < 0) ? gmem[- pad + pn - p_Dyn_First] :
        (pad > 0) ? pad[pn - p_Dyn_First] :
            paramValues[pn] ;
);

function dyn_set_par(pad, pn, val)
(
    (pad < 0) ? (gmem[- pad + pn - p_Dyn_First] = val) :
        (pad > 0) ? (pad[pn - p_Dyn_First] = val) :
            parSet(pn, val);
);

function dyn_copy_set(dst, src)
local (ig, ip)
(
    (currCpMode === 0) ? (
        ig = 0;
    ) : (
        ig = 3;
    ) ;
    ig = 0; while(ig < paramDynSiz) (
        ip = paramDynNums[ig];
        dyn_set_par(dst, ip, dyn_get_par(src, ip));
        ig += 1;
    );
    (currCpMode === 2) ? (
        dyn_set_par(dst, p_Dyn_Type, dyn_get_par(src, p_Dyn_Type));
        dyn_set_par(dst, p_Dyn_Flgs1, (dyn_get_par(src, p_Dyn_Flgs1) & dyn_And_Mask) | dyn_Or_Mask);
        dyn_set_par(dst, p_Dyn_Flgs2, (dyn_get_par(src, p_Dyn_Flgs2) & dyn_And_Mask) | dyn_Or_Mask);
    );
);


//====== Dynamic Parameters
function
show_Dyn_pars()
local(h1, h2, h3, h4, h5, uix_jmini, uix_jneed, zzmi, zzch, zzmcl, zzmmd, zzent, pa, paty, jmc, ig,
    ih, p, v, x, y, ik, psrc, f1, f2, flgm, chz)
(
    h1 = uix_jpadHeight(padDynParNL); // height
    h2 = uix_jpadHeight(padDynFlgNL) * 0.9; // height
    h3 = uix_jBoxHeight(1) + ui_jd_delta2;
    h4 = ui_jd_slidh + ui_jd_delta2;
    h5 = uix_jpadHeight(padDynPrstNL);
    Col3 = Color_Bright_Turquoise; // Color_Amethyst;
    Col4 = Color_Bondi_Blue; // Color_Cadet_Blue_B;
    uix_jmini = uix_jneed = h1+h2+h3+h4+h5+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockDynPars);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
                ui_GFXdoNow |= 1; // keep interaction
            );
            control_group(blockDispNames[blockDispInverts[blockDynPars]]);

            (zzmi) ? (
                u_ch = do_GenericKeyRead();
                (u_ch != 0) ? (
                    (u_ch === 'A') ? DynParamModulate(0, 2, 0) :
                    (u_ch === 'Z') ? DynParamModulate(0, 5, 0) :
                    (u_ch === 'E') ? DynParamModulate(0, 10, 0) :
                    (u_ch === 'R') ? DynParamModulate(0, 25, 0) :
                    (u_ch === 'T') ? DynParamModulate(0, 50, 0) :
                    (u_ch === 'Y') ? DynParamModulate(0, 75, 0) :
                    (u_ch === 'I') ? (
                        interType = 1;
                        (interMod != 0) ? (
                            ppb_Interact[pp_Min] = -1;
                            ppb_Interact[pp_SavedMax] = ppb_Interact[pp_Max] = 1;
                        );
                    ) :
                    (u_ch === 'X') ? (
                        interType = 2;
                        (interMod != 0) ? (
                            ppb_Interact[pp_Min] = -3;
                            ppb_Interact[pp_SavedMax] = ppb_Interact[pp_Max] = 3;
                        );
                    ) :
                    (Keyed = u_ch;);  // u_ch has not been used
                );
            );

            (currLastDate + 30 < tUnix) ? (currLastSet = -1);
            (currVal & currUpdt) ? (
                // the selected "Sound Units" cell has been changed - save previous
                (((currUAddPrev != 0) && (currplayerPrev == - (gmem[currUAddPrev+cbPlIdt] + 1))
                && (currclipPrev == gmem[currUAddPrev+RCB_ClipNb])
                && (currclcntPrev == gmem[currUAddPrev+cbClipCnt])
                && (uSEditing == gmem[currUAddPrev+cbStat]))) ? (
                    // we do save the current status of the previous reader if edit mode
                    gmem[currUAddPrev+RCB_State_Changed] = i_M_Upd | 2;
                    gmem[currUAddPrev+cbStat] = uSSaving;
                );
                currUpdt = 0;
            );

            // Main Control Pannel
            ui_split_top(h1);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padDynParLabs, padDynParSiz);
                xtval = (ffshow == 1) ? ((ffmode === 0) ? f1 : ((f1 & dyn_And_Mask) | dyn_Or_Mask)) :
                        (ffshow == 2) ? ((ffmode === 0) ? f2 : ((f2 & dyn_And_Mask) | dyn_Or_Mask)) :
                        (ffshow == 3) ? dyn_And_Mask :
                        (ffshow == 4) ? dyn_Or_Mask : 0;
                ig = 0; loop(padDynParSiz,
                    padDynParColrs[ig] = Col_Inactive;
                    ig +=1;
                );

                (currcell < 0) ? (
                    // Address still valid ?
                    ! ((currxAdd != 0) && (currcell == - (gmem[currxAdd+cbPlIdt] + 1))
                        && (currxcnt == gmem[currxAdd+cbClipCnt])) ? (
                            currcell = 0; currpad = 0;
                    );
                );
                y = (currcell < 0) ? Col_InfoC : (currcell > 0) ? Col_InfoB : Col_Cmnds ;
                sprintf(padDynParLabs[0], "Config. %d", currcell);
                padDynParColrs[0] = y;

                sprintf(padDynParLabs[1], "%d ▶︎ %04d", - currplayer, currclip);
                padDynParColrs[1] = (currpmode === KmdPlay) ? U4_16 : (currpmode === KmdLoop) ? U5_16 : Col_Cmnds;
                (currVal = ((currUAdd != 0) && (currplayer == - (gmem[currUAdd+cbPlIdt] + 1))
                    && (currclip == gmem[currUAdd+RCB_ClipNb])
                    && (currclcnt == gmem[currUAdd+cbClipCnt]))) ? (
                        // la cellule est encore valide
                        padDynParCells[1] &= mSL_Max_Flgs ~ ui_jpad_ct_disab;
                ) : (
                    padDynParCells[1] |= ui_jpad_ct_disab;
                );

                strcpy(padDynParLabs[2], (currCpMode === 0) ? "Copy All" : (currCpMode === 1) ? "Copy Par" : "Copy Mod");
                padDynParColrs[2] = (currCpMode === 0) ? Color_Dark_Orange : (currCpMode === 1) ? Color_Heliotrope : Col3;

                f1 = dyn_get_par(currpad, p_Dyn_Flgs1);
                sprintf(padDynParLabs[3], "F1: %06X", f1);
                padDynParColrs[3] = Color_Dark_Orange;

                f2 = dyn_get_par(currpad, p_Dyn_Flgs2);
                sprintf(padDynParLabs[4], "F2: %06X", f2);
                padDynParColrs[4] = Color_Bright_Green ;

                sprintf(padDynParLabs[5], "And: %06X", dyn_And_Mask);
                padDynParColrs[5] = Col3 ;

                sprintf(padDynParLabs[6], "Or: %06X", dyn_Or_Mask);
                padDynParColrs[6] = Col4 ;

                v = (ffshow == 1) ? Color_Dark_Orange : (ffshow == 2) ? Color_Bright_Green :
                      (ffshow == 3) ? Col3 : (ffshow == 4) ? Col4 : Color_Deep_Brown;
                (ffdisp === 0) ? (
                    padDynParW[ui_jpad_color2] = -1 ;
                    strcpy(padDynParLabs[7], paramDynIds[kcell]);
                    (!(xtval & uix_bit_set[kcell])) ? v = ui_pcol_fade(v,0.7,0.6);
                ) :
                (
                    //padDynParW[ui_jpad_color2] = Color_Blue_Violet ;
                    (ffshow == 1) ? (
                        sprintf(padDynParLabs[7], (ffmode ? "F1=>%06X" : "F1: %06X"), xtval);
                        v = Color_Dark_Orange;
                    ) :
                    (ffshow == 2) ? (
                        sprintf(padDynParLabs[7], (ffmode ? "F2=>%06X" : "F2: %06X"), xtval);
                        v = Color_Bright_Green;
                    ) :
                    (ffshow == 3) ? (
                        sprintf(padDynParLabs[7], "And: %06X", xtval);
                        v = Col3;
                    ) :
                    (ffshow == 4) ? (
                        sprintf(padDynParLabs[7], "Or: %06X", xtval);
                        v = Col4;
                    ) :
                    (
                        (!(xtval & uix_bit_set[kcell])) ? v = ui_pcol_fade(v,0.7,0.6);
                        strcpy(padDynParLabs[7], paramDynIds[kcell]);
                    );
                );
                padDynParColrs[7] = v;

                zz = control_jpad(padDynParW);
                (zz > 0) ? (
                    zzch = padDynParW[ui_jpad_lkey];
                    zzent = padDynParW[ui_jpad_entkey]-1;
                    zzmcl = padDynParW[ui_jpad_last]-1;
                    zzmmd = padDynParW[ui_jpad_lmods];

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch; // keep the char
                        (zzent === 0) ? (
                            (zzch === 'c') ? (
                                // copy current currpad
                                dyn_copy_set(paramDynCopy65, currpad);
                                1 ? (sprintf(#sfc, "Pd. %d Copied", currcell); mSL_log(SysLogBox, #sfc););
                            ) :
                            (zzch === 'v') ? (
                                // paste to currpad
                                dyn_copy_set(currpad, paramDynCopy65);
                                1 ? (sprintf(#sfc, "Pd. %d Pasted", currcell); mSL_log(SysLogBox, #sfc););
                            ) :
                            (zzch === 'z') ? (
                                currcell =  0;
                            ) :
                            (zzch === 'd') ? (
                                currcell =  68;
                            ) :
                            (zzch === 'p') ? (
                                currcell =  65;
                            ) :
                            (zzch === 'q') ? (
                                currcell =  66;
                            ) :
                            (zzch === 'r') ? (
                                currcell =  67;
                            ) :
                            (zzch === 's') ? (
                                currcell =  68;
                            ) :
                            ((zzch === '+') || (zzch === '=')) ? (
                                currcell = (max(0, currcell + 1)) % (padDynPrstSizT);
                            ) :
                            ((zzch === '-') || (zzch === '_') || (zzch === ':')) ? (
                                currcell = (max(0, currcell - 1 + padDynPrstSizT)) % (padDynPrstSizT);
                            ) ;
                            (currcell === 0) ? (currpad = 0) :
                            ((currcell > 0) && (currcell < (padDynPrstSizT))) ? (currpad = arrDyns + (currcell - 1) * paramDynSiz);

                        ) :
                        (zzent === 1) ? (
                            (zzch === 'c') ? (
                                // copy if valid
                                (currVal && (currDPars < 0)) ? (
                                    dyn_copy_set(paramDynCopy65, currDPars);
                                    1 ? (sprintf(#sfc, "Cl. %d Copied", currcell); mSL_log(SysLogBox, #sfc););
                                )
                            ) :
                            (zzch === 'v') ? (
                                // paste to clip if valid
                                (currVal && (currDPars < 0)) ? (
                                    dyn_copy_set(currDPars, paramDynCopy65);
                                    1 ? (sprintf(#sfc, "Cl. %d Pasted", currcell); mSL_log(SysLogBox, #sfc););
                                );
                            ) :
                            (zzch === 's') ? ( // save right now
                                (currVal && (currDPars < 0)) ? (
                                    gmem[currUAdd+RCB_State_Changed] = i_M_Upd | 2;
                                    1 ? (sprintf(#sfc, "Cl. %d Saving", currcell); mSL_log(SysLogBox, #sfc););
                                    // stop resetting the value
                                    currVal = currcell = currpad = 0;
                                );
                            ) :
                            (zzch === 'i') ? ( // install in clip and save right now
                                (currVal && (currDPars < 0)) ? (
                                    gmem[currUAdd+RCB_PM_Flgs1] = gmem[currUAdd+RCB_PM_Flgs2] = 0;
                                    gmem[currUAdd+RCB_State_Changed] = i_M_Upd | i_M_Rcd;
                                    1 ? (sprintf(#sfc, "Cl. %d Installing", currcell); mSL_log(SysLogBox, #sfc););
                                    // stop resetting the value
                                    currVal = currcell = currpad = 0;
                                );
                            ) :
                            (zzch === 'a') ? ( // abend edit
                                (currVal && (currDPars < 0)) ? (
                                    gmem[currUAdd+RCB_State_Changed] = i_M_Upd | 0;
                                    1 ? (sprintf(#sfc, "Cl. %d Abend", currcell); mSL_log(SysLogBox, #sfc););
                                    currVal = currcell = currpad = 0;
                                );
                            ) ;
                        ) :
                        (zzent === 2) ? (
                            (zzch === 'a') ? (
                                currCpMode = 0;
                            ) :
                            (zzch === 'p') ? (
                                currCpMode = 1;
                            ) :
                            (zzch === 'm') ? (
                                currCpMode = 2;
                            );
                            ((zzch === '+') || (zzch === '=')) ? (
                                currCpMode = (currCpMode + 1) % 3;
                            );
                        ) :
                        (zzent === 3) ? (
                            (zzch === 'z') ? (
                                dyn_set_par(currpad, p_Dyn_Flgs1, 0);
                            ) :
                            (zzch === 'f') ? (
                                dyn_set_par(currpad, p_Dyn_Flgs1, mSL_Dyn_Flg1_def);
                            );
                        ) :
                        (zzent === 4) ? (
                            (zzch === 'z') ? (
                                dyn_set_par(currpad, p_Dyn_Flgs2, 0);
                            ) :
                            (zzch === 'f') ? (
                                dyn_set_par(currpad, p_Dyn_Flgs2, mSL_Dyn_Flg2_def);
                            );
                        ) :
                        (zzent === 5) ? (
                            (zzch === 'z') ? (
                                dyn_And_Mask = 0;
                            ) :
                            (zzch === 'f') ? (
                                dyn_And_Mask = mSL_Dyn_Mask_def;
                            );
                        ) :
                        (zzent === 6) ? (
                            (zzch === 'z') ? (
                                dyn_Or_Mask = 0;
                            ) :
                            (zzch === 'f') ? (
                                dyn_Or_Mask = mSL_Dyn_Mask_def;
                            );
                        ) :
                        (zzent === 7) ? (
                            (zzch === 'x') ? (
                                // alternate "show mode"
                                (ffmode = !ffmode) ? (
                                    padDynParCells[7] |= ui_jpad_ct_selec;
                                ) : (
                                    padDynParCells[7] &= ui_jpad_ct_UNselec;
                                );
                            ) :
                            (zzch === 't') ? (
                                // alternate "show mode"
                                ffdisp = !ffdisp;
                            );
                        );
                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            currcell = (max(0, currcell - 1 + padDynPrstSizT)) % padDynPrstSizT;
                        ) :
                        (zzmcl === 1) ? (
                            // select "clip" entry
                            currpad = currDPars;
                            currcell = currplayer;
                            currxcnt = currclcnt;
                            currxAdd = currUAdd;
                        ) :
                        (zzmcl === 2) ? (
                            // change curr copy mode
                            currCpMode = (currCpMode + 2) % 3;
                        ) :
                        (zzmcl === 3) ? (
                            // select F1
                            ffshow = 1;
                        ) :
                        (zzmcl === 4) ? (
                            // select F2
                            ffshow = 2;
                        ) :
                        (zzmcl === 5) ? (
                            // select F3
                            ffshow = 3;
                        ) :
                        (zzmcl === 6) ? (
                            // select F4
                            ffshow = 4;
                        ) :
                        (zzmcl === 7) ? (
                            // alternate "show mode"
                            ffdisp = !ffdisp;
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            currcell = (max(0, currcell + 1)) % padDynPrstSizT;
                        ) :
                        (zzmcl === 1) ? (
                            // Try to rerun the clip
                            currVal ? (gmem[currUAdd+RCB_State_Changed] |= i_M_Rst);
                        ) :
                        (zzmcl === 2) ? (
                            // change curr mode
                            currCpMode = (currCpMode + 1) % 3;
                        ) :
                        (zzmcl === 3) ? (
                            // unselect F1
                            ffshow = 0;
                        ) :
                        (zzmcl === 4) ? (
                            // unselect F2
                            ffshow = 0;
                        ) :
                        (zzmcl === 5) ? (
                            // unselect F3
                            ffshow = 0;
                        ) :
                        (zzmcl === 6) ? (
                            // unselect F4
                            ffshow = 0;
                        ) :
                        (zzmcl === 7) ? (
                            // alternate "show mode"
                            (ffmode = !ffmode) ? (
                                padDynParCells[7] |= ui_jpad_ct_selec;
                            ) : (
                                padDynParCells[7] &= ui_jpad_ct_UNselec;
                            );
                        );
                    );

                    parSet(p_Interact, dyn_get_par(currpad, prn));
                );

            ui_pop();





            // Edit an hexadecimal value (FLM1 / FLM2)
            ui_split_top(h2);
                ui_pad(1,0,3,0);
                (shcell = ui_hover()) ? (
                    ui_push();
                        ui_color(Col_SubFrame);
                        ui_border();
                    ui_pop();
                );
                ui_pad(0,4,0,6);
                shcell ? (   // get a bit in 0 .. padDynFlgNC - 1
                    k = max(0, min(padDynFlgNC - 1, padDynFlgNC - floor(0.7 + (uix_mouse_x - ui_left())/(0.98 * (ui_right() - ui_left())) * padDynFlgNC)));
                    (k != kcell) ? (
                        kcell = k;
                    );
                );
                xtval = (ffshow == 1) ? f1 : (ffshow == 2) ? f2 : (ffshow == 3) ? dyn_And_Mask : (ffshow == 4) ? dyn_Or_Mask : 0;
                ColX = (ffshow == 1) ? Color_Dark_Orange : (ffshow == 2) ? Color_Bright_Green :
                    (ffshow == 3) ? Col3 : (ffshow == 4) ? Col4 : Color_Deep_Brown;
                mSL_setStrArray(padDynFlgLabs, padDynParSiz);
                ig = 0; loop(padDynFlgSiz,
                    ih = padDynFlgNC - ig - 1;
                    padDynFlgVals[ig] = k = (xtval & uix_bit_set[ih]) != 0;
                    padDynFlgColrs[ig] = k ? ColX : Col_Inactive;
                    ig += 1;
                );

                zz = control_jpad(padDynFlgW);
                (zz > 0) ? (
                    zzch = padDynFlgW[ui_jpad_lkey];
                    zzent = padDynFlgW[ui_jpad_entkey]-1;
                    zzmcl = padDynFlgW[ui_jpad_last]-1;
                    zzmmd = padDynFlgW[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        padDynFlgVals[zzmcl] =  ! padDynFlgVals[zzmcl];
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        // select one parameter associated to this bit
                        ih = padDynFlgNC - zzmcl - 1; prn = paramDynNums[ih];
                        clone_parameter(p_Interact, prn); parSet(p_Interact, dyn_get_par(currpad, prn)); cpsrc = prn;
                        0 ? (sprintf(#uuu, "rmc : ih %d prn %d", ih, prn);
                            mSL_log(SysLogBox, #uuu););
                    );

                    // Rebuild value
                    xtval = 0;
                    ig = 0; loop(padDynFlgSiz,
                        ih = padDynFlgNC - ig - 1;
                        padDynFlgVals[ig] ? (xtval |= uix_bit_set[ih]);
                        ig += 1;
                    );
                    (ffshow == 1) ? (
                        dyn_set_par(currpad, p_Dyn_Flgs1, xtval)
                    ) :
                    (ffshow == 2) ? (
                        dyn_set_par(currpad, p_Dyn_Flgs2, xtval)
                    ) :
                    (ffshow == 3) ? (
                        dyn_And_Mask = xtval;
                    ) :
                    (ffshow == 4) ? (
                        dyn_Or_Mask = xtval;
                    );
                );
            ui_pop();






            // Display parameters values of current entry
            ui_split_top(h3);
                ui_hover() ? (
                    (jmc == 0) ? (
                        (KeyedT === 'left') ? (iKPar = (iKPar + paramDynCnt - 1) % paramDynCnt; KeyedT = 0; ) :
                        (KeyedT === 'rght') ? (iKPar = (iKPar + 1) % paramDynCnt; KeyedT = 0; ) ;
                    );
                );
                ui_pad(1,2,3,2);
                ik = iKPar;
                ig = 0; loop (4,
                    (ig === 0) ? ui_new_column(1/4) : ui_new_column();
                    chz = 0;
                    ui_hover() ? (
                        ui_push();
                            ui_color(Col_SubFrame);
                            ui_border();
                        ui_pop();
                        (jmc & 2) ? chz = 1; // right clicked on this cell
                    );
                    prn = paramDyn[ik];
                    ui_show(parGetPP(prn, pp_Name), (v = dyn_get_par(currpad, prn)), parGetPP(prn, pp_SFmt));
                    // Clicked ?
                    chz ? (chz = 0; clone_parameter(p_Interact, prn); parSet(p_Interact, v); cpsrc = prn; interMod = 0;);
                    ig += 1;
                    ik = (ik + 1) % paramDynCnt;
                );

                ui_pop();

            ui_pop();





            // Display  slider associated with current selected parameter
            ui_split_top(h4);
                ui_pad(0,3,1,0);
                ui_pcolor(ui_jcolor_text);
                flgm = parCtl(p_Interact);
                (flgm != 0) ? (
                    (interMod != 0) ? (
                        DynParamsInterpol(paramValues[p_Interact], inter1pa, inter2pa);
                    ) : (
                        dyn_set_par(currpad, cpsrc, paramValues[p_Interact]);
                    );
                );
            ui_pop();





            // Display current presets
            ui_split_top(h5);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padDynPrstLabs, padDynPrstSiz);
                ig = 0; loop(padDynPrstSiz,
                    pa = arrDyns + ig * paramDynSiz;
                    paty = pa[paramType];
                    (ig === currLastSet) ? (
                        padDynPrstColrs[ig] = (paty === 0) ? Col_Inactive : (paty === 1) ? Color_Blue_Green :
                                    (paty === 2) ? Color_Forest_Green : (paty === 3) ? Color_Goldenrod :
                                    (paty === 4) ? Color_Blaze_Orange : (paty === 5) ? Color_Gold :
                                    (paty === 6) ? Color_Persian_Indigo :
                                    (paty === 7) ? Color_Deep_Reddish_Orange :
                                    (paty === 8) ? Color_Light_Red :
                                    Col_Cmnds;
                    ) : (
                        pa[paramType] = paty = (paty != 0);
                        padDynPrstColrs[ig] = paty ? Color_Blue_Green : Col_Inactive;
                    );
                    sprintf(padDynPrstLabs[ig], "%d", ig+1);
                    ig +=1;
                );

                zz = control_jpad(padDynPrstW);
                (zz > 0) ? (
                    zzch = padDynPrstW[ui_jpad_lkey];
                    zzent = padDynPrstW[ui_jpad_entkey]-1; // in [0 .. N-1]
                    zzmcl = padDynPrstW[ui_jpad_last]-1; // in [0 .. N-1]
                    zzmmd = padDynPrstW[ui_jpad_lmods];

                    0 ? (sprintf(#sfc, "mcl = %d   ent = %d   jmc = %x   s = %d, %d", zzmcl, zzent, jmc, zzch, zzmmd); mSL_log(SysLogBox, #sfc););

                    (zz & ui_jpad_ev_key) ? (
                        pa = arrDyns + zzent * paramDynSiz;
                        paty = pa[paramType];
                        (paty != 0) ? (
                            (zzch === 'c') ? (
                                // copy to "65"
                                pa[paramType] = 1;
                                dyn_copy_set(paramDynCopy65, pa);
                                (sprintf(#sfc, "%d Copied", zzent+1); mSL_log(SysLogBox, #sfc););
                                pa[paramType] = 2; currLastSet = zzent; currLastDate = tUnix;
                            );
                        );
                        (zzch === 'v') ? (
                            // paste "65"
                            dyn_copy_set(pa, paramDynCopy65);
                            (sprintf(#sfc, "%d Pasted", zzent+1); mSL_log(SysLogBox, #sfc););
                            pa[paramType] = 3; currLastSet = zzent; currLastDate = tUnix;
                        );

                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        pa = arrDyns + zzmcl * paramDynSiz;
                        paty = pa[paramType];

                        (((paty === 0) && (jmc === 0)) || (jmc === 4)) ? (  // cg ou cmd-cg
                            // save configuration in current cell
                            DynParamsSave(pa);
                            currpad = pa;
                            paty = pa[paramType];
                            currcell = zzmcl + 1;
                            pa[paramType] = 4; currLastSet = zzmcl; currLastDate = tUnix;

                        );

                        (((paty != 0) && (jmc === 0))) ? (  //  cg as select
                            // select configuration of current cell
                            currpad = pa;
                            currcell = zzmcl + 1;
                            pa[paramType] = 6; currLastSet = zzmcl; currLastDate = tUnix;
                            inter1 = zzmcl;
                            (inter1pa != 0) ? (inter1pa[paramType] = 1;);
                            inter1pa = pa;
                        );

                        ((paty != 0) && (jmc === 0x14)) ? (  // cmd-alt-cg
                            // delete configuration of the cell
                            memset(pa, 0, paramDynSiz); // also sets type to 0
                            currpad = currcell = 0; // return to "0"
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        pa = arrDyns + zzmcl * paramDynSiz;
                        paty = pa[paramType];
                        (paty != 0)  ? (
                            (jmc === 0x4) ? (
                                // select this cell as 2d interpolation item
                                (inter2pa != 0) ? (inter2pa[paramType] = 1;);
                                inter2 = zzmcl; inter2pa = pa;
                                (inter1pa != 0) ? (
                                    interMod = interType;
                                    inter1pa[paramType] = 7;
                                    inter2pa[paramType] = 8;
                                    DynParamsLoad(inter2pa);
                                    clone_parameter(p_Interact, p_Interpol); parSet(p_Interact, 1);
                                    sprintf(#istr, "Interp. %d/%d  %%0.3f", inter1+1, inter2+1);
                                    ppb_Interact[pp_MFmt] = #istr;
                                    ppb_Interact[pp_Min] = (interMod === 1) ? -1 : -3;
                                    ppb_Interact[pp_SavedMax] = ppb_Interact[pp_Max] = (interMod === 1) ? 1 : 3;
                                );
                            ) : (
                                // load configuration from current cell
                                pa[paramType] = 1;
                                DynParamsLoad(pa);
                                currpad = pa;
                                currcell = zzmcl + 1;
                                pa[paramType] = 5; currLastSet = zzmcl; currLastDate = tUnix;
                            );
                        );
                    );
                );


            ui_pop();


        do_ModuleKeySave();
        ui_pop();


        ((currpad > 0) && (currpad[paramType] < 1)) ? (
            // fill with current values
            DynParamsSave(currpad);
        );

        // Cells management
        (currclprv != currcell) ? (
            // save (once) new selected configuration in 67
            currclprv = currcell;
            dyn_copy_set(paramDynamic67, currpad);
        );
        // Update players values while editing
        (currVal && (currcell < 0)) ? (
            gmem[currUAdd+RCB_State_Changed] = i_M_Upd | 8;
        );

    );
);



//====== mSL Scripts ======
function
show_ProcessesMgr()
local (h1, h2, uix_jneed, uix_jmini, ig, r, w, xx, zzmi, jmc, zz, zzch, zzent, zzmcl, errv, zzmmd)
(
    h1 = uix_jpadHeight(padScriptsNL); // height
    h2 = uix_jBoxHeight(10); // second block height
    h3 = uix_jBoxHeight(2); // minimum 2nd block height
    uix_jneed = h1+h2+ui_jd_ctgr;
    uix_jmini = h1+h3+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            jmc = ui_jmouse_cap;
            keepBlockInfos(blockProcessesMgr);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockProcessesMgr]]);


            ui_split_top(h1);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padScriptsLabs, padScriptsSiz);
                ig = 0; loop(padScriptsSiz,
                    padScriptsColrs[ig] = Col_Inactive;
                    ig+=1;
                );

                padScriptsLabs[0] = "Load";
                padScriptsColrs[0] = Col_Cmnds;

                padScriptsLabs[1] = "Show Mem.";
                padScriptsColrs[1] = Color_Fern_Green;

                padScriptsLabs[2] = "Run GC";
                padScriptsColrs[2] = Color_Dark_Olive_Green;

                (zz = atomic_get(mSL_Lock)) ? (
                    sprintf(padScriptsLabs[3], "Locked [%d]", zz);

                    padScriptsColrs[3] = (zz === 1) ? Color_Indian_Red : (zz === 2) ? Color_Deep_Cadmium_Red : (zz === 3) ? Color_Deep_Reddish_Orange :  Color_Deep_Red;
                ) : (
                    padScriptsLabs[3] = "Unlocked";
                    padScriptsColrs[3] = Col_InfoC;
                );

                sprintf(padScriptsLabs[4], "Xop: %d", mSL_xop_cnt);
                padScriptsColrs[4] = (jmc & cmdCap) ? Col_Cmnds : SchedLockAll ? Color_Purple : mSL_act ? Col_InfoA : Col_InfoC;


                sprintf(padScriptsLabs[5], "Fr.Thrds %d", SchedListSize(SchedInactPts));
                padScriptsColrs[5] = ((mSL_act+mSL_wait+mSL_plck) > 0) ?  Color_Light_Green : Col_InfoC;

                (jmc & cmdCap) ? (
                    padScriptsLabs[6] = "Kill Scripts";
                    padScriptsColrs[6] = Color_Deep_Cadmium_Red;
                ) : (
                    sprintf(padScriptsLabs[6], "Fr.Ents %d", SchedListSize(SchedFreePts));
                    padScriptsColrs[6] = ((mSL_act+mSL_wait+mSL_plck) > 0) ?  Color_Light_Green : Col_InfoC;
                );

                (jmc & cmdCap) ? (
                    padScriptsLabs[7] = "Unlock Scripts";
                    padScriptsColrs[7] = Color_Fern_Green;
                ) : (
                    errv = mSL_errC ? mSL_errC : mSL_errX ;
                    errv ? (
                        sprintf(padScriptsLabs[7], "Err: %d", errv);
                        padScriptsColrs[7] = SchedLockAll ? Color_Purple : Col_Error;
                    ) : (
                        padScriptsLabs[7] = "No err.";
                        padScriptsColrs[7] = SchedLockAll ? Color_Purple : Col_InfoC;
                    );
                );

                padScriptsLabs[8] = showThrdTypeNms[showThrdType];
                padScriptsColrs[8] = Col_InfoC;

                zz = control_jpad(padScriptsp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    zzch = padScriptsp[ui_jpad_lkey];
                    zzent = padScriptsp[ui_jpad_entkey]-1;
                    zzmcl = padScriptsp[ui_jpad_last]-1;
                    zzmmd = padScriptsp[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 1) ? (
                            mSL_log(SysLogBox, "Memory.");
                            mem_walk(0); mem_show();
                        ):
                        (zzmcl === 2) ? (
                            mSL_log(SysLogBox, "GC run.");
                            gc_run(2);
                        ):
                        (zzmcl === 3) ? (
                            atomic_get(mSL_Lock) ? (
                                (zzmmd & cmdCap) ? (
                                    atomic_add(mSL_Lock, -min(10, atomic_get(mSL_Lock)));
                                ) : (
                                    atomic_add(mSL_Lock, -1);
                                );
                            );
                        ):
                        (zzmcl === 6) ? (
                            (jmc & cmdCap) ? flagKillAllThreads = 1;
                        ):
                        (zzmcl === 7) ? (
                            mSL_errC = mSL_errX = 0; // reset error
                            (zzmmd & cmdCap) ? (
                                SchedLockAll = 0;
                                mSL_gc_MaxDur = mm_cyc_maxU = mm_dur_maxU = 0;
                                mm_cyc_max=0; mm_dur_max = 0; gmaxd = 0; lmaxd = 0;
                                memset(mm_cyc_mm, 0, mm_cyc_siz);
                                memset(mm_dur_mm, 0, mm_cyc_siz);
                            );
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            xx = control_jmenu(menu_Scripts);
                            (xx != 0) ? (
                                doMslCompile(scripts_tab[xx-1]);
                            );
                        ):
                        (zzmcl === 1) ? (
                            mSL_log(SysLogBox, "Memory.");
                            mem_walk(1); mem_show();
                        ):
                        (zzmcl === 2) ? (
                            mSL_log(SysLogBox, sprintf(#, "GC start.  %X", FlagsTbVals[Flgs_GC]));
                            gc_run(FlagsTbVals[Flgs_GC]);
                        ):
                        (zzmcl === 3) ? (
                            (zzmmd & cmdCap) ? (
                                atomic_add(mSL_Lock,10);
                            ) : (
                                atomic_add(mSL_Lock,1);
                            );
                            atomic_add(mSL_loc_tim,mSL_loc_tadd);
                        ):
                        (zzmcl === 4) ? (
                            (zzmmd & cmdCap) ? (
                                SchedLockAll ? (
                                    SchedLockAll = 0;
                                ) : (
                                    Schedrestart1 = 1;
                                    mSL_log(SysLogBox, "——> Schedrestart1");
                                    atomic_add(mSL_Lock,1);
                                );
                            );
                        ):
                        (zzmcl === 5) ? (
                            XV = ! XV ;
                        ):
                        (zzmcl === 7) ? (
                            (zzmmd & cmdCap) ? (
                                // Lock all processes
                                SchedLockAll = 1;
                                atomic_add(mSL_Lock,max(1,mSL_Lock));
                            ) : (
                                mSL_errC = mSL_errX = 0; // reset error
                                mSL_gc_MaxDur = mm_cyc_maxU = mm_dur_maxU = 0;
                                mm_cyc_max=0; mm_dur_max = 0; gmaxd = 0; lmaxd = 0;
                                memset(mm_cyc_mm, 0, mm_cyc_siz);
                                memset(mm_dur_mm, 0, mm_cyc_siz);
                            );
                        );
                    );

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch;
                    );

                );

            ui_pop();

            mm_cyc_maxU = max(mm_cyc_max, mm_cyc_maxU);
            mm_dur_maxU = max(mm_dur_max, mm_dur_maxU);

            ui_split_top(h2);
            w = ui_width();
            r = (w > 4* ui_MinSubColSize) ? 4 : (w > 3* ui_MinSubColSize) ? 3 : 2;
                ui_new_column(1/r);
                    ui_show("X Version", XV, "%d");
                    ui_show("Mem size", mm_sizmem, "%d");
                    ui_show("Free mem", mm_show_ttf, "%d");
                    ui_show("Free % m.", 100 * mm_show_ttf/mm_sizmem, "%.2f %%");
                    ui_show("Free blocks", mm_show_frbl, "%d");
                    ui_show("Free [Huge]", mm_bl_huge, "%d");
                    ui_show("Free Strings", mSL_Str_Uptr, "%d");
                    ui_show("Temp Str use", mSL_Str_TempU, "%d");
                    ui_show("Instr./second", mm_xec_cnt, "%d");
                    ui_show("Max. Inst./s.", mm_xec_max, "%d");
                ui_new_column();
                    ui_show("Used mem", mm_show_ttu, "%d");
                    ui_show("Used % m.", 100 * mm_show_ttu/mm_sizmem, "%.2f %%");
                    ui_show("Used blocks", mm_show_usbl, "%d");
                    ui_show("Free [Big]", mm_bl_big, "%d");
                    ui_show("Tmp. Inst./bl", mm_cyc_max, "%d");
                    ui_show("Tmp. Dur/bl", mm_dur_max*1000, "%.2f ms.");
                    ui_show("malloc #", mSL_mallocated, "%d");
                    ui_show("mfree #", mSL_mfreed, "%d");
                    ui_show("low []", mm_lowblocks, "%d");
                    ui_show("high []", mm_highblocks, "%d");
                (r > 2) ? (
                ui_new_column();
                    ui_show("GC count", gc_run_count, "%d");
                    ui_show("Obj. List count", mm_list_mxc, "%d");
                    ui_show("mSL Lock", atomic_get(mSL_Lock), "%d");
                    ui_show("wrng fr:", mSL_wfr, "%d");
                    ui_show("Free [Mini]", mm_bl_mini, "%d");
                    ui_show("Free [Large]", mm_bl_large, "%d");
                    ui_show("Max. Inst./bl", mm_cyc_maxU, "%d");
                    ui_show("Max. Dur/bl", mm_dur_maxU*1000, "%.2f ms.");
                    ui_show("Active", mSL_dispatch_entry, "%d");
                    ui_show("Thread. @", mSL_active_Thread, "%d");
                );
                (r > 3) ? (
                ui_new_column();
                    ui_show("Pr.Active", mSL_act, "%d");
                    ui_show("Pr.Wait", mSL_wait, "%d");
                    ui_show("Pr.Lock", mSL_plck, "%d");
                    ui_show("Fr.msgs", mSL_pmsg, "%d");
                    ui_show("Free [Med.]", mm_bl_medium, "%d");
                    ui_show("Max.gc.dur", mSL_gc_MaxDur*1000, "%.2f ms.");
                    ui_show("Max xop.d", gmaxd*1000, "%.2f ms.");
                    ui_show("Max GLp", lmaxd*1000, "%.2f ms.");
                    ui_show("Max stack", mSL_High_Stack, "%d");
                    ui_show("Th. mark.", mSL_Thread_mark, "%d");
                );
                ui_pop();

            ui_pop();

            do_ModuleKeySave();
        ui_pop();
    );
);


//====== SHORTCUTS linking ======
function
show_Links_Pad()
local (h1, h2, uix_jneed, uix_jmini, str, p, u, par_reduce, cty, col, ig, sic, ty, xtp, mc, lst, fmt, xkey, xmds, flgm,
    z, zz, zzch, zzent, zzmcl, zzmi, zzmmd)
(
    h1 = uix_jpadHeight(2); // height
    h2 = SysLinksActive ? ui_jd_slidh  + 4 : 0; // display one slider
    uix_jneed = uix_jmini = h1+h2+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            ((zzmi = ui_hover()) && SysLinksActive) ? (
                ui_Xtime_period = 0.1; // some graphic acceleration when in this module
            );
            keepBlockInfos(blockSysLinks);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            mc = ui_jmouse_cap;
            lst = 0;
            control_group(blockDispNames[blockDispInverts[blockSysLinks]]);
            ui_split_top(h1);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padLinksLabs, padLinksSiz);
                ig = 0; loop(padLinksSiz,
                    padLinksColrs[ig] = Col_Inactive;
                    ig+=1;
                );
                padLinksLabs[0] = "Learn off";

                (MIDILogActive) ? (
                    padLinksLabs[8] = "MIDI log on";
                    padLinksColrs[8] = Col_Cmnds;
                ) : (
                    padLinksLabs[8] = "MIDI log off";
                );

                (SysLinksActive) ? (
                    par_reduce = 0; // do not alter parameter range

                    padLinksLabs[0] = "Learn on";
                    padLinksColrs[0] = Col_Cmnds;

                    padLinksColrs[1] = Col_Cmnds;

                    // Which source ?
                    (SysSourceType === 0) ? (
                        // Source is MIDI
                        padLinksLabs[1] = "MIDI";
                        SysSourceKod = ((MIDI_lk_msg1 << 8) & 0xff00) | MIDI_lk_msg2;
                        cty = MIDI_lk_msg1 & 0x7F0; // keep command type - yes
                        sprintf(#MTy, "%01X", MIDI_lk_msg1 >> 4);
                        (cty === 0xB0) ? (
                            #MTy = "CC";
                            Link_Type = MIDI_LinkTY_CC; // link type
                            col = Color_Goldenrod;
                        ) :
                        (cty === 0x1B0) ? (
                            #MTy = "CC/SV";
                            Link_Type = MIDI_LinkTY_SV; // link type
                            col = Color_Peach_Yellow;
                            par_reduce = 1;
                        ) :
                        ((cty === 0x80) || (cty === 0x90)) ? (
                            // Change to "note-on"
                            SysSourceKod = SysSourceKod | 0x9000;
                            MIDI_lk_msg1 = MIDI_lk_msg1 | 0x90;
                            #MTy = "Note";
                            Link_Type = MIDI_LinkTY_SV; // link type
                            col = Color_Peach_Yellow;
                            par_reduce = 1;
                        ) :
                        (cty === 0xC0) ? (
                            #MTy = "PC";
                            Link_Type = MIDI_LinkTY_SV; // link type
                            col = Color_Std_Orange;
                            par_reduce = 1;
                        ) : (
                            col = Color_Limegreen; // unknown/unregistered type
                        );
                        // Display command message in [2-3]
                        sprintf(padLinksLabs[2], "MIDI %s", #MTy);
                        sprintf(padLinksLabs[3], "%d:%d (%d)", 1+(MIDI_lk_msg1 & 0xF), MIDI_lk_msg2, MIDI_lk_msg3);
                    ) :
                    (SysSourceType === 1) ? (
                        // Source is a slider
                        padLinksLabs[1] = "Slider";
                        Link_Type = MIDI_LinkTY_Slid; // link type
                        (JSFXSlShow != 1) ? (
                            JSFXSlShow = 1;
                            slider_show(2 ^ JSFXSlNb, 1);
                        );
                        SysSourceKod = Slider_Source_Ty | (JSFXSlNb+1);
                        sprintf(padLinksLabs[2], "Slider %d", JSFXSlNb+1);
                        sprintf(padLinksLabs[3], "(%d)", slider(JSFXSlNb+1));
                        col = Color_Forest_Green;
                    ) :
                    (SysSourceType === 2) ? (
                        // A key ?
                        padLinksLabs[1] = "Key";
                        (key_last_in > 0xffffff) ? (
                            sprintf(padLinksLabs[2], "Key '%c%c%c%c'", (key_last_in >> 24) & 0xff, (key_last_in >> 16) & 0xff, (key_last_in >> 8) & 0xff, key_last_in & 0xff);
                        ) :
                        (key_last_in > 0xffff) ? (
                            sprintf(padLinksLabs[2], "Key '%c%c%c'", (key_last_in >> 16) & 0xff, (key_last_in >> 8) & 0xff, key_last_in & 0xff);
                        ) :
                        (key_last_in > 0xff) ? (
                            sprintf(padLinksLabs[2], "Key '%c%c'", (key_last_in >> 8) & 0xff, key_last_in & 0xff);
                        ) :
                        (
                            sprintf(padLinksLabs[2], "Key '%c'", key_last_in);
                        );
                        sprintf(padLinksLabs[3], "Mods %d", key_last_mods);
                        SysSourceKod = (key_last_in * 256) + (key_last_mods | 0x80) ;
                        Link_Type = MIDI_LinkTY_SV; // link type
                        par_reduce = 1;
                        col = Color_Blue_Bell;
                    ) :
                    (SysSourceType === 3) ? (
                        padLinksLabs[1] = "Inner";
                        Link_Type = MIDI_LinkTY_Act; // link type
                        sprintf(padLinksLabs[2],"Event %d", Evnt_Current);
                        padLinksLabs[3] = "-";
                        SysSourceKod = 0x2000 | Evnt_Current;
                        Link_Type = MIDI_LinkTY_SV; // link type
                        par_reduce = 1;
                        col = Color_Std_Brown;
                    ) : (
                        padLinksLabs[1] = "unset";
                        SysSourceKod = 0;
                        col = Color_Light_Green;
                    );
                    padLinksColrs[2] = col;
                    padLinksColrs[3] = col;


                    ((JSFXSlShow === 1) && (SysSourceType != 1)) ? (
                        // Hide the slider
                        JSFXSlShow = 0;
                        slider_show(2 ^ JSFXSlNb, 0);
                    );

                    // Look for the targets
                    // A parameter
                    (param_touch_count != param_touch_last) ? (
                        SysLinkType = 1;
                        param_touch_last = param_touch_count;
                        (param_current != param_last_touched) ? (
                            param_current = param_last_touched;
                            param_current_min_m = param_current_min = parGetPP(param_current, pp_Min);
                            param_current_max_m = param_current_max = parGetPP(param_current, pp_Max);
                        );
                    );

                    (SysLinkType === 1) ? (
                        // Control a Parameter
                        sprintf(padLinksLabs[4], "n° %d", param_current);
                        padLinksLabs[5] = parGetPP(param_current, pp_Name) ;
                        fmt = parGetPP(param_current, pp_SFmt);
                        param_current_val = parGetV(param_current);
                        sprintf(padLinksLabs[6], fmt, param_current_min_m);
                        sprintf(padLinksLabs[7], fmt, param_current_max_m);
                        padLinksColrs[4] = Col_InfoC;
                        padLinksColrs[5] = Col_InfoC;
                        padLinksColrs[6] = Col_InfoC;
                        padLinksColrs[7] = Col_InfoC;
                        // These can be overwritten later
                        sprintf(padLinksLabs[14], fmt, param_current_min);
                        sprintf(padLinksLabs[15], fmt, param_current_max);
                        padLinksColrs[14] = Col_InfoC;
                        padLinksColrs[15] = Col_InfoC;
                        SysLinkKod = Link_Type + param_current;
                    ) :
                    (SysLinkType === 2)? (
                        // Control an Action
                        action_num = ActionTbNums[action_ent];
                        sprintf(padLinksLabs[4], "Act: %d", action_num);
                        padLinksColrs[4] = Col_InfoD;
                        padLinksLabs[5] = ActionShNames[action_ent];
                        padLinksColrs[5] = Col_InfoD;
                        SysLinkKod = MIDI_LinkTY_Act + action_num;
                    ) : (
                        SysLinkKod = 0xF000; // undefined
                    );

                    // Is this command already used ?
                    ((SysSourceUsed = getLinkEntry(SysSourceKod)) >= 0) ? ( // entry corresponding to the sourece
                        u = Links_Actn[SysSourceUsed]; // Action
                        p = u & 0x7FF;
                        ty = u & 0xF000;
                        col = Col_InfoD;
                        (ty === MIDI_LinkTY_CC) ? (
                            col = Col_InfoC;
                            sprintf(padLinksLabs[10], "n° %d", p);
                            padLinksLabs[11] = parGetPP(p, pp_Name) ;
                        ) :
                        (ty = MIDI_LinkTY_SV) ? (
                            col = Col_InfoC;
                            sprintf(padLinksLabs[10], "n° %d (%g)", p, Links_Par1[SysSourceUsed]);
                            padLinksLabs[11] = parGetPP(p, pp_Name) ;
                        ) :
                        (ty === MIDI_LinkTY_Act) ? (
                            col = Color_Std_Brown;
                            sprintf(padLinksLabs[10], "Act: %d", p);
                        ) :
                        (ty === MIDI_LinkTY_Slid) ? (
                            col = Col_InfoC;
                            sprintf(padLinksLabs[10], "n° %d", p);
                            padLinksLabs[11] = parGetPP(p, pp_Name) ;
                        ) : (
                            sprintf(padLinksLabs[10], "[%X]", u);
                        );
                        padLinksColrs[10] = col;
                        padLinksColrs[11] = col;
                    );


                    // Which type is the last message ?
                    col = Col_Inactive;
                    // Is the destination already used ?
                    (SysLinkFlag || (SysLinkTime < lastTime)) ? (
                        SysLinkUsed = findLink(SysLinkKod);
                        SysLinkFlag = 0;
                        SysLinkTime = lastTime + 4;
                    );
                    (SysLinkUsed >= 0) ? (// entry corresponding to the link
                        u = Links_HTab[SysLinkUsed];
                        (SysLinkKod & 0x1000) ? (
                            fmt = parGetPP(param_current, pp_SFmt);
                        ) : (
                            fmt = "%g";
                        );
                        (u & 0x80) ? (
                            ty = 0x4000; // a key
                            col = Color_Blue_Bell;
                            xkey = 0|(u / 256); // name of the key
                            xmds = u & 0x7F; // modifiers
                            xtp = 0;
                            (xkey > 0xffffff) ? (
                                sprintf(padLinksLabs[12], "Key '%c%c%c%c'", (xkey >> 24) & 0xff, (xkey >> 16) & 0xff, (xkey >> 8) & 0xff, xkey & 0xff);
                            ) :
                            (xkey > 0xffff) ? (
                                sprintf(padLinksLabs[12], "Key '%c%c%c'", (xkey >> 16) & 0xff, (xkey >> 8) & 0xff, xkey & 0xff);
                            ) :
                            (xkey > 0xff) ? (
                                sprintf(padLinksLabs[12], "Key '%c%c'", (xkey >> 8) & 0xff, xkey & 0xff);
                            ) :
                            (
                                sprintf(padLinksLabs[12], "Key '%c'", xkey);
                            );
                            sprintf(padLinksLabs[13], "Mods %d", xmds);
                        ) : (
                            ty = u & 0xF000;
                            xtp = u & 0xfff; // in 1-64
                            (ty === 0x1000) ? (
                                // Slider
                                sprintf(padLinksLabs[12], "Slider %d", xtp);
                                sprintf(padLinksLabs[13], "(%d)", slider(xtp));
                                col = Color_Forest_Green;
                            ) :
                            (ty === 0x2000) ? (
                                // Event
                                padLinksLabs[12] = "Event";
                                sprintf(padLinksLabs[13], "%d", xtp);
                                col = Color_Std_Brown;
                            ) :
                            (ty === 0x9000) ? (
                                // Note ON
                                sprintf(padLinksLabs[12], "MIDI note");
                                sprintf(padLinksLabs[13], "%d:%d", 1+(xtp>>8), xtp & 0xff);
                                col = Color_Peach_Yellow;
                            ) :
                            (ty === 0xB000) ? (
                                // controller
                                u = Links_Actn[SysLinkUsed] & 0xff000;
                                (u === 0x21000) ? (
                                    sprintf(padLinksLabs[12], "MIDI CC/SV");
                                    col = Color_Peach_Yellow;
                                ) : (
                                    sprintf(padLinksLabs[12], "MIDI CC");
                                    col = Color_Goldenrod;
                                );
                                sprintf(padLinksLabs[13], "%d:%d", 1+(xtp>>8), xtp & 0xff);
                            ) :
                            (ty === 0xC000) ? (
                                // prog change
                                sprintf(padLinksLabs[12], "MIDI PC");
                                sprintf(padLinksLabs[13], "%d:%d", 1+(xtp>>8), xtp & 0xff);
                                col = Color_Std_Orange;
                            );
                        );
                        sprintf(padLinksLabs[14], fmt, Links_Par1[SysLinkUsed]);
                        sprintf(padLinksLabs[15], fmt, Links_Par2[SysLinkUsed]);
                        padLinksColrs[12] = col;
                        padLinksColrs[13] = col;
                        padLinksColrs[14] = col;
                        padLinksColrs[15] = col;
                    );


                    ((SysLinkUsed >= 0) && (SysSourceUsed >= 0) && (SysLinkUsed === SysSourceUsed)) ? (
                        padLinksLabs[9] = "Linked";
                        padLinksColrs[9] = Color_Blaze_Orange;
                        lst = 1;
                    ) :
                    ((SysLinkUsed >= 0) || (SysSourceUsed >= 0)) ? (
                        padLinksLabs[9] = "(Un)link";
                        padLinksColrs[9] = Color_Light_Green;
                        lst = 2;
                    ) : (
                        padLinksLabs[9] = "Link";
                        padLinksColrs[9] = Color_Azure;
                    );

                );

                //======================================================================

                zz = control_jpad(padLinksp);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    zzch = padLinksp[ui_jpad_lkey];
                    zzent = padLinksp[ui_jpad_entkey]-1;
                    zzmcl = padLinksp[ui_jpad_last]-1;
                    zzmmd = padLinksp[ui_jpad_lmods];

                    //=======================
                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            // flip activity
                            SysLinksActive = ! SysLinksActive ;
                        ) :
                        (zzmcl === 8) ? (
                            // flip log activity
                            MIDILogActive = ! MIDILogActive ;
                        );
                    );

                    (SysLinksActive) ? (
                        SysLinkFlag = 1;
                        (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                            (zzmcl === 1) ? (
                                // flip source
                                SysSourceType = (SysSourceType + 3) % 4;
                            ) :
                            (zzmcl === 2) ? (
                                // modify source type
                                sic = (mc & 0x20) ? 10 : 1;
                                (SysSourceType === 0) ? (
                                    // MIDI mode - change a "CC" to a "Single value"
                                    z = MIDI_lk_msg1 & 0x7F0;
                                    (z === 0xB0) ? MIDI_lk_msg1 |= 0x100;
                                    (z === 0x1B0) ? MIDI_lk_msg1 &= 0x6FF;
                                ) :
                                (SysSourceType === 1) ? (
                                    slider_show(2 ^ JSFXSlNb, 0);
                                    JSFXSlNb = (JSFXSlNb + 64 - sic) % 64;
                                    JSFXSlShow ? slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                                ) :
                                (SysSourceType === 3) ? (
                                    Evnt_Current = (Evnt_Current + 512 - sic) % 512;
                                );
                            ):
                            ((zzmcl === 4) || (zzmcl === 5)) ? (
                                sic = (mc & 0x20) ? 10 : 1;
                                (SysLinkType === 1) ? (
                                    // Parameter
                                    param_touch_count += 1;
                                    param_last_touched = (param_current + paramCount - sic) % paramCount;
                                ) :
                                (SysLinkType === 2) ? (
                                    // Action
                                    action_ent = (action_ent + ActionCount - sic) % ActionCount;
                                ) :
                                (SysLinkType === 3) ? (
                                    action_num = (action_num + ActionTbSiz - sic) % ActionTbSiz;
                                );
                            ) :
                            (zzmcl === 9) ? (
                                    // do link
                                    par_reduce ? param_current_min_m = param_current_max_m = param_current_val;
                                    removeLink(SysSourceKod);
                                    enterLink(SysSourceKod, SysLinkKod, param_current_min_m, param_current_max_m);

                            ) :
                            (zzmcl === 10) ? (
                                (SysSourceUsed >= 0) ? (
                                    // remove the corresponding [source] link
                                    Links_HTab[SysSourceUsed] = -1;
                                    Links_Actn[SysSourceUsed] = 0;
                                    Links_Par1[SysSourceUsed] = 0;
                                    Links_Par2[SysSourceUsed] = 0;
                                );
                            ) :
                            (zzmcl === 12) ? (
                                (SysLinkUsed >= 0) ? (
                                    // remove the corresponding [target] link
                                    Links_HTab[SysLinkUsed] = -1;
                                    Links_Actn[SysLinkUsed] = 0;
                                    Links_Par1[SysLinkUsed] = 0;
                                    Links_Par2[SysLinkUsed] = 0;
                                );
                            ) :
                            (zzmcl === 6) ? (
                                param_current_min_m = param_current_val;
                                (param_current_min_m > param_current_max_m) ? (
                                    z = param_current_min_m;
                                    param_current_min_m = param_current_max_m;
                                    param_current_max_m = z;
                                );
                            ) :
                            (zzmcl === 7) ? (
                                param_current_max_m = param_current_val;
                                (param_current_min_m > param_current_max_m) ? (
                                    z = param_current_min_m;
                                    param_current_min_m = param_current_max_m;
                                    param_current_max_m = z;
                                );
                            ) :
                            ((zzmcl === 14) || (zzmcl === 15)) ? (
                                // (re)Display this configuration
                                param_current_min_m = param_current_min = parGetPP(param_current, pp_Min);
                                param_current_max_m = param_current_max = parGetPP(param_current, pp_Max);
                            );
                        );

                        //=======================
                        (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                            (zzmcl === 1) ? (
                                SysSourceType = (SysSourceType + 1) % 4;
                            ) :
                            (zzmcl === 2) ? (
                                // modify source type
                                sic = (mc & 0x20) ? 10 : 1;
                                (SysSourceType === 1) ? (
                                    slider_show(2 ^ JSFXSlNb, 0);
                                    JSFXSlNb = (JSFXSlNb + sic) % 64;
                                    JSFXSlShow ? slider_show(2 ^ JSFXSlNb, JSFXSlShow);
                                ) :
                                (SysSourceType === 3) ? (
                                    Evnt_Current = (Evnt_Current + sic) % 512;
                                );
                            ):
                            ((zzmcl === 4) || (zzmcl === 5)) ? (
                                sic = (mc & 0x20) ? 10 : 1;
                                (SysLinkType === 1) ? (
                                    // Parameter
                                    param_touch_count += 1;
                                    param_last_touched = (param_current + sic) % paramCount;
                                ) :
                                (SysLinkType === 2) ? (
                                    // Action
                                    action_ent = (action_ent + sic) % ActionCount;
                                ) :
                                (SysLinkType === 3) ? (
                                    action_num = (action_num + sic) % ActionTbSiz;
                                );
                            ) :
                            (zzmcl === 9) ? (
                                xx = control_jmenu(uix_MIDI_menu);
                                (xx > 0) ? (
                                    (xx === 1) ? (
                                        clearLinksTables();
                                    );
                                );
                            ) :
                            (zzmcl === 10) ? (
                                xx = control_jmenu(menu_Actions);
                                (xx > 0) ? (
                                    // use an action as command
                                    SysLinkType = 2;
                                    action_ent = xx-1;
                                    action_num = ActionTbNums[action_ent];
                                    Link_Type = MIDI_LinkTY_Act;
                                    0;
                                );
                            );
                        );
                    );


                );

            ui_pop();

            SysLinksActive ? (
                ui_split_top(h2);
                    ui_pad(1,3,1,0);
                    flgm = parCtl(param_current);
                ui_pop();
            );

            do_ModuleKeySave();
        ui_pop();
    );
);

//====== Scheduler GFX ======
function
show_Scheduler_Pad()
local (h1, h2, uix_jneed, uix_jmini, str, ig, u, v, zz, zzch, zzent, zzmcl, zzmmd, zzmi, jmc)
(
    h1 = uix_jpadHeight(padSchNL); // height
    // h2 = uix_jBoxHeight(2);
    h2 = 0;
    uix_jneed = uix_jmini = h1+h2+ui_jd_ctgr;
    str = #;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            keepBlockInfos(blockScheduler);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockScheduler]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            ui_split_top(h1);
                ui_pad(1,2,3,2);
                mSL_setStrArray(padSchLabs, padSchSiz);
                jmc = ui_jmouse_cap;
                //
                (SchedActive) ? (
                    (jmc & cmdCap) ? (
                        padSchLabs[0] = "Turn off";
                        padSchColrs[0] = Color_Std_Orange;
                    ) : (
                        padSchLabs[0] = "Scheduler on";
                        padSchColrs[0] = Col_Cmnds ;
                    ) ;
                ) : (
                    padSchLabs[0] = "Sch. off";
                    padSchColrs[0] = Col_Inactive ;
                );


                (jmc & cmdCap) ? (
                    padSchLabs[3] = "Kill";
                    padSchColrs[3] = Col_CmdStp ;
                ) : (
                    padSchLabs[3] = "Now";
                    padSchColrs[3] = Col_InfoC ;
                );


                padSchLabs[4] = "";
                padSchColrs[4] = Col_Inactive ;

                padSchLabs[5] = "Grp. Change";   //"Task A";
                padSchColrs[5] = Col_InfoC ;

                padSchLabs[6] = "Vol. Change";  // "Task B";
                padSchColrs[6] = Col_InfoC ;

                padSchLabs[7] = "Gen. Change";  // "Task C";
                padSchColrs[7] = Col_InfoC ;

                padSchLabs[8] = "Task D";
                padSchColrs[8] = Col_InfoC ;

                padSchLabs[9] = "Task E";
                padSchColrs[9] = Col_InfoC ;

                padSchLabs[10] = "Task F";
                padSchColrs[10] = Col_InfoC ;

                padSchLabs[11] = "Task G";
                padSchColrs[11] = Col_InfoC ;

                padSchLabs[12] = "Task H";
                padSchColrs[12] = Col_InfoC ;

                padSchLabs[13] = "Task I";
                padSchColrs[13] = Col_InfoC ;

                padSchLabs[14] = "Task J";
                padSchColrs[14] = Col_InfoC ;

                padSchLabs[15] = "Task K";
                padSchColrs[15] = Col_InfoC ;

                ig = 5;
                while (ig < padSchSiz) (
                    padSchColrs[ig] = (SchedActv[ig] != 0) ?  Color_Blizzard_Blue : Col_InfoC;
                    ig += 1;
                );


                (SchedListNonEmpty(SchedDlydPts)) ? (
                    u = SchedDlydPts[SchedNxtEnt];
                    v = SchedCode[u];
                    ((v >= 5) && (v <= 15)) ? (
                        sprintf(padSchLabs[1], "%s ->", padSchLabs[v]);
                    ) : (
                        sprintf(padSchLabs[1], "Next: %d", SchedCode[u]);
                    );
                    padSchColrs[1] = Col_InfoD ;
                    sprintf(padSchLabs[2], "%.1f", max(0, SchedDly[u] - Sched_TimeNow));
                    padSchColrs[2] = Col_InfoD ;
                ) : (
                    padSchLabs[1] = "no event";
                    padSchColrs[1] = Col_Inactive ;
                    padSchLabs[2] = "";
                    padSchColrs[2] = Col_Inactive ;
                );

                zz = control_jpad(padSched);
                (zz > 0) ? (
                    ui_GFXdoNow |= 4; ui_GFXReason = 34;
                    zzch = padSched[ui_jpad_lkey];
                    zzent = padSched[ui_jpad_entkey]-1;
                    zzmcl = padSched[ui_jpad_last]-1;
                    zzmmd = padSched[ui_jpad_lmods];

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        (zzmcl === 0) ? (
                            ((jmc & cmdCap) && SchedActive) ? (SchedActive = 0;) : SchedActive =  1 ;
                        ) :
                        (zzmcl === 3) ? (
                            (jmc & cmdCap) ? (
                                SchedControl = 1; // kill
                            ) : (
                                SchedControl = 2; // now
                            );
                        ) :
                        ((zzmcl >= 5) && (zzmcl <= 7)) ? (
                            SchedRemove(SchedDlydPts, zzmcl); Schedule(SchedRelative, 0.0001, zzmcl);
                        ) :
                        ((zzmcl >= 8) && (zzmcl <= 15)) ? (
                            Schedule(SchedRelative, 0.0001, zzmcl);
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        (zzmcl === 0) ? (
                            SchedActive =  1 ;
                        ) :
                        (zzmcl === 4) ? (
                            SchedControl = 5; // clear all waiting tasks
                        ) :
                        ((zzmcl >= 5) && (zzmcl <= 15)) ? (
                            SchedRemove(SchedDlydPts, zzmcl);
                        );
                    );
                );

                (zz & ui_jpad_ev_key) ? (
                    Keyed = zzch; // do not use keys
                );

            ui_pop();


            do_ModuleKeySave();
        ui_pop();
    );
);

//====== STUDIO ======
//   for "keyboard playing..."
function do_StudioPadKeyboard() local (k)
(
    (Keyed === 0) ? ( Keyed = KeyedT; KeyedT = 0; );
    (Keyed === 0) ? ( Keyed = ui_key(); ui_key_next(););
    ((k = Keyed) >= ' ') ? (
        AAAA_SP_Keyed = Keyed;
        Keyed = 0;
        (k === 'a') ? ( Kbtp = cmdPadBase + 0 | FLdoForcePlay;) :
        (k === 'z') ? ( Kbtp = cmdPadBase + 1 | FLdoForcePlay;) :
        (k === 'e') ? ( Kbtp = cmdPadBase + 2 | FLdoForcePlay;) :
        (k === 'r') ? ( Kbtp = cmdPadBase + 3 | FLdoForcePlay;) :
        (k === 't') ? ( Kbtp = cmdPadBase + 4 | FLdoForcePlay;) :
        (k === 'y') ? ( Kbtp = cmdPadBase + 5 | FLdoForcePlay;) :
        (k === 'u') ? ( Kbtp = cmdPadBase + 6 | FLdoForcePlay;) :
        (k === 'i') ? ( Kbtp = cmdPadBase + 7 | FLdoForcePlay;) :
        (k === 'q') ? ( Kbtp = cmdPadBase + 8 | FLdoForcePlay;) :
        (k === 's') ? ( Kbtp = cmdPadBase + 9 | FLdoForcePlay;) :
        (k === 'd') ? ( Kbtp = cmdPadBase + 10 | FLdoForcePlay;) :
        (k === 'f') ? ( Kbtp = cmdPadBase + 11 | FLdoForcePlay;) :
        (k === 'g') ? ( Kbtp = cmdPadBase + 12 | FLdoForcePlay;) :
        (k === 'h') ? ( Kbtp = cmdPadBase + 13 | FLdoForcePlay;) :
        (k === 'j') ? ( Kbtp = cmdPadBase + 14 | FLdoForcePlay;) :
        (k === 'k') ? ( Kbtp = cmdPadBase + 15 | FLdoForcePlay;) :
        (k === 'w') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispPar;) :
        (k === 'v') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispGrp;) :
        (k === 'x') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispGBk;) :
        (k === 'l') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispRng; ) :
        (k === 'm') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispErr; ) :
        (k === 'c') ? ( StdnumLastM = lastTime; StdnumUnchkd = padStDispClip; ) :
        ( Keyed = k; ); // keyed not used
        ui_GFXdoNow |= 1;
    );
    (KeyedT === 0) ? ( KeyedT = Keyed; Keyed = 0; );
);


function
show_Studio_Play_Pad()
local(h1, rc, str, zz, zzch, zzent, zzmcl, zzmi, zzmmd, rtc, part, select, u, u_Grp, u_Bnk, u_Part, gf,
    ig, kg, ty, u_Pnb, u_ClL, u_ClH, u_ClX, uix_jneed, uix_jmini, str, w)
(
    // ui_Xtime_period = 0.2; // refresh screen every 200 milli-second
    gf = 1 + padStGFact * (max (0, (ui_width() - ui_MinSize1Pane) / (ui_BestSize1Pane - ui_MinSize1Pane))); // grow factor
    h1 = uix_jpadHeight(padStvNL*gf); // A few lines Pad
    uix_jneed = uix_jmini = h1+ui_jd_ctgr;
    uix_jmini = uix_jpadHeight(5) + ui_jd_ctgr;

    rtc = 0;
    str = #;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());

            zzmi = ui_hover();
            studio_pad_active = 1;

            keepBlockInfos(blockPlayPad);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockPlayPad]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            ui_split_top(h1);
                ui_pad(0,2,2,2);
                // Update colors for pads
                mSL_setStrArray(padStLabs, padStSiz);
                ig = 0; loop(padStSiz,
                    kg = ig + padStOffset;
                    padStCells[ig] = padStFlags[kg];
                    ty = padStCells[ig] & padStFlDisp;
                    ((StdnumUnchkd>0) && (StdnumUnchkd < 16)) ? ty = StdnumUnchkd;
                    u_Part = padStPVals[kg]; // the partial number
                    u = (u_Part % BKEcnt) * BKEsize;
                    u_Grp = BKTab[u + idx_Pa_Grp];
                    u_Bnk = BKTab[u + idx_Pa_Bnk];
                    // u_Pnb = BKTab[u + idx_Pa_PNumb];
                    u_ClL = padStClipsL[kg] >= 0 ? padStClipsL[kg] : BKTab[u + idx_Pa_Clps];
                    u_ClH = padStClipsH[kg] >= 0 ? padStClipsH[kg] : BKTab[u + idx_Pa_Clps+1];
                    (ty === padStDispPar) ? (
                        sprintf(padStLabs[ig], "Partial: %04d", u_Part);
                        padStColrs[ig] = Col_Partial;
                    ) :
                    (ty === padStDispGrp) ? (
                        ((u_Grp === Undef) || (u_Bnk === Undef)) ? (
                            sprintf(padStLabs[ig], "Undefined");
                        ) : (
                            sprintf(padStLabs[ig], "Group: %d", u_Grp);
                        );
                        padStColrs[ig] = Col_Group ;
                    ) :
                    (ty === padStDispGBk) ? (
                        ((u_Grp === Undef) || (u_Bnk === Undef)) ? (
                            sprintf(padStLabs[ig], "Undefined");
                        ) : (
                            sprintf(padStLabs[ig], "Grp:%d Bnk:%d", u_Grp, u_Bnk);
                        );
                        padStColrs[ig] = Col_GrBnk ;
                    ) :
                    (ty === padStDispRng) ? (
                        // Show the clip range of the partial
                        ((u_ClL === Undef) || (u_ClH === Undef)) ? (
                            sprintf(padStLabs[ig], "Undefined");
                        ) : (
                            sprintf(padStLabs[ig], "%04d:%04d", u_ClL, u_ClH);
                        );
                        padStColrs[ig] = Col_ClRange ;
                    ) :
                    (ty === padStDispClip) ? (
                        // Show a specific clip of the partial
                        u_ClX = u_ClL;
                        ((u_ClX >= 0) && (u_ClX <= 9999)) ? (
                            sprintf(padStLabs[ig], "> %04d <", u_ClX);
                        ) : (
                            sprintf(padStLabs[ig], "> none <");
                        );
                        padStColrs[ig] = Col_ClUniq ;
                    ) :
                    (ty === padStDispAct) ? (
                        // An action is associated to the 3 avail. values
                        u_ClX = u_ClL;
                        ((u_ClX >= 0) && (u_ClX <= 9999)) ? (
                            sprintf(padStLabs[ig], "Act: %d", u_ClX);
                        ) : (
                            sprintf(padStLabs[ig], "] none [");
                        );
                        padStColrs[ig] = Color_Cornflower_Blue ;
                    ) :
                    (ty === padStDispSpec) ? (
                        padStColrs[ig] = Color_Bondi_Blue ;
                        sprintf(padStLabs[ig], "MIDI: %d %d", u_ClL, u_ClX);
                    ) :
                    (ty === padStDispNone) ? (
                        padStLabs[ig] = "";
                        padStColrs[ig] = Col_Inactive;
                        (padStCells[ig] & ui_jpad_ct_selec) ? (
                        padStCells[ig] = padStCells[ig] ~ ui_jpad_ct_selec;
                        );
                    ) :
                    ((ty === padStDispErr) || (ty & padStFlErrbit)) ? (
                        // signal an error
                        (u = padStErrors[ig]) ? (
                            sprintf(padStLabs[ig], "Err. %d", u);
                            padStColrs[ig] = Col_Error;
                        ) : (
                            sprintf(padStLabs[ig], "No err.");
                            padStColrs[ig] = Col_InfoC;
                        );
                    ) :
                    (
                        padStCells[ig] = (padStCells[ig] & padStFlMsk) ;
                    );
                    ig += 1;
                );
                AA = padStudio[ui_jpad_gloff]; // padStudio[ui_jpad_gloff] = 0;

                zz = control_jpad(padStudio);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1;
                    ui_GFXReason = 35;
                    AAzzch = zzch = padStudio[ui_jpad_lkey];
                    zzent = padStudio[ui_jpad_entkey]-1;
                    zzmcl = padStudio[ui_jpad_last]-1;
                    zzmmd = padStudio[ui_jpad_lmods];
                    ty = (u = padStCells[zzmcl]) & padStFlDisp;
                    StdnumLastM = lastTime; StdnumUnchkd = 16;

                    (zz & ui_jpad_ev_key) ? (
                        (zzch === '+') ? (
                            padStGFact += max(0.1, padStGFact * 0.1);
                        ) :
                        (zzch === '-') ? (
                            padStGFact = max(0, padStGFact - padStGFact * 0.1);
                        ) :
                        (zzch === '=') ? (
                            padStGFact = 2;
                        ) : (
                            Keyed = zzch; // note char
                            updStudPadKey(zzent, zzch);
                            AAAA_lastKeyedT = zzch;
                        );
                    );

                    // Left mouse click
                    (zz & ui_jpad_ev_lmc) ? (
                        (zzmmd & 4) ? ( // cmd-left-click
                            (u & ui_jpad_ct_selec) ? (
                                padStCells[zzmcl] = u ~ ui_jpad_ct_selec;
                            ) : (
                                (padStCells[zzmcl] & padStFlDspM) ? (
                                    // we can select the cell
                                    padStCells[zzmcl] = u | ui_jpad_ct_selec;
                                );
                            );
                        ) :
                        (zzmmd & cmdCap) ? ( // ctrl-left-click
                            // reset err indication
                            padStErrors[zzmcl] = 0;
                        ) :
                        (
                            (u & ui_jpad_ct_selec) ? (
                                (u & ui_jpad_ct_round) ? (
                                    // stop playing the pad
                                    padStCells[zzmcl] = u ~ ui_jpad_ct_round;
                                    w = cmdPadBase + zzmcl + padStOffset | FLdoForcePlay | FLdoForceLock;
                                    doPlayer(-1, KmdUnlock, w); // unlock the player
                                ) : (
                                    // start playing & lock
                                    padStCells[zzmcl] = u | ui_jpad_ct_round;
                                    Kbtp = cmdPadBase + zzmcl + padStOffset | FLdoForcePlay | FLdoForceLock;
                                );
                            ) : (
                                // standard play
                                Kbtp = cmdPadBase + zzmcl + padStOffset | FLdoForcePlay;
                            );
                            BKnumLastM = lastTime; BKnumUnchkd  = 16; // ?
                        );
                        padStCells[zzmcl] &= padStFlMsk7;
                    );

                    // Right Mouse click
                    (zz & ui_jpad_ev_rmc) ? (
                        menu_Stud_Pad[ui_jmenu_ticks] = uix_bit_set[u & padStFlDspM];
                        w = control_jmenu(menu_Stud_Pad);
                        (w != 0) ? (
                            padStCells[zzmcl] = (u & padStFlMsk) | (w - 1); ///
                        );
                        padStCells[zzmcl] &= padStFlMsk7;
                    );

                    // Center mouse click
                    (zz & ui_jpad_ev_cmc) ? (
                        w = ty >= padStDispErr ? padStDispPar : ty + 1;
                        padStCells[zzmcl] = (padStCells[zzmcl] & padStFlMsk) | w; ///
                    );
                );
            ui_pop();

            ig = 0; loop(padStSiz,
                kg = ig + padStOffset;
                padStFlags[kg] = padStCells[ig];
                ig += 1;
            );

            (zzmi && do_ModuleKeyboard()) ? (
                do_StudioPadKeyboard();
            );
            do_ModuleKeySave();


        ui_pop();
    );
);





function
show_Play_Control()
local (h1, pl, uix_jneed, zz, zzch, zzent, zzmcl, zx, zzmi, zzmmd, key, jmc, val, p, uix_jmini)
(
    h1 = uix_jpadHeight(padcNl_PCtrl); // A 2 lines Pad
    uix_jneed = uix_jmini = h1+ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());

            zzmi = ui_hover();  // true if we are "in the module"
            jmc = ui_jmouse_cap;

            // Keep block position
            keepBlockInfos(blockPlayControls);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockPlayControls]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);


            ui_split_top(h1);
                ui_pad(1,2,3,2);

                pl = gmem[comPlCnt];
                GvPlayPartent = BKTab + GvPlayPart * BKEsize; // The partial address
                GvPlayPM =  GvPlayPartent[idx_Pa_PlM];
                GvPlaySM =  GvPlayPartent[idx_Pa_SpM];
                mMod = GvPlayTyp === GvPlayTypPartial;

                // Update colors & strings
                mSL_setStrArray(padAcLabs, padAcSiz);

                (paramValues[p_GvAutoMd]) ? (
                    padAcLabs[0] = "Auto-play (on)";
                    padAcColrs[0] = Col_Cmnds ;
                ) : (
                    padAcLabs[0] = "Auto-play (off)";
                    padAcColrs[0] = Col_Inactive;
                );

                padAcLabs[1] = "Default";
                padAcColrs[1] = Col_InfoD ;

                // padAcLabs[2] = menu_Act_Mode[ui_jmenu_items+GvPlayTyp];
                strcpy(padAcLabs[2], ui_menu_item(menu_Act_Mode, GvPlayTyp + 1)) ;
                padAcColrs[2] = Col_InfoB ;

                sprintf(padAcLabs[3], "Group: %d", (padAcVals[3] = GvPlayGrp));
                padAcColrs[3] = (PadTypGroup & uix_bit_set[GvPlayTyp]) ?
                                Col_Group : Col_Inactive;

                sprintf(padAcLabs[4], "Bank: %d", (padAcVals[4] = GvPlayBnk));
                padAcColrs[4] = (PadTypBank & uix_bit_set[GvPlayTyp]) ?
                                Col_Bank : Col_Inactive;

                sprintf(padAcLabs[5], "Partial: %04d", (padAcVals[5] = GvPlayPart));
                padAcColrs[5] = (PadTypPartial & uix_bit_set[GvPlayTyp]) ?
                                Col_Partial : Col_Inactive;
                // mMod = (PadTypPartial & uix_bit_set[GvPlayTyp]);
                zz = mMod || (PadTypPM & uix_bit_set[GvPlayTyp]);

                sprintf(padAcLabs[6], "P.Mode: %d", (padAcVals[6] = GvPlayPM));
                padAcColrs[6] = zz ? Col_PlMode : Col_Inactive;

                sprintf(padAcLabs[7], "S.Mode: %d", (padAcVals[7] = GvPlaySM));
                padAcColrs[7] = zz ? Col_SpMode : Col_Inactive;

                padAcLabs[8] =  "Stop Play";
                padAcColrs[8] = Col_CmdStp;

                sprintf(padAcLabs[9], "Playing %d/%d", pl, parV(p_maxGenerators));
                padAcColrs[9] = Col_InfoD ;

                sprintf(padAcLabs[10], "> %04d <", gmem[comPlClLast]);
                padAcColrs[10] = pl ? Col_ClUniq : Col_Inactive;

                sprintf(padAcLabs[11],"P.M: %d, S.M: %d", GvpM, GvsM);
                padAcColrs[11] = pl ? Col_InfoC : Col_Inactive;

                sprintf(padAcLabs[12], "Err: %d", Krtc);

                sprintf(padAcLabs[13], "> %04d <", (padAcVals[13] = GvPlayCl0));
                padAcColrs[13] = (PadTypCl0 & uix_bit_set[GvPlayTyp]) ?
                                Col_ClUniq : Col_Inactive;


                sprintf(padAcLabs[14], "Cl.low: %04d", (padAcVals[14] = GvPlayCl1));
                padAcColrs[14] = (zz || (PadTypCl1 & uix_bit_set[GvPlayTyp])) ?
                                Col_ClRange : Col_Inactive;

                sprintf(padAcLabs[15], "Cl.high: %04d", (padAcVals[15] = GvPlayCl2));
                padAcColrs[15] = (zz || (PadTypCl2 & uix_bit_set[GvPlayTyp])) ?
                                Col_ClRange : Col_Inactive;


                //*/
                w = ui_width(); c = padAcNc;
                (w < ui_jpad_cl_minWidth * padAcNc) ? (
                    c = 0|(w/ui_jpad_cl_minWidth);
                );
                padcNl_PCtrl = max(1, 0|((padAcSiz + c - 1)/c));
                zz = control_jpad(padActions, padcNl_PCtrl, c, 3);
                //*/

                //zz = control_jpad(padActions);
                (zz > 0) ? (
                    ui_GFXdoNow |= 1; ui_GFXReason = 36;
                    zzch = padActions[ui_jpad_lkey];
                    zzent = padActions[ui_jpad_entkey]-1;
                    zzmcl = padActions[ui_jpad_last]-1;
                    zzmmd = padActions[ui_jpad_lmods];
                    zzmc = ui_jmouse_cap & 0x3;
                    StdActLastM = lastTime; StdActUnchkd = 1;
                    /*
                    sprintf(#u, "padActions: zz:%d ch:%d ent:%d mcl:%d mmd:%d mc:%x mMod:%d",
                                              zz,zzch,zzent,zzmcl,zzmmd,zzmc, mMod);
                    mSL_log(SysLogBox, #u);
                    */

                    (zz & ui_jpad_ev_key) ? (
                        Keyed = zzch;
                        AAAA_lastKeyedT = zzch;

                        (zzmc === 0) ? (
                            (zzent === 2) ? (
                                Keyed = 0;
                                (zzch === 'c') ? (GvPlayTyp = GvPlayTypClip) :
                                (zzch === 's') ? (GvPlayTyp = 0) :
                                (zzch === 'r') ? (GvPlayTyp = GvPlayTypRange) :
                                (zzch === 'p') ? (GvPlayTyp = GvPlayTypPartial) :
                                (zzch === 'g') ? (GvPlayTyp = GvPlayTypGroup) :
                                (zzch === 'b') ? (GvPlayTyp = GvPlayTypBank) :
                                (zzch === 'a') ? (GvPlayTyp = GvPlayTypAnyClip) :
                                ((zzmc === 0) && (zzch === 'left')) ? (GvPlayTyp = (GvPlayTyp + menuActModeCnt - 1) % menuActModeCnt) :
                                ((zzmc === 0) && (zzch === 'rght')) ? (GvPlayTyp = (GvPlayTyp + 1) % menuActModeCnt) :
                                (zzch === '*') ? (
                                    // very slow stop all...
                                    parSet(p_GvAutoMd, 0);
                                    // clearCmd();
                                    doActivePlayer(-1, KmdStop, 0);
                                    BPLSTClear();
                                ) :
                                (Keyed = zzch;) ; // we didn't used the char.
                            ) :
                            (zzent === 3) ? (
                                GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', padAcVals[3], zzch);
                            ) :
                            (zzent === 4) ? (
                                GvPlayBnk = padAcVals[4] = updGrBkNumber('bk', padAcVals[4], zzch);
                            ) :
                            (zzent === 5) ? (
                                padBKVals[0] = GvPlayPart = padAcVals[5] = updPartNumber(padAcVals[5], zzch);
                                GvPlayPartent = BKTab + GvPlayPart * BKEsize; // The partial address
                            ) :
                            (zzent === 6) ? (
                                // update the play mode entry
                                GvPlayPM = padAcVals[6] = updPlMdNumber(padAcVals[6], zzch);
                                mMod ? (GvPlayPartent[idx_Pa_PlM] = GvPlayPM;);
                            ) :
                            (zzent === 7) ? (
                                // update the space mode entry
                                p = padAcVals[7];
                                GvPlaySM = padAcVals[7] = updSpMdNumber(p, zzch);
                                mMod ? (GvPlayPartent[idx_Pa_SpM] = GvPlaySM;);
                                sprintf(#u, "padAcVals[7]: ch:%d ent:%d [7]:%d => %d mc:%x mMod:%d",
                                                          zzch,zzent,p,GvPlaySM,zzmc, mMod);
                                mSL_log(SysLogBox, #u);
                            ) :
                            (zzent === 13) ? (
                                // update the clip number entry
                                GvPlayCl0 = padAcVals[13] = updClipNumber(padAcVals[13], zzch, 1007);
                            ) :
                            (zzent === 14) ? (
                                // update the clip number entry
                                GvPlayCl1 = padAcVals[14] = updClipNumber(padAcVals[14], zzch, 1008);
                            ) :
                            (zzent === 15) ? (
                                // update the clip number entry
                                GvPlayCl2 = padAcVals[15] = updClipNumber(padAcVals[15], zzch, 1009);
                            ) ;
                        );
                    );

                    (zz & ui_jpad_ev_rmc) ? (  // right mouse clic
                        key = buildKey(1, zzmmd);
                        (zzmcl === 0) ? (
                            SchedAddTask(5, 1|ActFlg1, 1, -1, 0, 0, 0); // Lock & unmute all
                            parSet(p_GvAutoMd, 0); // and stop playing
                            // gmem[commonGlobalVolume] = 1;
                            parSet(p_Vol_Global, 0);
                        ) :
                        (zzmcl === 2) ? (
                            zx = control_jmenu(menu_Act_Mode);
                            (zx != 0) ? (GvPlayTyp = zx-1; );
                        ) :
                        (zzmcl === 3) ? (
                            GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', padAcVals[3], - key);
                        ) :
                        (zzmcl === 4) ? (
                            GvPlayBnk = padAcVals[4] = updGrBkNumber('bk', padAcVals[4], - key);
                        ) :
                        (zzmcl === 5) ? (
                            padBKVals[0] = GvPlayPart = padAcVals[5] = updPartNumber(padAcVals[5], - key);
                            GvPlayPartent = BKTab + GvPlayPart * BKEsize; // The partial address
                        ) :
                        (zzmcl === 6) ? (
                            // update the play mode entry
                            key = buildKey(1, zzmmd);
                            GvPlayPM = padAcVals[6] = updPlMdNumber(padAcVals[6], - key);
                            mMod ? (GvPlayPartent[idx_Pa_PlM] = GvPlayPM;);
                        ) :
                        (zzmcl === 7) ? (
                            // update the space mode entry
                            key = buildKey(1, zzmmd);
                            GvPlaySM = padAcVals[7] = updSpMdNumber(padAcVals[7], key);
                            mMod ? (GvPlayPartent[idx_Pa_SpM] = GvPlaySM;);
                        ) :
                        (zzmcl === 8) ? (
                            parSet(p_GvAutoMd, 0);
                            // clearCmd();
                            (zzmmd & cmdCap) ? (
                                doActivePlayer(-1, KmdStop, 0);
                            ) : (
                                doActivePlayer(-1, KmdQStop, 0);
                            );
                            BPLSTClear();
                        ) :
                        ((zzmcl === 13)||(zzmcl === 14)||(zzmcl === 15)) ? (
                            // update a clip entry
                            val= padAcVals[zzmcl] = updClipNumber(padAcVals[zzmcl], - key, 1010);
                            (zzmcl === 13) ? (GvPlayCl0 = val;) :
                            (zzmcl === 14) ? (GvPlayCl1 = val;) :
                            (zzmcl === 15) ? GvPlayCl2 = val;
                        );

                    );

                    (zz & ui_jpad_ev_lmc) ? (  // left mouse clic
                        key = buildKey(-1, zzmmd);
                        (zzmcl === 0) ? (
                            (jmc & 4) ? ( // command key
                                GvPlayOnce = 1;
                            ) : (
                                switchAuto();
                            );
                        ) :
                        ((zzmcl === 1)||(zzmcl === 2)) ? (
                            Kbtp = cmdClMdBase + GvPlayTypGrLoop;
                        ) :
                        (zzmcl === 3) ? (
                            GvPlayGrp = padAcVals[3] = updGrBkNumber('gr', padAcVals[3], - key);
                        ) :
                        (zzmcl === 4) ? (
                            GvPlayBnk = padAcVals[4] = updGrBkNumber('bk', padAcVals[4], - key);
                        ) :
                        (zzmcl === 5) ? (
                            padBKVals[0] = GvPlayPart = padAcVals[5] = updPartNumber(padAcVals[5], - key);
                            GvPlayPartent = BKTab + GvPlayPart * BKEsize; // The partial address
                        ) :
                        (zzmcl === 6) ? (
                            // update the play mode entry
                            GvPlayPM = padAcVals[6] = updPlMdNumber(padAcVals[6], - key);
                            mMod ? (GvPlayPartent[idx_Pa_PlM] = GvPlayPM;);
                        ) :
                        (zzmcl === 7) ? (
                            // update the space mode entry
                            GvPlaySM = padAcVals[7] = updSpMdNumber(padAcVals[7], key);
                            mMod ? (GvPlayPartent[idx_Pa_SpM] = GvPlaySM;);
                        ) :
                        (zzmcl === 8) ? (
                            // clearCmd();
                            (zzmmd & cmdCap) ? ( // control key
                                doActivePlayer(-1, KmdStop, 0);
                            ) : (
                                doActivePlayer(-1, KmdQStop, 0);
                            );
                            BPLSTClear();
                        ) :
                        ((zzmcl === 13)||(zzmcl === 14)||(zzmcl === 15)) ? (
                            // update a clip entry
                            val= padAcVals[zzmcl] = updClipNumber(padAcVals[zzmcl], - key, 1011);
                            (zzmcl === 13) ? (GvPlayCl0 = val;) :
                            (zzmcl === 14) ? (GvPlayCl1 = val;) :
                            (zzmcl === 15) ? (GvPlayCl2 = val;);
                        ) :
                        ((zzmcl === 10)||(zzmcl === 11)) ? (
                            // keep the clip information to be able to replay it...
                            padAcVals[10] = GvPlayCl0 = gmem[comPlClLast];
                            // select mode "clip"
                            GvPlayTyp = GvPlayTypClip;
                            parSet(p_GvAutoMd, 0);
                            // clearCmd();
                            GvPlayPM = GvpM; GvPlaySM = GvsM;
                            GvPlayPart = 0; // use Partial "0"
                            GvPlayPartent = BKTab + GvPlayPart * BKEsize; // The partial address
                        );
                    );
                );
            ui_pop();

            do_ModuleKeySave();

        ui_pop();
    );


);





function showCSlider(slb, num)
local(xx, p, flgm)
(
    ui_hover() ? (
        xx = control_jmenu(menu_Param_mSL); // ubl
        (xx != 0) ? (
            // AAAAAAAA_xx = xx;
            (xx === 1) ? (
                // "up move"
                ((num > Bpl_Sl1) && (num < slb[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    // xch this entry with the previous
                    p = slb[num]; slb[num] = slb[num - 1]; slb[num - 1] = p;
                );
            ) :
            (xx === 2) ? (
                // down move
                ((num >= Bpl_Sl1) && (num < slb[Bpl_SlCnt]+Bpl_Sl1-2)) ? (
                    // xch this entry with the next one
                    p = slb[num]; slb[num] = slb[num + 1]; slb[num + 1] = p;
                );
            ) :
            (xx === 3) ? (
                // blank entry
                ((num >= Bpl_Sl1) && (num <= slb[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    slb[num] = -1;
                );
            ) :
            (xx === 4) ? (
                // clear entry
                ((num >= Bpl_Sl1) && (num < slb[Bpl_SlCnt]+Bpl_Sl1-1)) ? (
                    slb[num] = 0;
                );
            ) :
            (xx === 5) ? (
                // clear all
                k = Bpl_Sl1; while (k < slb[Bpl_SlCnt]+Bpl_Sl1-1) (
                    slb[k] = 0; k += 1;
                );
            ) :
            (xx === 6) ? (
                slb[Bpl_CCSlCnt] = 0;
            ) :
            (xx === 7) ? (
                slb[Bpl_CCSlCnt] = 1;
            ) :
            (
                // Changing the displayed control
                slb[num] = paramMSLMenuNums[xx];
            );
        ) : (
            uix_click(1) ? (
                param_last_touched = slb[num];
                param_touch_count += 1;
            );
        );
    );
    BAA_par = p = slb[num]; // the parameter
    (p >= 1) ? (
        // display the control
        ui_pcolor(ui_jcolor_text);
        flgm = parCtl(p);
    ) : (
        ui_pad(5,0,0,0); ui_align(0, 0.5);
        ui_text((p === 0) ? " (unset entry) " : "");
    );

);


function
show_Control_Sliders(slBlock, blockId)
local (h2, h3, uix_jneed, k, n, e, zzmi)
(
A_0000_slBlock = slBlock;
A_0000_blockId = blockId;
A_0000_h2_A = slBlock[Bpl_CCSlCnt];
A_0000_h2_B = slBlock[Bpl_SlCnt];
    // h2 = ui_jd_slidh*(mdWide ? 28 : 14); // sliders
    (slBlock[Bpl_CCSlCnt] === 0) ? (
        h2 = ui_jd_slidh * max(1,slBlock[Bpl_SlCnt]) + 4;
    ) : (
        h2 = ui_jd_slidh * max(1,ceil(slBlock[Bpl_SlCnt]/2)) + 4;
    );

A_0000_h2_D = h2;
    // h3 = uix_jBoxHeight(3);
    h3 = 0;
    uix_jneed = h2+h3+ui_jd_ctgr;
A_000_uix_jneed = uix_jneed ;

    (ui_height() > max(uix_jneed * 0.8, ui_jd_min_block)) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            // Keep block position
            keepBlockInfos(blockId);
            (zzmi) ? (
                0 ? (
                    (((pmous & 1) === 1) && ((cmous & 1) === 0)) ? (
                        sprintf(#sx, "**G_G [%d/%d -- %d/%d]  (%d/%d  -- %d/%d)",
                                ui_left(), ui_top(), ui_right(), ui_bottom(),
                                ui_left_retina(), ui_top_retina(), ui_right_retina(), ui_bottom_retina());
                                mSL_log(SysLogBox, #sx);
                    );
                );
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockId]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

            // ui_split_top(h2);

                (slBlock[Bpl_CCSlCnt] === 0) ? (
                    k = Bpl_Sl1; loop (max(1,slBlock[Bpl_SlCnt]),
                        (ui_height() >= ui_jd_slidh) ? (
                            ui_split_top(ui_jd_slidh);
                                showCSlider(slBlock, k);
                            ui_pop();
                        );
                        k += 1;
                    );
                ) : (
                    k = Bpl_Sl1; loop (max(1,ceil(slBlock[Bpl_SlCnt]/2)),
                        (ui_height() >= ui_jd_slidh) ? (
                            ui_split_top(ui_jd_slidh);
                                ui_split_leftratio(0.5);
                                    showCSlider(slBlock, k);
                                ui_split_next();
                                    showCSlider(slBlock, k+1);
                                ui_pop();
                            ui_pop();
                        );
                        k += 2;
                    );
                );

                //// Update next
                k = n = Bpl_Sl1;
                while (k < Bpl_SlLast) (
                    ((e = slBlock[k]) != 0) ? (
                        slBlock[n] = e; n += 1;
                    );
                    k += 1;
                );
                slBlock[Bpl_SlCnt] = n + 1 - Bpl_Sl1;
                while (n < Bpl_SlLast) (
                    slBlock[n] = 0; n += 1;
                );
                slBlock[n] = -1;

            // ui_pop();

        ui_pop();
    );
    AAAAAAAA_SlCnt = slBlock[Bpl_SlCnt];
);





function show_Random_States()
local (uix_jneed, uix_jmini, ig, zzmi)
(
    uix_jneed = uix_jmini = ui_jd_slidh * 8 + ui_jd_ctgr;
    (ui_height() >= uix_jmini) ? (
        ui_split_top(uix_jneed);
            ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            // Keep block position
            zzmi = ui_hover();
            keepBlockInfos(blockRandStates);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group(blockDispNames[blockDispInverts[blockRandStates]]);
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
            AAAA_height = ui_height();

            ui_split_leftratio(0.5);
                ig = p_rgenA1; loop(RandomStates,
                    parCtl(ig);
                    ig += 1;
                );
            ui_split_next();
                ig = p_rgenP1; loop(RandomStates,
                    parCtl(ig);
                    ig += 1;
                );
            ui_pop();

        ui_pop();
    );
);

flagpr = 1;
function
show_UserModule(module)
local(umid, chk, i, statn, recomp, modInst, modSrc, ucod, uent, err)
(
    // module is a module number
    // Lets check the existence of the object
    modInst = err = recomp = 0;
    umid = module - blockUsrFirst; // user module. number, in 0 .. 31
    statn = blockUsrNum[umid]; // inverse reference number : from umid (dyn. computed) to statn (static number)
    modSrc = blockUsrRefs[statn]; // Memory address of the module prototype
    (chk = (mSL_bl_check(modSrc, 'umod') && mSL_bl_check(modSrc[ubx_mref], 'umod'))) ? (
        ucod = 0x10000 | (PanIdt << 8) | umid; // internal code for the module in this position
        uent = -1; // entry number of the module if it exists
        i = 0;
        while ((uent === -1) && (i < dcbUXRefsSiz)) (
            (blockUsrCode[i] === ucod) ? (uent = i; modInst = blockUsrDesc[i]);
            i += 1;
        );
        (uent === -1) ? (
            i = 0;
            while ((blockUsrCode[i] != 0) && (i < dcbUXRefsSiz)) ( i+= 1; );
            (i < dcbUXRefsSiz) ? (
                uent = i;
                modInst = blockUsrDesc[i] = mSL_bl_Dup(modSrc);
                blockUsrCode[i] = ucod;
                // (FlagsTbVals[Flgs_Umods] & 1) ? (
                    sprintf(#u, "Creating umod %x at %d from %d", ucod, modInst, modSrc);
                    mSL_log(SysLogBox, #u);
                // );
            );
        );
        // Now, modInst is the instance in this position of the module prototype
        chk = mSL_bl_check(modInst, 'umod');
    );

    (chk) ? (
        thrd = modInst[ubx_thread];
        chk = ((thrd[-2] === mSL_THR_KeyStrt) && (thrd[mSL_THR_UTId] === modInst[ubx_thrdid]));
    );

    (chk) ? (
        ut = user_top = ui_top();
        ul = user_left = ui_left();
        uw = user_width = ui_width();
        uh = user_height = ui_height(); // total available height
        // Are our computations still valid ?
        (ui_Resized || (modInst[ubx_flgs] & 1) || (user_top !== modInst[ubx_t]) || (user_left !== modInst[ubx_l]) ||
            (user_width !== modInst[ubx_w])) ? (    //  || (user_height < modInst[ubx_h])
            // Recompute positions off all fields
            recomp = 1;
            modInst[ubx_flgs] &= 0x7ffffffe;
            rptb = ubx_isiz; ptbl = modInst[-1];
            modInst[ubx_t] = user_top;
            modInst[ubx_l] = user_left;
            modInst[ubx_w] = user_width;
            modInst[ubx_h] = ui_jd_ctgr;
            // Compute internal needed height
            //sprintf(#u, "Recomputing umod %x positions", ucod);
            // mSL_log(SysLogBox, #u);
            state = 1; // start in state 1
            prvstk = ptstk = 0; stack = wa256;
            // AWA! Almost Working Algorithm
            uh = 0;
            while (state != 0) (
                (state === 1) ? (
                    // Push the umod infos
                    stack[0] = -1;
                    ptstk += stk_isiz;
                    stack[ptstk+stk_btyp] = 'umod';
                    stack[ptstk+stk_cbx] = 0;
                    stack[ptstk+stk_rtsk] = 0; // return stack
                    stack[ptstk+stk_rtst] = 0; // return state
                    stack[ptstk+stk_mode] = 0; // work mode = vertical
                    stack[ptstk+stk_h] = 0;
                    stack[ptstk+stk_i] = 0;
                    stack[ptstk+stk_b] = ubx_isiz; // first box in the sequence of siblings
                    state = 2; // goto state 2
                ) :
                (state === 2) ? (
                    anc = stack[ptstk+stk_cbx]; // position ancestor
                    typanc = stack[ptstk+stk_btyp]; // type of ancestor
                    k = anc + ubx_isiz * stack[ptstk+stk_i];
                    cbxrpt = stack[ptstk + stk_b] + k; // relative pointer to current box instance
                    cbxref = modInst[cbxrpt + ubx_mref]; // reference to current box prototype
                    typtb = cbxref[ubx_ty];
                    mode = stack[ptstk+stk_mode];
                    (typtb === 'sbox') ? (
                        // Add the height of the sbox
                        modInst[cbxrpt + ubx_h] = h = cbxref[ubx_h];
                        /*
                        sprintf(#u, "   ++ sbox %d add:%d/%d to %d", k, mode, h, stack[ptstk+stk_h]);
                        mSL_log(SysLogBox, #u);
                        */
                        mode ? (
                            stack[ptstk+stk_h] = max(stack[ptstk+stk_h],h);
                        ) : (
                            stack[ptstk+stk_h] += h;
                        );
                    ) :
                    (typtb === 'ibox') ? (
                        // Add the height of the sbox
                        modInst[cbxrpt + ubx_h] = h = cbxref[ubx_h];
                        /*
                        sprintf(#u, "   ++ ibox %d add:%d/%d to %d", k, mode, h, stack[ptstk+stk_h]);
                        mSL_log(SysLogBox, #u);
                        */
                        mode ? (
                            stack[ptstk+stk_h] = max(stack[ptstk+stk_h],h);
                        ) : (
                            stack[ptstk+stk_h] += h;
                        );
                    ) :
                    (typtb === 'tbox') ? (
                        // Get the size with the text wrap function
                        // cbxref is the ref to the text box
                        txt = cbxref[ubx_isiz]; // the text string
                        // evaluate the height
                        modInst[cbxrpt + ubx_h] = (h = ui_wraptext_height(txt));
                        // sprintf(#u, "   ++ tbox %d add:%d/%d to %d", k, mode, h, stack[ptstk+stk_h]); mSL_log(SysLogBox, #u);
                        mode ? (
                            stack[ptstk+stk_h] = max(stack[ptstk+stk_h],h);
                        ) : (
                            stack[ptstk+stk_h] += h;
                        );
                    ) :
                    (typtb === 'vbox') ? (
                        // A vertical box
                        // Push this box
                        prvstk = ptstk;
                        ptstk += stk_isiz;
                        stack[ptstk+stk_btyp] = typtb;
                        stack[ptstk+stk_cbx] = k;
                        stack[ptstk+stk_rtsk] = prvstk; // return stack
                        stack[ptstk+stk_rtst] = 2; // return state
                        stack[ptstk+stk_mode] = 0; // work mode = vertical
                        stack[ptstk+stk_h] = 0; // height so far
                        stack[ptstk+stk_i] = 0; // index in descendants
                        stack[ptstk+stk_b] = modInst[cbxrpt + ubx_1st]; // first box in the sequence of siblings
                        state = 2; // goto state 2
                    ) :
                    (typtb === 'hbox') ? (
                        // An horizontal box
                        // Push this box
                        prvstk = ptstk;
                        ptstk += stk_isiz;
                        stack[ptstk+stk_btyp] = typtb;
                        stack[ptstk+stk_cbx] = k;
                        stack[ptstk+stk_rtsk] = prvstk; // return stack
                        stack[ptstk+stk_rtst] = 2; // return state
                        stack[ptstk+stk_mode] = 1; // work mode = horizontal
                        stack[ptstk+stk_h] = 0; // height so far
                        stack[ptstk+stk_i] = 0; // index in descendants
                        stack[ptstk+stk_b] = modInst[cbxrpt + ubx_1st]; // first box in the sequence of siblings
                        state = 2; // goto state 2
                    ) :
                    (
                        err = 0871;
                        state = 0;
                    );
                    //== Skip to next sibling
                    i = (stack[ptstk+stk_i] += 1); // number of next sibling
                    (i >= modInst[anc + ubx_lcnt]) ? (
                        // return to previous state
                        state = stack[ptstk+stk_rtst]; // return state
                        ptstk = stack[ptstk+stk_rtsk]; // return stack
                    );
                ) :
                (
                    err = 0870;
                    state = 0;
                );
            );
            modInst[ubx_h] = stack[stk_isiz+stk_h] + ui_jd_ctgr; // computed height
        );

        uix_jneed = uix_jmini = modInst[ubx_h];
        (chk && (ui_height() >= uix_jmini)) ? (
            ui_split_top(uix_jneed);
                ui_set_rect(ui_left(), ui_top(), max(ui_MinSize1Pane, min(ui_BestSize1Pane, ui_width())), ui_height());
                zzmi = ui_hover();  // true if we are "in"
                // Keep block position
                keepBlockInfos(module);
                (zzmi) ? (
                    ui_push();
                        // stack is now 2 levels deep
                        ui_color(Col_Frame);
                        ui_border(); // draws in orange
                    ui_pop();
                );
                control_group(blockDispNames[blockDispInverts[module]]);

                ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
                // Inside of the module dimensions
                ut = ui_top();
                ul = ui_left();
                uw = ui_width();
                uh = ui_height();

                // Should we recomp item sizes ?
                (recomp) ? (
                    state = 1; prvstk = ptstk = 0; stack = wa256;
                    rptb = ubx_isiz; ptbl = modInst[-1];
                    while (state != 0) (
                        (state === 1) ? (
                            // Push the umod infos
                            stack[0] = -1;
                            ptstk += stk_isiz;
                            stack[ptstk+stk_btyp] = 'umod';
                            stack[ptstk+stk_cbx] = 0; // position of the box in the umod
                            stack[ptstk+stk_rtsk] = 0; // return stack
                            stack[ptstk+stk_rtst] = 0; // return state
                            stack[ptstk+stk_h] = uh;
                            stack[ptstk+stk_w] = uw;
                            stack[ptstk+stk_l] = ul;
                            stack[ptstk+stk_t] = ut;
                            stack[ptstk+stk_i] = 0;
                            stack[ptstk+stk_b] = ubx_isiz; // first box in the sequence of siblings
                            state = 2; // goto state 2
                        ) :
                        (state === 2) ? (
                            anc = stack[ptstk+stk_cbx]; // position ancestor
                            typanc = stack[ptstk+stk_btyp]; // type of ancestor
                            k = anc + ubx_isiz * stack[ptstk+stk_i];
                            cbxrpt = stack[ptstk + stk_b] + k; // relative pointer to current box instance
                            cbxref = modInst[cbxrpt + ubx_mref]; // reference to current box prototype
                            typtb = cbxref[ubx_ty];
                            (typtb === 'sbox') ? (
                                // Set the size of the rectangle for the 'sbox'
                                h = cbxref[ubx_h]; // height - already computed
                                modInst[cbxrpt + ubx_t] = stack[ptstk+stk_t]; // top
                                stack[ptstk+stk_t] += h; // update parent top
                                modInst[cbxrpt + ubx_l] = stack[ptstk+stk_l]; // same left as parent
                                modInst[cbxrpt + ubx_w] = stack[ptstk+stk_w]; // same width as parent
                                /*
                                sprintf(#u, "   ++ sbox %d [%d %d %d %d]", k, modInst[cbxrpt + ubx_l],
                                modInst[cbxrpt + ubx_t], modInst[cbxrpt + ubx_w], modInst[cbxrpt + ubx_h]);
                                mSL_log(SysLogBox, #u);
                                */
                            ) :
                            (typtb === 'ibox') ? (
                                h = cbxref[ubx_h]; // height - already computed
                                modInst[cbxrpt + ubx_t] = stack[ptstk+stk_t]; // top
                                stack[ptstk+stk_t] += h; // update parent top
                                modInst[cbxrpt + ubx_l] = stack[ptstk+stk_l]; // same left as parent
                                w = min(stack[ptstk+stk_w], cbxref[ubx_maxw]);
                                modInst[cbxrpt + ubx_w] = stack[ptstk+stk_w]; // same width as parent
                                /*
                                sprintf(#u, "   ++ ibox %d [%d %d %d %d]", k, modInst[cbxrpt + ubx_l],
                                modInst[cbxrpt + ubx_t], modInst[cbxrpt + ubx_w], modInst[cbxrpt + ubx_h]);
                                mSL_log(SysLogBox, #u);
                                */
                            ) :
                            (typtb === 'tbox') ? (
                                // recheck the size of the text
                                txt = cbxref[ubx_isiz]; // the text string
                                // re-evaluate the height
                                modInst[cbxrpt + ubx_h] = (h = ui_wraptext_height(txt));
                                modInst[cbxrpt + ubx_t] = stack[ptstk+stk_t]; // top
                                stack[ptstk+stk_t] += h; // update parent top
                                modInst[cbxrpt + ubx_l] = stack[ptstk+stk_l]; // same left as parent
                                modInst[cbxrpt + ubx_w] = stack[ptstk+stk_w]; // same width as parent
                                /*
                                sprintf(#u, "   ++ tbox %d [%d %d %d %d]", k, modInst[cbxrpt + ubx_l],
                                modInst[cbxrpt + ubx_t], modInst[cbxrpt + ubx_w], modInst[cbxrpt + ubx_h]);
                                mSL_log(SysLogBox, #u);
                                */
                            ) :
                            (typtb === 'vbox') ? (
                                // A vertical box
                                prvstk = ptstk;
                                // Push this box
                                prvstk = ptstk;
                                ptstk += stk_isiz;
                                stack[ptstk+stk_btyp] = typtb;
                                stack[ptstk+stk_cbx] = k;
                                stack[ptstk+stk_rtsk] = prvstk; // return stack
                                stack[ptstk+stk_rtst] = 2; // return state
                                stack[ptstk+stk_l] = stack[ptstk+stk_l]; // left from ancestor
                                stack[ptstk+stk_t] = stack[ptstk+stk_t]; // top from ancestor
                                stack[ptstk+stk_w] = stack[ptstk+stk_w]; // width from ancestor
                                stack[ptstk+stk_h] = h = cbxref[ubx_h]; // height - already computed;
                                stack[ptstk+stk_i] = 0; // index in descendants
                                stack[ptstk+stk_b] = modInst[cbxrpt + ubx_1st]; // first sibling
                                state = 2; // goto state 2
                            ) :
                            (
                                err = 0881;
                                state = 0;
                            );
                            //== Skip to next sibling
                            i = (stack[ptstk+stk_i] += 1); // number of next sibling
                            (i >= modInst[anc + ubx_lcnt]) ? (
                                // return to previous state
                                state = stack[ptstk+stk_rtst]; // return state
                                ptstk = stack[ptstk+stk_rtsk]; // return stack
                            );
                        ) :
                        (
                            err = 0880;
                            state = 0;
                        );
                    );


                    (FlagsTbVals[Flgs_Umods] & 2) ? (
                sprintf(#u, "User Block %x : %d / %d / %d / %d / %d => %d [t:%d  l:%d  w:%d  h:%d]  =>  [%d  %d  %d  %d]",
                ucod, module, umid, statn, blockUsrChecks[statn], blockUsrRefs[statn], modInst, user_top, user_left, user_width,
                user_height, ut, ul, uw, uh); mSL_log(SysLogBox, #u);
                    );

                );
                // ui_text(#u);


                // (Finally !) Let's put out items...
                rptb = ubx_isiz; ptbl = modInst[-1];
                while (rptb < ptbl) (
                    crptb = rptb;
                    (modInst[rptb + ubx_flgs] & ubx_final) ? (
                        ty = modInst[rptb + ubx_ty];
                        (ty === 'sbox') ? (
                            // position the rectangle for all sliders
                            ui_set_rect(modInst[rptb + ubx_l], modInst[rptb + ubx_t], modInst[rptb + ubx_w], modInst[rptb + ubx_h]);
                            //ui_pad(0,2,1,0);
                            ui_pcolor(ui_jcolor_text);
                            // Put the various sliders
                            addb = modInst[rptb + ubx_mref] + modInst[rptb + ubx_lcnt];
                            rcnt = addb[ubx_icnt]; // number of references
                            (recomp && (FlagsTbVals[Flgs_Umods] & 2)) ? (
                                sprintf(#u, "Slider box: %d -- %d refs.", addb, rcnt); mSL_log(SysLogBox, #u);
                            );
                            i = 0;
                            while (rcnt > 0) (
                                adds = addb[ubx_isiz+i]; // final "slider" address
                                pnum = adds[1]; // its parameter number
                                (recomp && (FlagsTbVals[Flgs_Umods] & 2)) ? (
                                    sprintf(#u, "Slider %d in [%d %d %d %d]  %d / %d / %d", pnum,
                                        ui_top(), ui_left(), ui_width(), ui_height(), i, rcnt, adds);
                                        mSL_log(SysLogBox, #u);
                                );
                                flgm = parCtl(pnum);
                                i += 1; rcnt -= 1;
                            );
                        ) :
                        (ty === 'ibox') ? (
                            // position the rectangle for the info block
                            ui_set_rect(modInst[rptb + ubx_l], modInst[rptb + ubx_t], modInst[rptb + ubx_w], modInst[rptb + ubx_h]);
                            blk = modInst[crptb + ubx_mref]; // ref to the info box
                            cnt = blk[ubx_isiz]; // parameter count
                            thrd = modInst[ubx_thread];
                            (recomp) ? (
                                sprintf(#u, "Info box: %d thrd: %d -- %d pars.", blk, thrd, cnt);
                                mSL_log(SysLogBox, #u);
                            );
                            wa = wa128; memset(wa, 0, 32);
                            i = 0; loop(cnt,
                                k = blk[ubx_isiz+i+1]; // next parameter
                                ((k >= mSL_Sym_Low) && (k <= mSL_Sym_High)) ? (k = mSL_idt_addr(thrd, k));
                                wa[i+16] = k; // keep address
                                (!mSL_isString(k)) ? ((k >= 0) ? (k = k[0]) : (k = gmem[-k]));
                                wa[i] = k; i += 1;
                            );
                            (recomp) ? (
                                sprintf(#u, "Info [%d/%d  %d/%d  %d/%d  %d/%d  %d/%d  %d/%d]",
                                            wa[16+0], wa[0], wa[16+1], wa[1], wa[16+2], wa[2],
                                            wa[16+3], wa[3], wa[16+4], wa[4], wa[16+5], wa[5]);
                                mSL_log(SysLogBox, #u);
                            );
                            (cnt === 0) ? (
                                ui_show();
                            ) :
                            (cnt === 1) ? (
                                ui_show(wa[0]);
                            ) :
                            (cnt === 2) ? (
                                ui_show(wa[0], wa[1]);
                            ) :
                            (cnt === 3) ? (
                                ui_show(wa[0], wa[1], wa[2]);
                            ) :
                            (cnt === 4) ? (
                                ui_show(wa[0], wa[1], wa[2], wa[3]);
                            ) :
                            (cnt === 5) ? (
                                ui_show(wa[0], wa[1], wa[2], wa[3], wa[4]);
                            ) :
                            (cnt === 6) ? (
                                ui_show(wa[0], wa[1], wa[2], wa[3], wa[4], wa[5]);
                            ) : (
                                ui_show("Error 8793");
                            );
                        ) :
                        (ty === 'tbox') ? (
                            // position the rectangle for the text
                            ui_set_rect(modInst[rptb + ubx_l], modInst[rptb + ubx_t], modInst[rptb + ubx_w], modInst[rptb + ubx_h]);
                            blk = modInst[crptb + ubx_mref]; // ref to the text box
                            txt = blk[ubx_isiz]; // the text string
                            ui_align(0.5, 0.5);
                            reh = w3 = ui_wraptext(txt);
                            (reh != modInst[crptb + ubx_h]) ? (
                                modInst[rptb + ubx_h] = reh;
                                // we have to adjust the height
                                modInst[ubx_flgs] |= 1;
                            );
                            (recomp && (FlagsTbVals[Flgs_Umods] & 2)) ? (
                                sprintf(#u, "Text box %d in [%d %d %d %d]   %d / %d / %d", txt,
                                ui_top(), ui_left(), ui_width(), ui_height(), w1, w2, w3);
                                mSL_log(SysLogBox, #u);
                            );
                        );
                    );
                    rptb += ubx_isiz;
                );

            ui_pop();
        );
    );

    (!chk) ? (
        h1 = uix_jpadHeight(1); // A 1 line to display info
        uix_jneed = uix_jmini = h1+ui_jd_ctgr;
        (ui_height() >= uix_jmini) ? (
            ui_split_top(uix_jneed);
                ui_set_rect(ui_left(), ui_top(), max(ui_MinSize1Pane, min(ui_BestSize1Pane, ui_width())), ui_height());
                zzmi = ui_hover();  // true if we are "in
                // Keep block position
                keepBlockInfos(module);
                (zzmi) ? (
                    ui_push();
                        // stack is now 2 levels deep
                        ui_color(Col_Frame);
                        ui_border(); // draws in purple
                    ui_pop();
                );
                control_group(blockDispNames[blockDispInverts[module]]);
                statn = blockUsrNum[umid];
                ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
                sprintf(#u, "Error: User Block %d / %d / %d / %d / %d [t:%d  l:%d  w:%d  h:%d]", module, umid, statn,
                    blockUsrChecks[statn], blockUsrRefs[statn], user_top, user_left, user_width, user_height);
                ui_text(#u);
            ui_pop();
        );
    );

    (!chk) ? (
        // module doesn't exist anymore
        blockDesc[Bigx] = 0; // remove reference
        blockUsrRefs[statn] = 0;
        blockUsrNames[statn] = 0;
        blockUsrChecks[statn] = 0;
        blockUsrIds[statn] = 0;
        blockUsrNum[umid] = 0;
    );
);


function
genericItemsPos(bNumb)
local(xx, xy, igb, u, v, w, m, myp, i, j, k, p, s, wst, kit)
(
    blockMouseWasIn = 0;
    PanIdt = bNumb;
    // wst = #;
    ((bNumb >=0) && (bNumb < dcbMCount) && menu_Stud_Mod) ? (
        blockDesc = dcbBlocksAll + bNumb * dcbWSize;
        (ui_hover()) ? (
            colMouseWasIn = studDispCol;
            ((KeyedT === 'rght') && (Kmouse_cap === 8)) ? (
                // try to increase colum size
                p = serialBlock + Pr7_StudRat + 4 * TabIdt;
                ((colMouseWasIn === 0) && (studDispPCnt >= 2)) ? (
                    // increase first col. size
                    k = min(20, max(0, p[1] - ui_MinSize1Pane));p[0] += k; p[1] -= k;
                ) :
                ((colMouseWasIn === 1) && (studDispPCnt === 2)) ? (
                    // increase 2nd col. size
                    k = min(20, max(0, p[0] - ui_MinSize1Pane)); p[1] += k; p[0] -= k;
                ) :
                ((colMouseWasIn === 1) && (studDispPCnt >= 3)) ? (
                    // increase 2nd col. size
                    k = min(20, max(0, p[2] - ui_MinSize1Pane)); p[1] += k; p[2] -= k;
                ) :
                ((colMouseWasIn === 2) && (studDispPCnt === 3)) ? (
                    // increase 3nd col. size
                    k = min(20, max(0, p[0] - ui_MinSize1Pane)); p[2] += k; p[0] -= k;
                ) :
                ((colMouseWasIn === 2) && (studDispPCnt === 4)) ? (
                    // increase 3nd col. size
                    k = min(20, max(0, p[3] - ui_MinSize1Pane)); p[2] += k; p[3] -= k;
                ) :
                ((colMouseWasIn === 3) && (studDispPCnt === 4)) ? (
                    // increase 4nd col. size
                    k = min(20, max(0, p[0] - ui_MinSize1Pane)); p[3] += k; p[0] -= k;
                ) ;
                KeyedT = 0;
            ) :
            ((KeyedT === 'left') && (Kmouse_cap === 8)) ? (
                // try to increase colum size
                p = serialBlock + Pr7_StudRat + 4 * TabIdt;
                ((colMouseWasIn === 0) && (studDispPCnt === 4)) ? (
                    // increase first col. size
                    k = min(20, max(0, p[3] - ui_MinSize1Pane));p[0] += k; p[3] -= k;
                ) :
                ((colMouseWasIn === 0) && (studDispPCnt === 3)) ? (
                    // increase first col. size
                    k = min(20, max(0, p[2] - ui_MinSize1Pane));p[0] += k; p[2] -= k;
                ) :
                ((colMouseWasIn === 0) && (studDispPCnt === 2)) ? (
                    // increase first col. size
                    k = min(20, max(0, p[1] - ui_MinSize1Pane));p[0] += k; p[1] -= k;
                ) :
                ((colMouseWasIn === 1) && (studDispPCnt >= 2)) ? (
                    // increase first col. size
                    k = min(20, max(0, p[0] - ui_MinSize1Pane));p[1] += k; p[0] -= k;
                ) :
                ((colMouseWasIn === 2) && (studDispPCnt >= 3)) ? (
                    // increase 2nd col. size
                    k = min(20, max(0, p[1] - ui_MinSize1Pane)); p[2] += k; p[1] -= k;
                ) :
                ((colMouseWasIn === 3) && (studDispPCnt === 4)) ? (
                    // increase 2nd col. size
                    k = min(20, max(0, p[2] - ui_MinSize1Pane)); p[3] += k; p[2] -= k;
                ) ;
                KeyedT = 0;
            );
            // Update col. size
            blockMouseWasIn = blockDesc[dcbWSize - 1];
            // we may need to update the menu
            p = menu_Stud_Mod + ui_jmenu_items;
            i=0; while (i < blockMenuITC) (
                s = p[i]; // u = str_getchar(s, 2, 'cu');
                //((u === ui_jmenu_chSP) || (u === ui_jmenu_noSel))? (
                    str_setchar(s, 1, ui_jmenu_chSP);
                //);
                i += 1;
            );
            i=0; loop(dcbMSize,
                (k = blockDesc[i]) ? (
                    ((k > 0) && (k < blockDispITC)) ? (
                        j = blockDispInverts[k];
                        s = p[j]; str_setchar(s, 1, '!');
                    ) : (
                        blockDesc[i] = 0;
                    );
                );
                i += 1;
            );
            //is there a "current" block ?
            // update "clicked in"
            blockDesc[dcbWSize - 1] = 0;
            A99m = mouse_y;
            i = 0; while ((k = blockDesc[i]) != 0) (
                u = blockDesc[i+dcbMSize]; v = u/10000; u = u %10000; // the block
                ((A99m >= v) && (A99m < (u+v))) ? (
                    // clicked in the box
                    blockDesc[dcbWSize - 1] = k;
                );
                i += 1;
            );
            cModule = A99CBlock = k = blockDesc[dcbWSize - 1];
            strncpy(#Aws3, p[0], 6);
            (k != 0) ? (
                strcat(#Aws3, blockDispNames[blockDispInverts[k]]);
                str_setchar(#Aws3, 1, '!');
            ) : (
                strcat(#Aws3, "-");
            );
            strcpy(p[0], #Aws3);
            // Indicates the pane preferences
            s = p[block1Pane -1 + studDispPrf];
            str_setchar(s, 1, '!');
            0 ? (
                sprintf(#dbg_trace1, "*ZZZ* [%d]  \"%s\"  (%d)  \"%s\" ", A99CBlock, blockDispNames[blockDispInverts[A99CBlock]], p[0],#Aws3);
            );


            // ADump(blockDesc);

            xx = control_jmenu(menu_Stud_Mod);
            xx ? (
                ui_GFXdoNow |= 1;
                blockRent = xx; // entry selected (trace only)
                kit = jmenu_res2item(menu_Stud_Mod, xx);
                0 ? (
                    sprintf(#dbg_trace0, "[%d/%d] XX  %d \"%s\" %d", TabIdt, bNumb, xx, ui_menu_item(menu_Stud_Mod, xx), kit);
                    mSL_log(SysLogBox, #dbg_trace0);
                );
                // ADump(blockDesc);
                //xx2 = ui_menu_ent(menu_Stud_Mod, xx);
                //p = menu_Stud_Mod + ui_jmenu_items + xx -1; wst = p[0]; k = blockDispIdts[xx-1];
                //    #dbg_desc = #sfc;
                (kit === 0) ? (
                    (cModule > 0) ? (
                        copiedMod = cModule;
                        i = j = 0;
                        while (i < dcbMax) (
                            (cModule === blockDesc[j]) ? (  j+= 1; );
                            blockDesc[i] = blockDesc[j];
                            i += 1 ; j += 1;
                        );
                    );
                ) :
                ((kit >= blockFirst) && (kit < blockDispITC)) ? (
                    // we choose a module entry
                    p = menu_Stud_Mod + ui_jmenu_items + kit ; // correct here
                    wst = p[0]; k = blockDispIdts[kit]; // k is ok

                    (x = (str_getchar(wst, 1, 'cu') === '!')) ? (
                        // We must add the new module at the end of the list
                        i = 0; while (blockDesc[i] != 0) ( i+= 1;);
                        blockDesc[i] = e = k; d = i;
                    ) : (
                        // the module was selected. We suppress it from the list
                        i = j = 0;
                        while (j < dcbMax) (
                            (k === blockDesc[j]) ? ( d = j; e = k; j+= 1; );
                            blockDesc[i] = blockDesc[j];
                            i += 1 ; j += 1;
                        );
                    );
                    0 ? (
                        x ? (
                            sprintf(#dbg_trace1, "*ADD* [%d] %d \"%s\" p:%d  n:%d  xx:%d  B:%d", blockDesc, k, wst, d, e, xx, blockMouseWasIn);
                        ) : (
                            sprintf(#dbg_trace1, "*DEL* [%d] %d \"%s\" p:%d  x:%d  xx:%d  B:%d", blockDesc, k, wst, d, e, xx, blockMouseWasIn);
                        );
                        mSL_log(SysLogBox, #dbg_trace1);
                    );
                    // ADump(blockDesc);
                ) :
                (kit === blockTabRename) ? (
                    sprintf(#tmp, "New name for tabulation %d...", TabIdt);
                    ui_screen_open("control.prompt");
                    ui_screen_arg(0, altTabsNames[TabIdt]);
                    ui_screen_arg(1, #tmp);
                ) :
                (kit >= blockThemeDefault) ? (
                    uix_jtheme = kit - blockThemeDefault;
                ) :
                (
                    mSL_GUI_Generic(3, bNumb, cModule, kit);
                );


            );
        );


        // move bottom system log if present
        1 ? (
            i = 0; while (i < dcbMax) (
                u = blockDesc[i]; v = blockDesc[i+1];
                ((u === blockSysLog) && (v !== 0))  ? (
                    blockDesc[i] = v; blockDesc[i+1] = u;
                );
                i += 1;
            );
        );


        // Hors interaction : mise en place des blocs
        Bigx = 0; loop(dcbMSize, igb = blockDesc[Bigx];  // = DISPLAY BLOCKS =
            (igb > 0) ? (
                (igb === blockPlayPad) ? (
                    show_Studio_Play_Pad();
                ) :
                (igb === blockSlidersA) ? (
                    show_Control_Sliders(SlidersBlockA, blockSlidersA);
                ) :
                (igb === blockSlidersB) ? (
                    show_Control_Sliders(SlidersBlockB, blockSlidersB);
                ) :
                (igb === blockSlidersC) ? (
                    show_Control_Sliders(SlidersBlockC, blockSlidersC);
                ) :
                (igb === blockSlidersD) ? (
                    show_Control_Sliders(SlidersBlockD, blockSlidersD);
                ) :
                (igb === blockSlidersE) ? (
                    show_Control_Sliders(SlidersBlockE, blockSlidersE);
                ) :
                (igb === blockSlidersF) ? (
                    show_Control_Sliders(SlidersBlockF, blockSlidersF);
                ) :
                (igb === blockSlidersG) ? (
                    show_Control_Sliders(SlidersBlockG, blockSlidersG);
                ) :
                (igb === blockSlidersH) ? (
                    show_Control_Sliders(SlidersBlockH, blockSlidersH);
                ) :
                (igb === blockPlayControls) ? (
                     show_Play_Control();
                ) :
                (igb === blockBanksDef) ? (
                     show_Banks_Definitions();
                ) :
                (igb === blockRandStates) ? (
                     show_Random_States();
                ) :
                (igb === blockUnits) ? (
                     show_Units(0);
                ) :
                (igb === blockClips) ? (
                     show_Clips_Selection();
                ) :
                (igb === blockScheduler) ? (
                    show_Scheduler_Pad();
                ) :
                (igb === blockMainInfos) ? (
                    show_Main_Infos();
                ) :
                (igb === blockHPConfig) ? (
                    show_HP_Configuration();
                ) :
                (igb === blockPlayModes) ? (
                    show_Play_Modes();
                ) :
                (igb === blockSpaceModes) ? (
                    show_Space_Modes();
                ) :
                (igb === blockClipsSettings) ? (
                    show_Clips_Settings();
                ) :
                (igb === blockSysLog) ? (
                    show_SysLog(blockSysLog, SysLogBox);
                ) :
                (igb === blockUsrLog) ? (
                    show_SysLog(blockUsrLog, UsrLogBox);
                ) :
                (igb === blockDisplayerA) ? (
                    show_Generator(BplayerA, blockDisplayerA);
                ) :
                (igb === blockDisplayerB) ? (
                    show_Generator(BplayerB, blockDisplayerB);
                ) :
                (igb === blockDisplayerC) ? (
                    show_Generator(BplayerC, blockDisplayerC);
                ) :
                (igb === blockDisplayerD) ? (
                    show_Generator(BplayerD, blockDisplayerD);
                ) :
                (igb === blockSysLinks) ? (
                    show_Links_Pad();
                ) :
                (igb === blockScripts) ? (
                    show_Scripts();
                ) :
                (igb === blockSensors) ? (
                    show_Sensors();
                ) :
                (igb === blockProcessesMgr) ? (
                    show_ProcessesMgr();
                ) :
                (igb === blockPlayLog) ? (
                    show_PlayLog();
                ) :
                (igb === blockMemory1) ? (
                    show_Memory(memoryBox1);
                ) :
                (igb === blockMemory2) ? (
                    show_Memory(memoryBox2);
                ) :
                (igb === blockDynPars) ? (
                    show_Dyn_pars();
                ) :
                (igb === blockPreset) ? (
                    show_Presets();
                ) :
                //((igb >= blockUsrFirst) && (igb <= blockUsrLast) && (blockUsrChecks[igb - blockUsrFirst])) ? (
                ((igb >= blockUsrFirst) && (igb <= blockUsrLast)) && (blockUsrChecks[blockUsrNum[igb - blockUsrFirst]]) ? (
                    show_UserModule(igb);
                );
            );
            Bigx += 1;
        );


    );
    blockDesc = 0;
    studDispCol += 1;
);


function
genericTabSet(tbNum)
local (ww, t)
(
    do_GenericTabStart();
    //colMouseWasIn = -1;
    BankLink = 1;
    TabIdt = tbNum;
    studDispPrf = studDispPCnt = max(1, min(4, 0|(serialBlock[Pr7_StudConf+TabIdt])));

    ww = gfx_w / ui_retina();


    (studDispPCnt === 4) ? (
        (ww < ui_MinSize4Panes) ? studDispPCnt = 3;
    );
    (studDispPCnt === 3) ? (
        (ww < ui_MinSize3Panes) ? studDispPCnt = 2;
    );
    (studDispPCnt === 2) ? (
        (ww < ui_MinSize2Panes) ? studDispPCnt = 1;
    );
    /*
    (studDispPCnt === 1) ? (
        (ww > ui_MaxSize1Pane) ? studDispPCnt = 2;
    );
    */

    studDispCol = 0;
    p = serialBlock + Pr7_StudRat + 4 * tbNum;
    (studDispPCnt === 4)  ? (
        ui_split_leftratio(max(1, p[0])/max(1, p[0] + p[1] + p[2] + p[3]));
            genericItemsPos(TabIdt * dcbPannelsMax);
        ui_pop();
        ui_split_leftratio(max(1, p[1])/max(1, p[1] + p[2] + p[3]));
            genericItemsPos(TabIdt * dcbPannelsMax + 1);
        ui_pop();
        ui_split_leftratio(max(1, p[2])/max(1, p[2] + p[3]));
            genericItemsPos(TabIdt * dcbPannelsMax + 2);
        ui_pop();
            genericItemsPos(TabIdt * dcbPannelsMax + 3);
    ) :
    (studDispPCnt === 3)  ? (
        /*
        (ffff2 != 0) ? (
            ffff2 = 0;
            sprintf(#sx, "3 Panes: %d  %d  %d  --- %f  %f  %f ", p[0], p[1], p[2],
                max(1, p[0])/max(1, p[0] + p[1] + p[2]),
                max(1, p[1])/max(1, p[1] + p[2]), 1);
            mSL_log(SysLogBox, #sx);
        );
        */
        ui_split_leftratio(max(1, p[0])/max(1, p[0] + p[1] + p[2]));
            genericItemsPos(TabIdt * dcbPannelsMax);
        ui_pop();
        ui_split_leftratio(max(1, p[1])/max(1, p[1] + p[2]));
            genericItemsPos(TabIdt * dcbPannelsMax + 1);
        ui_pop();
        //ui_split_leftratio(1);
            genericItemsPos(TabIdt * dcbPannelsMax + 2);
        //ui_pop();
    ) :
    (studDispPCnt === 2)  ? (
        ui_split_leftratio(max(1, p[0])/max(1, p[0] + p[1]));
            genericItemsPos(TabIdt * dcbPannelsMax);
        ui_pop();
            genericItemsPos(TabIdt * dcbPannelsMax + 1);
    ) : (
        genericItemsPos(TabIdt * dcbPannelsMax);
    );
    studio_pad_active ? do_StudioPadKeyboard();
    do_GenericTabEnd();
);



(gfxMn !== lastMn) ? (
    gfxMn = lastMn;
    ((gfxMcnt -= 1) <= 0) ? (flagShowMemory = 1);
    flagShowMemory ? (
        flagShowMemory = 0;
        gfxMcnt = 5;
        mem_walk(8);
    );
    //mSL_Dyn_Recycle(-1);
    //mSL_Dyn_TmpProtect(-1);
);


/*
=== GRAPHIC EXECUTION START ====
*/

must_do_gfx() ? (

    gfx_executed += 1; // just a trace
    ui_GFXCount += 1;
    ui_Xtime_period = 1; // Once a second is enough
    // do here the graphic stuff...

    do_gfx_init ? (
        do_gfx_init = 0; // perform only once
        uix_default_fontsize = ui_jdefault_fontsize;
        // uix_default_fontface = "Verdana";
        // uix_default_fontface = "Times";
        // uix_default_fontface = "Futura";
        uix_default_fontface = ui_jdefault_fontface;
    );

    update_theme();
    (uix_jtheme_known != uix_jtheme) ? (
        uix_jtheme_known = uix_jtheme;
        parSet(p_uix_jtheme, uix_jtheme);
    );


    (prev_gfx_w != gfx_w) ? (
        prev_gfx_w = gfx_w;
        ui_jGUI_prev = 0;
    );

    currScreen = ui_screen();
    ui_Xtime_period = 1; // refresh screen every second


    ui_font();
    ui_fontface(uix_default_fontface);
    ui_fontsize(uix_default_fontsize);

    blockMouseWasIn = blockDesc = 0; // no menu associated to this screen
    my_menu_bar(uix_jG_menuscr);

    ui_jmouse_cap |= mouse_cap;

    zzzgx = ui_key(); zzzmc = 0;

    /*
    (FlagsTbVals[Flgs_GFXTrcs] & 1) ? (
        pmous = cmous;
        cmous = ui_jmouse_cap;
        (zzzgx != 0) ? (
            sprintf(#sq, "***Key  @  %d  %d    [%d+%d -> '%c']", mouse_x, mouse_y, cmous, zzzgx, zzzgx);
            mSL_log(SysLogBox, #sq);
        ) :
        (((pmous & 1) === 1) && ((cmous & 1) === 0)) ? ( // left clic released
            sprintf(#sq, "***Mouse @  %d  %d   [%d -> %d]", mouse_x, mouse_y, pmous, cmous);
            mSL_log(SysLogBox, #sq);
        );
    );
    */

   SysLinksActive ? (
        (SysSourceType === 2) ? (
            (zzzgx != 0) ? (
                key_last_in = zzzgx;
                key_last_mods = ui_jmouse_cap & 0x3C;
                (key_last_in < 32) ? (
                    key_last_in += 64;
                    (key_last_mods === 0) ? key_last_mods |= 0x20;
                );
                ui_key_next(); // the key has been used
            );
        );
    ) : (
        JSFXSlShow ? (
            JSFXSlShow = 0;
            slider_show(2 ^ JSFXSlNb, 0);
        );
        (zzzgx != 0) ? (
            zzzmc = ui_jmouse_cap & 0x3C;
            (zzzgx < 32) ? (
                zzzgx += 64;
                // (zzzmc === 0) ? zzzmcf |= 0x20;
            );
            // Look for this Key Short cut
            kshrtct = (zzzgx * 256) + (zzzmc | 0x80); // codification of a key short cut
            ((sysEnt = getLinkEntry(kshrtct)) >= 0) ? (
                // Enter the action in the micro list
                W_Actions_Ent[W_Actions_Ptr] = sysEnt; // keep the entry
                W_Actions_Par[W_Actions_Ptr] = 0;
                W_Actions_Flg = 1;
                ui_key_next(); // the key has been used
                W_Actions_Ptr = (W_Actions_Ptr + 1) % W_Actions_Siz;
            );
        );
    );

    (MIDILogActive && (zzzgx > 0)) ? (
        zzzmc = ui_jmouse_cap & 0x3C;
        /*
        (zzzgx < 32) ? (
            zzzgx += 64;
            (zzzmc === 0) ? zzzmc |= 0x20;
        );
        */
        // Log into log
        (zzzgx > 0xffffff) ? (
            sprintf(#gfxu, "Key '%c%c%c%c' (%d)", (zzzgx >> 24) & 0xff, (zzzgx >> 16) & 0xff, (zzzgx >> 8) & 0xff, zzzgx & 0xff, zzzmc);
        ) :
        (zzzgx > 0xffff) ? (
            sprintf(#sgfxu, "Key '%c%c%c' (%d)", (zzzgx >> 16) & 0xff, (zzzgx >> 8) & 0xff, zzzgx & 0xff, zzzmc);
        ) :
        (zzzgx > 0xff) ? (
            sprintf(#gfxu, "Key '%c%c' (%d)", (zzzgx >> 8) & 0xff, zzzgx & 0xff, zzzmc);
        ) :
        (
            sprintf(#gfxu, "Key '%c' (%d)", zzzgx, zzzmc);
        );
        mSL_log(SysLogBox, #gfxu);
    );
    //colMouseWasIn = -1;

    //SCREEN—MAIN
    currScreen === "Main" ? (
        genericTabSet(0);
    ) :

    //SCREEN—STUDIO-A
    currScreen === "Studio A" ? (
        genericTabSet(1);
    ) :

    //SCREEN—STUDIO-B
    currScreen === "Studio B" ? (
        genericTabSet(2);
    ) :

    //SCREEN—STUDIO-C
    currScreen === "Studio C" ? (
        genericTabSet(3);
    ) :

    //SCREEN—STUDIO-D
    currScreen === "Studio D" ? (
        genericTabSet(4);
    ) :

    //SCREEN—STUDIO-D
    currScreen === "Studio E" ? (
        genericTabSet(5);
    ) :

    //SCREEN—Live 1
    currScreen === "Live 1" ? (
        genericTabSet(6);
    ) :

    //SCREEN—Live 2
    currScreen === "Live 2" ? (
        genericTabSet(7);
    ) :


    //SCREEN—DEFAULT
    (
        ui_GFXdoNow |= 3;
        do_GenericTabStart();
        control_system();
        do_GenericTabEnd();
    );


    // Did we change some display mode ?
    (uix_jtheme_rtc_code) ? (
        // Remember to update the values when necessary !
        (uix_jtheme_rtc_code === 8) ? (
            // switch to small
            studPrefDispSize = 1;
        ) :

        (uix_jtheme_rtc_code === 9) ? (
            // switch to large
            studPrefDispSize = 2;
        ) :

        (uix_jtheme_rtc_code === 10) ? (
            // switch to 1 pannel
            studPrefDispPanes = 1;
            studDispPPrev = -1;
        ) :

        (uix_jtheme_rtc_code === 11) ? (
            // switch to 2 pannels
            studPrefDispPanes = 2;
            studDispPPrev = -1;
        ) :

        (uix_jtheme_rtc_code === 12) ? (
            // switch to 3 pannels
            studPrefDispPanes = 3;
            studDispPPrev = -1;
        ) :

        (uix_jtheme_rtc_code === 13) ? (
            // switch to 4 pannels
            studPrefDispPanes = 4;
            studDispPPrev = -1;
        );

        uix_jtheme_rtc_code = 0;
        ui_GFXdoNow |= 1;
        ui_GFXReason = 39;
    );





    // EVERY TICK in Graphic...
    (lastGTick != gmem[timeTick]) ? (
        lastGTick = gmem[timeTick];

        (sysSamplesBlock != sysGSamplesBlock) ? (
            sysGSamplesBlock = sysSamplesBlock;
            sprintf(#gfxu, "Block Size %d — Block Delay %.2f ms", sysSamplesBlock, Curr_Block_Max_Delay * 1000);
            mSL_log(SysLogBox, #gfxu);
        );
    );


);


ui_end_do_gfx();


xCnt = 4; //
ClCheckView ? (
    while ((xCnt > 0) && (cBk4 <= clInBank)) (
        xNum = (xNum + UClipPrime) % clInBank; cBk4 += 1; zNum = xnum + (slBankset * clBSSize + slGroupNum) * clInBank;
        (((gmem[clClInfos+zNum] === 0) && (gmem[clInfStart+zNum] === 0))) ? (
            checkClip(zNum, ClCheckForce); xCnt -= 1;
        );
    );
    (cBk4 >= clInBank) ? (
        0 ? (
            sprintf(#s, "++Done CheckView [%d/%d]", slBankset, slGroupNum);
            mSL_log(SysLogBox, #s);
        );
        ClCheckView = cBk4 = 0;
    );
);
ClCheckFlag ? (
    (ClCheckCnt >= clTSize) ? (
        ClCheckFlag = 0;
        ClCheckForce = 0;
        UClipPrime = gmem[somePrimes + (gmem[primeCurrent] = (gmem[primeCurrent]+1)%primeCount)];
    ) : (
        while ((xCnt > 0) && (ClCheckCnt <= clTSize)) (
            ClCheckNum = (ClCheckNum + UClipPrime) % clTSize; ClCheckCnt += 1;
            (ClCheckForce || ((gmem[clClInfos+ClCheckNum] === 0) && (gmem[clInfStart+ClCheckNum] === 0))) ? (
                checkClip(ClCheckNum, ClCheckForce); xCnt -= 1;
            );
        );
    );
);


string_cst_last = "very last string constant used";
string_tmp_last = #;
string_var_last = #string_var_last;
