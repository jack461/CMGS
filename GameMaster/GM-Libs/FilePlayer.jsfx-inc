/*
    The FILE PLAYER main code
*/


@init

FilePlayerVersion = ui_version(1,7,2);

// Local trace
TRC = 0; // 0xff; // 16; //  0x00000;

tStart = tUnix = time();
spl_prev_count = spl_count = -1;
FP____memtop = __memtop();
the_host = mSL_KW_FilePlayer;


// Important parameters


#GL_Directory = "";
#tmpFname = "";
#GM_Scripts = "";
#GM_Project_Path = "";
#GM_Project_PathX = "";

MaxGr = 256; // max number of simultaneous grains
smplEMaxS = 512; // max events in the queue
sactMaxS = 20; // max number of actions in the list
editDelayStd = 10;
ModWSize = 1024; // size of modulation tables
timeAllow = 0.1; // max time allowed for actions in a @gsfx sequence
GrXVolAdj = 1.2; // In 0.5 ... 10  : adjust volume for multiple grains
GrMinXpect = 0.001; // min. expected grains

FP_Coeff = 0.00015;  // global volume... [NU]
FP_CoeffK = 1 - FP_Coeff; // ...smoothing factors [NU]
clRdMaxD = 7200; // standard very large duration, in seconds, for clips
clMaxDur = clRdMaxD; // standard max duration, in seconds, for clips

genAlgo = 0x9000; // generation algo
spaceAlgo = 0x5000; // space algos

currSrate = max(1, srate);
currRdSize = maxRdSize = currSrate * 2 * 12; // read 12" stereo at a time
frstRdsize = currSrate * 6; // start with few samples

clOffset = 0; // Read offset in clip
RState = 0; // Long read state
playHold = 0;

currScreen = 0;
stdScreen = Undef;
stdPointer = Undef;
currScreenWrg = Undef;
ErrorScreen = 0;
gfx_col_width = gfx_col_def_width = 320; // 522; // 620; // min width for an info column
gfx_colM_width = 960; // max width for a memory column
gfx_colL_width = 260; // min width for a memory column
current_Memory_Mode = 0; // no memory allocation allowed for now
mSL_Dyn_RecycleF = 1;
mSL_Dyn_Tr = 0; // 0xffff;
UType = uPlayer; // I am a lonesome player,
UAdd = UGDummy; // with no Unit bloc allocated,
UId = Undef; // and an undefined identification...
UStime = 0;
CheckTime = 0;
XDcount = 1;
gc_count = 0;
gfxMaxDur = 0.025; //
mSL_loc_tadd = 0.1;
mSL_loc_tim = 5;
gui_show_syslog = 1;
gui_show_memory = 0;
dbg_show_height = 96;
dbg_line_height = 19;
mm_show_ratio = 1;
gfxCurrT = gfxStrtT = gfxPlayT = time_precise() + timeD;

// (minima) number of mSL instructions we can execute in a second
// This is of course depending of the CPU !
// Here for my iMac, 3.5 GHz, Intel Core i7
// mSL_insts_per_s = 18000000;
// mSL_insts_per_s = 14000000; // Mac Book Pro
mSL_insts_per_s = 32000000; // Mac Studio Pro
#efs = "";
#gfx_uc = "Nothing keyed";

GMI('File', 'Play', 'er--'); // init memory


#dbg_trace0 = "";
#dbg_trace1 = "";
#dbg_trace2 = "";
#dbg_trace3 = "";
#dbg_trace4 = "";
#dbg_trace5 = "";
#dbg_trace6 = "";
#dbg_trace7 = "";


function nowTime()
(
    sprintf(#nowis, "Now: %02d/%02d/%02d ", gmem[timeDay], gmem[timeMonth], gmem[timeYear]);
    edTimeL(gmem[timeSecOfDay]);
    strcat(#nowis, #edt);
);

// ========== EXTENSIONS ==========
KodedSchFree = mSL_symbol("SchFree");
KodedSchDlay = mSL_symbol("SchDlay");
KodedSchActv = mSL_symbol("SchActv");
KodedSchInac = mSL_symbol("SchInac");
KodedSchCthr = mSL_symbol("CThread");
KodedSchPads = mSL_symbol("SchPads");

padStPVals = padStFlags = padStClipsL = padStClipsH = 0;

SchedPadSet = 0;

// This redefines the function "mSL_134" as the product of its operands
function mSL_134(argc, argv)
local (product, ip)
(
    product = 1;
    ip = 0;
    loop(argc, product *= argv[ip]; ip += 1;);
    product;
);

// Print a sequence of strings
function mSL_133(argc, argv)
(
    while (argc > 0) (
        mSL_log(SysLogBox, argv[0]);
        argc -= 1; argv += 1;
    );
);


// External access to some useful data structures
function mSL_135(argc, argv)
local (item)
(
    item = argv[0];
    (item == 'padv') ? ( padStPVals; ) :
    (item == 'padf') ? ( padStFlags; ) :
    (item == 'padl') ? ( padStClipsL; ) :
    (item == 'padh') ? ( padStClipsH; ) :
    (item == KodedSchFree) ? (
        SchedFreePts;
    ) :
    (item == KodedSchDlay) ? (
        SchedDlydPts;
    ) :
    (item == KodedSchActv) ? (
        SchedActivPts;
    ) :
    (item == KodedSchInac) ? (
        SchedInactPts;
    ) :
    (item == KodedSchCthr) ? (
        mSL_current_thread;
    ) :
    (item == KodedSchPads) ? (
        SchedPadSet; // A 16 entries array
    ) :
    (
        -1;
    );
);


function mSL_define_extensions()
(
    mSL_define_opcode("GM_Log", 133); // define 133 as "GM_Log"
    mSL_define_opcode("prod", 134); // define 134 as "prod"
    mSL_define_opcode("GM_Addr", 135); // etc.
);


function SmoothUpdt(value, src, inc)
(
    (src != value) ? (
        (src > value) ? (
            min(src, value + inc);
        ) : (
            max(src, value - inc);
        );
    ) : (
        value;
    );
);
function SmoothUpdt2(value, src, inc)
(
    (src > value) ? (
        min(src, value + inc);
    ) : (
        max(src, value - inc);
    );
);

syssrate = sysTempo = sysPlayState = sysPlayPosition = sysBeatPosition = 0; // set later
sysSampPosition = sysSampBeatPosition = sysSampBeat = 0; // set later

glIsiz = 1;
glIsiz0 = 1;
glIsiz1 = 1;

inPlay = 0x100;
inWait = 0x200;
fileReading = 0;
limitime = 0;
startime = 0;

editDelay = 0;

mdInactive = idx = 0;
CurrentDoing =
ActWorking = (idx += 1) + inPlay;
ActPlaying = (idx += 1) + inPlay;
ActPlaying2 = (idx += 1) + inPlay;
ActLooping = (idx += 1) + inPlay;
WaitPlaying = (idx += 1) + inWait;
WaitLooping = (idx += 1) + inWait;
ActNext = (idx += 1) ;
ActRand = (idx += 1) ;
ActEdit = (idx += 1) ;
Actstop = (idx += 1) ;
ActClear = (idx += 1) ;
ActSaving = (idx += 1) ;
ActUnknown = (idx += 1) ;

// Some globals variables
mSL_act = 0; // active threads
mSL_wait = 0; // waiting threads
mSL_plck = 0; // locked threads
mSL_inactv = 0; // inactive threads
mSL_maxact = 0; // maximum active threads
currentClip = -1;
currSmpl = 0;
FP_Flg1 = 0; // flags initiaux
FP_Flg2 = 0; // flags dynamiques
FP_Flg = 0; // flags courants
FP_F = 0; // flags activés par gmem[dynGlFlags]
FP_L = 0x7FFFFFFF; // local mask
FP_GlobVol = 1; // smoothed global volume
FP_GlobSet = 1; // raw global volume
FP_Dyn_Vol = 0; // raw dynamic volume
FP_GlobWidth = 1; // Managed, but unused
FP_GlobWSet = 1; // Managed, but unused
FP_GL_GSpd1 = 1; // dyn speed 1
FP_GL_GSpd2 = 0; // dyn speed 2, AKA Transpose
FP_GL_GSiz = 1; // glob. grains size
FP_GL_Slant = 0; // glob. slant
FP_GL_GTWd = 0; // glob top enveloppe
FP_GL_Gmin = 0; // Min. grain size (ms)
FP_GL_Gmax = 0; // Max. grain size (ms)
FP_G_PPos = 50; // position in middle of clip
FP_G_PVar = 100; // 100 % variation allowed
FP_G_PMass = 1; // default play "mass"
FP_G_PAsyn = 0; // default asynchronicity
FP_G_Direct = 0; // direction inverter
FP_G_Inharm = 0; // grain inharmonicity
FP_G_HarmShp = 0; // grain inharmonicity shapes
FP_G_FI_Shp = 0; // grains fade in shape
FP_G_FO_Shp = 0; // grains fade out shape
GrAsyncFact = 0.98; // asynchronicity factor
FP_P_Direct = 0; // direction slider
GrXpect  = 0;
GrXVol = 1;
GrSpdVFact = 9;
VolumeMod0_u = 1;
VolumeMod1_u = 1;
MaxGrSize = 5 * 60; // 5' for max size
FP_GlobVAdj = 1; // all global volume adjustments
clClip = 0;  // The clip we are playing
GCBL = 0; // current play buffer, unspecified yet
PBFlgs = 0; // Flags associés à la commande  +++
BState = 0; // The block automaton state
GState = 0; // The gfx automaton state
KmdIn = 0; // Last command
KmdLast = 0; // Last "non inquery" command
KmdLastIn = 0; // Last command
KmdLastDate = 0; // reduced date of last command
KmdKurrent = -1; // Current play command : PLAY or LOOP
Pmode = mdInactive; // playmode
doSync = 0; // prepare synchro
doStop = 0; // stop asked...
doRestart = 0; // execute a full restart
RZcnt = 4; // add. some zero values samples at start or end for each channel
CCCC = 0; // current clip channel count
HPCnt1 = 0; // number of HP (channels) provided in set 1
HPCnt2 = 0; // number of HP (channels) provided in set 2
chGenCnt = 0; // Channels to generate
chTmpCnt1 = 0; // intermediate Channels count
chTmpCnt2 = 0; // intermediate Channels count
chTmpPtr1 = 0; // intermediate Channels pointer
chTmpPtr2 = 0; // intermediate Channels pointer
chOutCnt = 0; // Channels to output
HPIndx = 0; // HP index allocation
clRSpeed = 1; // Clip Read Speed - normal is 1 for a 48k speed 1 clip
ClRIndex = 0; // Clip Read index, in tupples
ClRIndInc = 0; // Clip Read index increment, in tupples
ClTpl1st = 0; // relative address of first tupple in UBuffer
ClTplLast = 0; // relative address of last tupple in UBuffer
ClTplSize = 0; // Size in tupples
ClTplSec = 0; // usable tupples/second
ClLowLimit = 0; // low read limit, in tupples
ClHighLimit = 0; // high read limit, in tupples
ClLowArea = 0; // low read limit w/out fade, in tupples
ClHighArea = 0; // high read limit w/out fade, in tupples
CLStartPC = 0; // low read limit, in percent
CLEndPC = 0; // high read limit, in percent
Tmem = 0; // Top of memory defined later
clDur = 0; // this clip asked duration, in seconds
clLng = 0; // this clip to play, in tupples
CFSize = 0; // size of the clip in samples
CRSize = 0; // clip max read size in sample excluding zeroes
CTSize = 0; // clip max read size in tupples excluding zeroes
FInDur = 0; // fade in time in milliseconds
FOutDur = 0; // fade out time in milliseconds
FInTpl = 0; // fade in time in tupples
FOutTpl = 0; // fade out time in tupples
GrFInTpl = 0; // grain fade in time in samples
GrFOutTpl = 0; // grain fade out time in samples
GrStLLimit = 0; // grain start lower limit
GrStHLimit = 0; // grain start upper limit
GrMinTpl = 0; // grain min. length in tupples
GrMaxTpl = 0; // grain max. length in tupples
ActivePlaying = 0; // are we playing, or not ?
doGen = 0; // used as stop test in LOOP
guarddog = 0;  // used as a time limit when playing
endclip = 0;  // date of the end of the clip
Fhandle = -1; // handle of current file
FLgHandle = -1; // handle of current file
FileOpenCtr = 0; // file_open operations counter
FErrc = 0; // error found when reading clip
cflag = 0; // when != 0 : "all is ok" indicator
Fformat = 0; // clip internal file format - c.f. fFormats[]
FFrRate = 0; // clip frequency rate
FAdjRate = 1; // clip adjust rate to srate
UBuffer = 0; // universal very large clip buffer
M_avail = 0; // memory available for the buffer
zCount = 0; // number of "zeroes" added at the start and the end of the clip
PlayMono =  0; // max duration for a mono clip in seconds
bSize = 0; // size to read at each block execution
bAddr = 0; // memory address for next read
SpdFact = currSrate; // speed factor : srate * abs(clRSpeed) number of samples/s
SpdFactms = 0; // speed factor: number of samples/ms SpdFactms = SpdFact / 1000;
flSaveAddr = 0; // Entry where we have to save the RCB in play log memory
smUpdateFlag = smUFlagVol;
smUpdateFlagCP = 0;
rsize = 0;
rpos = 0;
genCount = 0;
playCount = 0;
loopCount = 0;
CheckNum = 0;
synchroPos = 0; // synchro process
synchroSource = 0; // no synchro
synchSmpls = currSrate; // a 1 second synchro factor
second = ticker = lastMn = gfxMn = 0;
gfxMcnt = 5;
volUpdt = -1;
NState = 0; // State changed flags
PF_Coeff = 0.00015;
PF_Const = 0.00001;
flGmod = 0;
flSpdmod = 0;
GrInc = 1;
GinvDir = 1;
//PF_CoeffX = 0.1;
//PF_CoeffK = 1 - PF_Coeff;
//PF_Coeff2 = PF_Coeff * PF_CoeffX;
//PF_CoeffK2 = 1 - PF_Coeff2;
dirChangeNum = 0;
xind = 0; // effects index level 1
pflg = 0; // some flag
ph = 0; // temporary phase
iph = 0; // temporary phase
ipos = 0; // temp. index
XPND = 0;
mdtb = 0; // temp ref. modulation table
bfsx = 0; // buffer in the modulation table
pvol = 0;
lvol = 0;
evLState = 0;
pvolEv = 0;
pvolInc = 0;
pvolDec = 0;
GrLen = 0;
status = 0;
lpSmplCnt = 0;
GrMLen = 0; // Grain mean length
GrFIn = 0;  // computed fade-in in tupples
GrFOut = 0; // computed fade-out in tupples
reapeat = 0; // lock mode
reapeatx = 0; // lock mode
ti = 0; // a time inerval, as samples
abp = 0;
lgf = 0; // long file indicator
grBnum = 0;
P_Gp_ct = A_Gp_ct = 0;
ClTplLast2 = 0;
#finfo = "n.a.";
hpfold = 0;
clAsk = 0;
hpcnf1 = 0;
hpcnf2 = 0;
chused1 = 0;
chused2 = 0;
L_fact = 0;
R_fact = 0;
SPAlgo = 0;
SPAux = 0;
PMod = 0;
PClass = 0;

gmem[clPlAvail] = UTmem = __memtop() - 4; // total memory available

SharedLowMemory = 0;
SharedLowMemorySize = 1024;
// 0 to 127 reserved
wa128 = 128; // a 128 words work area
wa256 = 256; // a 256 words work area
wa512 = 512; // a (surprise !) 512 words work area

SharedHighMemory = 0; // will be updated later
SharedHighMemorySize = 0; // yet unknown

// Graphic
// protect location "0" from errors...



// x = ui_setup(2);
/*
==== STATIC MEMORY ====
*/
idx = SharedLowMemory + SharedLowMemorySize;
mSL_StM_Init(idx); // init static memory
current_Memory_Mode = mSL_MMd_Static; // starting now, allow use of "make_array"
mSL_Str_Init(#strFirst, #strLast); // allocate strings for strings allocator
mSL_Str_TInit(#wstrFirst, #wstrLast); // allocate strings for temporary strings
mSL_Str_PInit(#xstrFirst, #xstrLast); // allocate strings for permanent strings

init_idents();
mSL_Init_Keywords();
mSL_Init_long_Keywords();
init_log_boxes();


//====== Init "ui-lib-JJ.jsfx-inc" ======
ui_lib_start = mSL_StM_BlockStart('uilb'); // ui lib block
ui_lib_end = ui_setup(ui_lib_start);
mSL_StM_BlockEnd(ui_lib_end);
gfxInit();
ui_lib_JJ_GUI_init(1);
uix_jtheme = 1; // use theme "dark" by default

//====== GRAPHICS-INIT ======

<? include("GM-Libs/mSL_Colors.jsfx-inc"); ?>

Player_Mode_Cnt = 3; // Play & Loop
Player_Color_cnt = 72;
Player_Color_Set = make_array(Player_Mode_Cnt);
Player_Color_Set[0] = make_array(Player_Color_cnt+2); // Play
set_pcolors_array(Player_Color_Set[0], Player_Color_cnt+1, U1_1, U4_0, 0.5, -1);
Player_Color_Set[1] = make_array(Player_Color_cnt+2); // Loop
set_pcolors_array(Player_Color_Set[1], Player_Color_cnt+1, U1_1, U5_0, 0.5, -1);
Player_Color_Set[2] = make_array(Player_Color_cnt+2); // Loop
set_pcolors_array(Player_Color_Set[1], Player_Color_cnt+1, U1_1, U5_0, 0.5, -1);
currColor = Player_Color_Set[0];
currColState = 0;
currColVar = 0;
gmem[UAdd+RCB_Color] = currColor[currColState];

//---------------------------
// Memory recycling
memrcysiz = 32;
memrcused = make_array(memrcysiz);  // in use
memrcrlsd = make_array(memrcysiz);  // just released
memptused = memptrlsd = 0;

//---------------------------
// The "theme" menu
uix_jtheme_menu = make_jmenu(
    ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel |
    //
    ui_jmenu_opt_rclick |
    //  ui_jmenu_opt_alclick |
    // ui_jmenu_opt_alclick |
    ui_jmenu_opt_notitle,
    "Theme",
    // "&1 Default|&1 Black|&1 Tron|&1 Light Cyan|&1 Orange|&1 Blue|&1 Dark Cyan||&2 Small|&2 Large|| &3 1 pane|&3 2 panes|&3 3 panes|&3 4 panes"
    "!&1 Default|&1 Black|&1 Tron|&1 Light Cyan|&1 Orange|&1 Blue|&1 Dark Cyan"
    );
uix_jtheme_rtc_max = 7;  // 7 entries in the menu
//---------------------------
// Info disp
glIsizCnt = 8;
glIsizTab = make_array(glIsizCnt);  //
nbcol = 1;
nblig = 1;
nbligMax = 2;
//---------------------------
/*
=== GRAIN STRUCTURE ===
*/
// Structure of a playblock/grain block
gStatus = idx = 0;
gClRIndex = (idx += 1);
gClLowLimit = (idx += 1);
gClHighLimit = (idx += 1);
gCllvol = (idx += 1);
gClLowArea = (idx += 1);
gClHighArea = (idx += 1);
gClRSpeed = (idx += 1);
gClRVarbl = (idx += 1);
gChIndex = (idx += 1);
gChOffset = (idx += 1);
gChCount = (idx += 1);
gChNum = (idx += 1);
cEvLindx = (idx += 1);
cEvLvol = (idx += 1);
cGrFOut = (idx += 1);
GPBSize = idx + 1; // 16
// MaxGr already defined
NumbGr = MaxGr + 2; // with security


// Block part Automaton States
GSStInactive = (idx = 0);
GSStFinal = (idx += 1);
GSStDelaying3 = (idx += 1);
GSKReadPhase1 = (idx += 1);
GSKReadPhase2 = (idx += 1);
GSKReadPhase3 = (idx += 1);
GSKReadPhase4 = (idx += 1);
GSKPlayHold = (idx += 1);
GSKStartPlay = (idx += 1);
GSKStartLoop = (idx += 1);
GSStReadBlck = (idx += 1);


// Actions control block
ActbN = 32;
ActEnt = 8;
ActBsize = ActbN * ActEnt;
ActBls = make_array(ActBsize);

// Output channels
ChanMax = 128; // max of channels in REAPER
ChanSize = 128; // Size of arrays of channels
AddChsZ = make_array(ChanSize * 2); //
Chans1 = AddChsZ;
Chans2 = Chans1 + ChanSize; //

// Transition matrices
TransSiz = 512;
TransMat = make_array(TransSiz * 2); //
TransSrc = TransMat + TransSiz;

// Envelope array
SinEnvSize = 48000;
SinEnvSize1 = SinEnvSize + 1;
SinEnvLim = 2;
SinEnv = make_array(SinEnvSize * 2 + 1); //
CosEnv = SinEnv + SinEnvSize;
EnvPtS = EnvPtC = 0;
EnvInc = 1;
EnvLim = 2;
function
setSinEnv(size)
local (ip, li)
(
    SinEnvLim = 0xffffe & max(2, min(SinEnvSize, 0|size));
    li = $pi / SinEnvLim / 2;
    loop (ip = 0; SinEnvLim * 2 + 1,
        SinEnv[ip] = sin(ip * li);
        ip += 1;
    );
    CosEnv = SinEnv + SinEnvLim;
    EnvPtS = 0; EnvPtC = SinEnvLim;
    EnvLim = 2 * SinEnvLim;
);
setSinEnv(SinEnvSize);

/*
=== mSL DATA ===
*/
// Some global variables


FlagsTbSiz = 32;
FlagsTbVals = make_array(FlagsTbSiz);
idx = 0;
Flgs_PrOps = (idx += 1);
Flgs_Thrds = (idx += 1);
Flgs_Evnts = (idx += 1);
Flgs_Acts = (idx += 1);
Flgs_Traces = (idx += 1);


KRun_mSL_Thread = 10;




// choose a specific tempo for updating
xCount = 20; // update counter
xDecrement = 1; // decrement counter
xIncrement = 10;

uuuMslFn = 0;
uuuMslFname = 0;
uuuMslFent = 0;
uuuMslTSiz = 64;
uuuMslTabs = make_array(uuuMslTSiz); // an array of names of files to compile
uuuMslTPt =  0; // index in this table
uuuMslCSiz = 128;
uuuMslCTab = make_array(uuuMslCSiz); // an array of names of compileds files to execute
uuuMslCPt = 0; // index in this table



err_sys = 0; // generic error system
err_sys_ini = 0; // generic initialization error system
err_sys_rtm = 0; // generic run-time error system
err_sys_gfx = 0; // generic graphic error system
err_fclp = 0; // error when reading clips description file
err_fplm = 0; // error in play modes description file
err_fhpc = 0; // error in HP configuration description file
err_fspm = 0; // error in space modes description file
err_fbnk = 0; // error in partials/banks description file
err_sdfr = 0; // error in sensors def reader

SchedActive = 1; // scheduler activity


/*
=== SAMPLES MANAGEMENT ===
*/
// smplEMaxS // max events in the queue already defined (512)
smplEvSiz = 6;
smplLimit = smplEMaxS * smplEvSiz;
D1 = smplEvSiz * 4;
smplEvents = make_array(smplLimit+D1);
smpltmp = make_array(smplEvSiz);
smplNeutre = -2.25;
smplEInfinite = 2^58; // a very large number
smplEvCnt = 0;
smplXPtr = 0;
smplXPtrMax = 0;
smplNxtE = smplEInfinite;

function
smplClear()
(
    memset(smplEvents, smplNeutre, smplLimit+D1);
    smplEvents[0] = smplNxtE = smplEInfinite;
    smplXPtr = 0;
);

smplClear();

// Post an action to be executed at a specific output sample number
function
smplNewEV(date, op, p0, p1)
local (pt, ptz)
(
    sprintf(#gfs_zzz, "* %s * Enter event %d / %g / %g {%.0f}", #nowtim, op, p0, p1, date);
    date = max(0, 0|date); // an integer number of samples
    pt = 0;
    ptz = -1;
    while ((date >= 0) && (pt < smplLimit))  (
        while ((date <= smplEvents[pt]) && (pt < smplLimit)) (pt += smplEvSiz);
        (ptz < 0) ? ptz = pt;
        (smplEvents[pt] <  0) ? (
            // enter and quit
            smplEvents[pt] = date; smplEvents[pt+1] = op; smplEvents[pt+2] = p0; smplEvents[pt+3] = p1;
            date = -1.5;
        ) : (
            // save current
            memcpy(smpltmp, smplEvents+pt, smplEvSiz);
            // enter this event
            smplEvents[pt] = date; smplEvents[pt+1] = op; smplEvents[pt+2] = p0; smplEvents[pt+3] = p1;
            // previous event becomes the new one
            date = smpltmp[0]; op = smpltmp[1]; p0 = smpltmp[2]; p1 = smpltmp[3];
            pt += smplEvSiz;
        );
    );
    (TRC & 1) ? (
        sprintf(#gfw_mss, "%s  ->  %d", #gfs_zzz, ptz);
        mSL_log(SysLogBox, #gfw_mss);
    );
    smplXPtrMax = max(smplXPtrMax, (smplXPtr = pt));
    smplNxtE = smplEvents[smplXPtr];
);

// Remove events given by their numbers and 1st parameter
// parameter can be "Undef"
function
smplRemovEvnt(op, par, cnt)
local (pt, ptx, flg, date, tc, rmv)
(
    rmv = pt = 0;
    flg = 1;
    tc = cnt = max(1, 0|cnt);
    while (flg && (pt < smplLimit) && (pt >= 0) && (smplEvents[pt] != smplNeutre) ) (
        ((smplEvents[pt+1] === op) && ((par === Undef) || (par === smplEvents[pt+2]))) ? (
            // last event of the list ?
            (smplEvents[pt+4] === smplNeutre) ? (
                // we can just clear the event
                memset(smplEvents + pt, smplNeutre, smplEvSiz);
                smplXPtr = pt - smplEvSiz;
                smplNxtE = smplEvents[smplXPtr];
            ) : (
                ptx = pt;
                // delete event
                while (ptx <= smplXPtr) (
                    memcpy(smplEvents+ptx, smplEvents+ptx+4, smplEvSiz);
                    ptx += smplEvSiz;
                );
                smplXPtr = ptx - smplEvSiz;
                smplNxtE = smplEvents[smplXPtr];
                pt -= smplEvSiz;
            );
            rmv += 1;
            ((cnt -= 1) <= 0) ? (flg = 0);
            (TRC & 1) ? (
                date = smplEvents[pt];
                sprintf(#gfw_mss, "* %s * Removed event %d / %d {%.0f}", #nowtim, op, par, date);
                mSL_log(SysLogBox, #gfw_mss);
            );
        );
        pt += smplEvSiz;
    );
    (flg != 0) ? (
        (TRC & 1) ? (
            sprintf(#gfw_mss, "* %s * Remove Event %d/%0.1f / %d/%d  not found.", #nowtim, op, par, (tc - cnt), tc);
            mSL_log(SysLogBox, #gfw_mss);
        );
    );
    rmv; // how many have been removed
);


// @sample actions management
// sactMaxS (16) max number of actions in the list
sactAsiz = 2;
sactLim = sactMaxS * sactAsiz;
D2 = 8;
sactLimX = sactLim + D2;
sactActs = make_array(sactLimX);
sactNeutre = -3.5;
sactACnt = 0;
function
sactClear()
(
    memset(sactActs, sactNeutre, sactLimX);
);
sactClear();

// Add an action with its parameter in the action list
function
sactAdd(act, par)
local (pt, re, x1, x2)
(
    act = max(0, act);
    re = -1; pt = 0;
    while ((act >= 0) && (pt < sactLim)) (
        while ((act < sactActs[pt]) && (pt < sactLim))  (pt += sactAsiz);
        ((act === sactActs[pt]) && (par === sactActs[pt+1])) ? (
            act = sactNeutre;
            (re < 0) ? (re = pt;);
        ) :
        (sactActs[pt] === sactNeutre) ? (
            // insert the action
            (re < 0) ? (re = pt;);
            sactActs[pt] = act; sactActs[pt+1] = par;
        ) : (
            x1 = sactActs[pt]; x2 = sactActs[pt+1];
            (re < 0) ? (re = pt;);
            sactActs[pt] = act; sactActs[pt+1] = par;
            act = x1; par = x2;
        );
    );
    (pt > sactLim) ? (FErrc = 7123;);
    re;
);

// Remove an action given by its code and parameter
// "par" can be "Undef"
function
sactRem(act, par)
local (pt)
(
    act = max(0, act);
    pt = 0;
    while ((act < sactActs[pt]) && (pt < sactLim)) (pt += sactAsiz);
    ((act === sactActs[pt]) && ((par === Undef) || (par === sactActs[pt+1]))) ? (
        while ((act >= 0) && (pt < sactLim)) (
            sactActs[pt] = act = sactActs[pt+2];
            sactActs[pt+1] = sactActs[pt+3];
            pt += 2;
        );
    );
);

// Remove an action given by its position
function
sactRAPos(pt)
local (act)
(
    while ((pt >= 0) && (pt < sactLim) && ((act = sactActs[pt]) > 0)) (
        sactActs[pt] = sactActs[pt+2];
        sactActs[pt+1] = sactActs[pt+3];
        pt += 2;
    );
);

// Remove a class of actions
function
sactRMClass(class)
local(pt, k)
(
    pt = 0; pq = 0;
    while ((pt < sactLim) && (pq < sactLim)) (
        (k = ((sactActs[pt] >= class) && (sactActs[pt] < class+0x1000))) ? (
            pq += 2;
        );
        sactActs[pt] = sactActs[pq];
        sactActs[pt+1] = sactActs[pq+1];
        (!k) ? (pt += 2; pq += 2;);
    );
);

// player sent action list
actlSiz = 32;
actlAdds = make_array(3);
actlL0 = make_array(actlSiz * 4 + 16);
actlL1 = actlL0 + actlSiz + 4;
actlL2 = actlL1 + actlSiz + 4;
actlL3 = actlL2 + actlSiz + 4;
actlAdds[0] = actlL0;
actlAdds[1] = actlL1;
actlAdds[2] = actlL2;
actlNum = 0;
actlPt = 0;
actlIn = actlL0;
actlOut = actlL2;
actlflg = 0;

function
switchActions()
(
    actlNum = (actlNum + 1) % 3;
    actlIn = actlAdds[actlNum];
    actlIn[0] = 0;
    actlOut = actlAdds[(actlNum + 2) % 3];
    actlflg = max(0, actlflg-1);
);


//====== GC ======
mSL_Dyn_LogSiz = 128;
mSL_Dyn_Log = make_array(mSL_Dyn_LogSiz);
mSL_Dyn_fLogSiz = 128;
mSL_Dyn_fLog = make_array(mSL_Dyn_LogSiz);
// Memory management Arrays
gc_run_phaz = 0;
gc_run_count = 0;
mm_rem_siz = 128;
mm_rem_in = 0;
gc_MMA = mm_rem_mm = make_array(mm_rem_siz); // A list of remanent/protected objects
mm_list_siz = 49957;
mm_list_in = 0;
mm_list_pt = 0;
mm_list_cnt = 0;
mm_list_mxc = 0;
mm_list_mm = make_array(mm_list_siz); // temporary circular list of encountered object
mm_hash_siz = 104729;
mm_hash_mm = make_array(mm_hash_siz); // temporary hashcode table for already encountered objects
mm_tmp_siz = 8;
mm_tmp_in = 0;
mm_tmp_mm = make_array(mm_tmp_siz); // temporary array of blocs to free
mm_xec_siz = 180;
mm_xec_ptr = 0;
mm_xec_cnt = 0;
mm_xec_max = 0;
mm_xec_mm = make_array(mm_xec_siz); // temporary array
mm_cyc_siz = 2048;
mm_cyc_ptr = 0;
mm_cyc_max=0;
mm_cyc_maxU = 0;
mm_cyc_mm = make_array(mm_cyc_siz); // temporary array
mm_dur_max = 0;
mm_dur_mm = make_array(mm_cyc_siz); // temporary array
mm_lowmem = 0; // low and
mm_highmem = 0; // high memory address of the memory allocated blocks
mm_Knew = -2;
mm_show_frbl = 1;
mm_show_usbl = 0;
mm_show_flr = 0;
mm_show_dmg = 0;
mm_show_ttf = 0;
mm_show_ttu = 0;
mSL_gc_start = 0;
mSL_gc_end = 0;
mSL_gc_MaxDur = 0;

mm_bl_huge = 1;
mm_bl_big = 0;
mm_bl_large = 0;
mm_bl_medium = 0;
mm_bl_mini = 0;


// Hash table for parameters coded names
//paramHashIds = make_array(paramHSiz);
//paramHashNbs = make_array(paramHSiz);
paramHashTbl = mSL_makeHT(paramHSiz, paramHStep);
paramHStep = paramHashTbl[-1]; // in case the func updated the step

//  Hash table for JSFX vars access
jvarsHashTbl = mSL_makeHT(128 + 0|(1.35*mSL_JSFX_var_count), 6121);
jvarsHStep = jvarsHashTbl[-1];
jvarsHSize = jvarsHashTbl[-2];

// Create the entries
mSL_dcl_JSFX_vars();



// Global objects
menu_uix_jlog = make_jmenu(
    ui_jmenu_typ_sel | ui_jmenu_opt_rndrect | ui_jmenu_opt_usesel | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
    "Log Layout", "!&X1 column|&X2 columns|&X3 columns|&X4 columns||&/height +|&/height -|&/blank|&/clear");


////===================XPERIMENT===================
// We have 16 mod.tables with 20 parameters each, and 4 base
ModTabCnt=16;
ModTabSiz=20;
ModTabPtrs=make_array(ModTabCnt);
ii=0; loop(ModTabCnt, ModTabPtrs[ii]=make_array(ModTabSiz); ii+=1;);

// ModWSize // size of modulation tables
ModWSizB = ModWSize+1;
/*
ModWav0 = make_array(ModWSizB);
*/

GrShpIn = make_array(ModWSizB);
GrShpOut = make_array(ModWSizB);


function
buildShape(tab, sh)
local (k, i, j, l)
(
    sh = max(-1, min (1, sh));
    (sh <= -0.5) ? (
        k = 2 * (-0.5 - sh);
        i = 0; loop (ModWSizB,
            j = i / ModWSize; l = j * j;
            tab[i] = (l * (k * l + (1 - k)));
            i += 1;
        );
    ) :
    (sh <= 0) ? (
        k = 2 * (0 - sh);
        i = 0; loop (ModWSizB,
            j = i / ModWSize;
            tab[i] = j * (k * j + (1 - k));
            i += 1;
        );
    ) :
    (sh <= 0.5) ? (
        k = 2 * (0.5 - sh);
        i = 0; loop (ModWSizB,
            j = i / ModWSize;
            tab[i] = (k * j + (1 - k) * sqrt(j));
            i += 1;
        );
    ) :
    (
        k = 2 * (1 - sh);
        i = 0; loop (ModWSizB,
            j = i / ModWSize; l = sqrt(j);
            tab[i] = l * k + (1 - k) * sqrt(l);
            i += 1;
        );
    );
    (TRC & 32) ? (
        sprintf(#zz, "buildShape (%d, %.4f)  k:%.4f i:%d", tab, sh, k, i); mSL_log(SysLogBox, #zz);
    );
);



buildShape(GrShpIn, FP_G_FI_Shp);
buildShape(GrShpOut, FP_G_FO_Shp);


// ====== Special Scales ======

// Classical Scale
scale_12TET_itm = 12;
scale_12TET_siz = scale_12TET_itm * 8 + 1;
scale_12TET_mid_siz = 12 * 4;
scale_12TET = make_array(scale_12TET_siz); // Tranposition factors for +/- 48 half tones
ii = 0; loop(scale_12TET_siz, scale_12TET[ii] = 2 ^ ((ii-scale_12TET_itm * 4)/scale_12TET_itm); ii += 1; );
mid_scale = scale_12TET_mid = scale_12TET + scale_12TET_mid_siz;

// Pythagore scale
scale_Pyth_itm = 28 ;
scale_Pyth_siz = scale_Pyth_itm  * 3 + 1;
scale_Pyth_mid_siz = 0|((scale_Pyth_siz -1) / 2);
scale_Pyth = make_array(scale_Pyth_siz);
idx = -1;
scale_Pyth[idx += 1] = 1; scale_Pyth[idx += 1] = 3/4; scale_Pyth[idx += 1] = 3/8; scale_Pyth[idx += 1] = 3/2;
scale_Pyth[idx += 1] = 2; scale_Pyth[idx += 1] = 3/16; scale_Pyth[idx += 1] = 9/8; scale_Pyth[idx += 1] = 3;
scale_Pyth[idx += 1] = 9/16; scale_Pyth[idx += 1] = 9/4; scale_Pyth[idx += 1] = 27/16; scale_Pyth[idx += 1] = 9/32;
scale_Pyth[idx += 1] = 27/32; scale_Pyth[idx += 1] = 27/64; scale_Pyth[idx += 1] = 81/32; scale_Pyth[idx += 1] = 81/64;
scale_Pyth[idx += 1] = 81/128; scale_Pyth[idx += 1] = 27/128; scale_Pyth[idx += 1] = 81/256; scale_Pyth[idx += 1] = 243/64;
scale_Pyth[idx += 1] = 243/128; scale_Pyth[idx += 1] = 243/256; scale_Pyth[idx += 1] = 243/512; scale_Pyth[idx += 1] = 243/1024;
scale_Pyth[idx += 1] = 729/512; scale_Pyth[idx += 1] = 729/1024; scale_Pyth[idx += 1] = 729/2048; scale_Pyth[idx += 1] = 2187/2048;
ii = 0; loop(scale_Pyth_itm, scale_Pyth[ii+scale_Pyth_itm] = scale_Pyth[ii]/2; ii += 1;);
ii = 0; loop(scale_Pyth_itm, scale_Pyth[ii+2*scale_Pyth_itm] = scale_Pyth[ii]*2; ii += 1;);
scale_Pyth[scale_Pyth_siz - 1] = 3;
scale_Pyth_mid =  scale_Pyth + scale_Pyth_mid_siz;
mSL_sort_bl(scale_Pyth);

// Harry Partch Scale
scale_Partch_itm = 43 ;
scale_Partch_siz = scale_Partch_itm * 4 + 1;
scale_Partch = make_array(scale_Partch_siz);
idx = 85;
// Create the initial 43 scale
scale_Partch[idx += 1] = 1/1; scale_Partch[idx += 1] = 81/80; scale_Partch[idx += 1] = 33/32;
scale_Partch[idx += 1] = 21/20; scale_Partch[idx += 1] = 16/15; scale_Partch[idx += 1] = 12/11;
scale_Partch[idx += 1] = 11/10; scale_Partch[idx += 1] = 10/9; scale_Partch[idx += 1] = 9/8;
scale_Partch[idx += 1] = 8/7; scale_Partch[idx += 1] = 7/6; scale_Partch[idx += 1] = 32/27;
scale_Partch[idx += 1] = 6/5; scale_Partch[idx += 1] = 11/9; scale_Partch[idx += 1] = 5/4;
scale_Partch[idx += 1] = 14/11; scale_Partch[idx += 1] = 9/7; scale_Partch[idx += 1] = 21/16;
scale_Partch[idx += 1] = 4/3; scale_Partch[idx += 1] = 27/20; scale_Partch[idx += 1] = 11/8;
scale_Partch[idx += 1] = 7/5; scale_Partch[idx += 1] = 10/7; scale_Partch[idx += 1] = 16/11;
scale_Partch[idx += 1] = 40/27; scale_Partch[idx += 1] = 3/2; scale_Partch[idx += 1] = 32/21;
scale_Partch[idx += 1] = 14/9; scale_Partch[idx += 1] = 11/7; scale_Partch[idx += 1] = 8/5;
scale_Partch[idx += 1] = 18/11; scale_Partch[idx += 1] = 5/3; scale_Partch[idx += 1] = 27/16;
scale_Partch[idx += 1] = 12/7; scale_Partch[idx += 1] = 7/4; scale_Partch[idx += 1] = 16/9;
scale_Partch[idx += 1] = 9/5; scale_Partch[idx += 1] = 20/11; scale_Partch[idx += 1] = 11/6;
scale_Partch[idx += 1] = 15/8; scale_Partch[idx += 1] = 40/21; scale_Partch[idx += 1] = 64/33;
scale_Partch[idx += 1] = 160/81;
scale_Partch[idx += 1] = 2/1;
ii = 0; loop(43, scale_Partch[ii] = scale_Partch[ii + 2 * 43]/4; ii += 1;);
ii = 0; loop(43, scale_Partch[ii + 43] = scale_Partch[ii + 2 * 43]/2; ii += 1;);
ii = 0; loop(43, scale_Partch[ii + 3 * 43] = scale_Partch[ii + 2 * 43]*2; ii += 1;);
scale_Partch[scale_Partch_siz - 1] = 4;
scale_Partch_mid = scale_Partch + scale_Partch_itm * 2;

// ====== Special Sequences ======
seq_step = 0;


seq_1_siz = 5;
seq_1 =  make_array(seq_1_siz+2);
seq_1[0] = 0; seq_1[idx = 1] = seq_1_siz;
seq_1[idx += 1] = mid_scale[-3]; seq_1[idx += 1] = mid_scale[4];
seq_1[idx += 1] = mid_scale[5];  seq_1[idx += 1] = mid_scale[0];
seq_1[idx += 1] = mid_scale[-12];


seq_2_siz = 7;
seq_2 =  make_array(seq_2_siz+2);
seq_2[0] = 0; seq_2[idx = 1] = seq_2_siz;
seq_2[idx += 1] = mid_scale[-3]; seq_2[idx += 1] = mid_scale[4];
seq_2[idx += 1] = mid_scale[0]; seq_2[idx += 1] = mid_scale[6];
seq_2[idx += 1] = mid_scale[-1]; seq_2[idx += 1] = mid_scale[4];
seq_2[idx += 1] = mid_scale[3];


seq_3_siz = 17;
seq_3 =  make_array(seq_3_siz+2);
seq_3[0] = 0; seq_3[idx = 1] = seq_3_siz;
seq_3[idx += 1] = mid_scale[6]; seq_3[idx += 1] = mid_scale[-2];
seq_3[idx += 1] = mid_scale[7]; seq_3[idx += 1] = mid_scale[12];
seq_3[idx += 1] = mid_scale[7]; seq_3[idx += 1] = mid_scale[0];
seq_3[idx += 1] = mid_scale[-5]; seq_3[idx += 1] = mid_scale[11];
seq_3[idx += 1] = mid_scale[-1]; seq_3[idx += 1] = mid_scale[-13];
seq_3[idx += 1] = mid_scale[-13]; seq_3[idx += 1] = mid_scale[10];
seq_3[idx += 1] = mid_scale[11]; seq_3[idx += 1] = mid_scale[-13];
seq_3[idx += 1] = mid_scale[-13]; seq_3[idx += 1] = mid_scale[5];
seq_3[idx += 1] = mid_scale[13];


seq_4_siz = 19;
seq_4 =  make_array(seq_4_siz+2);
seq_4[0] = 0; seq_4[idx = 1] = seq_4_siz;
seq_4[idx += 1] = mid_scale[6]; seq_4[idx += 1] = mid_scale[-2];
seq_4[idx += 1] = mid_scale[7]; seq_4[idx += 1] = mid_scale[12];
seq_4[idx += 1] = mid_scale[7]; seq_4[idx += 1] = mid_scale[0];
seq_4[idx += 1] = mid_scale[-5]; seq_4[idx += 1] = mid_scale[11];
seq_4[idx += 1] = mid_scale[-1]; seq_4[idx += 1] = mid_scale[-13];
seq_4[idx += 1] = mid_scale[-13]; seq_4[idx += 1] = mid_scale[10];
seq_4[idx += 1] = mid_scale[11]; seq_4[idx += 1] = mid_scale[-13];
seq_4[idx += 1] = mid_scale[-13]; seq_4[idx += 1] = mid_scale[5];
seq_4[idx += 1] = mid_scale[7]; seq_4[idx += 1] = mid_scale[11];
seq_4[idx += 1] = mid_scale[12];


seq_5_siz = 8;
seq_5 =  make_array(seq_5_siz+2);
seq_5[0] = 0; seq_5[idx = 1] = seq_5_siz;
seq_5[idx += 1] = mid_scale[-5]; seq_5[idx += 1] = mid_scale[-2];
seq_5[idx += 1] = mid_scale[0]; seq_5[idx += 1] = mid_scale[-2];
seq_5[idx += 1] = mid_scale[5]; seq_5[idx += 1] = mid_scale[3];
seq_5[idx += 1] = mid_scale[5]; seq_5[idx += 1] = mid_scale[7];


seq_6_siz = 9;
seq_6 =  make_array(seq_6_siz+2);
seq_6[0] = 0; seq_6[idx = 1] = seq_6_siz;
seq_6[idx += 1] = mid_scale[15]; seq_6[idx += 1] = mid_scale[0];
seq_6[idx += 1] = mid_scale[14]; seq_6[idx += 1] = mid_scale[8];
seq_6[idx += 1] = mid_scale[0]; seq_6[idx += 1] = mid_scale[-9];
seq_6[idx += 1] = mid_scale[5]; seq_6[idx += 1] = mid_scale[-12];
seq_6[idx += 1] = mid_scale[4];


//================ Debugging ===================// Memory display boxes
memoryBoxSize = 24;
memoryBox1  = make_array(memoryBoxSize);
memoryBox2  = make_array(memoryBoxSize);

// Pad debug
padDebugNL = 1;
padDebugNC = 8;
padDebugSiz = padDebugNL * padDebugNC;
padDebug1p = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDebugNL, padDebugNC, padDebugSiz);

padDebug1Labs = padDebug1p + padDebug1p[ui_jpad_labs]; // addresses of labels
padDebug1Colrs = padDebug1p + padDebug1p[ui_jpad_clrs]; // addresses of colors
padDebug1Cells = padDebug1p + padDebug1p[ui_jpad_cells]; // addresses of cells desc.
padDebug1Vals = padDebug1p + padDebug1p[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDebugSiz,
            padDebug1Colrs[ii] = Col_Inactive;
            padDebug1Labs[ii] = "";
            ii+=1;
);

padDebug2p = make_jpad(
    ui_jpad_ty_act | ui_jpad_mk_labs | ui_jpad_mk_colors | ui_jpad_mk_values,
    padDebugNL, padDebugNC, padDebugSiz);

padDebug2Labs = padDebug2p + padDebug2p[ui_jpad_labs]; // addresses of labels
padDebug2Colrs = padDebug2p + padDebug2p[ui_jpad_clrs]; // addresses of colors
padDebug2Cells = padDebug2p + padDebug2p[ui_jpad_cells]; // addresses of cells desc.
padDebug2Vals = padDebug2p + padDebug2p[ui_jpad_values]; // addresses of values
//
ii = 0; loop(padDebugSiz,
            padDebug2Colrs[ii] = Col_Inactive;
            padDebug2Labs[ii] = "";
            ii+=1;
);

memoryBoxAdd = 0; // shared address between boxes

memoryBox1[0] = padDebug1p;
memoryBox1[1] = padDebug1Labs;
memoryBox1[2] = padDebug1Colrs;
memoryBox1[3] = padDebug1Cells;
memoryBox1[4] = padDebug1Vals;
memoryBox1[5] = "Memory 1";
// 6
memoryBox1[17] = 96;
memoryBox1[18] = 19;
memoryBox1[19] = 0;
memoryBox1[20] = 0;


memoryBox2[0] = padDebug2p;
memoryBox2[1] = padDebug2Labs;
memoryBox2[2] = padDebug2Colrs;
memoryBox2[3] = padDebug2Cells;
memoryBox2[4] = padDebug2Vals;
memoryBox2[5] = "Memory 2";
// 6
memoryBox2[17] = 96;
memoryBox2[18] = 19;
memoryBox1[19] = 0;
memoryBox1[20] = 0;

// The debug menu ActionTbSiz
DebugTbSize = 64;
DebugTbNames = make_array(DebugTbSize);
DebugTbTyps = make_array(DebugTbSize);
DebugTbAdds = make_array(DebugTbSize);
DebugTbDecs = make_array(DebugTbSize);

dbg_u_za = 0;

/*
=== Memory Debug ===
*/
/*
    Types:   0x100  : the address to display is computed in the memory displayer
             0x001  : show absolute : relative address
             0x002  : data is in gmem
             0x004  : show @ in hexadecimal
             0x008  : show data in hexadecimal
*/
// The debug menu ActionTbSiz
idx = 0;
DebugTbTyps[idx] = 0; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Memory"; idx += 1;
DebugTbTyps[idx] = 0x101; DebugTbAdds[idx] = 4; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Mem. mSL"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = serialBlock; DebugTbDecs[idx] = serialBlock; DebugTbNames[idx] = "Presets"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = paramBlock; DebugTbDecs[idx] = paramBlock; DebugTbNames[idx] = "Params"; idx += 1;
DebugTbTyps[idx] = 2; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Gmem"; idx += 1;

//DebugTbTyps[idx] = 2; DebugTbAdds[idx] = HP_usage; DebugTbDecs[idx] = HP_usage; DebugTbNames[idx] = "HP usage"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = AAAAC_thrdArea; DebugTbDecs[idx] = AAAAC_thrdArea; DebugTbNames[idx] = "Threads"; idx += 1;
DebugTbTyps[idx] = 0x101; DebugTbAdds[idx] = 0; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "C.thread"; idx += 1;
DebugTbTyps[idx] = 0x101; DebugTbAdds[idx] = 1; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Tree.gen"; idx += 1;
DebugTbTyps[idx] = 0x10D; DebugTbAdds[idx] = 2; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Blocks.gen"; idx += 1;
DebugTbTyps[idx] = 0x103; DebugTbAdds[idx] = 3; DebugTbDecs[idx] = 0; DebugTbNames[idx] = "Play. UCB"; idx += 1;
DebugTbTyps[idx] = 0xF; DebugTbAdds[idx] = 0x300; DebugTbDecs[idx] = 0x300; DebugTbNames[idx] = "Ugens"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = BKTab; DebugTbDecs[idx] = BKTab; DebugTbNames[idx] = "Banks"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = SchedArea; DebugTbDecs[idx] = SchedArea; DebugTbNames[idx] = "Sched ents"; idx += 1;
DebugTbTyps[idx] = 3; DebugTbAdds[idx] = gHPATab; DebugTbDecs[idx] = gHPATab; DebugTbNames[idx] = "HP Sets"; idx += 1;
DebugTbTyps[idx] = 3; DebugTbAdds[idx] = gHPPTab; DebugTbDecs[idx] = gHPPTab; DebugTbNames[idx] = "HP Ptrs"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Chans1; DebugTbDecs[idx] = Chans1; DebugTbNames[idx] = "HP List 1"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Chans2; DebugTbDecs[idx] = Chans2; DebugTbNames[idx] = "HP List 2"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = PMTab; DebugTbDecs[idx] = PMTab; DebugTbNames[idx] = "Play Modes"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = MIDISeqncs; DebugTbDecs[idx] = MIDISeqncs; DebugTbNames[idx] = "Sensors"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Tab; DebugTbDecs[idx] = Mac_WA_Tab; DebugTbNames[idx] = "Macros"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Temp; DebugTbDecs[idx] = Mac_WA_Temp; DebugTbNames[idx] = "M.Expensions"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Errs; DebugTbDecs[idx] = Mac_WA_Errs; DebugTbNames[idx] = "Errors"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = Mac_WA_Tcrs; DebugTbDecs[idx] = Mac_WA_Tcrs; DebugTbNames[idx] = "Play info"; idx += 1;
//DebugTbTyps[idx] = 2; DebugTbAdds[idx] = plHDStrt; DebugTbDecs[idx] = plHDStrt; DebugTbNames[idx] = "Play store"; idx += 1;
//DebugTbTyps[idx] = 2; DebugTbAdds[idx] = playLogStrt; DebugTbDecs[idx] = playLogStrt; DebugTbNames[idx] = "Play entries"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = playTimes; DebugTbDecs[idx] = playTimes; DebugTbNames[idx] = "Play line"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = SlidersBlockA; DebugTbDecs[idx] = SlidersBlockA; DebugTbNames[idx] = "P.Blocks"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = clipsWorkArea; DebugTbDecs[idx] = clipsWorkArea; DebugTbNames[idx] = "Clips WA"; idx += 1;
//DebugTbTyps[idx] = 1; DebugTbAdds[idx] = ClSetTab; DebugTbDecs[idx] = ClSetTab; DebugTbNames[idx] = "ClipSets"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = mSL_Dyn_Log; DebugTbDecs[idx] = mSL_Dyn_Log; DebugTbNames[idx] = "Log malloc"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = mSL_Dyn_fLog; DebugTbDecs[idx] = mSL_Dyn_fLog; DebugTbNames[idx] = "Log mfree"; idx += 1;
DebugTbTyps[idx] = 0; DebugTbAdds[idx] = GrShpIn; DebugTbDecs[idx] = GrShpIn; DebugTbNames[idx] = "Wave tables"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = scale_Pyth; DebugTbDecs[idx] = scale_Pyth; DebugTbNames[idx] = "Scales"; idx += 1;
DebugTbTyps[idx] = 1; DebugTbAdds[idx] = scale_12TET; DebugTbDecs[idx] = scale_12TET; DebugTbNames[idx] = "Trans"; idx += 1;
DebugCount = idx;

mSL_Sort_Strings(DebugCount, 0, DebugTbNames, DebugTbTyps, DebugTbAdds, DebugTbDecs);

menu_Debug = make_jmenu(
            ui_jmenu_typ_action | ui_jmenu_opt_rndrect | ui_jmenu_opt_rclick | ui_jmenu_opt_notitle,
            "debug", DebugCount, DebugTbNames);

debugDSize = 128;
memoryBox1[12] = make_array(debugDSize);
memoryBox2[12] = make_array(debugDSize);
// Preselect "Memory"
// Look for the "Memory" entry.
dbg_curr_sel = -1;
ii = 0; while ((dbg_curr_sel < 0) && (ii < DebugCount)) (
    (DebugTbNames[ii] == "Memory") ? dbg_curr_sel = ii;
    ii += 1;
);
memoryBox1[6] = memoryBox2[6] = dbg_curr_sel;
memoryBox1[8] = memoryBox2[8] = 0;
memoryBox1[9] = memoryBox2[9] = 0;
memoryBox1[10] = memoryBox2[10] = 0;
memoryBox1[11] = memoryBox2[11] = 0;
memoryBox1[13] = memoryBox2[13] = 0;
memoryBox1[14] = memoryBox2[14] = 0;



/* Add a file name to the compiler list */
function doMslCompile(fname)
(
    // Do not accept empty strings
    (strlen(fname) != 0) ? (
        0 ? (sprintf(#s, "::About to doMslCompile: \"%s\"", fname); mSL_log(SysLogBox, #s););
        atomic_set(mSL_Lock, max(1,atomic_get(mSL_Lock)));
        uuuMslTabs[uuuMslTPt] = fname; uuuMslTPt = (uuuMslTPt + 1) % uuuMslTSiz;
        atomic_add(mSL_loc_tim, mSL_loc_tadd);
        uuuMslFn = 1; // set flag
    )
);




// The threads operations
<? include("GM-Libs/mSL_Threads.jsfx-inc"); ?>


// The Garbage Collector
<? include("GM-Libs/mSL_Garbage_Collector.jsfx-inc"); ?>






// Try to open a file somewhere
function
GM_file_open(fname)
local (fhd)
(
    strcpy(#tmpFname, fname);
    0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
    fhd = file_open(#tmpFname);
    (fhd < 0) ? (
        // is the file in current directory ?
        strcpy(#tmpFname, #GL_Directory); strcat(#tmpFname, fname);
        0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
        fhd = file_open(#tmpFname);
        (fhd < 0) ? (
            // is the file in the script directory ?
            strcpy(#tmpFname, #GM_Scripts); strcat(#tmpFname, fname);
            0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
            fhd = file_open(#tmpFname);
            (fhd < 0) ? (
                strcpy(#tmpFname, #GL_Directory); strcat(#tmpFname, #GM_Scripts); strcat(#tmpFname, fname);
                0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
                // is the file is Libs/Scripts
                fhd = file_open(#tmpFname);
                (fhd < 0) ? (
                    strcpy(#tmpFname, #GM_Project_Path); strcat(#tmpFname, #GM_Scripts); strcat(#tmpFname, fname);
                    0 ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", #tmpFname, mSL_errC); mSL_log(SysLogBox, #gfxu););
                    fhd = file_open(#tmpFname);
                );
            );
        );
    );
    fhd;
);




/*
    Try to understand the why(s) of an error in mSL
*/
function mSL_error_analysis(thrd)
(
    sprintf(#uuu, " _ Thread: %d", thrd);
    mSL_log(SysLogBox, #uuu);
    sprintf(#uuu, " _ Mem avail: %d", mSL_available_memory());
    mSL_log(SysLogBox, #uuu);
);

info_blocksSize = 20;
info_blocks = make_array(info_blocksSize+1);



function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19)
(
    info_blocks[0] = a0;
    info_blocks[1] = a1;
    info_blocks[2] = a2;
    info_blocks[3] = a3;
    info_blocks[4] = a4;
    info_blocks[5] = a5;
    info_blocks[6] = a6;
    info_blocks[7] = a7;
    info_blocks[8] = a8;
    info_blocks[9] = a9;
    info_blocks[10] = a10;
    info_blocks[11] = a11;
    info_blocks[12] = a12;
    info_blocks[13] = a13;
    info_blocks[14] = a14;
    info_blocks[15] = a15;
    info_blocks[16] = a16;
    info_blocks[17] = a17;
    info_blocks[18] = a18;
    info_blocks[19] = a19;
    info_blocks[20] = -1;
);
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, a8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6, a7)
( info_config(a0, a1, a2, a3, a4, a5, a6, a7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5, a6)
( info_config(a0, a1, a2, a3, a4, a5, a6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4, a5)
( info_config(a0, a1, a2, a3, a4, a5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3, a4)
( info_config(a0, a1, a2, a3, a4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2, a3)
( info_config(a0, a1, a2, a3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1, a2)
( info_config(a0, a1, a2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0, a1)
( info_config(a0, a1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );
function info_config(a0)
( info_config(a0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1); );


info_config(0, 4, 5, 6, 7, 8, 1, 2, 3, 9, 10, 11);

// The formats array
fFormats = make_array(16);
setFileFormats(fFormats);

// The status indicators
statNames = make_array(16);
ii = 0; loop(16,
    statNames[ii] = "Unspecified";
    ii += 1;
);
statMask = 0xf;
statNames[uSUnused & statMask] = "Unused";
statNames[uSReady & statMask] = "Ready";
statNames[uSBusy & statMask] = "Busy";
statNames[uSStarting & statMask] = "Starting";
statNames[uSHalting & statMask] = "Halting";
statNames[uSDummy & statMask] = "Dummy";
statNames[uSUnreachable & statMask] = "Unresponsive";
statNames[uSEditing & statMask] = "Edit";
statNames[uSSaving & statMask] = "Save";
statNames[uSError] = "ERROR";
statNames[uSSError] = "SYSTEM ERROR";



// Make the Grains control blocks (NumbGr = 256 + 2)
GCBpts = make_array(NumbGr); // pointers
GCBacts = make_array(NumbGr); // active pointers
GCBactM = -1; // max. indice of active pointers
GCBArraySiz = NumbGr * GPBSize;
GCBArray = make_array(GCBArraySiz); // the blocks
ii = 0; loop(NumbGr,
    GCBpts[ii] = GCBArray + ii * GPBSize;
    ii += 1;
);
GCBL = GCBArray; // Pointer to current control bloc of a grain



// The values to send for each tupple
tpChNb = 128;
tuplesZ = 1+make_array(tpChNb+2); // always 0 samples
TPLG = tuplesA = 1+make_array(tpChNb+2); // the channels values (gen)
TPLR = tuplesM = 1+make_array(tpChNb+2); // the channels values (matrix)
CmDval = 1+make_array(tpChNb+2);
UsDval = 1+make_array(tpChNb+2);

//oooooooooooooooooooooo
// TransMatrix data
TM_HP = 0;
TM_mxsiz = 1024;
TM_HP_Dest = make_array(TM_mxsiz); // Destinations
TM_HP_Src = make_array(TM_mxsiz); // Sources
TM_Fix_Coef = make_array(TM_mxsiz); // Fixed values coefficients
TM_Dyn_Coef = make_array(TM_mxsiz); // Dynamic values coefficients
TM_HP_SrcPts = make_array(TM_mxsiz); // Pointers to sources
TM_SCnt = 0;
TM_delta_inc = 0.001; // Matrix max. standard variation up
TM_delta_dec = 0.001; // Matrix max. standard variation down
xxupdf = p_XPar0; // update from p_XPar0
xxint = xxsum = xxalg = kupd = 0;

// Build the transfert vector
function
mkTransVec()
local(i, j,k)
(
    // what is the needed size ? Limited (not tested) by TM_mxsiz = 1024
    // Destination channels
    chTmpCnt1 = max(1, max(HPCnt1, chGenCnt));
    chTmpCnt2 = max(1, max(HPCnt2, chGenCnt));
    TM_HP = chTmpCnt1 + chTmpCnt2;
    i = j = 0; k = 1/sqrt(chTmpCnt1);
    loop (chTmpCnt1,
        TM_HP_Dest[i] = Chans1[j % HPCnt1];
        TM_HP_Src[i] = j % chGenCnt;
        TM_Fix_Coef[i] = k;
        TM_Dyn_Coef[i] = 0;
        i += 1; j+= 1;
    );
    j = 0; k = 1/sqrt(chTmpCnt2);
    loop (chTmpCnt2,
        TM_HP_Dest[i] = Chans2[j % HPCnt2];
        TM_HP_Src[i] = j % chGenCnt;
        TM_Fix_Coef[i] = k;
        TM_Dyn_Coef[i] = 1;
        i += 1; j+= 1;
    );
    memset(CmDval, 0, hpfold);
    memset(UsDval, 0, hpfold);
    kupd = 0;
    spaceAlgo | 4;
);
function
mkTransVectInit()
(
    CmDval[0] = 1; CmDval[1] = 0;
);



//oooooooooooooooooooooo
Mat_Raw = Mat_Soft = 0;
// Build the raw/smooth matrices
function
mkMatrices()
local(i,j,k,s)
(
    // First array is the set of channels
    // Destination channels
    chTmpCnt1 = max(1, max(HPCnt1, chGenCnt));
    chTmpCnt2 = max(1, max(HPCnt2, chGenCnt));
    TM_HP = chTmpCnt1 + chTmpCnt2;
    i = j = 0; k = 1/sqrt(chTmpCnt1);
    loop (chTmpCnt1,
        TM_HP_Dest[i] = Chans1[j];
        TM_HP_Src[i] = j % chGenCnt;
        TM_Fix_Coef[i] = k;
        TM_Dyn_Coef[i] = 0;
        i += 1; j+= 1;
    );
    j = 0; k = 1/sqrt(chTmpCnt2);
    loop (chTmpCnt2,
        TM_HP_Dest[i] = Chans2[j];
        TM_HP_Src[i] = j % chGenCnt;
        TM_Fix_Coef[i] = k;
        TM_Dyn_Coef[i] = 1;
        i += 1; j+= 1;
    );
    // Build the coef. matrix
    s = TM_HP * chGenCnt;
    Mat_Raw = mSL_Dyn_Alloc(s*2, 'TMat', mSL_StM_FlClear);
    Mat_Soft = Mat_Raw + s;
);
function
mkMatricesInit()
(
    0;
);



//oooooooooooooooooooooo
// Slide sources (L & R) to Conf1 and Conf2
TM_Strt1 = 0;
TM_Strt2 = 0;
TM_Last1 = 127;
TM_Last2 = 127;
TM_Dcp = 256;
TM_HP_Dest1 = TM_HP_Dest;
TM_HP_Dest2 = TM_HP_Dest + TM_Dcp;
TM_Fix_Coef1 = TM_Fix_Coef;
TM_Fix_Coef2 = TM_Fix_Coef + TM_Dcp;
TM_Dyn_Coef1 = TM_Dyn_Coef;
TM_Dyn_Coef2 = TM_Dyn_Coef + TM_Dcp;
function
mkDbSlider()
local(i,j,p,q)
(
    // Reduce channels to Strt/Last
    TM_HP_Dest1 = TM_HP_Dest;
    TM_HP_Dest2 = TM_HP_Dest + TM_Dcp;
a=    chTmpCnt1 = max(1, min(TM_Dcp, max(HPCnt1, chGenCnt)));
b=    chTmpCnt2 = max(1, min(TM_Dcp, max(HPCnt2, chGenCnt)));
    // "Left" set
c=    p = max(0, 0|TM_Strt1);
d=    q = min(chTmpCnt1-1, 0|TM_Last1);
    (p <= q) ? (
        loop(i = 0; j = p; (chTmpCnt1 = q-p+1),
            TM_HP_Dest1[i] = Chans1[j % HPCnt1];
            i += 1; j += 1;
        );
        TM_HP_Dest1[i] = TM_HP_Dest1[i-1]
    ) : (
        loop(i = 0; j = p; (chTmpCnt1 = p-q+1),
            TM_HP_Dest1[i] = Chans1[j % HPCnt1];
            i += 1; j -= 1;
        );
        TM_HP_Dest1[i] = TM_HP_Dest1[i-1]
    );
    // "Right" set
    p = max(0, 0|TM_Strt2);
    q = min(chTmpCnt2-1, 0|TM_Last2);
    (p <= q) ? (
        loop(i = 0; j = p; (chTmpCnt2 = q-p+1),
            TM_HP_Dest2[i] = Chans2[j % HPCnt2];
            i += 1; j += 1;
        );
        TM_HP_Dest2[i] = TM_HP_Dest2[i-1]
    ) : (
        loop(i = 0; j = p; (chTmpCnt2 = p-q+1),
            TM_HP_Dest2[i] = Chans2[j % HPCnt2];
            i += 1; j -= 1;
        );
        TM_HP_Dest2[i] = TM_HP_Dest2[i-1]
    );
    sprintf(#dbg_trace4, "a=%d b=%d, c=%d d=%d",
        a,b,c,d);
    // spaceAlgo | 9; //
    //
    spaceAlgo | 10; //
);
function
mkDbSliderInit()
local(i,j,p,q)
(
    // Set default as "pan left"
    Lch = 0; Llfact = 1; Lrfact = 0;
    Rch = 0; Rlfact = 1; Rrfact = 0;
    gmem[UAdd+RCB_Pan] = gmem[UAdd+RCB_Pan_Src] = 0;
    memset(TM_Dyn_Coef, 0, TM_mxsiz);
    memset(TM_Fix_Coef, 0, TM_mxsiz);
    TM_Fix_Coef1[0] = TM_Dyn_Coef1[0] = 1;
    TM_Fix_Coef2[0] = TM_Dyn_Coef2[0] = 1;
    TPLG = tuplesZ;
);




//oooooooooooooooooooooo
function
mkStdPan()
(
    L_fact = CosEnv[SinEnvSize * gmem[UAdd+RCB_Pan]];
    R_fact = SinEnv[SinEnvSize * gmem[UAdd+RCB_Pan]];
    spaceAlgo | 3;
);
function
mkStdPanInit()
(
    gmem[UAdd+RCB_Pan] = gmem[UAdd+RCB_Pan_Src] = 0;
);




//oooooooooooooooooooooo
function
mkFixAlgo()
local(i)
(
    chTmpCnt1 = max(1, max(HPCnt1, chGenCnt));
    chTmpCnt2 = max(1, max(HPCnt2, chGenCnt));
    chOutCnt = max(1, min(num_ch, hpfold));
    spaceAlgo | 2; // fixed HP location
);
function
mkFixAlgoInit()
local(i)
(
    spaceAlgo | 2; // fixed HP location
);




//oooooooooooooooooooooo
//// Oct. 2023 -- New objects

mm_lowblocks = make_array(2); // creates a gap of 2 zeroes.
mSL_GC_Protected = make_array(1123, mSL_KODE_protect);

// Create the scheduler structure
SchedSetup();
0 ? (sprintf(#uuu, "    ---> SchedSetup :   %d tasks", SchedListSize(SchedFreePts));mSL_log(SysLogBox, #uuu););


/*
=== COMPILER ===
*/
// Sizes of Allocated arrays for the Compiler and the Evaluator
C_compSize = 32 * 1024; // size : 64 kW [kilo words, not kilo watts]
C_progSize = 32 * 1024; // size  for the evaluator
ui_jmake_arraymax = 0x7FFFFFF; // "no" limit in the size of an array...

// Then, initialize all structures of the compiler.
C_compArea = make_array(C_compSize);
C_progArea = make_array(C_progSize);

mm_limit_a = make_array(2);
mm_limit_a[0] = 'STRT'; mm_limit_a[1] = 'MEMR';


// Memory size :
C_memrSize = 8 * 1024 * 1024; // size : X x 1MW
C_memrArea = make_array(C_memrSize); // THE MEMORY !

mm_limit_b = make_array(2);
mm_limit_b[0] = 'END_'; mm_limit_b[1] = 'MEMR';

// Build the memory
mSL_current_memory = mSL_new_memory = 0; // make sure it is clear
AAAAC_5 = mSL_make_memory(C_memrArea, C_memrSize);

memoryBox1[7] = memoryBox2[7] = AAAAC_5 - 2; // actual start
mm_lowmem = mSL_new_memory + mSL_new_memory[mSL_MM_LowAd];
mm_highmem = mSL_new_memory + mSL_new_memory[mSL_MM_HighAd];
// mm_sizmem = max(1, mm_highmem - mm_lowmem);
mm_show_ttf = mm_sizmem = mSL_new_memory[mSL_MM_MemSiz];//
//AGMW166 = GMW();

// Provide an independent main symbol table for the compiler - "var" declarations
aprime = 3313;
size = 4 * (aprime + 1);
mem = make_array(size + 4);
A_mSL_GCTab = mSL_buildGVTab(mem, size, aprime);

// Provide an independent local symbol table for the compiler - "loc" declarations
aprime = 191;
size = 4 * (aprime + 1);
mem = make_array(size + 4);
A_mSL_LCTab = mSL_buildLCTab(mem, size, aprime);
// Build the compiler
AAAAC_6 = mSL_make_compiler(C_compArea, C_compSize);
// Then, the interpreter
AAAAC_7 = mSL_make_evaluator(C_progArea, C_progSize);
mSL_new_thread = 0;

// define our new extensions
mSL_define_extensions();

mm_limit_g = make_array(2);
mm_limit_g[0] = 'END_'; mm_limit_g[1] = 'COMP';





////===============================================

/*
function FillModWav(tab, siz, typ)
local (i, ph, inc, cnt)
(
    siz = max(1, siz);
    cnt = max(1, siz-1);
    (typ == 0) ? (
        memset(tab, 0, siz);
    ) : (
        // default : build a sin wave
        inc = (2 * $pi) / cnt;
        i = ph = 0; loop(siz,
            tab[i] = sin(ph); ph += inc; i += 1;
        );
        i = 0; ph = 0; loop(siz,
            ph = ph + abs(tab[i]); i += 1;
        );
        gmem[ModSWav] = ph;
    );
);


////===================XPERIMENT===================
XPND = 4;
FillModWav(ModWav0, ModWSizB, 1);
ii=0; loop(ModTabCnt, mdtb = ModTabPtrs[ii]; mdtb[0] = ModWav0; ii+=1;);
mdtb = ModTabPtrs[0];
mdtb[0] = ModWav0;
mdtb[1] = 0; // initial position in buffer
mdtb[2] = 0; // initial phase
mdtb[3] = 0.18; // increment
mdtb[4] = 189; // excursion
mdtb[5] = ModWSize; // wave size (-1)
mdtb[6] = 0; // add. offset
mdtb[7] = 0; // volume modification
mdtb[8] = 0; // Flags [ex: wrap around/not]
mdtb = ModTabPtrs[1];
mdtb[0] = ModWav0;
mdtb[1] = 0; // initial position in buffer
mdtb[2] = 10000; // initial phase
mdtb[3] = 0.29; // increment
mdtb[4] = 177; // excursion
mdtb[5] = ModWSize;
mdtb = ModTabPtrs[2];
mdtb[0] = ModWav0;
mdtb[1] = 0; // initial position in buffer
mdtb[2] = 33333; // initial phase
mdtb[3] = 0.21; // increment
mdtb[4] = 182; // excursion
mdtb[5] = ModWSize;
mdtb = ModTabPtrs[3];
mdtb[0] = ModWav0;
mdtb[1] = 0; // initial position in buffer
mdtb[2] = 440000; // initial phase
mdtb[3] = 0.14; // increment
mdtb[4] = 122; // excursion
mdtb[5] = ModWSize;
*/


////===============================================

// Reset all globals variables modified during a play or loop command
function
resetGlobals()
(
    memset(CmDval, 0, tpChNb);
    memset(UsDval, 0, tpChNb);
    TM_delta_inc = 0.001; // Matrix max. standard variation up
    TM_delta_dec = 0.001; // Matrix max. standard variation down
    xxupdf = p_XPar0; // update from p_XPar0
    xxrep = 3;
    FP_L = 0x7FFFFFFF; // local mask
);

// save entry in playlog
function saveEntry()
local (ix, pp)
(
    (flSaveAddr > 0) ? (
        pp = flSaveAddr;
        ix = playLogHdrSize; loop(playLogCopySize, gmem[pp+ix] = gmem[UAdd+ix]; ix += 1); // do save
    );
);


function
manageSpeed()
local (ii, it)
(

    // Compute the actual speed
    //         asked speed                * rate.initial                * rate.synamic                * direction
    clRSpeed = gmem [UAdd+RCB_SpeedAbs_u] * gmem [UAdd+RCB_SpeedMod1_u] * gmem [UAdd+RCB_SpeedMod2_u] * gmem [UAdd+RCB_Speed_Dir_u];
    AAASP1 = gmem [UAdd+RCB_SpeedAbs_u];
    AAASP2 = gmem [UAdd+RCB_SpeedMod1_u];
    AAASP3 = gmem [UAdd+RCB_SpeedMod2_u];
    AAASP4 = gmem [UAdd+RCB_Speed_Dir_u];


    (RState != 0) ? clRSpeed = abs(clRSpeed); // keep speed positive for long plays

    (clRSpeed >= 0) ? (
        (clRSpeed > 8) ? clRSpeed = 8;
        (clRSpeed < 0.01) ? clRSpeed = 0.01;
    ):(
        (clRSpeed < -8) ? clRSpeed = -8;
        (clRSpeed > -0.01) ? clRSpeed = -0.01;
    );


    SpdFact = currSrate * max(0.01, abs(clRSpeed)); // samples
    SpdFactAdj = SpdFact * FAdjRate; // samples
    SpdFactms = SpdFact / 1000;
    ClRIndInc = clRSpeed * FAdjRate;
    /*
    gmem [UAdd+RCB_StartIndex] = (clRSpeed >0) ? ClLowLimit : ClHighLimit; // update start index
    */
    AAASP0 = clRSpeed;
);


// Should be appropriate for all loops
function
manageGrainsMods(flgs)
local (Cb, k, stpcnt, pgr)
(
    ((KmdKurrent == KmdLoop)) ? (
        // Remove their previous new loops events
        pgr = GrMLen; // previous grain size
        smplRemovEvnt(6, Undef, 128);
        stpcnt = MaxGr;
        (flgs & 2) ? ( // Grain mass changed
            GrXpect = max(GrMinXpect, min (gmem [UAdd+RCB_GrXpect] * FP_G_PMass, MaxGr-1));
            GrXVol = (GrXVolAdj + invsqrt(max(1,GrXpect)) / (GrXVolAdj + 1)); // (N + a)/(N + 1)
            stpcnt = ceil(P_Gp_ct - GrXpect);
        );
        (flgs & 1) ? ( // Grain length changed
            // Evaluate New Grain Mean Length in Tupples
            GrMLen = 0|min(MaxGrSize * currSrate, max(24, (FP_GL_Gmin + FP_GL_Gmax) * FP_GL_GSiz * currSrate / 2000));
            P_Gp_ct = 0; // will force creation of a new grain
        );
        // stop some grains
        k = MaxGr-1; while ((k >= 0) && (stpcnt > 0)) (
            Cb = GCBpts[k];
            (Cb[gStatus] > 0) ? (
                // prepare to stop the grain
                smplRemovEvnt(5, k, 1); // remove its previous fade-out event
                Cb[cEvLindx] = ModWSize;
                Cb[cEvLvol] = max(ModWSize/Cb[cGrFOut], ModWSize * 0.5/currSrate); // in 2000 ms
                Cb[gStatus] = 3;
                stpcnt -= 1;
            );
            k -= 1;
        );
        evLState |= 4; // start a new loop right now if useful
    );
);


function
update_dynpars()
local (flSpdmod, flGmod, xp)
(
    FP_F = FP_Flg = FP_Flg2 = gmem[UAdd+RCB_PM_Flgs2]; // Can be dynamically modified
    // Manage global grains size/shape/params/speed etc.
    flSpdmod = flGmod = 0;
    // FP_F = FP_Flg2 & gmem[dynGlFlags];
    paramInClip = UAdd + RCB_DynPar - p_Dyn_First;

    // Volume
    xp = (FP_F & smUFlagVol) ? gmem[paramGCopy+p_Dyn_Vol] : gmem[paramInClip+p_Dyn_Vol];
    (FP_Dyn_Vol != xp) ? (
        FP_Dyn_Vol = xp;
        smUpdateFlag |= smUFlagVol;
    );
    // Grain size
    xp = (FP_F & smUFlagGSize) ? gmem[paramGCopy+p_Dyn_GS] : gmem[paramInClip+p_Dyn_GS];
    (FP_GL_GSiz != xp) ? (
        FP_GL_GSiz = xp;
        flGmod |= 1;
    );
    // Dynamic rate
    xp = (FP_F & smUFlagGspeed) ? gmem[paramGCopy+p_Dyn_Rate] : gmem[paramInClip+p_Dyn_Rate];
    (FP_GL_GSpd1 != xp) ? (
        FP_GL_GSpd1 = xp;
        flSpdmod |= 1;
    );
    // Dynamic transpose
    xp = (FP_F & smUFlagDGspeed) ? gmem[paramGCopy+p_Transpose] : gmem[paramInClip+p_Transpose];
    (FP_GL_GSpd2 != xp) ? (
        FP_GL_GSpd2 = xp;
        flSpdmod |= 1;
    );
    // Slant
    xp = (FP_F & smUFlagGSlant) ? gmem[paramGCopy+p_Dyn_Slant] : gmem[paramInClip+p_Dyn_Slant];
    (FP_GL_Slant != xp) ? (
        FP_GL_Slant = xp;
    );
    // Sustain phase
    xp = (FP_F & smUFlagGSust) ? gmem[paramGCopy+p_Dyn_GTWd] : gmem[paramInClip+p_Dyn_GTWd];
    (FP_GL_GTWd != xp) ? (
        FP_GL_GTWd = xp;
    );
    // Dynamic position
    xp = (FP_F & smUFlagGPos) ? gmem[paramGCopy+p_Dyn_PlPos] : gmem[paramInClip+p_Dyn_PlPos];
    (FP_G_PPos != xp) ? (
        FP_G_PPos = xp;
    );
    // Position latency
    xp = (FP_F & smUFlagGPVar) ? gmem[paramGCopy+p_Dyn_PlLat] : gmem[paramInClip+p_Dyn_PlLat];
    (FP_G_PVar != xp) ? (
        FP_G_PVar = xp;
    );
    // Dynamic mass
    xp = (FP_F & smUFlagGMass) ? gmem[paramGCopy+p_Dyn_PlMass] : gmem[paramInClip+p_Dyn_PlMass];
    (FP_G_PMass != xp) ? (
        FP_G_PMass = xp;
        GrXpect = max(GrMinXpect, min(gmem [UAdd+RCB_GrXpect] * FP_G_PMass, MaxGr-1));
        GrXVol = (GrXVolAdj + invsqrt(max(1,GrXpect)) / (GrXVolAdj + 1)); // (N + a)/(N + 1)
        flGmod |= 2;
    );
    // Asynchronicity
    xp = (FP_F & smUFlagAsync) ? gmem[paramGCopy+p_Dyn_Asynch] : gmem[paramInClip+p_Dyn_Asynch];
    (FP_G_PAsyn != xp) ? (
        FP_G_PAsyn = xp;
    );
    // Direction 1
    xp = (FP_F & smUFlagDDir) ? gmem[paramGCopy+p_Dyn_Direct] : gmem[paramInClip+p_Dyn_Direct];
    (FP_G_Direct != xp) ? (
        FP_G_Direct = xp;
    );
    // Direction 2
    xp = (FP_F & smUFlagDDir) ? gmem[paramGCopy+p_RDirSwitch];
    (FP_P_Direct != xp) ? (
        FP_P_Direct = xp;
        gmem[UAdd+RCB_Speed_Dir_u] = xp ? -1 : 1; // Sens
        flSpdmod |= 1;
    );
    // X Panoramique
    (FP_L & smUFlagXPan) ? (
        xp = (FP_F & smUFlagXPan) ? gmem[paramGCopy+p_Dyn_XPan] : gmem[paramInClip+p_Dyn_XPan];
        (gmem[UAdd+RCB_Pan_Src] != xp) ? (
            gmem[UAdd+RCB_Pan_Src] = xp;
        );
    );
    // Inhamonicity
    xp = (FP_F & smUFlagInharm) ? gmem[paramGCopy+p_Inharmonicity] : gmem[paramInClip+p_Inharmonicity];
    (FP_G_Inharm != xp) ? (
        FP_G_Inharm = xp;
    );
    // Harmonic shape
    xp = (FP_F & smUFlagHarmShp) ? gmem[paramGCopy+p_Harmonic_Shape] : gmem[paramInClip+p_Harmonic_Shape];
    (FP_G_HarmShp != xp) ? (
        FP_G_HarmShp = xp;
    );
    // Fade In Shape
    xp = (FP_F & smUFlagGrISh) ? gmem[paramGCopy+p_Dyn_GrFISh] : gmem[paramInClip+p_Dyn_GrFISh];
    (FP_G_FI_Shp != xp) ? (
        FP_G_FI_Shp = xp;
        buildShape(GrShpIn, FP_G_FI_Shp);
    );
    // Fafe Out Shape
    xp = (FP_F & smUFlagGrOSh) ? gmem[paramGCopy+p_Dyn_GrFOSh] : gmem[paramInClip+p_Dyn_GrFOSh];
    (FP_G_FO_Shp != xp) ? (
        FP_G_FO_Shp = xp;
        buildShape(GrShpOut, FP_G_FO_Shp);
    );
    gmem[UAdd+RCB_SpeedMod2_u] = scale_12TET[max(0, min(96, 48 + FP_GL_GSpd2))];
    gmem[UAdd+RCB_SpeedMod1_u] = FP_GL_GSpd1;
    //
    flGmod ? manageGrainsMods(flGmod);
    flSpdmod ? manageSpeed();

);

function
initDynPars()
(
    // Clip flags
    paramInClip = UAdd + RCB_DynPar - p_Dyn_First;
    FP_F = FP_Flg = (FP_Flg1 = gmem[UAdd+RCB_PM_Flgs1]);
    FP_Flg2 = gmem[UAdd+RCB_PM_Flgs2];
    // FP_F = FP_Flg & gmem[dynGlFlags];
    // Define some default/initial values for some modififers
    (FP_F & smUFlagVol) ?     (FP_Dyn_Vol = gmem[paramGCopy+p_Dyn_Vol]; ) :
                                (FP_Dyn_Vol = gmem[paramInClip+p_Dyn_Vol]; ) ; //
    (FP_F & smUFlagGSize) ?   (FP_GL_GSiz = gmem[paramGCopy+p_Dyn_GS]; ) :
                                (FP_GL_GSiz = gmem[paramInClip+p_Dyn_GS]; ) ; //
    (FP_F & smUFlagGspeed) ?  (FP_GL_GSpd1 = gmem[paramGCopy+p_Dyn_Rate]; ) :
                                (FP_GL_GSpd1 = gmem[paramInClip+p_Dyn_Rate]; ) ; //
    (FP_F & smUFlagDGspeed) ?  (FP_GL_GSpd2 = gmem[paramGCopy+p_Transpose]; ) :
                                (FP_GL_GSpd2 = gmem[paramInClip+p_Transpose]; ) ; //
    (FP_F & smUFlagGSlant) ?  (FP_GL_Slant = gmem[paramGCopy+p_Dyn_Slant]; ) :
                                (FP_GL_Slant = gmem[paramInClip+p_Dyn_Slant]; ) ; //
    (FP_F & smUFlagGSust) ?   (FP_GL_GTWd = gmem[paramGCopy+p_Dyn_GTWd]; ) :
                                (FP_GL_GTWd = gmem[paramInClip+p_Dyn_GTWd]; ) ; //
    (FP_F & smUFlagGPos) ?    (FP_G_PPos = gmem[paramGCopy+p_Dyn_PlPos]; ) :
                                (FP_G_PPos = gmem[paramInClip+p_Dyn_PlPos]; ) ; //
    (FP_F & smUFlagGPVar) ?   (FP_G_PVar = gmem[paramGCopy+p_Dyn_PlLat]; ) :
                                (FP_G_PVar = gmem[paramInClip+p_Dyn_PlLat]; ) ; //
    (FP_F & smUFlagGMass) ?   (FP_G_PMass = gmem[paramGCopy+p_Dyn_PlMass]; ) :
                                (FP_G_PMass = gmem[paramInClip+p_Dyn_PlMass]; ) ; //
    (FP_F & smUFlagAsync) ?   (FP_G_PAsyn = gmem[paramGCopy+p_Dyn_Asynch]; ) :
                                (FP_G_PAsyn = gmem[paramInClip+p_Dyn_Asynch]; ) ; //
    (FP_F & smUFlagDDir) ?    (FP_G_Direct = gmem[paramGCopy+p_Dyn_Direct]; ) :
                                (FP_G_Direct = gmem[paramInClip+p_Dyn_Direct]; ) ; //
    (FP_F & smUFlagXPan) ?  (gmem[UAdd+RCB_Pan_Src] = gmem[paramGCopy+p_Dyn_XPan]; ) :
                                (gmem[UAdd+RCB_Pan_Src] = gmem[paramInClip+p_Dyn_XPan]; ) ; //
    (FP_F & smUFlagInharm) ?  (FP_G_Inharm = gmem[paramGCopy+p_Inharmonicity]; ) :
                                (FP_G_Inharm = gmem[paramInClip+p_Inharmonicity]; ) ; //
    (FP_F & smUFlagHarmShp) ? (FP_G_HarmShp = gmem[paramGCopy+p_Harmonic_Shape]; ) :
                                (FP_G_HarmShp = gmem[paramInClip+p_Harmonic_Shape]; ) ; //
    (FP_F & smUFlagGrISh) ?   (FP_G_FI_Shp = gmem[paramGCopy+p_Dyn_GrFISh]; ) :
                                (FP_G_FI_Shp = gmem[paramInClip+p_Dyn_GrFISh]; ) ; //
    (FP_F & smUFlagGrOSh) ?   (FP_G_FO_Shp = gmem[paramGCopy+p_Dyn_GrFOSh]; ) :
                                (FP_G_FO_Shp = gmem[paramInClip+p_Dyn_GrFOSh]; ) ; //
    gmem[UAdd+RCB_SpeedMod2_u] = scale_12TET[max(0, min(96, 48 + FP_GL_GSpd2))];
    gmem[UAdd+RCB_SpeedMod1_u] = FP_GL_GSpd1;
    // now switch to FP_Flg2 for dynamic modifiers
    FP_F = FP_Flg = FP_Flg2;
    //FP_F = FP_Flg & gmem[dynGlFlags];
);

/*
    Main check for the RCB

    It is now filled with the UCB
    We can Check and correct everything,

    and build all global variables needed
*/
function
checkRCB()
local (u, v, k, c, c1, c2, cu1, cu2, cu3, cu4, ix, iy, ch, t1, t2, pp, errk,
    chk)
(
    errk = 0;
    // Check we have correct clip informations
    chk = (gmem [UAdd+RCB_CFty_enu] != 0) && (gmem [UAdd+RCB_CSiz_smp] > 480) && (gmem [UAdd+RCB_CCCC] > 0)
            && (gmem [UAdd+RCB_CFreq_sps] > 4000) ;
    (!chk) ? (
        errk = 0601; // probably messed up RCB
    );
    // Compute Clip size in tupples
    chk ? (
        initDynPars();
        // Compute some internal adjustements
        (gmem [UAdd+RCB_CFrCorr_u] == 0) ? (
            gmem [UAdd+RCB_CFrCorr_u] = gmem [UAdd+RCB_CFreq_sps] / currSrate;
        );
        (gmem [UAdd+RCB_CSiz_tpl] == 0) ? (
            gmem [UAdd+RCB_CSiz_tpl] = gmem [UAdd+RCB_CSiz_smp] / gmem [UAdd+RCB_CCCC];
        );
        // Update fade-in, fade-out times : at least 1 ms
        ((FInDur = gmem [UAdd+RCB_FadeIn_ms]) < 1) ? (
            gmem [UAdd+RCB_FadeIn_ms] = FInDur = 1;
        );
        ((FOutDur = gmem [UAdd+RCB_FadeOut_ms]) < 1) ? (
            gmem [UAdd+RCB_FadeOut_ms] = FOutDur = 1;
        );
        // Update global speed [some might look redundant, but are not !
        (gmem [UAdd+RCB_SpeedAbs_u] == 0) ? gmem [UAdd+RCB_SpeedAbs_u] = 1;
        (gmem [UAdd+RCB_SpeedMod1_u] == 0) ? gmem [UAdd+RCB_SpeedMod1_u] = 1;
        (gmem [UAdd+RCB_SpeedMod2_u] == 0) ? gmem [UAdd+RCB_SpeedMod2_u] = 1;
        (gmem [UAdd+RCB_Speed_Dir_u] == 0) ? gmem [UAdd+RCB_Speed_Dir_u] = 1;
        manageSpeed();
    );
    chk ? (
        // Duration for the clip ?
        // Evaluate Start/Stop position in tupples
        (gmem [UAdd+RCB_PlayTime_sec] <= 0) ? (gmem [UAdd+RCB_PlayTime_sec] = clRdMaxD; );
        // Adjust the clip duration, in tupples
        clLng = clAsk = gmem[UAdd+RCB_PlayTime_sec];  // duration asked to play
        CTSize = 0|(CRSize/CCCC); // what we really have, in tupples
        (KmdKurrent == KmdPlay) ? (
            clSec = CTSize / FFrRate; // what we really have, in duration in seconds
            clLng = clSec / abs(clRSpeed); // and how long we can play at current speed
        );

        // clLng = min(CTSize, 0|(clDur * SpdFact)); // what we need/have in tupples
        clDur = min(clAsk, clLng); // the decision
        (PBFlgs & FLdoForceIntegral) ? (
            clDur = max(clDur, clLng);
            // FLdoForceIntegral already managed
            // clLng = 0|(CFSize/CCCC); // play the whole clip
            FInDur = FOutDur = 2; // in ms
        );
        /*
        AAA_Cllng = clLng;
        clOffset = 0;
        u = gmem[paramGCopy+p_PlayStart];
        (u > irand(100)) ? (
            // start from a possibly different position
            ((clLng < CTSize) && (!(PBFlgs & FLdoForcePFS))) ? (
                // we have to play less than what we have ;
                clOffset = irand(CTSize - clLng);
            );
        );
        */
        // define start and end positions in Tupples
        ClLowLimit = ClTpl1st + clOffset;
        ClHighLimit = ClTplLast;

        // CLStartPC = gmem [UAdd+RCB_ClStart] = 100 * clOffset / CTSize ;
        // CLEndPC = gmem [UAdd+RCB_ClEnd] = 100 * (clOffset + clLng) / CTSize ;
        GrStHLimit = ClHighLimit; // Grains/Play high limit
        GrStLLimit = ClLowLimit; // Grains/Play low limit

        (KmdKurrent == KmdPlay) ? (
            // define fade in and fade out position, and start position
            (PBFlgs & FLdoForceFadesSL) ? (
                // Special case, short fade-in, long fade out
                FInDur = 4; // 4 ms
                // Fade out is some % of clip duration
                FOutDur = 1000 * 20 / 100  * clDur; // 20% of clDur, in ms
            );
            // Check fades vs length clDur
            ((k = FInDur+FOutDur) >= (w = 1000 * clDur - 100)) ? (
                // Reduce fades
                FInDur = max(1, FInDur * w/k);
                FOutDur = max(1, FOutDur * w/k);
            );
            FInTpl = 0|(FInDur * SpdFactAdj / 1000);
            FOutTpl = 0|(FOutDur * SpdFactAdj / 1000);
            // Some problematic case ?
            ((k = FInTpl+FOutTpl) >= clLng) ? (
                // reduce both durations
                FInTpl = 0|(FInTpl * clLng/(k+1));
                FOutTpl = 0|(FOutTpl * clLng/(k+1));
            );
            (clRSpeed > 0) ? (
                // forward read - fade-in at the start
                ClRIndex = ClLowLimit;
                ClLowArea = ClLowLimit + FInTpl;
                ClHighArea = ClHighLimit - FOutTpl;
            ) : (
                // backward read - fade-in at the end
                ClRIndex = ClHighLimit;
                ClLowArea = ClLowLimit + FOutTpl;
                ClHighArea = ClHighLimit - FInTpl;
            );
        );

        (KmdKurrent == KmdLoop) ? (
            ClRIndex = ClLowLimit;
            ClLowArea = ClLowLimit;
            ClHighArea = ClHighLimit;
            // Check fades vs length clDur
            ((k = FInDur+FOutDur) >= (w = 1000 * clDur - 100)) ? (
                // Reduce fades
                FInDur = max(1, FInDur * w/k);
                FOutDur = max(1, FOutDur * w/k);
            );
            FInTpl = FOutTpl = 0;
        );

        gmem [UAdd+RCB_StartIndex] = ClRIndex ; // keep start index
    );
    chk ? (
        //----- Channels management
        hpfold = max(1, gmem[paramGCopy+p_GvChnUse]); // max channels, from Game Master
        // Clear channels sets
        memset(AddChsZ, 0, 256);
        // Get infos
        HPCnt1 = HPCnt2 = 0;
        hpcnf1 = gmem[UAdd+RCB_Channels_conf1];
        hpcnf2 = gmem[UAdd+RCB_Channels_conf2];
        chused1 = gmem [UAdd+RCB_Channels_cnt_used1];
        chused2 = gmem [UAdd+RCB_Channels_cnt_used2];
        (PBFlgs & FLdoForceFChs) ? (  // FLdoForceChCnt
            chused1 = chused1 = CCCC; // Use CCCC as channel count
        );
        ((chused1 <= 0) || (hpcnf1 === 0)) ? (
            // No channel specified - use 1st stereo as default
            //Chans1[0] = 0;
            //Chans1[1] = 1;
            //gmem [UAdd+RCB_Channels_cnt_used1] = HPCnt1 = 2;
            errk = 0602;
        ) :
        ((hpcnf1 > 0) && (hpcnf1 < HPPSize) && ((ptr = gmem[gHPPTab + hpcnf1]) > gHPATab) && (ptr < gHPATab+HPASize) && (gmem[ptr - 1] === hpcnf1)) ? (
            // we probably have a correct conf. number
            (((HPCnt1 = gmem[ptr]) > 0) && (HPCnt1 <= 128) && (HPCnt1 === (0|HPCnt1))) ? (
                // Copy channels # from gmem
                ptr += 1;
                ix = 0; loop(HPCnt1,
                    ch = gmem[ptr+ix] - 1; // change channels to zero origin
                    ((ch >= 0) && (ch < ChanMax)) ? (
                        Chans1[ix] = ch  %  hpfold;
                    ) : (
                        errk = 0605; // invalid channel #
                    );
                    ix += 1;
                );
                iy = 0; while (ix < ChanSize) (Chans1[ix] = Chans1[iy]; ix += 1; iy += 1;);
            ) : (
                errk = 0604;
            );
        ) : (
            errk = 0603;
        );
        (hpcnf2 != 0) ? (
            ((hpcnf2 > 0) && (hpcnf2 < HPPSize) && ((ptr = gmem[gHPPTab + hpcnf2]) > gHPATab) && (ptr < gHPATab+HPASize) && (gmem[ptr - 1] === hpcnf2)) ? (
                // we probably have a correct conf. number
                (((HPCnt2 = gmem[ptr]) > 0) && (HPCnt2 <= 128) && (HPCnt2 === (0|HPCnt2))) ? (
                    // Copy channels # from gmem
                    ptr += 1;
                    ix = 0; loop(HPCnt2,
                        ch = gmem[ptr+ix] - 1; // change channels to zero origin
                        ((ch >= 0) && (ch < ChanMax)) ? (
                            Chans2[ix] = ch  %  hpfold;
                        ) : (
                            errk = 0615; // invalid channel #
                        );
                        ix += 1;
                    );
                    iy = 0; while (ix < ChanSize) (Chans2[ix] = Chans2[iy]; ix += 1; iy += 1;);
                ) : (
                    errk = 0614;
                );
            ) : (
                errk = 0613;
            );
        ) : (
            // No channel specified - use 1st stereo as default
            Chans2[0] = 0;
            Chans2[1] = 1;
            gmem [UAdd+RCB_Channels_cnt_used2] = HPCnt2 = 2;
        );
    );
    (errk != 0) ? (
        sprintf(#sfc, "Errk: hpcnf1: %d  ptr: %d / %d  [%d %d %d]", hpcnf1, ptr, gHPATab, gmem[ptr - 1], gmem[ptr], gmem[ptr + 1]);
        mSL_log(SysLogBox, #sfc);
    );
    (chk &= (errk === 0)) ? (
        // randomize channels 1 ?
        (((PBFlgs & FLdoForceFChs) === 0) && (HPCnt1 > 1)) ? (
            ix = 0;
            loop(HPCnt1-1,
                iy = ix + irand(HPCnt1-ix);
                (ix != iy) ? (
                    v = Chans1[ix];
                    Chans1[ix] = Chans1[iy];
                    Chans1[iy] = v;
                );
                ix += 1;
            );
            // Should we reduce the number of used channels ?
            c1 = gmem [UAdd+RCB_Channels_cnt_min]; c2 = gmem [UAdd+RCB_Channels_cnt_max];
            (c1 === 0) ? (c1 = HPCnt1;); (c2 === 0) ? (c2 = HPCnt1;);
            c3 = c1 = max(1, c1); c2 = max(1, c2);
            (c2 > c1) ? c3 += irand(c2+1-c1);
            c3 = ceil(c3 * max(2, gmem [UAdd+RCB_Channels_density]) / 100); // 2% minimum so c1 is >0
            HPCnt1 = min(c3, HPCnt1);
        );
        // randomize channels 2 ?
        (((PBFlgs & FLdoForceFChs) === 0) && (HPCnt2 > 1)) ? (
            ix = 0;
            loop(HPCnt2-1,
                iy = ix + irand(HPCnt2-ix);
                (ix != iy) ? (
                    v = Chans2[ix];
                    Chans2[ix] = Chans2[iy];
                    Chans2[iy] = v;
                );
                ix += 1;
            );
            // Should we reduce the number of used channels ?
            c1 = gmem [UAdd+RCB_Channels_cnt_min]; c2 = gmem [UAdd+RCB_Channels_cnt_max];
            (c1 === 0) ? (c1 = HPCnt2;); (c2 === 0) ? (c2 = HPCnt2;);
            c3 = c1 = max(1, c1); c2 = max(1, c2);
            (c2 > c1) ? c3 += irand(c2+1-c1);
            c3 = ceil(c3 * max(2, gmem [UAdd+RCB_Channels_density]) / 100); // 2% minimum so c1 is >0
            HPCnt2 = min(c3, HPCnt2);
        );
        gmem [UAdd+RCB_Channels_cnt_used1] = HPCnt1 = max(0,HPCnt1);
        gmem [UAdd+RCB_Channels_cnt_used2] = HPCnt2 = max(0,HPCnt2);


        // Out generated channels
        chOutCnt = max(1, min(num_ch, hpfold));
        (PBFlgs & FLdoForceFChs) ? (
            chTmpCnt1 = chTmpCnt2 = chGenCnt = CCCC;
        ) : (
            // Manage the generator count
            c1 = gmem [UAdd+RCB_MinChCnt];
            c2 = gmem [UAdd+RCB_MaxChCnt];
            (c1 <= 0) ? (c1 = chOutCnt);
            (c2 <= 0) ? (c2 = c1);
            (c2 > (c3 = c1)) ? c3 += irand(c2+1-c1);
            chGenCnt = max(CCCC, c3);
            // We will be using intermediate channels :
            chTmpCnt1 = max(1, max(HPCnt1, chGenCnt));
            chTmpCnt2 = max(1, max(HPCnt2, chGenCnt));
        );
        // Size of each generated tupple
        gmem[UAdd+RCB_GenCnt] = chGenCnt;



        // Update global volume
        VolumeMod0_u = 1;
        PrevVolumeMod1_u = gmem[UAdd+RCB_VolumeMod1_u];
        VolumeMod0_u = 1;
        VolumeMod1_u = 10 ^ (PrevVolumeMod1_u/20);
        (PBFlgs & FLdoForceVol) ? (
            // Fix volume for this clip
            gmem[UAdd+RCB_VolumeTarget_dB] = (gmem[UAdd+RCB_VolumeMin_dB] +
                    gmem[UAdd+RCB_VolumeMax_dB]) / 2;
        );
        FP_GlobVAdj =  // invsqrt(chGenCnt) *
            10 ^ ((gmem [UAdd+RCB_VolumeTarget_dB] + (gmem[clClVolumes+clClip] & clVolumeMask) - clVolumeBias)/20); // vol. adjust
        FP_GlobVol = FP_GlobSet = max(0, min(4, VolumeMod0_u * VolumeMod1_u * FP_GlobVAdj * (10 ^ (FP_Dyn_Vol/20)) * gmem[UAdd+RCB_StdVol] * gmem[commonGlobalVolume]));
        smUpdateFlag |= smUFlagVol;


        clRepeatDur = 5;
        GCBL = GCBArray; // always use first buffer as a start
        GCBL[gStatus] = 0;

        (KmdKurrent == KmdPlay) ? (
            //clMaxDur = clLng / SpdFact; // evaluation of the duration
            //clMaxDur = (clMaxDur > 600) ? 600 : clMaxDur;
            //clMaxDur = (clMaxDur < 5) ? 5 : clMaxDur;
            // endclip = second + 1 + clMaxDur;
            clMaxDur = clLng;
        );

        (KmdKurrent == KmdLoop) ? (
            // compute grains durations, fades, positions
            v1 = gmem [UAdd+RCB_MinGrains_ms];
            v2 = gmem [UAdd+RCB_MaxGrains_ms];
            u1 = min(v1, v2);
            u2 = max(v1, v2);
            gmem [UAdd+RCB_MinGrains_ms] = FP_GL_Gmin = u1;
            gmem [UAdd+RCB_MaxGrains_ms] = FP_GL_Gmax = u2;

            //endclip = gmem [UAdd+RCB_PlayTime_sec];
            // define depth = number of grains to play simultaneously
            (gmem [UAdd+RCB_GrXpect] == 0) ? (
                t1 = gmem [UAdd+RCB_MinNGrains_u]; t2 = gmem [UAdd+RCB_MaxNGrains_u];
                gmem [UAdd+RCB_GrXpect] = max(1, 0|((t2 > t1) ? t1 + irand(t2 - t1 + 1 ) : t1));
            );
            GrXpect = max(GrMinXpect, min(gmem [UAdd+RCB_GrXpect] * FP_G_PMass, MaxGr-1));
            GrXVol = (GrXVolAdj + invsqrt(max(1,GrXpect)) / (GrXVolAdj + 1)); // (N + a)/(N + 1)
            HPIndx = 0; // 1st channel to use
            clMaxDur = clAsk; // asked duration
            clMaxDur = (clMaxDur < 5) ? 5 : (clMaxDur > 600) ? 600 : clMaxDur;
            //endclip = second + 1 + endclip;
        );

        gmem[UAdd+RCB_Rec_Duration] = clRepeatDur = clMaxDur;
        //guarddog = second + 20 + clMaxDur; // active guarddog
        FP_Coeff = gmem[UAdd+RCB_VolBias]; FP_CoeffK = 1 - FP_Coeff;

        // keep a copy of the clip number, for further editing
        gmem[UAdd+RCB_ClipDup] = gmem[UAdd+RCB_ClipNb];
        synchroSource = gmem[UAdd+RCB_Synchro_source];
    );

    // Update pan
    // Keep memory available
    gmem[UAdd+RCB_Mem_Avail] = __memtop() - mSL_StM_FreePt;
    gmem[UAdd+RCB_Errc] = FErrc = (FErrc ? FErrc : errk); // keep/return error indication
    gmem[UAdd+RCB_CPStart_tim] = time_precise() + gmem[timeDelta];
    (flSaveAddr > 0) ? (
        (plChckEnt(flSaveAddr)) ? (
            pp = flSaveAddr;
            gmem[UAdd+RCB_Rec_Last] = gmem[UAdd+RCB_Rec_Time] +  gmem[UAdd+RCB_Rec_Duration];
            gmem[plTInfo+4] += 1;
            saveEntry(); // save entry in playlog
            gmem[UAdd+RCB_Rec_Flag] = 1; // rechain it right now....
        );
    );

);//checkRCB()





checkUnit();
gmem[UAdd+RCB_Mem_Avail] = __memtop() - mSL_StM_FreePt; // set mem avail



/*
=== mSL functions ===
*/



mSL_baseAVSize = 822;
mSL_baseOVSize = 256;
mSL_basePVSize = 128;


// Clean what can be cleaned after playing
function endClean()
(
    ii = 0;
);



function parGetV(xp)
local (val, act)
(
    xp = 0|max(0,min(paramNMax,xp)); // minimalistic check
    val = gmem[paramGCopy+xp]; // paramValues[xp];
);

function parSet(xop, value)
local (f, pp, pq, pv, fspect)
(
    xop = 0|max(0,min(paramNMax,xop)); // minimalistic check
    pv = gmem[paramGCopy+xop]; // paramValues[xop]; // previous value
);

/*
    Implementation of the mSL "get"
*/
function mSL_get(argc, argv)
local (pfid, ref, addr, res, flg, kod, size, s, ip, k, k2, pt, kid, pid)
(
    pfid = argv[0]; ref = argv[1];
    res = addr = flg = 0;
    kod = size = -1;
    kid = (argc > 1) && (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max)));

    // is this a keyword ?
    ((pfid > mSL_Sym_Low) && (pfid < mSL_Sym_High)) ? (
        (FlagsTbVals[Flgs_PrOps] & 1) ? (
            // just for trace
            strcpy(#sZ0, mSL_id2Str(pfid));
            (TRC & 64) ? (
                (argc <= 1) ? (
                    sprintf(#sfc, "mSL_get[%d]  \"%s\".", argc, #sZ0);
                ) :
                (
                    sprintf(#sfc, "mSL_get[%d]  \"%s\"  \"%s\" / %d", argc, #sZ0, mSL_edit_value(#sZ1, ref), kid);
                );
                mSL_log(SysLogBox, #sfc);
            );
        );
        pid = -1;
        ((pfid === mSL_KW_JSFX) || (pfid === mSL_KW_jsfx_) || (pfid === mSL_KW_GM) || (pfid === mSL_KW_GM_)) ? (
            // acces a JSFX variable
            res = mSL_vGet(ref);
        ) :
        ((pfid === mSL_KW_JSFXref) || (pfid === mSL_KW_jsfxref_)) ? (
            // acces a JSFX variable reference
            res = mSL_get_var_idt(ref);
        ) :
        (pfid === mSL_KW_PNum) ? (
            // Get a parameter number
            (kid && ((k = mSL_getinHT(paramHashTbl, ref)) >= 0)) ? (
                pid = mSL_getinHTaux; // use the auxiliary result = param number
            );
            res = pid;
        ) :
        (pfid === mSL_KW_ParamV) ? (
            // get a parameter value
            pid = 0; k = -2; // for now
            // Get the value of a parameter by name or by number
            (kid) ? (
                // look for the ident. in a table
                ((k = mSL_getinHT(paramHashTbl, ref)) >= 0) ? (
                    pid = mSL_getinHTaux;
                );
            ) :
            ((ref >= 0) && (ref < paramNMax)) ? (
                pid = ref;
            );
            (pid >= 0) ? (
                res = parGetV(pid);
            );
            // sprintf(#sfc, "Get Param  %d / %d =>  %f", pid, k, res);
            // mSL_log(SysLogBox, #sfc);
        ) :
        (pfid === mSL_KW_Host) ? (
            res = the_host;
        ) :
        //(pfid === mSL_KW_vars) ? (
        //    // return the "vars" array
        //    res = mSL_baseAVars;
        //) :
        //(pfid === mSL_KW_locs) ? (
        //    // return the "locs" array
        //    res = mSL_baseOVars;
        //):
        (
            res = mSL_vGet(pfid);
        );
    ) : (
        // Is the first parameter the address of a table ?
        (((addr = pfid) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        // Is this the "raw" address of a table ?
        (((addr = pfid + 2) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        // Let's consider it as a simple pointer...
        (
            addr = pfid; // don't know much more
            size = 0x1000000; // default access...
        );


        (kid) ? (
            // look for an entry in the table
            ip = 0; k = addr[ip];
            (flg && ((ref === 'size') || (ref === mSL_KW_size))) ? (
                res = size; flg = 0;
            );
            (flg && ((ref === 'type') || (ref === mSL_KW_type))) ? (
                res = kod; flg = 0;
            );
            while (flg && (((k > mSL_Sym_Low) && (k < mSL_Sym_High)) || ((k >= mSL_MKey_min) && (k <= mSL_MKey_max)))) (
                (ip >= size) ? (
                    flg = 0;
                ) :
                (k === ref) ? (
                    res = addr[ip+1]; flg = 0;
                ) :
                (
                    ip += 2; k = addr[ip];
                );
            );
        ) :
        ((addr >= 0) && ((pt = addr + ref) >= 0)) ? (
            (pt < mSL_lastmemory) ? (
                res = pt[0];
            );
        ) :
        (addr < 0) ? (
            (((pt = -addr + ref) > 0) && (pt < 0x8000000)) ? (
                res = gmem[pt];
            );
        );

    );
    res;
);

/*
    Set the value of field ; return previous one
*/
function mSL_set(argc, argv)
local (pfid, ref, value, force, addr, res, flg, kod, size, s, ip, k, k2, pt, kid)
(

    pfid = argv[0]; ref = argv[1]; value = argv[2]; force = argv[3];
    res = addr = flg = 0;
    kod = size = -1;
    kid = (argc > 1) && (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max)));

    // is this a keyword ?
    ((pfid > mSL_Sym_Low) && (pfid < mSL_Sym_High)) ? (
        (FlagsTbVals[Flgs_PrOps] & 1) ? (
            strcpy(#sZ0, mSL_id2Str(pfid));
            (TRC & 64) ? (
                sprintf(#sfc, "mSL_set[%d]  \"%s\"  \"%s\" / %d    %g",argc, #sZ0, mSL_edit_value(#sZ1, ref), kid, value);
                mSL_log(SysLogBox, #sfc);
            );
        );
        ((pfid === mSL_KW_JSFX) || (pfid === mSL_KW_jsfx_) || (pfid === mSL_KW_GM) || (pfid === mSL_KW_GM_)) ? (
            // acces a JSFX variable
            (argc > 2) ? (
                res = mSL_vSet(ref, value);
            );
        ) :
        (pfid === mSL_KW_ParamV) ? (
            pid = -1; // for now
            // Get the value of a parameter by name or by number
            (kid) ? (
                // look for the ident. in a table
                ((k = mSL_getinHT(paramHashTbl, ref)) >= 0) ? (
                    pid = mSL_getinHTaux; // use the auxiliary result
                );
            ) :
            ((ref >= 0) && (ref < paramNMax)) ? (
                pid = ref;
            );
            // Set the value of a parameter
            (pid >= 0) ? (
                pid = 0|max(0,min(paramNMax,pid));
                res = gmem[paramGCopy+pid]; // paramValues[pid];
                parSet(pid, value);
            );
        ) :
        (
            (argc > 1) ? (
                res = mSL_vSet(pfid, ref);
            );
        );
    ) : (
        // Is this a table ?
        (((addr = pfid) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        (((addr = pfid + 2) > 2) && ((kod = addr[-2]) >= mSL_MKey_min) && ((s = addr[-1]) > 0)
            && (s === addr[s]) && (((k2 = addr[s+1]) === mSL_End_Mark) || (k2 === (kod ~ mSL_CC_Chksum)))) ? (
                flg = 1; size = s;
        ) :
        (
            addr = pfid; // don't know much more
            size = 0x1000000; // default access...
        );

        (((ref > mSL_Sym_Low) && (ref < mSL_Sym_High)) || ((ref >= mSL_MKey_min) && (ref <= mSL_MKey_max))) ? (
            // look for an entry in the table
            ip = 0; k = addr[ip];
            (flg && ((ref === 'type') || (ref === mSL_KW_type)) && (force & 1) && (value >= mSL_MKey_min) && (value <= mSL_MKey_max)) ? (
                flg = 0;  addr[-2] = value; addr[s+1] = value ~ mSL_CC_Chksum;
            );
            while (flg && (((k > mSL_Sym_Low) && (k < mSL_Sym_High)) || ((k >= mSL_MKey_min) && (k <= mSL_MKey_max)))) (
                (k === ref) ? (
                    res = addr[ip+1];
                    addr[ip+1] = value;
                    flg = 0;
                ) :
                (ip >= size) ? (
                    flg = 0;
                ) : (
                    ip += 2; k = addr[ip];
                );
            );
            (flg && (force & 1)) ? (
                // try to create the entry
                ip = 0; flg = 1;
                while (flg) (
                    (ip >= size) ? (
                        flg = 0;
                    ) :
                    (addr[ip] === 0) ? (
                        addr[ip] = ref;
                        addr[ip+1] = res = value;
                        flg = 0;
                    ) :
                    (
                        ip += 2; k = addr[ip];
                    );
                );
            );
        ) :
        ((addr >= 0) && ((pt = addr + ref) >= 0)) ? (
            (pt < mSL_lastmemory) ? (
                // but this may write anywhere in the memory !
                res = pt[0];
                pt[0] = value;
            );
        ) :
        (addr < 0) ? (
            (((pt = -addr + ref) > 0) && (pt < 0x8000000)) ? (
                // but this may write anywhere in the shared memory !
                res = gmem[pt];
                gmem[pt] = value;
            );
        );
    );
    res;
);


<? include("GM-Libs/mSL_DeAsm.jsfx-inc"); ?>



<? include("GM-Libs/mSL_Events.jsfx-inc"); ?>


// Read & Compile a mSL script file
function
mSL_load_file_inGFX(fname)
local (fhd, ent, thrd, s, mSL_baseAVars, mSL_baseOVars, mSL_basePVars)
(
    mSL_load_start = gfxStartTime;
    mSL_errX = mSL_errC = 0;
    ent = 0; fhd = -1;
    //(mSL_errC === 0) ? (
    //    SchedListEmpty(SchedInactPts) ? (
    //        mSL_errC = 2406; // can't get a thread
    //    );
    //);

    (FlagsTbVals[Flgs_Traces] & 4) ? (sprintf(#gfxu, "::-> Trying \"%s\"  %d", fname, mSL_errC); mSL_log(SysLogBox, #gfxu););

    (mSL_errC === 0) ? (
        fhd = GM_file_open(fname);
        ((fhd >= 0)) ? (
            0 ? (sprintf(#gfxu, "::-> Using \"%s\"", #tmpFname); mSL_log(SysLogBox, #gfxu););
            // get a free thread
            (ent = getNewThread()) ? (
                thrd = SchedThrdPt[ent];
                AAAAAAAA_01_cp_rtc = mSL_compile(fhd, -1, -1, 0); // we add the input in the memory
                0 ? (sprintf(#gfxu, "::-> Compiled: %d lines   [Err:%d] [Thrd:%d/%d]", mSL_C_numLine, mSL_errC,ent,thrd);
                     mSL_log(SysLogBox, #gfxu););
                fhd = -1; // file has been closed by the compiler
                (mSL_errC === 0) ? (
                    AAAAAAAA_02_add = mSL_main_cod;
                    // This duplicates the work made in "mSL_init_thread" - TODO!!
                    (mSL_main_cod != 0) ? (
                        (FlagsTbVals[Flgs_Scripts] & 1) ? (
                            sprintf(#gfxu, "SZ(%d) %d, %d, %d", ent, (mSL_gvar+1) & mSL_NumMask, (mSL_ovar+1) & mSL_NumMask, (mSL_pvar+1) & mSL_NumMask);
                            mSL_log(SysLogBox, #gfxu);
                        );
                        // Let's copy appropriate vars tables in the thread references
                        thrd[mSL_THR_baseAVars] = mSL_baseAVars = mSL_main_cod[mSL_CC_GlbTab];
                        thrd[mSL_THR_baseOVars] = mSL_baseOVars = mSL_main_cod[mSL_CC_OwnTab];
                        thrd[mSL_THR_basePVars] = mSL_basePVars = mSL_main_cod[mSL_CC_PtrTab];
                        SchedStatus[ent] |= SchThrUsed;  // now in use
                        AAAAAAAA_ent = ent ;
                        SchedPar1[ent] = mSL_main_cod; // the code
                        // Keep tables info in the main code
                        // sprintf(#gfxu, "TH: %d, %d, [%d, %d, %d]", ent, thrd, mSL_baseAVars, mSL_baseOVars, mSL_basePVars);
                        (FlagsTbVals[Flgs_Scripts] & 1) ? (
                            sprintf(#gfxu, "TH(%d) [%d, %d]", ent, mSL_baseAVars, mSL_baseOVars);
                            mSL_log(SysLogBox, #gfxu);
                        );
                        SchedCode[ent] = KRun_mSL_Thread; // start running a thread
                        mSL_init_thread(ent); // perform initalization
                        // ADump(mSL_main_cod); // just a trace
                        mSL_errX = max(mSL_errX, mSL_errC);
                        (mSL_errX === 0) ? (
                            (FlagsTbVals[Flgs_Scripts] & 1) ? (
                                sprintf(#gfxu, "Load OK - Ent: %d", ent);
                                mSL_log(SysLogBox, #gfxu);
                            );
                        );
                        mSL_High_Stack = mSL_max_TOS = 0;
                    ) : (
                        mSL_errX = 2409; // no code generated
                    );
                );
                // GMW2("D");
            ) : (
                mSL_errX = 2410; // no thread available
            );
        ) : (
            mSL_errX = 2405; // can't open
        );
    );

    (mSL_C_fH >= 0) ? (file_close(mSL_C_fH); mSL_C_fH = -1;);
    (fhd >= 0) ? (file_close(fhd); fhd = -1;);
    mSL_errX = max(mSL_errX, mSL_errC);

    (mSL_errX === 0) ? (
        (ent > 0) ? SchedInsertTail(SchedLockdPts, ent, SchETypeThrd);
    ) : (
        SchedFree(ent); // in case of error, free the entry
        ent = 0;
    );

    mSL_load_end = gfxStartTime;
    (FlagsTbVals[Flgs_Scripts] & 1) ? (
        sprintf(#gfxu, "Fread(%d) Err:%d Dur:%.2f ms", ent, mSL_errX,
                        1000 * (mSL_load_end - mSL_load_start));
        mSL_log(SysLogBox, #gfxu);
    );
    flagCheckMemory = 1;
    mSL_errX ? (
        sprintf(#gfxu, "ERR: %d    can't compile \"%s\".", mSL_errX, fname);
        mSL_log(SysLogBox, #gfxu);
    );
    ent;
);




function
Simple_Action(src)
local (zz, xp, mr, ccnt, ent, s1, mpt, w1, pindx, err, p, flgs, auxKmd, auxRes,
    par1, par2, par3, par4, par5, par6, par7, par8)
(
    flgs = FlagsTbVals[Flgs_Acts]; // trace flags
);


function Simple_Action(code, seq)
(
    Simple_temp[0] = 1;
    Simple_temp[1] = code;
    Simple_temp[2] = seq[0];
    Simple_temp[3] = seq[1];
    Simple_temp[4] = seq[2];
    Simple_temp[5] = seq[3];
    Simple_temp[6] = seq[4];
    Simple_temp[7] = seq[5];
    Simple_temp[8] = seq[6];
    Simple_Action(Simple_temp);
);

function
Set_Table(tbl)
local (st, itc, ptr, lptr, cwd, cwdMin, err, cid, hct, pt1st, xmct, flgs, stback, rd_err, pt, zpt, totsize, tout, pttr,
    Cl_n, Cl_dB, ii, s1, s2, s3, s4, s5, ty, n, ps, cp, cnt, kct, vmin, vmax, pos, stnext, kmax, cvl, LWA, LWAsiz,
    AddT)
(
    cvl = ptr = 0;
);


function mSL_call_ops(argc, argv)
local(res, kw)
(
    // Decode the parameters - could be integers or keywords
    0 ? (
        sprintf(#s, "*mSL_call_ops[%d]  %18.0f   \"%s\"   \"%s\"    %g",
            argc, argv[0], mSL_edit_value(#s1, argv[0]), mSL_edit_value(#s2, mSL_KW_SensorSize), argv[1]);
        mSL_log(SysLogBox, #s);
    );
    res = Undef;
);



/*
    Call operations = call a JSfX func from mSL
*/
function
mSL_players_ops(argc, argv)
local()
(
    Undef;
);// mSL_players_ops


/*
    Play operations = single operation for playing in mSL
*/
function mSL_play_ops(argc, argv)
local ()
(
    Undef;
);

/*
    Gui operations
*/
function mSL_gui_ops(argc, argv)
local ()
(
    Undef;
);


/*
    Events management operations
*/
function mSL_event_ops(argc, argv)
local (res, kw, ent, k, p1, p2, p3)
(
    res = 0;
);



/*
    Threads management = single operation on thread
*/
function
mSL_thread_ops(argc, argv)
local (res, k, kw, ent)
(
    res = -1;
    (argc > 0) ? (
        kw = argv[0];
        //sprintf(#ms, "** kw ** => %g  %s", kw, mSL_edit_value(#mt, kw));
        //mSL_log(SysLogBox, #ms);
        // we expect a keyword
        (kw === mSL_KW_new) ? (
            // expect : `new, func, params...
            k = argv[1];
            //sprintf(#ms, "** new ** => %d/%d", k, mSL_bl_check(k));
            //mSL_log(SysLogBox, #ms);
            ((argc > 1) && mSL_bl_check(k) && (k[mSL_CC_Key] === mSL_CC_KeyCKod)) ? (
                // The func is supposed to have no locals and no parameters
                ((k[mSL_CC_ParCnt] === 0) && (k[mSL_CC_LocCnt] === 0)) ? (
                    // this is a correct func - load it in a new thread
                    ent = getNewThread();
                    //sprintf(#ms, "** ent ** => %d/%d", ent, KRun_mSL_Thread);
                    // mSL_log(SysLogBox, #ms);
                    ent ? (
                        SchedPar1[ent] = k; // keep the code to execute
                        SchedPar4[ent] = 0; // use std locals
                        SchedCode[ent] = KRun_mSL_Thread; // ready to start
                        mSL_init_thread(ent);
                        SchedInsertTail(SchedSuspPts, ent, SchETypeThrd);
                        res = ent[SchedPid]; // return the process ID
                    );
                ) : (
                    res = -4001;
                );
            ) : (
                res = -4000;
            );
        ) :
        (kw === mSL_KW_run) ? (
            // k = argv[1]; // the thread id contains the entry number
            // ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz; // points to "a" thread
            ((argc > 1) && (k = argv[1])
                && (ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz)
                && (k === ent[SchedPid])
            ) ? (
                // this is a correct reference
                // ent is supposed to be in SchedSuspPts !
                SchedUnchainEnt(SchedSuspPts, ent, SchETypeThrd);
                SchedStatus[ent] |= SchThrUsed;  // now in use
                // introduce in the active list
                SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
                (FlagsTbVals[Flgs_Thrds] & 4) ? ( // trace flags
                    sprintf(#ms, "** RUN ** [%g:%g] => %d/%d", ent, SchedThrdPt[ent], (floor(k/SchedNEmax)), (k & SchedNMask));
                    mSL_log(SysLogBox, #ms);
                );
                res = k; // done
            );
        ) :
        (kw === mSL_KW_idt) ? (
            ent = mSL_active_Thread[mSL_THR_SchedEnt];
            ((ent >= SchedFirstEnt) && (ent <= SchedLastEnt)) ? (
                res = ent[SchedPid]; // return the process ID
            );
        ) :
        (kw === mSL_KW_name) ? (
            ent = mSL_active_Thread[mSL_THR_SchedEnt];
            ((ent >= SchedFirstEnt) && (ent <= SchedLastEnt)) ? (
                res = ent[SchedThrName]; // return the process name
                (argc > 1) ? (
                    // use 2nd word as name
                    ent[SchedThrName] = argv[1];
                    (FlagsTbVals[Flgs_Thrds] & 4) ? (
                        sprintf(#ms, "  --> Name : %s", mSL_edit_value(0, ent[SchedThrName]));
                        mSL_log(SysLogBox, #ms);
                    );
                );
            );
        ) :
        (kw === mSL_KW_status) ? (
            k = argv[1]; // should be in SchedSuspPts !
            res = 0; // undefined
            ent = SchedFirstEnt + (k & SchedNMask) * SchedEntSiz; // points to "a" thread
            ((k === ent[SchedPid]) && (argc > 1)) ? (
                res = SchedStatus[ent]; // done
            );
        ) :
        (kw === mSL_KW_find) ? (
            p1 = p2 = p3 = 0;
            (argc === 2) ? (
                p1 = argv[1]; p2 = 0; p3 = 2;
            ) :
            (argc === 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = 2;
            ) :
            (argc >= 3) ? (
                p1 = argv[1]; p2 = argv[2]; p3 = argv[2];
            );
            res = event_check_recipient(p1, p2, p3);
        ) :
        (kw === mSL_KW_count) ? (
            (argc === 2) ? (
                kw = argv[1]; ent = SchedFirstEnt; res = 0;
                loop (SchedNEmax,
                    (SchedThrName[ent] === kw) && (SchedStatus[ent] != 0) ? res += 1;
                    ent += SchedEntSiz;
                );
            );
        ) :
        (
            res = -4007;
        );
    );
    res;
);


// Insert here the mSL interpreter
<? include("GM-Libs/mSL_Evaluator.jsfx-inc"); ?>


TabAddrMax = mSL_StM_FreePt; // max. address recognized for an array

mm_highblocks = SharedHighMemory = make_array(2); // last use of the function  no block with memory references beyond that


UBuffer = mSL_StM_BlockStart('buff'); // DO NOT use make_array() after that !
M_avail = UTmem - UBuffer; // need to add up to CCCC * 2 * x zero-valued samples

current_Memory_Mode = mSL_MMd_Dynamic;  // change allocation mode


// Update a big number passed as parameter
// with "key" being the "command"
function updtBNumber(num, key, alt)
local (cq, cx, flu, flk, kuz, zplm)
(
    zplm = num;
    flu = 0; kuz = 1; cq = 1; flk = key > 0;
    key < 0 ? key = -key;
    ((key >= '0') && (key <= '9')) ? (
        num = num * 10 + key - '0';
    ) :
    ((key === '%')||(key === 'z')) ? (
        num = 0;
    ) :
    ((key === '+')||(key === '=')) ? (
        num = num + 8;
    ) :
    ((key === ':')||(key === '/')) ? (
        num = num - 8;
    ) :
    ((key === ';')||(key === '.')) ? (
        num = num + 1;
    ) :
    ((key === ',')||(key === '?')) ? (
        num = num - 1; cq = -1; flu = 1;
    ) :
    ((key === '$')) ? (
        num = alt;
    ) :
    ((key === 0)||(key === 1)) ? (
        flu = 1; // just "normalize" the value
        cq = (key === 0) ? 1 : -1;
    ) :
    (ui_jmouse_cap === 0) ? (
        ((key === 'n')||(key === 'p')||(key === 'b')||(key === 'rght')||(key === 'left')) ? (
            cq = ((key === 'n')||(key === 'rght')) ? 1 : -1;
            num = num + cq;
        ) :
        ((key === 'down')) ? (
            num = num + 32;
        ) :
        ((key === 'up')) ? (
            num = max(0, num - 32);
        ) :
        ((key === 'pgdn')) ? (
            num = num + 256;
        ) :
        ((key === 'pgup')) ? (
            num = max(0, num - 256);
        ) :
        ((key === 'home')) ? (
            num = 0;
        ) :
        (
            kuz = 0; // key has not been used
        );
    ) : (
        kuz = 0; // key has not been used
    );



    num;
);



// Mock-up function
function keepBlockInfos(b) ( 0; );
gui_show_syslog = 1;
gui_show_memory = 0;
SysLogBox[5] = 4;
SysLogBox[6] = 0;

//
GMW2("Init MAIN");


// (re)Build the space Algo
function
mkSPAlgo()
local(Err, outmd, param)
(
    sactRMClass(spaceAlgo); // remove previous space algos if any
    param = 0;
    (SPAlgo<6)?((SPAlgo<2)?((SPAlgo<0)?(
        //===-1===//
        Err=-1;
        //===-1===//
    ):((SPAlgo<1)?(
        //===0===//
        outmd = mkFixAlgo(); // fixed HP location
        mkFixAlgoInit();
        //===0===//
    ):(
        //===1===//
        outmd = mkFixAlgo(); // fixed HP location
        mkFixAlgoInit();
        //===1===//
    ););):((SPAlgo<4)?((SPAlgo<3)?(
        //===2===//
        outmd = mkTransVec();
        param = xxalg;
        mkTransVectInit(); //
        //===2===//
    ):(
        //===3===//
        outmd = mkStdPan(); //
        param = xxalg;
        mkStdPanInit();
        //===3===//
    );):((SPAlgo<5)?(
        //===4===//
        outmd = mkDbSlider(); // build
        mkDbSliderInit(); // and init
        //===4===//
    ):(
        //===5===//
        Err=5;
        //===5===//
    );););):((SPAlgo<10)?((SPAlgo<8)?((SPAlgo<7)?(
        //===6===//
        Err=6;
        //===6===//
    ):(
        //===7===//
        Err=7;
        //===7===//
    );):((SPAlgo<9)?(
        //===8===//
        Err=8;
        //===8===//
    ):(
        //===9===//
        Err=9;
        //===9===//
    ););):((SPAlgo<12)?((SPAlgo<11)?(
        //===10===//
        Err=10;
        //===10===//
    ):(
        //===11===//
        Err=11;
        //===11===//
    );):((SPAlgo<13)?(
        //===12===//
        Err=12;
        //===12===//
    ):(
        //===13===//
        Err=13;
        //===13===//
    ););););

    (outmd === 0) ? (
        outmd = mkFixAlgo(); // fixed HP location as default value
        mkFixAlgoInit();
    );
    sactAdd(outmd, param); // output mode
);


/*
=== PLAYER ACTIONS ===
*/
function
evalActions(actl)
local (pt, Act, Cmd, p0, p1, p2, p3, p4, Err, i, j, addr)
(
    pt = 0;
    while (pt < actlSiz) (
        Act = actl[pt]; actl[pt] = 0; pt += 1;
        (Act != 0) ? (
            0 ? (
            sprintf(#w, "  * Action executed from %d, [%d %f %f %f]", Act, gmem[Act], gmem[Act+1], gmem[Act+2], gmem[Act+3]);
            mSL_log(SysLogBox, #w);
            );

            Cmd = gmem[Act] & 0xfff; p0 = gmem[Act] >> 12; p1 = gmem[Act+1]; p2 = gmem[Act+2];



            (Cmd<13)?((Cmd<6)?((Cmd<3)?((Cmd<1)?(
                //===0===//
                Err=0; // ineffective action
                //===0===//
            ):((Cmd<2)?(
                //===1===//
                // Modify inc. variations
                (p1 != Undef) ? TM_delta_inc = p1;
                (p2 != Undef) ? TM_delta_dec = p2;
                //===1===//
            ):(
                //===2===//
                // Modify xxrep factor
                xxrep = max(1, min(hpfold, 0|p1));
                //===2===//
            ););):((Cmd<4)?(
                //===3===//
                // Reset globals
                resetGlobals();
                //===3===//
            ):((Cmd<5)?(
                //===4===//
                CmDval[0] = max(0, min(1, p1)); // Left coef.
                CmDval[1] = max(0, min(1, p2)); // Right coef.
                p3 = gmem[Act+3];
                (p3 != USep) ? (
                    (p3 != Undef) ? xxrep = max(1, min(hpfold, 0|p3));
                    p4 = gmem[Act+4];
                    (p4 != USep) ? (
                        (p4 != Undef) ? xxalg = 0|p4;
                    );
                );
                //===4===//
            ):(
                //===5===//
                // release hold mode
                playHold = 0;
                //===5===//
            );););):((Cmd<9)?((Cmd<7)?(
                //===6===//
                // Change / Rebuild space Algo
                ((p1 != Undef) && (p1 != USep)) ?  SPAlgo = p1;
                mkSPAlgo();
                //===6===//
            ):((Cmd<8)?(
                //===7===//
                // Set repeat on
                gmem[UAdd+RCB_Cl_Flgs] |= pmFlagRepeat;
                //===7===//
            ):(
                //===8===//
                // Set repeat off
                gmem[UAdd+RCB_Cl_Flgs] &= -1 ~ pmFlagRepeat;
                //===8===//
            ););):((Cmd<11)?((Cmd<10)?(
                //===9===//
                // Change the size of generated tupples
                gmem[UAdd+RCB_GenCnt] = chGenCnt = max(1, min(127, 0|p1));
                //===9===//
            ):(
                //===10===//
                // Change "pan. update source"
                ((p1 === 0) || ((p1 >= p_XPar0) && (p1 <= p_XPar3))) ? (
                    xxupdf = p1;
                );
                //===10===//
            );):((Cmd<12)?(
                //===11===//
                // Disconnect gmem[UAdd+RCB_Pan_Src] from its source and set its value
                FP_L &= 0x7FFFFFFF ~ smUFlagXPan;
                ((p1 != Undef) && (p1 != USep)) ?  (
                    gmem[UAdd+RCB_Pan_Src] = p1; // min(1, max(0, p1));
                    ((p2 != Undef) && (p2 != USep)) ?  gmem[UAdd+RCB_Pan] = p2; // min(1, max(0, p2));
                );
                //===11===//
            ):(
                //===12===//
                // Change HPSet 1
                HPCnt1 = 0; i=1;
                while ((gmem[Act+i] != USep) && (HPCnt1<75)) (
                    Chans1[HPCnt1] = gmem[Act+i] - 1;
                    HPCnt1 += 1; i += 1;
                );
                //===12===//
            ););););):((Cmd<19)?((Cmd<16)?((Cmd<14)?(
                //===13===//
                // Change HPSet 2
                HPCnt2 = 0; i=1;
                while ((gmem[Act+i] != USep) && (HPCnt2<75)) (
                    Chans2[HPCnt2] = gmem[Act+i] - 1;
                    HPCnt2 += 1; i += 1;
                );
                //===13===//
            ):((Cmd<15)?(
                //===14===//
                // Set "xxalg"
                xxalg = 0|p1;
                //===14===//
            ):(
                //===15===//
                // Vary some memory value A=p1 from current to "x=p2", in "y=p3" seconds,
                // by step "z=p4", multiply by "p5" and add "p6"
                p3 = gmem[Act+3]; p4 = gmem[Act+4]; p5 = gmem[Act+5]; p6 = gmem[Act+6];
                ((p3 != Undef) && (p3 != USep)) ? (
                    p3 = max(0.001, min(300, p3));
                    ((p4 != Undef) && (p4 != USep)) ? (
                        p4 = max(0.0000001, min(10000, p4));
                        ((p5 != Undef) && (p5 != USep)) ? (
                            p5 = max(0.80, min(1.5, p5)); // factor
                            ((p6 != Undef) && (p6 != USep)) ? (
                                p6 = max(-0.1, min(1.5, p6)); // addition
                            ) : (
                                p6 = 0.0; // default additive fator
                            );
                        ) : (
                            p5 = 1.0; // default multiplicative factor
                        );
                    ) : (
                        p4 = 0.0001; // default step
                    );
                ) : (
                    p3 = 1; // default: 1 second
                );
                // Look for an entry
                addr = 0;
                flagAct8 = 16;
                i = 0;
                while ((addr === 0) && (i < ActBsize)) (
                    (ActBls[i] === 0) ? (
                        addr = ActBls + i;
                        ((p1 > 0) && (p1 < UCBSize)) ? (
                            p1 = - (UAdd + p1); // an address in the UCB
                        );
                        // Now, an address in gmem
                        addr[0] = p1; // Address in mem/gmem - expected correct
                        addr[1] = p2; // value to reach
                        addr[2] = p4; // asked increment
                        // number of steps
                        iu = (p1 >= 0) ? p1[0] : gmem[-p1]; // initial value
                        addr[3] = max(1, 0 | (p3*srate/max(1,abs(iu-p2)/p4))); // sample count
                        addr[4] = p5; // facteur
                        addr[5] = p6; // add. value
                        // Enter the new event
                        smplNewEV(0, 8, addr, 0);
                    );
                    i += ActEnt;
                );
                //
                sprintf(#act_mss, "Vary : %d [ %d : %0.4f -> %0.4f / %0.4f %0.4f => %d]",
                addr, addr[0], iu, addr[1], addr[2], p3, addr[3]);
                mSL_log(SysLogBox, #act_mss);
                //===15===//
            ););):((Cmd<17)?(
                //===16===//
                Err=16;
                //===16===//
            ):((Cmd<18)?(
                //===17===//
                Err=17;
                //===17===//
            ):(
                //===18===//
                Err=18;
                //===18===//
            );););):((Cmd<22)?((Cmd<20)?(
                //===19===//
                Err=19;
                //===19===//
            ):((Cmd<21)?(
                //===20===//
                Err=20;
                //===20===//
            ):(
                //===21===//
                Err=21;
                //===21===//
            ););):((Cmd<24)?((Cmd<23)?(
                //===22===//
                Err=22;
                //===22===//
            ):(
                //===23===//
                Err=23;
                //===23===//
            );):((Cmd<25)?(
                //===24===//
                Err=24;
                //===24===//
            ):(
                //===25===//
                Err=25;
                //===25===//
            );););););


        );

    );
);



smplNewEV(currSmpl + 1 * currSrate, 2, 0, 0); // unactivate all in 1 seconds
mSL_log(SysLogBox, "*** File Player initialized ***");

















@block

XATP00_St = time_precise() + gmem[timeDelta];
tUnix = time();

/*
// Check first words of memory, to detect eventual bugs
((!GMW()) && (XDcount > 0)) ? (
    sprintf(#s2, "BBB//File Player Damaged! %s %s %s %s %s %s %s %s", mSL_edit_value(#, 0[0]), mSL_edit_value(#, 0[1]),
                mSL_edit_value(#, 0[2]), mSL_edit_value(#, 0[3]), mSL_edit_value(#, 0[4]), mSL_edit_value(#, 0[5]),
                mSL_edit_value(#, 0[6]), mSL_edit_value(#, 0[7]));
    mSL_log(SysLogBox, #s2);
    GMI();
    XDcount -= 1;
);
*/






(NState = gmem[UAdd+RCB_State_Changed]) ? (
    gmem[UAdd+RCB_State_Changed] = 0;
    ANState = NState;

    // analyse the state change

    // Volume updated ?
    (NState & i_M_Vol) ? (
        ((kb = gmem[UAdd+RCB_Cl_Flgs] & 2) != volUpdt) ? (
            volUpdt = kb;
            (kb) ? (
                // mode "mute"
                VolumeMod0_u = 0;
            ) : (
                VolumeMod0_u = 1;
            );
        );

        // Vol. adj. modified ?
        (gmem[UAdd+RCB_VolumeMod1_u] != PrevVolumeMod1_u) ? (
            PrevVolumeMod1_u = gmem[UAdd+RCB_VolumeMod1_u];
            VolumeMod1_u = 10 ^ (PrevVolumeMod1_u/20);
        );

        //PF_Coeff = gmem[UAdd+RCB_VolBias];
        PF_Coeff = gmem[gVolBias];
        //PF_CoeffK = 1 - PF_Coeff;
        //PF_Coeff2 = PF_Coeff * PF_CoeffX;
        //PF_CoeffK2 = 1 - PF_Coeff2;

        smUpdateFlag |= smUFlagVol;
    );


    (smUpdateFlag & smUFlagVol) ? (
        // Maybe min/max is overkill in some cases...
        FP_GlobSet = max(0, min(4, VolumeMod0_u * VolumeMod1_u * FP_GlobVAdj * (10 ^ (FP_Dyn_Vol/20)) * gmem[UAdd+RCB_StdVol] * gmem[commonGlobalVolume]));
    );

    /*
    (NState & i_M_Siz) ? (
        (CLStartPC != gmem [UAdd+RCB_ClStart]) ? (
            CLStartPC = gmem [UAdd+RCB_ClStart];
        );
        (CLEndPC != gmem [UAdd+RCB_ClEnd]) ? (
            CLEndPC = gmem [UAdd+RCB_ClEnd];
        );
        CLStartPC > CLEndPC ? (
            v = CLStartPC; CLStartPC = CLEndPC; CLEndPC = v;
            gmem [UAdd+RCB_ClStart] = CLStartPC;
            gmem [UAdd+RCB_ClEnd] = CLEndPC;
        );
        clOffset = CLStartPC * CTSize / 100 ;
        ClLowLimit = RZcnt + clOffset;  // for play
        GrStLLimit = ClLowLimit; // Grains low limit for loop
        ClHighLimit = RZcnt + CLEndPC * CTSize / 100 ;
        GrStHLimit = ClHighLimit; // Grains high limit

        (Pmode == ActPlaying) ? (
            (clRSpeed > 0) ? (
                ClLowArea = ClLowLimit + FInTpl;
                ClHighArea = ClHighLimit - FOutTpl;
            ) : (
                ClLowArea = ClLowLimit + FOutTpl;
                ClHighArea = ClHighLimit - FInTpl;
            );
        );


    );
    */

    (NState & i_M_Siz) ? (
        sprintf(#dbg_trace6, "Nstate change: 'i_M_Siz'");
    );

    /*
    (NState & i_M_Spd) ? (
        manageSpeed();
    );
    */

    (NState & i_M_Spd) ? (
        sprintf(#dbg_trace5, "Nstate change: 'i_M_Spd'");
    );

    /*
    (NState & i_M_HPc) ? (
        HPCnt1 = gmem [UAdd+RCB_Channels_cnt_used1];
        GrXpect = gmem [UAdd+RCB_GrXpect];
    );
    */
    (NState & i_M_HPc) ? (
        sprintf(#dbg_trace4, "Nstate change: 'i_M_HPc'");
    );


    (NState & i_M_Rst) ? (
        0 ? sprintf(#dbg_trace3, "Nstate change: 'i_M_Rst'  %d  %d  %d", ActivePlaying, KmdKurrent, gmem[UAdd+RCB_cbCKmd]);
        (!ActivePlaying) ? (
            // try to restart current playing
            KmdKurrent = gmem[UAdd+RCB_cbCKmd];
            ((KmdKurrent == KmdPlay) || (KmdKurrent == KmdLoop)) ? (
                Pmode = CurrentDoing = (KmdKurrent == KmdPlay) ? ActPlaying : ActLooping;
                // we can restart something
                (KmdKurrent == KmdPlay) ? GState = GSKStartPlay :
                (KmdKurrent == KmdLoop) ? GState = GSKStartLoop : GState = GSStFinal;
                fileReading = 1;
            );
        ) : (
            // playing is active. Just do some analysis of modified pars
            checkRCB();
        );
    );

    (NState & i_M_Upd) ? (
        editDelay = NState & 0xf;
        ((gmem[UAdd+cbStat] === uSReady) && (editDelay > 0)) ? (
            gmem[UAdd+cbStat] = editDelay <= 2 ? uSSaving : uSEditing;
            Pmode = ActEdit;
        );
        initDynPars(); // update
        update_dynpars(); //
        (NState & i_M_Rcd) ? (
            // update recorded version
            saveEntry(); // save entry in playlog
        );
    );
);



// every second or so...
(second != gmem[timeSecOfDay]) ? (
    // EVERY SECOND
    second = gmem[timeSecOfDay];
    strcpy(#nowtim, edTime(tUnix - tStart));
    currColState = max(0, currColState - currColVar);
    gmem[UAdd+RCB_Color] = currColor[currColState];

    (lastMn != gmem[timeMinute]) ? (
        // Edit time every minute
        lastMn = gmem[timeMinute];
    );

    currSrate = max(1, srate);
    currRdSize = maxRdSize = currSrate * 2 * 96; // read 96" stereo at a time
    frstRdsize  = currRdSize;

    // Manage process counting every second
    mSL_act = count_p_list(SchedActivPts) + (mSL_active_Thread > 0);
    mSL_wait = count_p_list(SchedDlydPts) + count_p_list(SchedEvntPts);
    mSL_plck = count_p_list(SchedSuspPts) + count_p_list(SchedLockdPts);
    mSL_pmsg = count_p_list(SchedRcyclPts);
    mSL_inactv = SchedListSize(SchedFreePts);
    mSL_maxact = max(mSL_maxact, mSL_act);

    ((mSL_Lock != 0) && (mSL_loc_tim <= 0) && (SchedLockAll === 0)) ? (
        mSL_Lock < 0 ? mSL_Lock = - mSL_Lock;
        atomic_add(mSL_loc_tim, 20); // "gfx" ticks, so about 2"
        atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
    );

    mSL_malloc_failed ? (
        atomic_add(mSL_Lock,1);
        atomic_add(mSL_loc_tim, 10);
        // run a GC
        gc_run_phaz = 1;
        mSL_malloc_failed = 0; // unset flag
    );

    (Schedrestart1 && (SchedLockAll === 0)) ? (
        (SchedListNonEmpty(SchedEvntPts)) ? (
            xgent = SchedDetachHead(SchedEvntPts);
            SchedInsertTail(SchedLockdPts, xgent, SchETypeThrd);
            //mSL_log(SysLogBox, "SchedEvntPts  ——> SchedLockdPts");
        ) :
        (SchedListNonEmpty(SchedSuspPts)) ? (
            xgent = SchedDetachHead(SchedSuspPts);
            SchedInsertTail(SchedLockdPts, xgent, SchETypeThrd);
            //mSL_log(SysLogBox, "SchedSuspPts  ——> SchedLockdPts");
        ) ;
        Schedrestart1 = 0;
    );

    (uuuMslFn != 0) ? (
        atomic_set(mSL_Lock, max(1,atomic_get(mSL_Lock)));
    );

    (gmem[UAdd+cbStat] === uSReady) ? resetGlobals();

    sysSampBeat = 60 / sysTempo;
    // just recompute synchSmpls in case srate changed...
    // manageSynchro();
    // (!sysPlayState) ? synchroPos = sysSampPosition;

    // every tick : check our Unit number
    (ticker != gmem[timeTick]) ? (
        ticker = gmem[timeTick];
        smUpdateFlagCP = 0;
        gmem[versionFReader] = FilePlayerVersion;
        CheckNum = gmem[ticksCount];
        (editDelay > 0) ? (
            editDelay = max(0, editDelay - 1);
            (editDelay === 0) ? (
                // Save in play log modified values
                saveEntry(); // save entry in playlog
            );
        );

        // check our Unit number
        checkUnit();
        //xPeriod = 1 + (0|((currSrate / samplesblock) * frand(0.10, 0.30)));
        //dXPeriod = xPeriod * samplesblock / currSrate;
        // choose a specific tempo for updating
        xDecrement = 10 * samplesblock / currSrate;
        xIncrement = 10 / frand(2.10, 3.30);

        gmem[UAdd+RCB_My_Track] = GMFXTrack = 1+get_host_placement(GMFXPos, GMFXFlags);
        gmem[UAdd+RCB_My_Pos] = GMFXPos;
        ui_GFXdoNow |= 1;

        pcbZ12 = 120;

        gmem[chnCount] = num_ch; // number of channels in the track

        // Find an appropriate value for maxRdSize
        frstRdsize = 24000 * (max(128, samplesblock) >> 7);
        maxRdSize = frstRdsize * 4;

        // Evaluate the ratio readsteps / clip
        AAA_clipReadRatio =  max(1, AAA_clipSteps) / max(1, AAA_clipRead);
        PlayMono =  floor(10 * M_avail / currSrate )/10;

        gmem[UAdd+cbPlavail] = PlayMono;  // duration available for mono clips
        gmem[UAdd+cbMemory] = M_avail;  // Memory available

        update_dynpars();

        // Update error display
        (err_sys === 0) ? (
            err_sys_ini ? (err_sys = err_sys_ini; err_sys_ini=0;)
          : mSL_StM_Err ? (err_sys = mSL_StM_Err; mSL_StM_Err=0;)
          : err_sys_rtm ? (err_sys = err_sys_rtm; err_sys_rtm=0;)
          : err_sys_gfx ? (err_sys = err_sys_gfx; err_sys_gfx=0;)
          : err_fclp ? (err_sys = err_fclp; err_fclp=0;)
          : err_fplm ? (err_sys = err_fplm; err_fplm =0;)
          : err_fhpc ? (err_sys = err_fhpc; err_fhpc=0;)
          : err_fspm ? (err_sys = err_fspm; err_fspm=0;)
          : err_fbnk ? (err_sys = err_fbnk; err_fbnk=0;)
          : err_sdfr ? (err_sys = err_sdfr; err_sdfr=0;)
          ;
      );

      // Signal delayed
      GMIfsig ? ( GMW2("TRC"); GMIfsig = 0; );
      ((!GMW()) && (XDcount > 0) && (GMIfsig == 0)) ? (
        GMIfsig = 1;
      );

    );


    (gmem[ModulAlgo] != 0) ? (
        (Pmode == ActPlaying) ? (
            Pmode = CurrentDoing = ActPlaying2;
        );
    ) : (
        (Pmode == ActPlaying2) ? (
            Pmode = CurrentDoing = ActPlaying;
        );
    );

    gmem[ModulAlgoPl] = gmem[ModulAlgo];
    PF_Coeff = gmem[gVolBias];
    PF_Const = max(0.000001, PF_Coeff * 0.1);

    (Pmode & inPlay) ? (
        gmem[ModPl] = Pmode;
    );


    (RState) ? (
        // Long files reading management
        // check a few things
        (RState === 2) ? (
            // Are we ready to read block B2 ?
            ClHighLimit = ClTplLast;
            (ClRIndex > UBl1) ? (
                (TRC & 0x100) ? (
                    sprintf(#gfs_mssb, "* %s * [%d] Index / UBl1 :  %d > %d", #nowtim, RState, ClRIndex, UBl1);
                    mSL_log(SysLogBox, #gfs_mssb);
                );
                RState = 3;
                GState = GSStReadBlck;
                fileReading = 1;
            );
        ) :
        (RState === 4) ? (
            // Are we ready to read block B3 ?
            (ClRIndex > UBl2) ? (
                (TRC & 0x100) ? (
                    sprintf(#gfs_mssb, "* %s * [%d] Index / UBl2 :  %d > %d", #nowtim, RState, ClRIndex, UBl2);
                    mSL_log(SysLogBox, #gfs_mssb);
                );
                RState = 5;
                GState = GSStReadBlck;
                fileReading = 1;
            );
        ) :
        (RState === 6) ? (
            (ClRIndex > UBl3) ? (
                // we have to move the read index back
                (TRC & 0x100) ? (
                    sprintf(#gfs_mssb, "* %s * [%d] Index / UBl3 :  %d > %d", #nowtim, RState, ClRIndex, UBl3);
                    mSL_log(SysLogBox, #gfs_mssb);
                );
                ClRIndex -= 2 * UBl;
                RState = 2;
            );
        ) :
        (RState === 7) ? (
            // we have to move the read index forward
            (TRC & 0x100) ? (
                sprintf(#gfs_mssb, "* %s * [%d] Index / UBl2 :  %d < %d", #nowtim, RState, ClRIndex, UBl2);
                mSL_log(SysLogBox, #gfs_mssb);
            );
            ClRIndex += UBl;
            RState = 9;
            GState = GSStReadBlck;
            fileReading = 1;
        ) :
        (RState === 8) ? (
            // last block read
            FOutTpl = 0|(FOutDur * SpdFactAdj / 1000);
            ClHighArea = ClHighLimit - FOutTpl;
            // Start fade out at that moment
            SmpFOStrt = 0|(currSmpl + (ClHighArea - ClRIndex)/ClRIndInc);
            (TRC & 0x100) ? (
                sprintf(#gfs_mssb, "* %s * [%d] Index & Fade :  %d / %d", #nowtim, RState, ClRIndex, ClHighArea);
                mSL_log(SysLogBox, #gfs_mssb);
            );
            smplNewEV(SmpFOStrt, 3, 0, 0); // run event 3 at that date
            RState = 10; // prepare to stop
        ) :
        (RState === 10) ? (
            (ActivePlaying === 0) ? (
                (TRC & 0x100) ? (
                    sprintf(#gfs_mssb, "* %s * [%d] Play end :  %d / %d", #nowtim, RState, ClRIndex, ClHighArea);
                    mSL_log(SysLogBox, #gfs_mssb);
                );
                RState = 0;
            );
            (FLgHandle >= 0) ? (
                file_close(FLgHandle); FLgHandle = -1;
            );
        );
    );
); // Every second "0"




// Happens a few times every second, but shifted in time
/*
=== Update Time ===
*/
(xCount <= 0) ? (
    xCount += xIncrement;


    TRC = gmem[playerFLGS]; // get player trace from GM
    (TRC & 0x100000) ? (
        // Try to unlock the player
        pvolEv = 0; ActivePlaying = 0; pflg = 0; evLState = 0; Pmode = mdInactive; currColVar = 1;
    );


    (dirChangeNum != gmem[dirChange]) ? (
        // we have changed the clip directory
        dirChangeNum = gmem[dirChange]; // update our number
        getexpldstr(0,0);
        strcpy(#clNameFormat, #sct);
    );


    ActivePlaying ? (
        reapeatx = (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) != 0;
        (reapeatx != reapeat) ? (
            reapeat = reapeatx;
            (KmdKurrent == KmdPlay) ? (
                (reapeat === 0) ? (
                    (RState === 0) ? (
                        // switching to "stop" in a moment
                        SmpPStart = currSmpl;
                        xdur = 0.5 * min(clDur, CTSize / SpdFact);
                        SmpFOStrt = 0|(SmpPStart + (xdur - FOutDur/1000) * currSrate); // as sample
                        smplNewEV(SmpFOStrt, 3, 0, 0);
                        (TRC & 2) ? (
                            sprintf(#gfb_mss, "* %s * Stop playing  {%.0f ~ %.0f} in %.3fs", #nowtim,
                                    SmpPStart, SmpFOStrt, (SmpFOStrt - SmpPStart)/currSrate);
                                    mSL_log(SysLogBox, #gfb_mss);
                        );
                    );
                ) : (
                    // switching to continuous play
                    pvolInc = 1000 / currSrate;
                    evLState = 1; // make sure we will reach plain volume
                    // remove all operations
                    smplClear();
                    (TRC & 2) ? (
                        sprintf(#gfb_mss, "* %s * Continuous playing start", #nowtim);
                        mSL_log(SysLogBox, #gfb_mss);
                    );
                );
            ) :
            (KmdKurrent == KmdLoop) ? (
                (reapeat === 0) ? (
                    // switching to "stop" in a moment
                    SmpPStart = currSmpl;
                    SmpFOStrt = 0|(SmpPStart + 4 + irand(min(20, clDur/2 - FOutDur/1000)) * currSrate); // as samples
                    smplNewEV(SmpFOStrt, 3, 0, 0); // will start decreasing in a moment
                    (TRC & 2) ? (
                        sprintf(#gfb_mss, "* %s * Stop looping  {%.0f ~ %.0f} in %.3fs", #nowtim,
                                SmpPStart, SmpFOStrt, (SmpFOStrt - SmpPStart)/currSrate);
                                mSL_log(SysLogBox, #gfb_mss);
                    );
                ) : (
                    // switching to continuous play
                    pvolInc = 1000 / currSrate;
                    evLState = 1; // make sure we are at plain volume
                    (TRC & 2) ? (
                        sprintf(#gfb_mss, "* %s * Continuous looping start", #nowtim);
                        mSL_log(SysLogBox, #gfb_mss);
                    );
                    smplRemovEvnt(3, Undef, 4); // remove stop
                );
            );
        );
    );



    // update our status
    (Pmode === mdInactive) ? (
        gmem[UAdd+cbStat] = uSReady;  // not playing
        // gmem[UAdd+cbCKmd] = 0; // clear command
        // gmem[UAdd+cbRS3] = second; // we were not playing at that time
        ActivePlaying = 0; // definitely
        KmdKurrent = 0; // forget last command
        doStop = 0;
        (Fhandle >= 0) ? (
            file_close(Fhandle);
            Fhandle = -1;
        );
        (FLgHandle >= 0) ? (
            file_close(FLgHandle);
            FLgHandle = -1;
        );
    );

    // Manage global volume updating
    FP_GlobSet = max(0, min(4, VolumeMod0_u * VolumeMod1_u * FP_GlobVAdj * (10 ^ (FP_Dyn_Vol/20)) * gmem[UAdd+RCB_StdVol] * gmem[commonGlobalVolume]));
    (FP_GlobVol != FP_GlobSet) ? (smUpdateFlag |= smUFlagVol;);
    gmem[UAdd+RCB_VolBias] = PF_Coeff = gmem[gVolBias];
    synchroSource = gmem[UAdd+RCB_Synchro_source];


    // Manage global width updating
    FP_GlobWSet = gmem[ModWidth];
    (FP_GlobWSet != FP_GlobWidth) ? (
        smUpdateFlag |= smUFlagWidth;
    );

    // Manage global speed

    syssrate = max(1,srate);
    sysTempo = tempo;
    sysPlayState = play_state;

    (editDelay > 0) ? (
        ((gmem[UAdd+cbStat] === uSReady) || (gmem[UAdd+cbStat] === uSSaving) || (gmem[UAdd+cbStat] === uSEditing)) ? (
            gmem[UAdd+cbStat] = editDelay <= 2 ? uSSaving : uSEditing;  // not playing
            Pmode = ActEdit;
        );
    ) : (
        ((gmem[UAdd+cbStat] === uSEditing) || (gmem[UAdd+cbStat] === uSSaving)) ? (
            // reset to available
            gmem[UAdd+cbStat] = uSReady;
            Pmode = mdInactive;
        );
    );
);// recurring tasks
xCount -= xDecrement;


sysPlayPosition = play_position;
sysBeatPosition = beat_position;
sysSampPosition = 0 | (u = 0.5 + sysPlayPosition * syssrate);
sysSampBeatPosition = 0 | (u * sysTempo / 60);
// currSmpl = sysSampPosition;



ActivePlaying ? (

    update_dynpars();

    // Manage HP Set usage
    ib = 0;
    loop (HPCnt1,
        gmem[HP_usage + Chans1[ib]] = 0;
        ib += 1;
    );

);//ActivePlaying



/*
    Some command received through the Unit Control Block ?
=== PLAYER KOMMANDS ===
*/
((KmdIn = gmem[UAdd+RCB_Kmd]) != 0) ? (

    gmem[UAdd+RCB_Kmd] = 0; // clean this one
    BState = GSStFinal; // default next state
    KmdLastIn = KmdIn;
    KmdLastDate = CheckNum;


    (KmdIn === KmdUnlock) ? (
        (gmem[UAdd+RCB_PlaySource] == gmem[UAdd+cbP08]) ? (
            gmem[UAdd+RCB_Cl_Flgs] &= -1 ~ pmFlagRepeat;
        );
    ) :


    // 1-  Getting the command
    ((KmdIn === KmdPlay) || (KmdIn === KmdLoop)) ? (
        FErrc = 0;
        PBFlgs = gmem[UAdd+RCB_PBFlgs];  // From partiel
        // we will be unavailable for a while
        KmdKurrent = KmdIn; // Keep the command Id
        flSaveAddr = gmem[UAdd+RCB_Rec_Entry];
        gmem[UAdd+RCB_cbCKmd] = KmdLast = KmdKurrent;
        gmem[UAdd+RCB_Random_seed] = Rndm_n; // keep current random seed
        gmem[UAdd+cbStat] = uSStarting;
        doStop = 0;
        ActivePlaying = 0; // not yet
        //guarddog = second + 60; // keep "busy" for some times, for now
        Pmode = CurrentDoing = (KmdKurrent == KmdPlay) ? ActPlaying : ActLooping; //
        gmem[UAdd+cbLKmd] = KmdKurrent;
        GState = GSKReadPhase1; // ready to skip to phase 1
        fileReading = 1;
        gfxlpcnt = gfxcycnt = 0;
    ) :


    ((KmdIn === KmdStop) || (KmdIn === KmdQStop) || (KmdIn === KmdSlowStop) || (KmdIn === KmdKStop)) ? (
        k = 1; // One second
        gmem[UAdd+cbStat] = uSHalting;
        // stop any playing
        ((KmdKurrent === KmdLoop) || (KmdKurrent === KmdPlay)) ? (
            gmem[UAdd+RCB_Cl_Flgs] &= -1 ~ pmFlagRepeat;
            // to stop in "N" seconds, do pvolDec = -1 / (N * currSrate)
            (KmdIn === KmdQStop) ? (
                pvolDec = - 1/(currSrate * (5 + irand(10)) / 100); // stop in about 100 ms
            ) :
            (KmdIn === KmdStop) ? (
                pvolDec = - 1/(currSrate * (k = 9 + irand(10))); // stop in about 15 s
            ) :
            (KmdIn === KmdSlowStop) ? (
                pvolDec = - 1/(currSrate * (k = 30 + irand(30))); // stop in about 18 s
            ) : (
                // use RCB_alt_par4 as base and RCB_alt_par5 as random
                k = max(0.01, min(120, gmem[UAdd+RCB_alt_par4] + irand(0|max(1,min(180,gmem[UAdd+RCB_alt_par5])))));
                pvolDec = - 1/(currSrate * k); // stop ...
            );
            doStop = 1;
            evLState = 2; // make sure we will decrement
        ) : (
            Pmode = mdInactive;
        );
        smplNewEV(currSmpl + k * currSrate, 2, 0, 0); // unactivate all in some second
        smplNewEV(currSmpl + k * currSrate, 3, 0, 0); // stop a.s.a.p. any loop
    ) :


    (KmdIn === KmdPlItem) ? (
        FErrc = 0;
        PBFlgs = gmem[UAdd+RCB_PBFlgs]; // From partiel
        flSaveKmd = KmdPlItem;
        flSaveAddr = gmem[UAdd+RCB_Rec_Entry];
        (plChckEnt(flSaveAddr)) ? (
            pp = flSaveAddr;
            ix = playLogHdrSize; loop(playLogCopySize, gmem[UAdd+ix] = gmem[pp+ix]; ix += 1); // do load
            Rndm_n = gmem[UAdd+RCB_Random_seed]; // Reset random seed
            KmdKurrent = gmem[UAdd+RCB_cbCKmd]; // Keep the command Id
            gmem[UAdd+cbStat] = uSStarting;
            doStop = 0;
            ActivePlaying = 0; // not yet
            //guarddog = second + 60; // keep "busy" for some times, for now
            Pmode = CurrentDoing =
                (KmdKurrent === KmdPlay) ? ActPlaying :
                (KmdKurrent === KmdLoop) ? ActLooping : ActUnknown; // ??
            gmem[UAdd+cbLKmd] = KmdKurrent;
            gmem[UAdd+RCB_Cl_Flgs] |= gmem[UAdd+cbClipLoop];
            gmem[UAdd+cbClipLoop] = 0;
            // All is saved, link in appropriates places
            gmem[UAdd+RCB_Rec_Last] = gmem[UAdd+RCB_Rec_Time] + gmem[UAdd+RCB_Rec_Duration];
            gmem[plTInfo+1] += 1;
            GState = GSKReadPhase1;
            fileReading = 1;
            gfxlpcnt = gfxcycnt = 0;
        );
        flSaveAddr = 0; // do not save again !
    ) :


    (KmdIn === KmdCClear) ? (
        AAA_failopen = 0;
        AAA_clipped = 0;
    ) :


    (KmdIn === KmdSpF1) ? (
        clRSpeed = -clRSpeed;
    ) :

    (
        0; // default do nothing
    );


);// Command received


// Alternate command ?
((KmdAlt = gmem[UAdd+RCB_KmdAlt]) != 0) ? (

    ((KmdAlt === KmdAct)) ? (
        0 ? (
            sprintf(#X, "Actions received  %d %d %d %d %d %d ...", gmem[UAdd+RCB_alt_par0],
            gmem[UAdd+RCB_alt_par1], gmem[UAdd+RCB_alt_par2], gmem[UAdd+RCB_alt_par3],
            gmem[UAdd+RCB_alt_par4], gmem[UAdd+RCB_alt_par5]);
            mSL_log(SysLogBox, #X);
        );
        // Enter action
        pq = UAdd + RCB_alt_par0;
        ptIm = 0; ptDl = 0;
        while ((ptIm < actlSiz) && (actlL3[ptIm] != 0)) (ptIm += 1;);
        while ((ptDl < actlSiz) && (actlIn[ptDl] != 0)) (ptDl += 1;);
        loop (alt_par_siz,
            ((l = gmem[pq]) != 0) ? (
                (l > 0) ? (
                    // Action immediate
                    actlL3[ptIm] = l; ptIm = (ptIm + 1) % actlSiz;
                    0 ? (sprintf(#X, " - Action immediate  %d  %d", l, gmem[l]); mSL_log(SysLogBox, #X););
                ) :
                (
                    // action delayed
                    actlIn[ptDl] = -l; ptDl = (ptDl + 1) % actlSiz;
                    0 ? (sprintf(#X, " - Action delayed  %d  %d", l, gmem[- l]); mSL_log(SysLogBox, #X););
                    actlflg |= 3;
                );
                gmem[pq] = 0;
            );
            pq += 1;
        );
        (ptIm != 0) ? evalActions(actlL3);
    );


    gmem[UAdd+RCB_KmdAlt] = 0; // clean this one

);// Command2 received

(xxupdf != 0) ? (
    xxint = gmem[paramGCopy+xxupdf]; // value in ms
);

(xxalg == 2) ? (
    // Update env. limit from xxint
    EnvInc = SinEnvLim / srate / max(0.00001, xxint/1000);
);
































@sample


// First get the actual current sample number
currSmpl = (floor(spl0 * T_fact)) + (floor(spl1 * T_fact)) * 16777216;
spl0 = spl1 = 0;



// ====== Samples related Events Handling ======
/*
=== SAMPLE EVENTS ===
*/
((smplNxtE <= currSmpl) && (smplXPtr >= 0)) ? (
    smplEvCnt += 1;
    evd = smplEvents[smplXPtr]; // event date
    op = smplEvents[smplXPtr+1];
    p0 = smplEvents[smplXPtr+2];
    p1 = smplEvents[smplXPtr+3];

    (TRC & 4) ? (
        sprintf(#gfs_mssT, "* %s * Event %d:%d / %.3fs [%.0f/%.0f/%.0f]", #nowtim, op, smplXPtr, (currSmpl - SmpPStart)/currSrate, currSmpl,
            smplNxtE, evd);
        mSL_log(SysLogBox, #gfs_mssT);
    );

    memset(smplEvents+smplXPtr, smplNeutre, smplEvSiz);
    (smplXPtr > 0) ? (smplXPtr -= smplEvSiz; );
    smplNxtE = smplEvents[smplXPtr];

    // Now, perform the action
    (op<6)?((op<3)?((op<1)?(



        //===0===//
        Err=0;
        //===0===//



    ):((op<2)?(



        //===1===//
        /*
        (TRC & 4) ? (
            sprintf(#gfs_mss, "* %s * Event 1 / %.3fs [%.0f] <-> %d", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        );
        */
        Evnt = 1;
        //===1===//



    ):(



        //===2===//
        /*
        (TRC & 4) ? (
            sprintf(#gfs_mss, "* %s * Event 2 / %.3fs [%.0f] <-> %d", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        );
        */
        // Make sure we stop
        pvolEv = 0; ActivePlaying = 0; pflg = 0; evLState = 0; Pmode = mdInactive; currColVar = 1;
        //===2===//



    ););):((op<4)?(



        //===3===//
        /*
        (TRC & 4) ? (
            sprintf(#gfs_mss, "* %s * Event 3 / %.3fs [%.0f] <-> %d", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        );
        */
        (TRC & 0x200) ? (
            sprintf(#gfs_mss, "* %s * Event 3 / %.3fs [-> stop", #nowtim, (currSmpl - SmpPStart)/currSrate);
            mSL_log(SysLogBox, #gfs_mss);
        );
        evLState = 2; // start decreasing volume before stop
        //===3===//



    ):((op<5)?(



        //===4===//
        /*
        (TRC & 4) ? (
            sprintf(#gfs_mss, "* %s * Event 4 / %.3fs [%.0f] <-> %d", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        );
        */
        Evnt = 4;
        //===4===//



    ):(



        //===5===//
        GCBL = GCBpts[p0]; // the buffer
        GCBL[gStatus] = 3;
        GCBL[cEvLvol] = max(0.00001, p1);
        GCBL[cEvLindx] = ModWSize;
        (TRC & 4) ? (
            sprintf(#gfs_mss, "* %s * Event 5 [%d %d %0.7f] %.3fs [%.0f] <-> %d", #nowtim, p0, GCBL, p1, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        // sprintf(#gfs_mss, "@ After Event 5");
        );
        //===5===//



    );););):((op<9)?((op<7)?(



        //===6===//
        // Time to start a new loop
        /*
        (TRC & 16) ? (
            // mSL_log(SysLogBox,"@ Before event 6");
            sprintf(#gfs_mss, "* %s * Event 6 / %.3fs [%.0f] <-> %d", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl, smplXPtr+4);
            mSL_log(SysLogBox, #gfs_mss);
        );
        */
        evLState |= 4; // start a new loop
        //===6===//



    ):((op<8)?(



        //===7===//
        // Long Play :: ready to read block 2.
        GState = GSStReadBlck;
        RState = p0;
        (TRC & 0x100) ? (
            sprintf(#gfs_mss, "* %s * Event 7 / %.3fs [-> %d %d", #nowtim, (currSmpl - SmpPStart)/currSrate, RState, p1);
            mSL_log(SysLogBox, #gfs_mss);
        );
        fileReading = 1; // reactivate gfx thread
        //===7===//



    ):(



        //===8===//
        // Vary a value A0 from current to A1, using increment A2 every A3 tupples
        Ac = p0; // Address of the control block - size 8
        adr = Ac[0];
        ((gu = (adr >= 0) ? adr[0] : gmem[-adr]) !== Ac[1]) ? (
            GVal = (gu > Ac[1]) ? max(Ac[1], gu - Ac[2]) : min(Ac[1], gu + Ac[2]); // new value
            (adr >= 0) ? (adr[0] = GVal) : (gmem[-adr] = GVal);
            // restart event
            smplNewEV(currSmpl + Ac[3], 8, Ac, 0);
            Ac[2] = Ac[2] * Ac[4] + Ac[5];
        ) : (
            // Work done
            Ac[0] = 0; // free the entry
        );
        (flagAct8 > 0) ? (
            sprintf(#act_mss, "8Vary : %d [%d/%d/%0.4f  %0.4f  %0.4f  %d] => %0.4f  %d %d %04d %0.4f",
                  Ac, adr, Ac[0], gu, Ac[1], Ac[2], Ac[3], GVal,
                  RCB_ClipNb, RCB_Pan_Src,
                   gmem[UAdd+RCB_ClipNb],gmem[UAdd+RCB_Pan_Src]);
            mSL_log(SysLogBox, #act_mss);
            flagAct8 -= 1;
        );
        /*
        Ac = p0;
        (gmem[UAdd+RCB_Pan_Src] !== Ac[1]) ? (
            (gmem[UAdd+RCB_Pan_Src] > Ac[1]) ? (
                gmem[UAdd+RCB_Pan_Src] = max(Ac[1], gmem[UAdd+RCB_Pan_Src] - Ac[2]);
            ) : (
                gmem[UAdd+RCB_Pan_Src] = min(Ac[1], gmem[UAdd+RCB_Pan_Src] + Ac[2]);
            );
            // restart event
            smplNewEV(currSmpl + Ac[3], 8, Ac, 0);
        ) : (
            Ac[0] = 0; // free the entry
        );
        (flagAct8 > 0) ? (
            sprintf(#act_mss, "8Vary : %d [%d/%d/%0.4f  %0.4f  %0.4f  %d] => %0.4f  %d %d %04d %0.4f",
                  Ac, adr, Ac[0], gu, Ac[1], Ac[2], Ac[3], GVal,
                  RCB_ClipNb, RCB_Pan_Src,
                   gmem[UAdd+RCB_ClipNb],gmem[UAdd+RCB_Pan_Src]);
            mSL_log(SysLogBox, #act_mss);
            flagAct8 -= 1;
        );
        */
        //===8===//



    ););):((op<11)?((op<10)?(
        //===9===//
        Err=9;
        //===9===//
    ):(
        //===10===//
        Err=10;
        //===10===//
    );):((op<12)?(
        //===11===//
        Err=11;
        //===11===//
    ):(
        //===12===//
        Err=12;
        //===12===//
    ););););

    smplNxtE = smplEvents[smplXPtr]; // in case smplXPtr has changed
);





smUpdateFlag ? (
    smUpdateFlagCP |= smUpdateFlag;
    (smUpdateFlag & smUFlagVol) ? (
        (FP_GlobVol >= FP_GlobSet) ? (
            // decreasing volume
            FP_GlobVol -= PF_Coeff * FP_GlobVol + PF_Const;
            ((FP_GlobVol <= FP_GlobSet)) ? (
                FP_GlobVol = FP_GlobSet;
                smUpdateFlag &= -1 ~ smUFlagVol;
            );
        ) : (
            // increasing volume
            FP_GlobVol += PF_Coeff * FP_GlobVol + PF_Const;
            ((FP_GlobSet <= FP_GlobVol)) ? (
                FP_GlobVol = FP_GlobSet;
                smUpdateFlag &= -1 ~ smUFlagVol;
            );
        );
    );
    (smUpdateFlag & smUFlagWidth) ? (
        (FP_GlobWSet >= FP_GlobWidth) ? (
            FP_GlobWidth = FP_GlobWidth * 1.000001 + 0.000001;
            (FP_GlobWidth >= FP_GlobWSet) ? (
                FP_GlobWidth = FP_GlobWSet;
                smUpdateFlag &= -1 ~ smUFlagWidth;
            );
        ) : (
            FP_GlobWidth = FP_GlobWidth * 0.999999 - 0.000001;
            (FP_GlobWidth <= FP_GlobWSet) ? (
                FP_GlobWidth = FP_GlobWSet;
                smUpdateFlag &= -1 ~ smUFlagWidth;
            );
        );
        gmem[ModWidthL] = FP_GlobWidth;
    );
);




/*
=== TUPPLE CALCULATION ===
*/
ActivePlaying ? (
    // we are playing, and not waiting


    xPtr = 0;

    while ((opr = sactActs[xPtr]) > 0) (
        par = sactActs[xPtr+1]; xPtr += 2;
        opr = opr & 0xff; // get actual operation
        // sactACnt += 1;



        (opr<9)?((opr<4)?((opr<2)?((opr<1)?(

            //===0===//
            Err=0;
            //===0===//

        ):(



            //===1===//
            Err=0;
            /*
            //  === Std Play ===
            pflg = 1;
            TPLG = tuplesA;
            pvol = FP_GlobVol;
            ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
                // are we finished ?
                ((ClRIndex <  GrStLLimit) || (ClRIndex > GrStHLimit)) ? (
                    // no more samples to generate - return all zeros tupples
                    TPLG = tuplesZ;
                    (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) ? (
                        // loop
                        pflg = 1;
                        ClRIndex = gmem [UAdd+RCB_StartIndex];
                        Pmode = ActPlaying; // ready to resync
                    ) : (
                        pflg = 0;
                    );
                ) : (
                    // compute an appropriate fade volume
                    d = (ClRIndex < ClLowArea) ? (
                            (ClRIndex - GrStLLimit) / (ClLowArea - GrStLLimit)
                        ) : (
                            (GrStHLimit - ClRIndex) / (GrStHLimit - ClHighArea)
                        );
                    pvol *= min(1,d*d); // use a quadratic coeff.
                );
            );
            (pflg) ? (
                (pvol == 0) ? (
                    TPLG = tuplesZ;
                ) : (
                    // do actual interpolation
                    index = floor(ClRIndex);
                    delta = ClRIndex - index;
                    // Convert to samples
                    index *= CCCC;
                    ((delta < 0.0001) || (delta > 0.9999)) ? (
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        (CCCC === 2) ? (
                            // stereo case
                            tuplesA[0] = pvol * UBuffer[index];
                            tuplesA[1] = pvol * UBuffer[index+1];
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            tuplesA[0] = pvol * UBuffer[index];
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                tuplesA[i] = pvol * UBuffer[index];
                                i +=1; index += 1;
                            );
                        );
                    ) : (
                        // We need to interpolate
                        (CCCC === 2) ? (
                            // stereo case
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            index += 1;
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[1] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            xm1 = UBuffer[index-1];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+1];
                            x2 = UBuffer[index+2];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                tuplesA[i] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                                * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                                i +=1; index += 1;
                            );
                        );
                    );
                );
                // Next index
                ClRIndex +=  ClRIndInc;

                doStop ? (
                    VolumeMod0_u = FP_GlobSet = 0;
                    smUpdateFlag |= smUFlagVol;
                    ActivePlaying = 1;
                    (FP_GlobVol == 0) ? Pmode = mdInactive;
                );
            ) : (
                ActivePlaying = 0; currColVar = 1;
                //sactClear();
                Pmode = mdInactive;
                gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
                sprintf(#dbg_trace4, "* %s * End play : %.3fs [%.0f]", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
            );
            */
            //===1===//



        );):((opr<3)?(



            //===2===//
            /*
            5002 = Dispatch Fix
            */
            // Distribute generated sources in fixed panorama space
            // TPLG contains "chGenCnt" values
            // We need "chOutCnt" values as output
            // valid for "play" command
            memset(tuplesM-1, 0, chOutCnt+2);
            loop (i=0; chTmpCnt1,
                tuplesM[Chans1[i % HPCnt1] % chOutCnt] += TPLG[i % chGenCnt];
                i += 1;
            );
            loop (i=0; chOutCnt,
                spl(i) = tuplesM[i];
                i += 1;
            );
            //===2===//



        ):(

            //===3===//
            /*
            5003 = Dispatch Pan
            */
            // Distribute sources in 2 panoramas - simple algorithme "A"
            // gmem[UAdd+RCB_Pan_Src] is in [0 ... 1]
            (gmem[UAdd+RCB_Pan] != gmem[UAdd+RCB_Pan_Src]) ? (
                gmem[UAdd+RCB_Pan_Src] = max(0, min(1, gmem[UAdd+RCB_Pan_Src]));
                gmem[UAdd+RCB_Pan] = (gmem[UAdd+RCB_Pan_Src] > gmem[UAdd+RCB_Pan]) ? (
                    min(gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan] + TM_delta_inc);
                ) : (
                    max(gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan] - TM_delta_dec);
                );
                // Compute left & right factors from sin/cos tables
                L_fact = CosEnv[SinEnvSize * gmem[UAdd+RCB_Pan]];
                R_fact = SinEnv[SinEnvSize * gmem[UAdd+RCB_Pan]];
            );
            memset(tuplesM-1, 0, chOutCnt+2);
            loop (i=0; chTmpCnt1,
                tuplesM[Chans1[i % HPCnt1] % chOutCnt] += L_fact * TPLG[i % chGenCnt];
                i += 1;
            );
            loop (i=0; chTmpCnt2,
                tuplesM[Chans2[i % HPCnt2] % chOutCnt] += R_fact * TPLG[i % chGenCnt];
                i += 1;
            );
            loop (i=0; chOutCnt,
                spl(i) = tuplesM[i];
                i += 1;
            );
            //===3===//


        ););):((opr<6)?((opr<5)?(

            //===4===//
            /*
            5004 = Dispatch evolutive
            */
            // Distribute sources from TPLG using "the matrix"
            (xxalg == 1) ? (
                (xxsum <= 0) ? (
                    // Simple "replacement"
                    CmDval[0] = (CmDval[0] != 0) ? 0 : 1;
                    CmDval[1] = (CmDval[1] != 0) ? 0 : 1;
                    xxsum += xxint;
                );
                xxsum -= 1000/srate;
            ) :
            (xxalg == 2) ? (
                // Use sin/cos interpolation
                CmDval[0] = SinEnv[EnvPtC];
                CmDval[1] = SinEnv[EnvPtS];
                EnvPtC += EnvInc; (EnvPtC > EnvLim) ?  EnvPtC -= EnvLim;
                EnvPtS += EnvInc; (EnvPtS > EnvLim) ?  EnvPtS -= EnvLim;
            );
            loop (xxrep,
                (UsDval[kupd] != CmDval[kupd]) ? (
                    (UsDval[kupd] > CmDval[kupd]) ? (
                        UsDval[kupd] = max(CmDval[kupd], UsDval[kupd] - TM_delta_dec);
                    ) : (
                        UsDval[kupd] = min(CmDval[kupd], UsDval[kupd] + TM_delta_inc);
                    );
                );
                kupd = (kupd + 1) % hpfold;
            );
            memset(tuplesM-1, 0, chOutCnt+2);
            i = 0;
            loop(TM_HP,
                tuplesM[TM_HP_Dest[i]] += TPLG[TM_HP_Src[i]] * TM_Fix_Coef[i] * UsDval[TM_Dyn_Coef[i]];
                i += 1;
            );
            i = 0;
            loop(hpfold,
                spl(i) = tuplesM[i]; i+= 1;
            );
            //===4===//

        ):(



            //===5===//
            /*
            === New Loop ===
            */
            //(0 && (trcNL2 != second)) ? (sprintf(#dbg_trace7, "***** In loop  S:%d  s:%d  G:%.1f", evLState, status, GrLen); trcNL2 = second; );
            // Evoluate global Loop volume
            lpSmplCnt += 1;
            pvol = FP_GlobVol;
            gfxPlayT = gfxCurrT;
            (evLState) ? (
                evLScnt += 1;
                (evLState & 1) ? (
                    // increase loc. volume value
                    pvolEv += pvolInc;
                    (pvolEv >= 1) ? (
                        pvolEv = 1; evLState &= 0xfe; // reset bit 1
                        pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // prepare next decrement
                    );
                );
                (evLState & 2) ? (
                    evLState &= 0xfe; // reset bit 1
                    pvolEv += pvolDec;
                    (pvolEv <= 0) ? (
                        pvolEv = 0; evLState &= 0xf9; // reset bit 2 and 4
                        GCBactM = -1;
                        GrXpectX = 0;
                        Pmode = mdInactive;
                        ActivePlaying = 0; currColVar = 1;
                        (TRC & 16) ? (
                            sprintf(#gfs_mss, "* %s * 5 Loop Ender : %.3fs [%.0f]", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );
                (evLState & 4) ? (
                    (TRC & 16) ? (
                        sprintf(#gfs_mss0, "* %s * 4 # %.3f (%d / %d) %d [%.0f]", #nowtim, GrXpect * GrXpectX, P_Gp_ct, MaxGr, GCBactM, currSmpl);
                        mSL_log(SysLogBox, #gfs_mss0);
                    );
                    evLState &= 0xfb; // reset bit 3
                    ((GrXpect * GrXpectX > 0) && (P_Gp_ct < GrXpect)) ? (
                        // create a new grain
                        grBnum = 0;
                        while ((GCBacts[grBnum] != 0) && (grBnum < MaxGr)) (grBnum += 1;);
                        (grBnum < MaxGr) ? (
                            // use grBnum
                            GCBactM = max(grBnum,GCBactM); // limit this
                            GCBacts[grBnum] = GCBL = GCBpts[grBnum];
                            memset(GCBL, 0, GPBSize);
                            GCBL[gStatus] = 4; // will be initialized soon
                            // GCBL[gCllvol] = 0; // init. vol is zero
                            (TRC & 16) ? (
                                sprintf(#gfs_mss1, "* %s * New loop %d/%d : %.3fs @ %.3fs [%.0f]", #nowtim, grBnum, GCBactM,
                                    GrLen/currSrate, (currSmpl - SmpPStart)/currSrate, currSmpl);
                                mSL_log(SysLogBox, #gfs_mss1);
                            );
                        );
                    );
                    // Relancer le signal
                    // Time Interval computed as grain duration / mass
                    (GrXpect * GrXpectX  > 0) ? (
                        // Time Interval computed as grain duration / mass
                        ti = 0| max(12, GrMLen / (max(0.01, FP_G_PMass))); // Ti in Tuples
                        ti1 = ti * (1 - GrAsyncFact * FP_G_PAsyn / 100);  // FP_G_PAsyn in [0  100]
                        ti2 = ti * (1 + GrAsyncFact * FP_G_PAsyn / 100);
                        ti = 0| (ti1 + (ti2 - ti1) * frand());
                        (TRC & 16) ? (
                            sprintf(#gfs_mss2, "* %s * Restart %d %.3f  %X  [%.0f]", #nowtim, ti, ti/currSrate, evLState, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss2);
                        );
                        smplNewEV(currSmpl + ti, 6, 0, 0);
                    ) :
                    (
                        (P_Gp_ct == 0) ? (
                            // no more buffer playing
                            Pmode = mdInactive;
                            ActivePlaying = 0; currColVar = 1;
                            gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
                            (TRC & 16) ? (
                                sprintf(#gfs_mssU, "* %s * End loop %d : %.3fs [%.0f]", #nowtim, abp, (currSmpl - SmpPStart)/currSrate, currSmpl);
                                mSL_log(SysLogBox, #gfs_mssU);
                            );
                        );
                    );

                );
                pvol = pvolEv * FP_GlobVol;
            );
            TPLG = tuplesA; memset(tuplesA, 0, chGenCnt);
            P_Gp_ct = A_Gp_ct ; // Previous active count
            abp = 0; A_Gp_ct = 0;
            while (abp <= GCBactM) (
                (GCBL = GCBacts[abp]) ? (
                    A_Gp_ct += 1; // this counts as a playing buffer
                    status = GCBL[gStatus]; // status of the grain
                    lvol = GCBL[gCllvol]; // volume of the grain
                    (status > 1) ? (
                        (status === 4) ? (
                            // restart a new bloc
                            lvol = 0; // local volume for the grain
                            // choose a random tupple : position and length
                            // First choose a length (in tpl)
                            // Note that Grain length can be greater than clip actual length
                            // gmem[UAdd+RCB_Gr_Size] = GrDur = min(MaxGrSize, max(4/currSrate, ((FP_GL_Gmin + (FP_GL_Gmax - FP_GL_Gmin) * frand()) * FP_GL_GSiz/ 1000)));
                            // GrLen = 0| (GrDur * currSrate);
                            // GrLen = 0|min(MaxGrSize * currSrate, max(4, ((FP_GL_Gmin + (FP_GL_Gmax - FP_GL_Gmin) * frand()) * FP_GL_GSiz * currSrate / 1000)));
                            Gr7 = Gr6; Gr6 = Gr5; Gr5 = Gr4; Gr4 = Gr3; Gr3 = Gr2; Gr2 = Gr1; Gr1 = Gr0; Gr0 = 1000 * GrLen/currSrate;
                            gmem[UAdd+RCB_Gr_Size] = Gr0;
                            // Adapt the top percent :  FP_GL_GTWd in [0 100]
                            kIn = max(0.125, gmem[UAdd+RCB_GrFdIn_ms]); kOut =  max(0.125, gmem[UAdd+RCB_GrFdOut_ms]);
                            GrLen2 = (Grlen * max(0.2, min(99.8, (100 - FP_GL_GTWd))) / 100); // # tupples available for Fades
                            // determine fadein and fade out
                            GrFIn = 0|((kIn * GrLen2)/(kIn + kOut)); // in tupples
                            GrFOut = 0|((kOut * GrLen2)/(kIn + kOut)); // in tupples
                            // Modify slant point ?  FP_GL_Slant in [0 100]
                            (FP_GL_Slant > 50) ? (
                                // longer fade in, shorter fade out
                                // remove from GrFOut to add to GrFIn
                                qt = 0|(GrFOut * ((FP_GL_Slant - 50) / 50));
                                GrFOut -= qt; GrFIn += qt;
                            ) :
                            (FP_GL_Slant < 50) ? (
                                // longer fade out, shorter fade in
                                // remove from GrFIn to add to GrFOut
                                qt = 0|(GrFIn * ((50 - FP_GL_Slant) / 50));
                                GrFIn -= qt; GrFOut += qt;
                            );
                            GrFIn = max(5, GrFIn); GrFOut = max(5, GrFOut); // allow at least a few tupples for fades
                            // decide a starting point
                            // when FP_G_PVar is 100%, qv is zero,  GRLL is  GrStLLimit and GRHL is GrStHLimit
                            // when FP_G_PVar is 0 %, qv is 1,
                            //             qw is usable clip length, GRLL is a position propotional to FP_G_PPos
                            //             and GRHL is equal to GRLL
                            // qv = (100 - FP_G_PVar) / 100; qw = GrStHLimit - GrStLLimit - GrLen;
                            // GRLL = 0|(GrStLLimit + qv * qw * FP_G_PPos / 100);
                            // GRHL = 0|(GrStHLimit - qv * qw * (100 - FP_G_PPos)/ 100);
                            // Since GrLen can be greater than the clip size, we use 2 different algorithms
                            (ClTplSize > 10 * GrLen) ? (
                                // "small" g grains
                                qv = (100 - FP_G_PVar) / 100; qw = ClTplSize - GrLen;
                                GRLL = 0|(ClTpl1st + qv * qw * FP_G_PPos / 100);
                                GRHL = 0|(ClTplLast - qv * qw * (100 - FP_G_PPos)/ 100);
                                v = GRHL - GrLen - GRLL + 1;
                            ) : (
                                // Large grains : use "0" for GrLen
                                qv = (100 - FP_G_PVar) / 100; qw = ClTplSize;
                                GRLL = 0|(ClTpl1st + qv * qw * FP_G_PPos / 100);
                                GRHL = 0|(ClTplLast - qv * qw * (100 - FP_G_PPos)/ 100);
                                v = GRHL - GRLL + 1;
                            );
                            //
                            GCBL[gClLowLimit] =
                            k = GRLL + irand(max(1, v));
                            //
                            GCBL[gClHighLimit] =
                            m = min(GRHL, k + GrLen);
                            GinvDir = 1;

                            GinvDir = ((FP_G_Direct > 100 * frand()) ? -1 : 1);

                            FP_G_HarmShp ? (
                                fgh = 0| FP_G_HarmShp;
                                (fgh<8)?((fgh<4)?((fgh<2)?((fgh<1)?(
                                    //===0===//
                                    0;
                                    //===0===//
                                ):(
                                    //===1===//
                                    GinvDir *= ((100 - FP_G_Inharm + FP_G_Inharm * (1 +  GrSpdVFact * frand()) / (1 +  GrSpdVFact * frand())) / 100);
                                    //===1===//
                                );):((fgh<3)?(
                                    //===2===//
                                    GinvDir *= (1 + irand(max(1, 0.5 + GrSpdVFact * (FP_G_Inharm + 5) / 100))) / (1 + irand(max(1, 0.5 + GrSpdVFact * FP_G_Inharm / 100)));
                                    //===2===//
                                ):(
                                    //===3===//
                                    n1 = irand(max(1, GrSpdVFact * (FP_G_Inharm + 4) / 35));
                                    GinvDir *= (n1 + 2) / (max (2, irand(1 + n1 * FP_G_Inharm / 50)));
                                    //===3===//
                                ););):((fgh<6)?((fgh<5)?(
                                    //===4===//
                                    n1 = irand(0.5 + 1.17 * scale_Pyth_siz * FP_G_Inharm / 100);
                                    GinvDir *= scale_Pyth[min(scale_Pyth_siz-1, n1)];
                                    //===4===//
                                ):(
                                    //===5===//
                                    seq = seq_1;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===5===//
                                );):((fgh<7)?(
                                    //===6===//
                                    seq = seq_2;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===6===//
                                ):(
                                    //===7===//
                                    seq = seq_3;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===7===//
                                );););):((fgh<12)?((fgh<10)?((fgh<9)?(
                                    //===8===//
                                    seq = seq_5;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===8===//
                                ):(
                                    //===9===//
                                    seq_step = ! seq_step ;
                                    seq = seq_step ? seq_4 : seq_6;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===9===//
                                );):((fgh<11)?(
                                    //===10===//
                                    seq = seq_6;
                                    seq[0] = (seq[0] + 1) % seq[1];
                                    GinvDir *= seq[seq[0]+2];
                                    //===10===//
                                ):(
                                    //===11===//
                                    Err=11;
                                    //===11===//
                                ););):((fgh<14)?((fgh<13)?(
                                    //===12===//
                                    Err=12;
                                    //===12===//
                                ):(
                                    //===13===//
                                    Err=13;
                                    //===13===//
                                );):((fgh<15)?(
                                    //===14===//
                                    Err=14;
                                    //===14===//
                                ):(
                                    //===15===//
                                    Err=15;
                                    //===15===//
                                ););););
                            );

                            ((clRSpeed * GinvDir ) > 0) ? (
                                GCBL[gClRIndex] = ClTpl1st + (k - ClTpl1st + 128 * ClTplSize) % ClTplSize;
                            ) : (
                                GCBL[gClRIndex] = ClTpl1st + (m - ClTpl1st + 128 * ClTplSize) % ClTplSize;
                            );
                            GCBL[gChOffset] = irand(CCCC); // Choose one channel from wich to extract samples
                            GCBL[gChCount] = 1;
                            //GCBL[gChNum] = Chans1[HPIndx]; HPIndx = (HPIndx + 1) % HPCnt1; // write in "next" output
                            GCBL[gChNum] = irand(chGenCnt); // out. this grain to a random gen out
                            xxcnt += 1;
                            // Create an event to start grain fade-out
                            smplNewEV((wgs = currSmpl + max(6, Grlen - GrFOut)), 5, abp, ModWSize/GrFOut);
                            (TRC & 32) ? (
                                sprintf(#gfs_mss, "* %s * Loop %d FadeOut: %.0fT/%.3fs in %.0fT / %.3fs [%.0f]", #nowtim, abp, GrFOut, GrFOut/currSrate, (wgs - currSmpl), (wgs - currSmpl)/currSrate, currSmpl);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                            GCBL[cEvLvol] = ModWSize/GrFIn; // evolution of fade index
                            GCBL[cEvLindx] = 0; // fade index in [0 .. ModWSize]
                            GCBL[cGrFOut] = GrFOut; // keep this value
                            GCBL[gClRSpeed] = ClRIndInc; // capture at grain creation

                            status = 2; // start right now increasing volume
                            (TRC & 8) ? (
                                sprintf(#gfs_mss, "* %s * Loop %d FadeIn : %.0fT/%.3fs %.7f %.7f [%.0f] %d", #nowtim, abp, GrFIn, GrFIn/currSrate, lvol, GCBL[cEvLvol], currSmpl, status);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                            ((TRC & 8) && ((k < ClTpl1st) || (k > ClTplLast) || (m < ClTpl1st) || (m > ClTplLast) || (GrLen > ClTplSize))) ? (
                                sprintf(#gfs_mss, "* %s * Anom: k: %.1f  m: %.3f s: %.3f", #nowtim, k, m, GrLen);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                        );
                        (status === 2) ? (
                            // starting to increase lvol
                            ix = max(0, min(ModWSize, GCBL[cEvLindx])); // index in shape
                            lvol = max(lvol, GrShpIn[0|ix]);
                            GCBL[cEvLindx] = ix + GCBL[cEvLvol];
                            ((lvol >= 1) || (ix >= ModWSize)) ? (
                                lvol = 1;
                                status = 1;
                                (TRC & 8) ? (
                                    sprintf(#gfs_mss, "* %s * Loop %d Sustain : %.0fT %.7f %.7f [%.0f]", #nowtim, abp, GCBL[cGrFOut], lvol, GCBL[cEvLvol], currSmpl);
                                    mSL_log(SysLogBox, #gfs_mss);
                                );
                                GCBL[cEvLindx] = ModWSize;
                            );
                        ) :
                        (status === 3) ? (
                            // starting to decrease lvol
                            ix = max(0, min(ModWSize, GCBL[cEvLindx]));
                            lvol = min(lvol, GrShpOut[0|ix]);
                            GCBL[cEvLindx] = ix - GCBL[cEvLvol];
                            ((lvol <= 0) || (ix <= 0)) ? (
                                (TRC & 8) ? (
                                    sprintf(#gfs_mss, "* %s * Loop %d FadeOut %.0fT %.7f %.7f [%.0f]", #nowtim, abp, GCBL[cGrFOut], lvol, GCBL[cEvLvol], currSmpl);
                                    mSL_log(SysLogBox, #gfs_mss);
                                );
                                lvol = 0;
                                GCBL[cEvLindx] = 0;
                                // Grain play is finished
                                // free the buffer
                                GCBacts[abp] = 0;
                                status = 0; // nothing to play
                            );
                        );
                    );
                    (status > 0) ? (
                        gspl = 0;
                        lastabp = abp; // last playing grain
                        ClRIndex = GCBL[gClRIndex];
                        GrInc = GinvDir * (((FP_F & smUFlagDGspeed) ? ClRIndInc : GCBL[gClRSpeed]));
                        // ClRIndex = ClTpl1st + (ClRIndex - ClTpl1st + ClTplSize) % ClTplSize;
                        // Quick check of ClRIndex
                        /*
                        (GrInc > 0) ? (
                            while (ClRIndex >= ClTplLast) (ClRIndex -= ClTplSize);
                        ) : (
                            while (ClRIndex < ClTpl1st) (ClRIndex += ClTplSize);
                        );
                        */
                        //
                        ((ClRIndex <= ClTpl1st) && (GrInc < 0)) ? (ClRIndex += ClTplSize);
                        //
                        ((ClRIndex >= ClTplLast) && (GrInc > 0)) ? (ClRIndex -= ClTplSize);
                        ((ClRIndex <= 0) || (ClRIndex >= ClTplLast2)) ? (
                            // Error - out of zeroes zones
                            (TRC & 0x200) ? (
                                sprintf(#gfs_mss, "* %s * ClRIndex = %.4f - [%.0f  %.0f  %.6f]", #nowtim, ClRIndex, ClTpl1st, ClTplLast, GrInc);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                            ClRIndex = (GrInc < 0) ? ClTplLast : ClTpl1st;
                        );
                        /*
                        ClLowArea = GCBL[gClLowArea];
                        ClHighArea = GCBL[gClHighArea];
                        ClLowLimit = GCBL[gClLowLimit];
                        ClHighLimit = GCBL[gClHighLimit];
                        ((ClRIndex < ClLowArea) || (ClRIndex > ClHighArea)) ? (
                            // are we finished ?
                            ((ClRIndex <  ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                                pflg = lvol = 0;
                            ) : (
                                // compute an appropriate fade volume
                                d = (ClRIndex < ClLowArea) ? (
                                        (ClRIndex - ClLowLimit) / (ClLowArea - ClLowLimit)
                                    ) : (
                                        (ClHighLimit - ClRIndex) / (ClHighLimit - ClHighArea)
                                    );
                                lvol = min(1,d*d); // use a quadratic coeff.
                            );
                        );
                        */
                        ((pvol != 0) && (lvol != 0)) ? (
                            // do actual interpolation
                            index = floor(ClRIndex); // In tupple for now
                            delta = ClRIndex - index;
                            // Convert to samples, add channel offset
                            index *= CCCC; index += GCBL[gChOffset];
                            ((delta < 0.0001) || (delta > 0.9999)) ? (
                                // return sample to optimize
                                (delta > 0.5) ? index += CCCC;
                                gspl = lvol * UBuffer[index];
                            ) : (
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                gspl = lvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            );
                        );
                        ClRIndex += GrInc;
                        GCBL[gClRIndex] = ClRIndex;
                        xx = GCBL[gChNum];
                        tuplesA[xx] += max(-0.999, min(0.999, GrXVol * pvol * gspl));
                        // spl(xx) += tuplesA[xx];
                        /*
                        (!pflg) ? (
                            // free the buffer
                            GCBacts[abp] = 0;
                            // Pmode = ActLooping;
                            doStop ? (
                                GrXpect = 0;
                            );
                        );
                        */
                    );
                    GCBL[gStatus] = status;
                    GCBL[gCllvol] = lvol;
                );
                abp += 1;
            );
            //===5===//



        );):((opr<7)?(



            //===6===//  8006
            /*
            === New Play ===
            */
            TPLG = tuplesA; // where to write samples
            pvol = FP_GlobVol;
            gfxPlayT = gfxCurrT;
            //*/
            evLState ? (
                (evLState & 1) ? (
                    // increase loc. volume value
                    pvolEv += pvolInc;
                    (pvolEv >= 1) ? (
                        pvolEv = 1; evLState &= 0xfe; // reset bit 1
                        pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // next decrement
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Stade2 : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );
                (evLState & 2) ? (
                    // decrease volume value
                    evLState &= 0xfe; // make sure bit 1 is reset
                    pvolEv += pvolDec;
                    (pvolEv <= 0) ? (
                        pvolEv = 0; evLState &= 0xfd; // reset bit 2
                        ActivePlaying = 0; currColVar = 1;
                        TPLG = tuplesZ;
                        pflg = 0;
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Ender : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );
                pvol = pvolEv * FP_GlobVol;
            );
            (pflg) ? (
                (pvol == 0) ? (
                    TPLG = tuplesZ;
                ) : (
                    // do actual interpolation
                    index = floor(ClRIndex); // in tupples
                    delta = ClRIndex - index; // decimal part
                    // Convert to samples
                    index *= CCCC;
                    ((delta < 0.0001) || (delta > 0.9999)) ? ( // decimal part small enough ?
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        (CCCC === 2) ? (
                            // stereo case
                            tuplesA[0] = pvol * UBuffer[index];
                            tuplesA[1] = pvol * UBuffer[index+1];
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            tuplesA[1] = tuplesA[0] = pvol * UBuffer[index];
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                tuplesA[i] = pvol * UBuffer[index];
                                i +=1; index += 1;
                            );
                        );
                    ) : (
                        // We need to interpolate
                        (CCCC === 2) ? (
                            // stereo case
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            index += 1;
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[1] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            xm1 = UBuffer[index-1];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+1];
                            x2 = UBuffer[index+2];
                            tuplesA[1] = tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                tuplesA[i] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                                * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                                i +=1; index += 1;
                            );
                        );
                    );
                );
                // Next index
                ClRIndex += ClRIndInc;
                ((ClRIndex < ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                    (TRC & 0x200) ? (
                        sprintf(#gfs_mss, "* %s * Play Stade3 : %.3fs  %.3f   [%.0f]", #nowtim, (currSmpl - SmpPStart)/currSrate, ClRIndex, currSmpl);
                        mSL_log(SysLogBox, #gfs_mss);
                    );
                    (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) ? (
                        (ClRIndInc > 0) ? (
                            ClRIndex = ClLowLimit;
                        ) : (
                            ClRIndex = ClHighLimit;
                        );
                        // pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                        pvolInc = 1000 / currSrate;
                        evLState = 1; // restart vol increase
                        (RState === 11) ? (RState = 2;);
                    ) : (
                        evLState = pvolEv = 0;
                        pflg = 0;
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Ender2 : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );

                doStop ? (
                    VolumeMod0_u = FP_GlobSet = 0;
                    smUpdateFlag |= smUFlagVol;
                    ActivePlaying = 1;
                    (FP_GlobVol == 0) ? Pmode = mdInactive;
                );
            ) : (
                ActivePlaying = 0; currColVar = 1;
                //sactClear();
                Pmode = mdInactive;
                gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
            );
            //===6===//



        ):((opr<8)?(




            //===7===//
            /*
            === Exp Play ===
            */
            memset(tuplesA, 0, CCCC); // clear out.
            TPLG = tuplesA; // where to write samples
            pvol = FP_GlobVol;
            gfxPlayT = gfxCurrT;
            //*/
            evLState ? (
                (evLState & 1) ? (
                    // increase loc. volume value
                    pvolEv += pvolInc;
                    (pvolEv >= 1) ? (
                        pvolEv = 1; evLState &= 0xfe; // reset bit 1
                        pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // next decrement
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Stade2 : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );
                (evLState & 2) ? (
                    // decrease volume value
                    evLState &= 0xfe; // make sure bit 1 is reset
                    pvolEv += pvolDec;
                    (pvolEv <= 0) ? (
                        pvolEv = 0; evLState &= 0xfd; // reset bit 2
                        ActivePlaying = 0; currColVar = 1;
                        TPLG = tuplesZ;
                        pflg = 0;
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Ender : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );
                pvol = pvolEv * FP_GlobVol;
            );
            (pflg) ? (
                (pvol == 0) ? (
                    TPLG = tuplesZ;
                ) : (
                    // do actual interpolation
                    index = floor(ClRIndex); // in tupples
                    delta = ClRIndex - index; // decimal part
                    // Convert to samples
                    index *= CCCC;
                    ((delta < 0.0001) || (delta > 0.9999)) ? ( // decimal part small enough ?
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        (CCCC === 2) ? (
                            // stereo case
                            tuplesA[0] = pvol * UBuffer[index];
                            tuplesA[1] = pvol * UBuffer[index+1];
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            tuplesA[0] = pvol * UBuffer[index];
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                tuplesA[i] = pvol * UBuffer[index];
                                i +=1; index += 1;
                            );
                        );
                    ) : (
                        // We need to interpolate
                        (CCCC === 2) ? (
                            // stereo case
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            index += 1;
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[1] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            xm1 = UBuffer[index-1];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+1];
                            x2 = UBuffer[index+2];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                tuplesA[i] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                                * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                                i +=1; index += 1;
                            );
                        );
                    );
                );
                // Next index
                ClRIndex += ClRIndInc;
                ((ClRIndex < ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                    (TRC & 0x200) ? (
                        sprintf(#gfs_mss, "* %s * Play Stade3 : %.3fs  %.3f   [%.0f]", #nowtim, (currSmpl - SmpPStart)/currSrate, ClRIndex, currSmpl);
                        mSL_log(SysLogBox, #gfs_mss);
                    );
                    (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) ? (
                        (ClRIndInc > 0) ? (
                            ClRIndex = ClLowLimit;
                        ) : (
                            ClRIndex = ClHighLimit;
                        );
                        evLState = 1; // restart vol increase
                        pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                        (RState === 11) ? (RState = 2;);
                    ) : (
                        evLState = pvolEv = 0;
                        pflg = 0;
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Ender2 : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );

                doStop ? (
                    VolumeMod0_u = FP_GlobSet = 0;
                    smUpdateFlag |= smUFlagVol;
                    ActivePlaying = 1;
                    (FP_GlobVol == 0) ? Pmode = mdInactive;
                );
            ) : (
                ActivePlaying = 0; currColVar = 1;
                //sactClear();
                Pmode = mdInactive;
                gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
            );

            (pflg) ? (
                (pvol == 0) ? (
                    TPLG = tuplesZ;
                ) : (
                    // do actual interpolation
                    index = floor(ClRIndex); // in tupples
                    delta = ClRIndex - index; // decimal part
                    // Convert to samples
                    index *= CCCC;
                    ((delta < 0.0001) || (delta > 0.9999)) ? ( // decimal part small enough ?
                        // return sample to optimize
                        (delta > 0.5) ? index += CCCC;
                        (CCCC === 2) ? (
                            // stereo case
                            tuplesA[0] = pvol * UBuffer[index];
                            tuplesA[1] = pvol * UBuffer[index+1];
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            tuplesA[0] = pvol * UBuffer[index];
                        ) : (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                tuplesA[i] = pvol * UBuffer[index];
                                i +=1; index += 1;
                            );
                        );
                    ) : (
                        // We need to interpolate
                        (CCCC === 2) ? (
                            // stereo case
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                            index += 1;
                            xm1 = UBuffer[index-2];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+2];
                            x2 = UBuffer[index+4];
                            tuplesA[1] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (CCCC === 1) ? (
                            // mono case
                            xm1 = UBuffer[index-1];
                            x0 = UBuffer[index];
                            x1 = UBuffer[index+1];
                            x2 = UBuffer[index+2];
                            tuplesA[0] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                        * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                            * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                        ) :
                        (
                            // multi channels case
                            i = 0;
                            loop(CCCC,
                                xm1 = UBuffer[index-CCCC];
                                x0 = UBuffer[index];
                                x1 = UBuffer[index+CCCC];
                                x2 = UBuffer[index+CCCC+CCCC];
                                tuplesA[i] = pvol * (((((3.0 * (x0 - x1) - xm1 + x2) * 0.5)
                                            * delta + (2.0 * x1 + xm1 - (5.0 * x0 + x2) * 0.5))
                                                * delta + ((x1 - xm1) * 0.5)) * delta + x0);
                                i +=1; index += 1;
                            );
                        );
                    );
                );
                // Next index
                ClRIndex += ClRIndInc;
                ((ClRIndex < ClLowLimit) || (ClRIndex > ClHighLimit)) ? (
                    (TRC & 0x200) ? (
                        sprintf(#gfs_mss, "* %s * Play Stade3 : %.3fs  %.3f   [%.0f]", #nowtim, (currSmpl - SmpPStart)/currSrate, ClRIndex, currSmpl);
                        mSL_log(SysLogBox, #gfs_mss);
                    );
                    (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) ? (
                        (ClRIndInc > 0) ? (
                            ClRIndex = ClLowLimit;
                        ) : (
                            ClRIndex = ClHighLimit;
                        );
                        evLState = 1; // restart vol increase
                        pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                        (RState === 11) ? (RState = 2;);
                    ) : (
                        evLState = pvolEv = 0;
                        pflg = 0;
                        (TRC & 0x200) ? (
                            sprintf(#gfs_mss, "* %s * Play Ender2 : %.3fs %.0f", #nowtim, (currSmpl - SmpPStart)/currSrate, currSmpl);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                    );
                );

                doStop ? (
                    VolumeMod0_u = FP_GlobSet = 0;
                    smUpdateFlag |= smUFlagVol;
                    ActivePlaying = 1;
                    (FP_GlobVol == 0) ? Pmode = mdInactive;
                );
            ) : (
                ActivePlaying = 0; currColVar = 1;
                //sactClear();
                Pmode = mdInactive;
                gmem[UAdd+RCB_CPStop_tim] = time_precise() + gmem[timeDelta];
            );
            //===7===//





        ):(



            //===8===//
            /*
            5008 = Dispatch 2 Sets
            */
            // Distribute to 2 sets of channels from 2 values Left & Right
            // Commands by L_fact_K and R_fact_K
            (L_fact != L_fact_K) ? (
                L_fact_K = max(0, min(1, L_fact_K));
                L_fact = (L_fact_K > L_fact) ? (
                    min(L_fact_K, L_fact + TM_delta_inc);
                ) : (
                    max(L_fact_K, L_fact - TM_delta_dec);
                );
            );
            (R_fact != R_fact_K) ? (
                R_fact_K = max(0, min(1, R_fact_K));
                R_fact = (R_fact_K > R_fact) ? (
                    min(R_fact_K, R_fact + TM_delta_inc);
                ) : (
                    max(FP_G_X_PanR_fact_K_Src, R_fact - TM_delta_dec);
                );
            );
            memset(tuplesM-1, 0, chOutCnt+2);
            loop (i=0; chTmpCnt1,
                tuplesM[Chans1[i % HPCnt1] % chOutCnt] += L_fact * TPLG[i % chGenCnt];
                i += 1;
            );
            loop (i=0; chTmpCnt2,
                tuplesM[Chans2[i % HPCnt2] % chOutCnt] += R_fact * TPLG[i % chGenCnt];
                i += 1;
            );
            loop (i=0; chOutCnt,
                spl(i) = tuplesM[i];
                i += 1;
            );
            //===8===//



        ););););):((opr<14)?((opr<11)?((opr<10)?(



            //===9===//
            /*
            5009 = Sliding panoramic, 2 sets
            */
            (gmem[UAdd+RCB_Pan] !== gmem[UAdd+RCB_Pan_Src]) ? (
                // Reset du pan ?
                /*
                (gmem[UAdd+RCB_Pan_Src] > 1) ? (gmem[UAdd+RCB_Pan_Src] -= 1; gmem[UAdd+RCB_Pan] -= 1;);
                (gmem[UAdd+RCB_Pan_Src] < 0) ? (gmem[UAdd+RCB_Pan_Src] += 1; gmem[UAdd+RCB_Pan] += 1;);
                // gmem[UAdd+RCB_Pan_Src] = max(0, min(1, gmem[UAdd+RCB_Pan_Src]));
                while (gmem[UAdd+RCB_Pan_Src] > 1) (gmem[UAdd+RCB_Pan_Src] -= 1;);
                while (gmem[UAdd+RCB_Pan_Src] < 0) (gmem[UAdd+RCB_Pan_Src] += 1;);
                while (gmem[UAdd+RCB_Pan] > 1) (gmem[UAdd+RCB_Pan] -= 1;);
                while (gmem[UAdd+RCB_Pan] < 0) (gmem[UAdd+RCB_Pan] += 1;);
                */
                gmem[UAdd+RCB_Pan] = (gmem[UAdd+RCB_Pan_Src] > gmem[UAdd+RCB_Pan]) ? (
                    min(gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan] + TM_delta_inc);
                ) : (
                    max(gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan] - TM_delta_dec);
                );
                // Compute left & right factors from sin/cos tables for "left" set
                // gmem[UAdd+RCB_Pan] in [0  1]
                Lindex = gmem[UAdd+RCB_Pan] * (chTmpCnt1-1); // in [0  chTmpCnt1 - 1]
                Lch = 0|Lindex; // 1st ch.
                Linc = Lindex - Lch;
                Llfact = CosEnv[SinEnvSize * Linc];
                Lrfact = SinEnv[SinEnvSize * Linc];
                // Compute left & right factors from sin/cos tables for "right" set
                Rindex = gmem[UAdd+RCB_Pan] * (chTmpCnt2-1); // in [0  chTmpCnt2 - 1]
                Rch = 0|Rindex; // 1st ch.
                Rinc = Rindex - Rch;
                Rlfact = CosEnv[SinEnvSize * Rinc];
                Rrfact = SinEnv[SinEnvSize * Rinc];
                /*
                sprintf(#dbg_trace4, "P:%.3f L:%.3f R:%.3f Lc:%d Rc:%d llf:%.3f lrf:%.3f rlf:%.3f rrf:%.3f",
                gmem[UAdd+RCB_Pan], Lindex, Rindex, Lch, Rch, Llfact, Lrfact, Rlfact, Rrfact);
                */
                0 ? (
                    sprintf(#dbg_trace4, "S:%.3f P:%.3f L:%.3f R:%.3f Lc:%d Rc:%d",
                        gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan], Lindex, Rindex, Lch, Rch);
                );
            );
            memset(tuplesM-1, 0, chOutCnt+2);
            tuplesM[TM_HP_Dest1[Lch % HPCnt1] % chOutCnt] += Llfact * TPLG[0];
            //tuplesM[TM_HP_Dest1[(Lch % HPCnt1)+ 1] % chOutCnt] += Lrfact * TPLG[0];
            tuplesM[TM_HP_Dest1[(Lch+ 1) % HPCnt1] % chOutCnt] += Lrfact * TPLG[0];
            tuplesM[TM_HP_Dest2[Rch % HPCnt2] % chOutCnt] += Rlfact * TPLG[1];
            //tuplesM[TM_HP_Dest2[(Rch % HPCnt2)+ 1] % chOutCnt] += Rrfact * TPLG[1];
            tuplesM[TM_HP_Dest2[(Rch+ 1) % HPCnt2] % chOutCnt] += Rrfact * TPLG[1];
            loop (i=0; chOutCnt,
                spl(i) = tuplesM[i];
                i += 1;
            );
            //===9===//



        ):(


            //===10===//
            /*
            500A = Sliding panoramic, 2 sets - larger sources
            */
            (gmem[UAdd+RCB_Pan] !== gmem[UAdd+RCB_Pan_Src]) ? (
                //
                gmem[UAdd+RCB_Pan_Src] = max(0, min(1, gmem[UAdd+RCB_Pan_Src]));
                gmem[UAdd+RCB_Pan] = gmem[UAdd+RCB_Pan_Src];
                // Compute factors from sin/cos tables for "left" set
                // gmem[UAdd+RCB_Pan] in [0  1]
                Lindex = gmem[UAdd+RCB_Pan] * (chTmpCnt1-1); // in [0  chTmpCnt1 - 1]
                Lch = 0|Lindex; // 1st ch.
                Rch = Lch + 1;
                Linc = Lindex - Lch;
                Llfact = CosEnv[SinEnvSize * Linc];
                Lrfact = SinEnv[SinEnvSize * Linc];
                loop (i=0; chTmpCnt1,
                    (i < Lch) ? (TM_Fix_Coef1[i] = 0) :
                    (i === Lch) ? (TM_Fix_Coef1[i] = Llfact) :
                    (i === Rch) ? (TM_Fix_Coef1[i] = Lrfact) :
                    (TM_Fix_Coef1[i] = 0);
                    i += 1;
                );

                Lindex = gmem[UAdd+RCB_Pan] * (chTmpCnt2-1); // in [0  chTmpCnt1 - 1]
                Lch = 0|Lindex; // 1st ch.
                Rch = Lch + 1;
                Linc = Lindex - Lch;
                Llfact = CosEnv[SinEnvSize * Linc];
                Lrfact = SinEnv[SinEnvSize * Linc];
                loop (i=0; chTmpCnt2,
                    (i < Lch) ? (TM_Fix_Coef2[i] = 0) :
                    (i === Lch) ? (TM_Fix_Coef2[i] = Llfact) :
                    (i === Rch) ? (TM_Fix_Coef2[i] = Lrfact) :
                    (TM_Fix_Coef2[i] = 0);
                    i += 1;
                );
                //
                /*
                sprintf(#dbg_trace4, "P:%.3f L:%.3f R:%.3f Lc:%d Rc:%d llf:%.3f lrf:%.3f rlf:%.3f rrf:%.3f",
                gmem[UAdd+RCB_Pan], Lindex, Rindex, Lch, Rch, Llfact, Lrfact, Rlfact, Rrfact);
                */
                0 ? (
                    sprintf(#dbg_trace4, "S:%.3f P:%.3f L:%.3f R:%.3f Lc:%d Rc:%d",
                        gmem[UAdd+RCB_Pan_Src], gmem[UAdd+RCB_Pan], Lindex, Rindex, Lch, Rch);
                );
            );
            memset(tuplesM-1, 0, chOutCnt+2);

            loop (i=0; chTmpCnt1,
                (TM_Fix_Coef1[i] !== TM_Dyn_Coef1[i]) ? (
                    (TM_Fix_Coef1[i] > TM_Dyn_Coef1[i]) ? (
                        TM_Dyn_Coef1[i] = min(TM_Fix_Coef1[i], TM_Dyn_Coef1[i] + TM_delta_inc);
                    ) : (
                        TM_Dyn_Coef1[i] = max(TM_Fix_Coef1[i], TM_Dyn_Coef1[i] - TM_delta_dec);
                    );
                );
                i += 1;
            );
            loop (i=0; chTmpCnt2,
                (TM_Fix_Coef2[i] !== TM_Dyn_Coef2[i]) ? (
                    (TM_Fix_Coef2[i] > TM_Dyn_Coef2[i]) ? (
                        TM_Dyn_Coef2[i] = min(TM_Fix_Coef2[i], TM_Dyn_Coef2[i] + TM_delta_inc);
                    ) : (
                        TM_Dyn_Coef2[i] = max(TM_Fix_Coef2[i], TM_Dyn_Coef2[i] - TM_delta_dec);
                    );
                );
                i += 1;
            );

            loop (i=0; chTmpCnt1,
                tuplesM[TM_HP_Dest1[i % HPCnt1]% chOutCnt] += TM_Dyn_Coef1[i] * TPLG[0];
                i += 1;
            );

            loop (i=0; chTmpCnt2,
                tuplesM[TM_HP_Dest2[i % HPCnt2]% chOutCnt] += TM_Dyn_Coef2[i] * TPLG[1];
                i += 1;
            );

            loop (i=0; chOutCnt,
                spl(i) = tuplesM[i];
                i += 1;
            );
            //===10===//
        );):((opr<12)?(
            //===11===//
            Err=11;
            //===11===//
        ):((opr<13)?(
            //===12===//
            Err=12;
            //===12===//
        ):(
            //===13===//
            Err=13;
            //===13===//
        );););):((opr<16)?((opr<15)?(
            //===14===//
            Err=14;
            //===14===//
        ):(
            //===15===//
            Err=15;
            //===15===//
        );):((opr<17)?(
            //===16===//
            Err=16;
            //===16===//
        ):((opr<18)?(
            //===17===//
            Err=17;
            //===17===//
        ):(
            //===18===//
            Err=18;
            //===18===//
        );););););



    );

//  );

);








@serialize


LoadMode = file_avail(0) >= 0;










@gfx
gfxCurrT = time_precise() + timeD;
gfxWStat = gfx_getchar(65536);


mSL_loc_tim = max(mSL_loc_tim - 1, 0);


1 ? (
    (strlen(#dbg_trace0) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace0);
        #dbg_trace0 = "";
    );
    (strlen(#dbg_trace1) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace1);
        #dbg_trace1 = "";
    );
    (strlen(#dbg_trace2) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace2);
        #dbg_trace2 = "";
    );
    (strlen(#dbg_trace3) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace3);
        #dbg_trace3 = "";
    );
    (strlen(#dbg_trace4) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace4);
        #dbg_trace4 = "";
    );
    (strlen(#dbg_trace5) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace5);
        #dbg_trace5 = "";
    );
    (strlen(#dbg_trace6) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace6);
        #dbg_trace6 = "";
    );
    (strlen(#dbg_trace7) != 0) ? (
        mSL_log(SysLogBox, #dbg_trace7);
        #dbg_trace7 = "";
    );
);

efi = 1; idx = efs = 0;
while (efi) (
  (efi = gfx_getdropfile(idx, #s)) ? (
    efs = mSL_Str_Tmp();
    strcpy(efs, #s);
    dropped_x = mouse_x; dropped_y = mouse_y;
    //
    (FlagsTbVals[Flgs_Traces] & 2) ? (
        mSL_log(SysLogBox, efs);
        sprintf(#s, "   at: %d  %d    [%x]", dropped_x, dropped_y, mouse_cap);
        mSL_log(SysLogBox, #s);
    );
    // Try to localize the file in the project
    (strlen(#GM_Project_PathX) > 0) && match(#GM_Project_PathX, efs) ? (
        strcpy_from(#s, efs, strlen(#GM_Project_PathX)-1);
        // strcpy(efs, "./"); strcat(efs, #s);
        strcpy(efs, #s);
        // mSL_log(SysLogBox, efs);
    );
    // mSL_log(SysLogBox, efs);
    ui_GFXdoNow |= 1; // Make sure we react as soon as possible
    // Is this an mSL script ?
    (match ("*mSL", efs) || match ("*txt", efs)) ? (
        ((mouse_cap & 8) || (dropped_y < 32)) ? (
            sprintf(#s, "*  Compile: %s  (%d)  *", efs, strlen(efs)); mSL_log(SysLogBox, #s);
            doMslCompile(efs); // add to compile list
        ) : (
            strcpy(#efs, efs); // save in #efs
            dpi = 1; // an mSL file is available
        );
    ) :
    (match ("*wav", efs) || match ("*aif", efs) || match ("*flac", efs) || match ("*mp3", efs) || match ("*aiff", efs) || match ("*ogg", efs) || match ("*wmv", efs)) ? (
        strcpy(#efs, efs); // save in #efs
        dpa = 1; // an audio file is available
        //mSL_log(SysLogBox, "Matching sound file");
    );
    idx += 1;

  ) : (
    (efs != 0) ? gfx_getdropfile(-1);
  );
);


function do_GenericKeyRead()
(
    (KeyedT === 0) ? (KeyedT = Keyed; Keyed = 0; );
    (KeyedT === 0) ? (KeyedT = ui_key(); );
    (KeyedT > 0) ? AAAA_lastKeyedT = KeyedT;
    KeyedT;
);


(atomic_get(mSL_Lock) && (mSL_loc_tim <= 0))? (
    // we may have a GC to run
    (gc_run_phaz != 0) ? (
        (gc_run_phaz === 1) ? (
            gc_count += 1;
            (mSL_Dyn_Tr & 4) ? ( sprintf(#gfxu, "Starting a GC [free:%d  used:%d] ", mm_show_ttf, mm_show_ttu); mSL_log(SysLogBox, #gfxu); );
            mSL_loc_tim = max(2, mSL_loc_tim + 2); // no GC for some time
            // Perform a GC
            mSL_gc_start = time_precise() + timeD;
            mSL_errX = mSL_errC = 0;
            gc_start();
            gc_release_unused_thread();
            gc_mark_active();
            gc_mark(0); // make sure the last blocks have been checked
            // execute the sweep phase
            gc_sweep();
            gc_run_phaz = 3; // This is over
            mSL_gc_end = time_precise() + timeD;
            mSL_errX = max(mSL_errX, mSL_errC);
            ((FlagsTbVals[Flgs_GC] & 1) && mSL_errX) ? (
                sprintf(#gfxu, "GC Err: %d - Dur %.2f ms", mSL_errX,
                        1000 * (mSL_gc_end - mSL_gc_start));
                mSL_log(SysLogBox, #gfxu);
            );
            mSL_gc_MaxDur = max(mSL_gc_end - mSL_gc_start, mSL_gc_MaxDur);
        );
    ) :
    (
        // If we have a func to compile, do it A.S.A.P.
        (uuuMslFn != 0) ? (
            // Do we have enough memory to run a compilation ?
            !((gc_run_phaz > 1) || (mm_bl_huge > 0) || (mm_bl_big > 0) || (mm_bl_large >= 4) || (mm_bl_medium >= 64)) ? (
                // we may need a GC
                gc_run_phaz = 1; // start it
            ) : (
                ((mSL_active_Thread <= 0) && (uuuMslFent === 0)) ? (
                    // We are sure there are no active mSL thread...
                    // or compiler structure used
                    // and none can be started yet...
                    // look for a file to compile
                    uuuMslFname = 0;
                    ig = 0; while ((uuuMslFname === 0) && (ig < uuuMslTSiz)) (
                        (uuuMslFname = uuuMslTabs[ig]) ? (
                            uuuMslTabs[ig] = 0;
                        );
                        ig += 1;
                    );
                    (uuuMslFname === 0) ? ( // no file found to compile
                        uuuMslTPt = uuuMslFent = uuuMslFn = 0; // reset indicators
                    ) : (
                        uuuMslFent = mSL_load_file_inGFX(uuuMslFname);
                    );
                );
                mSL_loc_tim += 2; // again save some time
            );
        );


        // Do we have an mSL file loaded and compiled, ready to execute ?
        (uuuMslFent != 0) ? (
            (FlagsTbVals[Flgs_Scripts] & 1) ? (
                (mSL_errX === 0) ? (
                    // ready to introduce in the queue
                    sprintf(#s, "Loaded %s", uuuMslFname);
                ) : (
                    sprintf(#s, "File %s: err %d", uuuMslFname, mSL_errX);
                );
                mSL_log(SysLogBox, #s);
            );
            mSL_bl_clear(mSL_GC_Protected); // free compiler's structures
            uuuMslFent = 0;
            uuuMslLastFname = uuuMslFname;
            uuuMslFname = 0;
            atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
        );
    );

);




// Have we just achieved a GC ?
(gc_run_phaz > 2) ? (
    // gc is over
    gc_run_phaz = 0;
    mem_walk(0);
    (mSL_Dyn_Tr & 4) ? ( mem_show(); );
    FlagsTbVals[Flgs_GC] = 0;
    atomic_set(mSL_Lock,  max(0, mSL_Lock - 1));
);



//====== Scheduler management ======
while (ent = Scheduler()) (
    AAAA_Sch_code = code = SchedCode[ent];
    AAAA_Sch_par1 = par1 = SchedPar1[ent];
    AAAA_Sch_par2 = par2 = SchedPar2[ent];
    AAAA_Sch_par3 = par3 = SchedPar3[ent];
    AAAA_Sch_par3 = par4 = SchedPar4[ent];

    // do some work...

    (code & SchedWBit) ? (
        SchedCode[ent] &= SchedWBMask ; // suppress wait bit
        SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
        ent = 0;
    ) :
    (code === 1) ? (
        // A defered action to perform
        (par1 === 'task') ? (
            // introduce this task in active list
            // par2 can be an entry number (in 1... 4096) or an entry address
            zact = par2;
            ((par2 > 0) && (par2 < SchedNEmax)) ? (
                zact = SchedFirstEnt + SchedEntSiz * par2;
            );
            ((zact >= SchedFirstEnt) && (zact <= SchedLastEnt)) ? (
                // This refers to an entry to execute
                SchedInsertTail(SchedActivPts, zact, SchETypeThrd);
            );
            SchedPar2[ent] = 0; // ok
        ) :
        (par1 === 'smsg') ? (
            // send a message to some task.
            // par2 is supposed to be a message - this is checked by event_send_msg
            (SchETypeMess === mSL_Mbl_check(par2)) ? (
                SchevDateSent[par2] = 0; // clear send date
                event_send_msg(par2);
            );
            SchedPar2[ent] = 0; // message has been transmitted
        );
    ) :
    (code === 8) ? (
        // Run entry "0" of tasks
        k = 0; // should refer to a compiled code
        mSL_errX = 0;
        ((mSL_bl_check(k, Undef, 9793) === 0) && (k[mSL_CC_Key] === mSL_CC_KeyCKod)) ? (
            // try to execute the gizmo
            (ent = getNewThread()) ? (
                SchedPar1[ent] = k; // keep the code to execute
                SchedPar4[ent] = 0; // use current own variables
                SchedCode[ent] = KRun_mSL_Thread; // ready to start running a thread
                mSL_init_thread(ent);
            ) : (
                err_sys_rtm = 9606;
            );
            (mSL_errX === 0) ? (
                SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
                ent = 0;
            ) : (
                sprintf(#u, "Code 8: Ent: %d - Err: %04d", ent, mSL_errX);
                mSL_log(SysLogBox, #u);
                // ADump(k);
            );
        );
    ) :
    (code === 9) ? (
        // execute a delayed list of "simple actions"
        Simple_Action(par1);
    ) :
    (code === KRun_mSL_Thread)? ( // 10
        // A delayed mSL Thread
        // reintroduce the thread in the queue
        SchedInsertTail(SchedActivPts, ent, SchETypeThrd);

        // GMW2("E"); // *DBG*
        ent = 0;
    );
    // possibly free the entry
    ent ? SchedFree(ent); // appropriate free operation
);



/*
==== FILE HANDLING ====
*/
(fileReading) ? (


    gfxcycnt += 1;
    AAA_Count += 1;
    limitime = (startime = time_precise()) + timeAllow;



    while (fileReading && (time_precise() <= limitime)) (

        AAA_While += 1;
        gfxlpcnt += 1;



        // ::::::::::::::::::::::::::::::::::::::: 2- Start "decode"
        (GState === GSKReadPhase1) ? (
            xxalg = RState = 0; // For now
            FP_L = mSL_Max_Flgs; // default local mask
            // Clip flags
            PClass = gmem [UAdd+RCB_PClass]; // class, from partiel PClass
            SPAlgo = gmem[UAdd+RCB_SP_Algo] & 0xfffffff; // SPAlgo, from space mode
            SPAux = gmem[UAdd+RCB_SP_Aux] & 0xfffffff; // SPAux, from space mode
            PMod = gmem[UAdd+RCB_Algo_enu] & 0xfffffff; // PMod, from play mode

            playHold = ((PMod & 4) === 4); // hold playing until release
            ((PMod & 8) === 8) ? (gmem[UAdd+RCB_Cl_Flgs] |= pmFlagRepeat;); // Set repeat on

            AAA_Ph1 += 1;
            AAA_RRR = 0;
            GState = GSStFinal; // default

            // Check parameters -
            (Fhandle >= 0) ? (
                file_close(Fhandle);
                Fhandle = -1;
            );
            (FLgHandle >= 0) ? (
                file_close(FLgHandle);
                FLgHandle = -1;
            );


            // clClip = gmem [UAdd+RCB_ClipNb];
            clClip = gmem [UAdd+RCB_ClipNb];
            AAA_Ferrc1 = FErrc;
            cflag = (clClip >= 0) && (clClip < 10000) && (gmem[clInfStart+clClip] >= 0);


            (cflag) ? (

                AAA_Ph2 += 1;
                GState = GSStFinal; // default next state

                Fhandle = -1;

                CRSize = 0;
                Fformat = FErrc = CCCC = FFrRate = 0;
                FAdjRate = 1;

                (dirChangeNum != gmem[dirChange]) ? (
                    // we have changed the clip directory
                    dirChangeNum = gmem[dirChange]; // update our number
                    getexpldstr(0,0);
                    strcpy(#clNameFormat, #sct);
                );

                (TRC & 0x100) ? (
                    sprintf(#u, "Try clip %04d    (%d  %d)", clClip, gmem[UAdd+RCB_ClpName], UAdd+RCB_Alias_Name);
                    mSL_log(SysLogBox, #u);
                );

                // is the clip an alias ?
                (gmem[UAdd+RCB_ClpName] != 0) ? (
                    // decode the name
                    mSL_g6unpackArray(#fname, gmem[UAdd+RCB_ClpName], 0);
                    Fhandle = file_open(#fname);
                    (TRC & 0x100) ? (
                        sprintf(#u, "A-Open \"%s\" => %d", #fname, Fhandle);
                        mSL_log(SysLogBox, #u);
                    );
                    Fformat = 1;
                ) : (
                    // Do we already know the file format ?
                    fFo = (gmem[clClInfos+clClip] >> 8) & 0xf;

                    (fFo != 0) ? (
                        sprintf(#fname, #clNameFormat, clClip, fFormats[fFo]);
                        ug = file_open(#fname);
                        (TRC & 0x100) ? (
                            sprintf(#u, "C-Open \"%s\" => %d", #fname, ug);
                            mSL_log(SysLogBox, #u);
                        );
                    ) : (
                        ug = -1; ip = 0;
                        while ((ug < 0) && (ip < 15) && (fFormats[ip+1] != 0)) (
                            ip += 1;
                            sprintf(#fname, #clNameFormat, clClip, fFormats[ip]);
                            ug = file_open(#fname);
                        );
                        (ug >= 0) ? fFo = ip;
                    );
                    Fformat = fFo; // keep file format
                    Fhandle = ug;
                );

                (Fhandle >= 0) ? (
                    FileOpenCtr +=1;
                    file_riff(Fhandle, CCCC, FFrRate);
                    gmem [UAdd+RCB_CFty_enu] = Fformat; // keep file format
                    gmem [UAdd+RCB_CCCC] = CCCC; // keep channels count
                    gmem [UAdd+RCB_CFreq_sps] = FFrRate; // keep sample rate
                    (CCCC < 1) ? (
                        FErrc = 0401;
                    );
                    (CCCC > 64) ? (
                        FErrc = 0464;
                    );
                    ((FFrRate < 2400) || (FFrRate > 384000)) ? (
                        FErrc = 0433;
                    );
                    gmem [UAdd+RCB_CFrCorr_u] = FAdjRate = FFrRate / currSrate;
                    XMdP = 0;
                    // number of zero values samples to add at start and end of buffer
                    zCount = CCCC * (RZcnt + 2 * ceil(FAdjRate));
                    // CFSize : # of samples in the file
                    // CRSize : # of samples we will actually read, limited by buffer size,
                    //            file size, and and duration required
                    gmem[UAdd+RCB_CSiz_smp] = CRSize = CFSize = file_avail(Fhandle);
                    filDur = CFSize / CCCC / FFrRate;
                    //CRSize = min(clRdMaxD * FFrRate * CCCC,  CFSize);
                    (CFSize <= 480) ? (
                        FErrc = 0400;
                    ); // File too short
                    // Should we play => read the file integrally ?
                    //(PBFlgs & FLdoForceIntegral) ? (
                    //    CRSize = max(CRSize, CFSize);
                    //);
                    lgf = ((PMod & 1) === 1); // 1: try to use "long play" mode
                    ((CFSize + 2 * zCount) >= (M_avail)) ? (
                        // FErrc = 0499; // File too long
                        // ((lgf === 0) && (KmdKurrent === KmdPlay)) ? (
                        ((KmdKurrent === KmdPlay)) ? (
                            // Read long files mode
                            XMdP = 1;
                        ) : (
                            // else, clip files
                            AAA_clipped += 1;
                            CRSize = min(CFSize, (M_avail) - 2 * zCount);
                        );
                    );
                    ((PMod & 2)  === 2) ? XMdP = 2;
                    (TRC & 0x100) ? (
                        sprintf(#u, "Clp %04d [%d] => %d %d %d %d %d", clClip, FErrc, Fhandle, CCCC, FFrRate, CRSize, zCount);
                        mSL_log(SysLogBox, #u);
                    );

                    (FErrc == 0) ? (
                        // edit file info
                        sprintf(#finfo, "%d / %d / %s", CCCC, FFrRate, edTimeMs(CFSize/FFrRate/CCCC, 0x13));
                        // add initial zeroes
                        bAddr =  UBuffer;
                        loop (zCount, bAddr[0]=0; bAddr +=1;);
                        // bAddr is the address of the first sample of the file
                        ClTpl1st = 0|((bAddr - UBuffer) / CCCC); // 1st tupple in buffer
                        //XATP01Zbr = time_precise() + gmem[timeDelta];
                        //pcbZ10 =
                        AAA_readSteps = 0;
                        AAA_clipRead += 1;
                        bSize = CRSize; // size to read
                        currRdSize = frstRdsize; // start with that
                        (Fformat == 4) ? (
                            limitime = 0; // skip one turn : it seems that opening a mp3 takes a very long time...
                        );
                        ui_GFXdoNow |= 1;
                        (TRC & 0x100) ? (
                            (sprintf(#gfxu, "::-> Opened \"%s\"  %d / %d", #fname, FErrc, Fhandle); mSL_log(SysLogBox, #gfxu););
                        );
                    );
                    (FErrc != 0) ? (
                    (sprintf(#gfxu, "::-> Can't open \"%s\"  %d / %d", #fname, FErrc, Fhandle); mSL_log(SysLogBox, #gfxu););
                    );
                ) : (
                    // can't open the file
                    FErrc = 0404; // file not found
                    (sprintf(#gfxu, "::-> Can't open clip %04d \"%s\"  %d / %d", clClip, #fname, FErrc, Fhandle); mSL_log(SysLogBox, #gfxu););
                );

                // Update clip infos in gmem
                (cflag = (FErrc == 0)) ? (
                    gmem[clInfStart+clClip] += 1; // file seems to be available
                    gmem[clClInfos+clClip] = CCCC + (Fformat << 8)
                                + (FFrRate << 12); // keep # of channels and sample rate
                    gmem[clClSizes+clClip] = CFSize;  // keep file size in samples

                    GState =
                    (XMdP === 1) ? GSKReadPhase3 :
                    // (XMdP === 2) ? GSKReadPhase4 : GSKReadPhase2; // skip to appropriate phase
                    GSKReadPhase2; // skip to appropriate phase
                ) : (
                    gmem[clInfStart+clClip] = -FErrc; // file not available, keep error code
                    AAA_failopen += 1;
                    (sprintf(#gfxu, "::-> Can't open clip %04d \"%s\"  %d / %d", clClip, #fname, FErrc, Fhandle); mSL_log(SysLogBox, #gfxu););
                );

                gmem[UAdd+cbErC] = AAA_clipped + AAA_failopen;
                AAA_Ferrc2 = FErrc;
            ) : (
                // invalid/not found clip number
                FErrc = 0407;
            );
            AAA_Ph3 = 0;
        );




        //  :::::::::::::::::::::::::::::::::::::::  2- Read phase
        ((GState === GSKReadPhase2) && (FErrc === 0)) ? (
            AAA_Ph3 += 1;
            // We are ready to read a block of data
            // Stay in this phase while reading data
            ug = min(currRdSize, bSize); // size to read
            (ug > 0) ? (
                AAA_fh = Fhandle;
                vg = file_mem(Fhandle, bAddr, ug);
                AAA_u = ug;
                AAA_v = vg;
                AAA_RRR += vg;
                (ug != vg) ? (
                    FErrc = 0444;
                ) : (
                    bAddr += ug; bSize -= ug; currRdSize = maxRdSize;
                );
                AAA_readSteps += 1;
                AAA_clipSteps += 1;
            );

            (bSize <= 0) ? (
                // add final zeroes
                // bAddr is the address of the first added zero after the file
                ClTplLast = 0|((bAddr - UBuffer) / CCCC);  // last tupple in buffer + 1
                ClTplSize = ClTplLast - ClTpl1st; // what we where able to read
                ClTplSec = ClTplSize/FFrRate; // convert to seconds for the sample = max play dur at speed 1.
                loop (zCount, bAddr[0]=0; bAddr +=1;);
                ClTplLast2 = 0|((bAddr - UBuffer) / CCCC) - 1; // last tupple after the zeroes
                // UBuffer is logical "0", 1st tupple including added zeroes
                (TRC & 0x100) ? (
                    sprintf(#s, "Read end [%d] @ %d//%d -- %d tupples -- %s", AAA_Ph3, bAddr, fmemmax, ClTplSize, edTimeMs(ClTplSize/FFrRate, 0x13));
                    mSL_log(SysLogBox, #s);
                );
                file_close(Fhandle);
                Fhandle = -1;

                (cflag = (FErrc === 0)) ? (    // OK, go on
                    gmem[comPlClLast] = clClip; // keep the clip id.
                    gmem[UAdd+cbClipCnt] += 1; // count read clips
                    // RCB_CFrCorr_u ?
                    clOffset = 0; // initial tupple offset
                    ClLowLimit = ClTpl1st + clOffset;
                    ClHighLimit = ClTplLast;

                    (KmdKurrent === KmdPlay) ?
                    (
                        GState = (XMdP === 2) ? GSKReadPhase4 : GSKStartPlay ;
                    ) :
                    (KmdKurrent === KmdLoop) ?
                    (
                        GState = GSKStartLoop ;
                    ) :
                    (
                        GState = GSStFinal;
                    );
                    ui_GFXdoNow |= 1;
                ) : (
                    clClip = -1; // can't use the clip because of read problems
                    GState = GSStFinal;
                );
            );


        );



        //  :::::::::::::::::::::::::::::::::::::::  3- Start Read long phase
        ((GState === GSKReadPhase3) && (FErrc === 0)) ? (
            RState = 1; // For now
            RestSize = CFSize;
            (TRC & 0x100) ? (
                sprintf(#gfxu, "* %s * [%d] Long Read phase.  Rest: %d", #nowtim, RState, RestSize); mSL_log(SysLogBox, #gfxu);
            );
            FLgHandle = Fhandle; Fhandle = -1;
            // We are ready to read a block of data
            RdLngSize = floor(((M_avail) - 2 * zCount - 1) / (96000 * 3)) * 96000; // size for 3 buffers
            UBuffP1 = bAddr + zCount; // we have already read zCount zeroes
            UBuffP2 = UBuffP1 + RdLngSize;
            UBuffP3 = UBuffP2 + RdLngSize;
            // Read first block
            vg = file_mem(FLgHandle, UBuffP1, RdLngSize);
            //(RdLngSize != vg) ? (
            //    FErrc = 0454;
            //);
            RestSize -= vg;
            // Fake a full read buffer
            ClTplLast = (RdLngSize * 3 + zCount) / CCCC; // never to be reached
            ClTplSize = ClTplLast;
            ClTplSec = ClTplSize/FFrRate; // convert to seconds for the sample = max play dur at speed 1.
            ClTplLast2 = ClTplLast + (zCount / CCCC);
            GState = GSStFinal;

            gmem[comPlClLast] = clClip; // keep the clip id.
            gmem[UAdd+cbClipCnt] += 1; // count read clips
            // RCB_CFrCorr_u ?

            clOffset = 0; // initial tupple offset
            ClLowLimit = ClTpl1st + clOffset;
            ClHighLimit = ClTplLast;

            checkRCB();

            UBl = RdLngSize / CCCC;
            UBl1 = 128 + ClLowLimit;
            UBl2 = UBl1 + UBl;
            UBl3 = UBl2 + UBl;

            KmdPLast = KmdKurrent;
            (TRC & 0x100) ? (
                sprintf(#gfxu, "* %s * [%d] Start 'Long Play' mode  Rest: %d (%d)", #nowtim, RState, RestSize, ClTplSize);
                mSL_log(SysLogBox, #gfxu);
            );
            (FErrc === 0) ? (
                /*
                (FLgHandle >= 0) ? (
                    file_close(FLgHandle);
                    FLgHandle = -1;
                );
                */
                gmem [UAdd+RCB_CPStart_tim] = gfxPlayT = gfxStrtT = gfxCurrT;
                genCount += 1;
                playCount += 1;
                xxcnt = 0;
                currColor = Player_Color_Set[0]; currColState = Player_Color_cnt; currColVar = 0;
                gmem[UAdd+RCB_Color] = currColor[currColState];
                smplClear(); // clear events [only for tests]
                sactClear();
                sactAdd(genAlgo | 6, 1); // new play mode
                chGenCnt = CCCC; // only generating this count of channels
                mkSPAlgo();
                pflg = 1;
                evLState = 1; // start
                evLScnt = 0;
                pvolEv = 0;
                pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // decrement
                ClRIndex = gmem [UAdd+RCB_StartIndex];
                saveEntry(); // save entry in playlog before starting playing
                update_dynpars();
                SmpPStart = max(currSmpl, gmem[UAdd+RCB_SmpPStart]);
                //((TRC & 4)) ? (
                    sprintf(#dbg_trace0, "   ");
                    sprintf(#dbg_trace3, "* %s * Start playing for %.3fs at {%.0f}", #nowtim, clDur, SmpPStart);
                    sprintf(#dbg_trace4, "* CT %.1f Sp %.3f FI %.1f FO %.1f", CTSize, SpdFact, FInDur, FOutDur);
                    sprintf(#dbg_trace5, "* cl %04d cD %.3f xD %.3f FO %.3f", clClip, clDur, xdur, FOutDur/1000);
                //);
                gmem[UAdd+cbStat] = uSBusy;  // playing
                (TRC & 0x100) ? (
                        sprintf(#gfxu, "* %s * [%d] ActivePlaying 'Long Play' mode", #nowtim, RState);
                        mSL_log(SysLogBox, #gfxu);
                );
                reapeat = 0;
                RState = 2;
                playHold ? (
                    GState = GSKPlayHold;
                ) : (
                    ActivePlaying = 1; // really ready to play !
                );
            );
        );




        //  ::::::::::::::::::::::::::::::::::::::: Start "Slow Play" mode
        ((GState === GSKReadPhase4) && (FErrc === 0)) ? (
            sprintf(#dbg_trace1, "Start 'Slow Play' mode   (%d)", ClTplSize);

            GState = GSStFinal;

            checkRCB();

            KmdPLast = KmdKurrent;
        );



        //  ::::::::::::::::::::::::::::::::::::::: Start "Play" mode
        ((GState === GSKStartPlay) && (FErrc === 0)) ? (
            (TRC & 0x80) ? sprintf(#dbg_trace1, "Start 'Play' mode   (%d)", ClTplSize);
            AAA_Spl += 1;
            GState = GSStFinal;

            checkRCB();

            KmdPLast = KmdKurrent;

            (TRC & 0x80) ? (sprintf(#dbg_trace2, "Play *  Err: %04d  Hndl: %d  Stat: %d", FErrc, Fhandle, gmem[UAdd+cbStat]););

            (FErrc === 0) ? (
                gmem [UAdd+RCB_CPStart_tim] = gfxPlayT = gfxStrtT = gfxCurrT;
                genCount += 1;
                playCount += 1;
                xxcnt = 0;
                currColor = Player_Color_Set[0]; currColState = Player_Color_cnt; currColVar = 0;
                gmem[UAdd+RCB_Color] = currColor[currColState];
                smplClear(); // clear events [only for tests]
                sactClear();
                sactAdd(genAlgo | 6, 0); // new play mode
                chGenCnt = CCCC; // only generating this count of channels
                mkSPAlgo();
                pflg = 1;
                evLState = 1; // start
                evLScnt = 0;
                pvolEv = 0;
                pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // decrement
                ClRIndex = gmem [UAdd+RCB_StartIndex];
                saveEntry(); // save entry in playlog before starting playing
                update_dynpars();
                SmpPStart = max(currSmpl, gmem[UAdd+RCB_SmpPStart]);
                // We want an event just before the fade out start
                // xdur = min(clDur, CTSize / SpdFact); // in seconds
                // SmpFOStrt = 0|(SmpPStart + (clDur - FOutDur/1000) * currSrate); // as sample
                // smplNewEV(SmpFOStrt, 1, 0, 0);
                SmpFOStrt = 0|(SmpPStart + (clDur - FOutDur/1000) * currSrate); // as sample
                smplNewEV(SmpFOStrt, 3, 0, 0); // run event 3 at that date
                //ii = max(0, min(96, 48 + gmem[paramGCopy+p_Transpose]));
                // ClRIndInc = clRSpeed * FAdjRate * scale_12TET[ii];
                //((TRC & 4)) ? (
                    sprintf(#dbg_trace0, "   ");
                    sprintf(#dbg_trace3, "* %s * Start playing for %.3fs at {%.0f}", #nowtim, clDur, SmpPStart);
                    sprintf(#dbg_trace4, "* CT %.1f Sp %.3f FI %.1f FO %.1f", CTSize, SpdFact, FInDur, FOutDur);
                    sprintf(#dbg_trace5, "* cl %04d cD %.3f xD %.3f FO %.3f", clClip, clDur, xdur, FOutDur/1000);
                    sprintf(#dbg_trace6, "* End {%.0f} in %.0f", SmpFOStrt, SmpFOStrt-SmpPStart);

                //);
                gmem[UAdd+cbStat] = uSBusy;  // playing
                0 ? sprintf(#dbg_trace6, "ActivePlaying 'Play' mode");
                reapeat = 0;
                playHold ? (
                    GState = GSKPlayHold;
                ) : (
                    ActivePlaying = 1; // really ready to play !
                );
            );

        );




        // ::::::::::::::::::::::::::::::::::::::: Start "Loop" mode
        ((GState === GSKStartLoop) && (FErrc === 0)) ? (
            (TRC & 0x100) ? (
                0 ? sprintf(#dbg_trace1, "Start 'Loop' mode   (%d)", ClTplLast);
            );

            AAA_Slp += 1;
            GState = GSStFinal;
            pCount = 0; doGen = 1;
            gmem[UAdd+cbUSt] = UStime = time_precise() + gmem[timeDelta]; // we started playing at that time

            checkRCB();

            0 ? (sprintf(#dbg_trace5, "Loop *  Err: %04d  Hndl: %d  Stat: %d", FErrc, Fhandle, gmem[UAdd+cbStat]););

            (FErrc === 0) ? (
                gmem [UAdd+RCB_CPStart_tim] = gfxPlayT = gfxStrtT = gfxCurrT;
                genCount += 1;
                loopCount += 1;
                xxcnt = 0;
                currColor = Player_Color_Set[1]; currColState = Player_Color_cnt; currColVar = 0;
                gmem[UAdd+RCB_Color] = currColor[currColState];
                KmdPLast = KmdKurrent;
                GCBactM = -1; // max. indice of active pointers
                grBnum = -1;
                smplClear(); // clear events [only for tests]
                sactClear(); // Clear operations stack
                sactAdd(genAlgo | 5, 0); // new loop 2
                mkSPAlgo();
                // Clear the loop buffers
                memset(GCBArray, 0, GCBArraySiz);
                evLState = 1 | 4; // and run a first grain
                evLScnt = 0;
                pvolEv = 0;
                pvolInc = 1 / max(10, FInDur * currSrate / 1000); // increment
                pvolDec = - 1 / max(10, FOutDur * currSrate / 1000); // decrement
                memset(GCBacts, 0, NumbGr); // reset all active pointers
                saveEntry(); // save entry in playlog
                update_dynpars();
                SmpPStart = max(currSmpl, gmem[UAdd+RCB_SmpPStart]);
                SmpFOStrt = 0|(SmpPStart + (clDur - FOutDur/1000) * currSrate); // when to start fading out as sample

                // ii = max(0, min(96, 48 + gmem[paramGCopy+p_Transpose]));
                // ClRIndInc = clRSpeed * FAdjRate * scale_12TET[ii];
                // GrLen = max(3, 0|((FP_GL_Gmin + FP_GL_Gmax) * 0.5) * FP_GL_GSiz * currSrate / 1000); // !!!!
                GrXpectX = 1;
                // Reshape shapes if necessary
                ((FP_F & smUFlagGrISh) && (FP_G_FI_Shp != gmem[paramGCopy+p_Dyn_GrFISh])) ? (
                    FP_G_FI_Shp = gmem[paramGCopy+p_Dyn_GrFISh];
                    buildShape(GrShpIn, FP_G_FI_Shp);
                );
                ((FP_F & smUFlagGrOSh) && (FP_G_FO_Shp != gmem[paramGCopy+p_Dyn_GrFOSh])) ? (
                    FP_G_FO_Shp = gmem[paramGCopy+p_Dyn_GrFOSh];
                    buildShape(GrShpOut, FP_G_FO_Shp);
                );
                (TRC & 4) ? (
                    sprintf(#dbg_trace0, "* %s * Start playing for %.3fs / %.3fs at {%.0f} [%.0f]", #nowtim, clDur,
                                    GrLen/currSrate, SmpPStart, currSmpl);
                );
                gmem[UAdd+cbStat] = uSBusy;  // playing
                manageGrainsMods(0xf);
                GrLen = GrMLen;
                smplNewEV(SmpFOStrt, 3, 0, 0); // we should start fading out at that date
                reapeat = 0;
                1 ? sprintf(#dbg_trace2, "ActivePlaying 'Loop' mode -- %d  %.3f", GrLen, GrXpect * GrXpectX);
                trcNL2 = 1; status = 8; lpSmplCnt = 0;
                playHold ? (
                    GState = GSKPlayHold;
                ) : (
                    ActivePlaying = 1; // really ready to play !
                );
            );

        );




        //  ::::::::::::::::::::::::::::::::::::::: Read block for long play
        (GState === GSStReadBlck) ? (
            (TRC & 0x100) ? (
                sprintf(#gfs_mss, "* %s * [%d] Long Play Rd Block  Rest [%d => %d", #nowtim, RState, FLgHandle, RestSize);
                mSL_log(SysLogBox, #gfs_mss);
            );
            ((RState === 3) || (RState === 5)|| (RState === 9)) ? (
                UBA = (RState === 3) ? UBuffP2 : (RState === 5) ? UBuffP3 : UBuffP1 ;
                vg = file_mem(FLgHandle, UBA, RdLngSize);
                pt = UBA + vg;
                RestSize -= vg;
                (RestSize <= 0) ? (
                    (TRC & 0x100) ? (
                        sprintf(#gfs_mss, "* %s * [%d] File End [=> %d", #nowtim, RState, RestSize);
                        mSL_log(SysLogBox, #gfs_mss);
                    );
                    // last block of file -- Add some zeroes
                    // new High Limit
                    ClHighLimit = (pt - UBuffer) / CCCC;
                    loop (zCount, pt[0]=0; pt +=1;);
                    // what should we do next ?
                    (gmem[UAdd+RCB_Cl_Flgs] & pmFlagRepeat) ? (
                        // we will be restarting the read
                        (RState === 3) ? (
                            // we are using B1, B2 just read.
                            // Copy B2 to B3
                            memcpy(UBuffP3, UBuffP2, RdLngSize);
                            // Copy B1 to B2
                            memcpy(UBuffP2, UBuffP1, RdLngSize);
                            file_rewind(FLgHandle);
                            RestSize = CFSize; // restart with new length
                            (TRC & 0x100) ? (
                                sprintf(#gfs_mss, "* %s * [%d] Restart A [=> %d", #nowtim, RState, RestSize);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                            ClHighLimit += UBl; // move limit further to restart correcty
                            RState = 7; // adjust safely pointer from B1 to B2
                        ) :
                        (RState === 5) ? (
                            // We are using B2, B3 just read.
                            // We can read buffer in B1
                            file_rewind(FLgHandle);
                            RestSize = CFSize; // restart with new length
                            vg = file_mem(FLgHandle, UBuffP1, RdLngSize);
                            RestSize -= vg;
                            (TRC & 0x100) ? (
                                sprintf(#gfs_mss, "* %s * [%d] Restart B [=> %d", #nowtim, RState, RestSize);
                                mSL_log(SysLogBox, #gfs_mss);
                            );
                            RState = 11; // quasi begin situation
                        );
                    ) : (
                        // file_close(FLgHandle); FLgHandle = -1;
                        (TRC & 0x100) ? (
                            sprintf(#gfs_mss, "* %s * [%d] Ending [=> %d", #nowtim, RState, RestSize);
                            mSL_log(SysLogBox, #gfs_mss);
                        );
                        RState = 8;
                    );
                ) : (
                    (RState === 3) ? (
                        RState = 4;
                    ) :
                    (RState === 5) ? (
                        // copy buffer 3 to buffer 1
                        memcpy(UBuffP1, UBuffP3, RdLngSize);
                        RState = 6;
                    ) :
                    (RState === 9) ? (
                        // B1 just read
                        RState = 11; // quasi begin situation
                    );
                );
                (TRC & 0x100) ? (
                    sprintf(#gfs_mss, "* %s * [%d] Rest [=> %d", #nowtim, RState, RestSize);
                    mSL_log(SysLogBox, #gfs_mss);
                );
            );
            GState = GSStInactive;
            fileReading = 0;
        );



        // ::::::::::::::::::::::::::::::::::::::: Final state
        (GState === GSStFinal) ? (

            AAA_Fin += 1;
            (TRC & 0x100) ? (
                sprintf(#gfs_mss, "* %s * Final *  Err: %04d  Hndl: %d  Stat: %d", #nowtim, FErrc, Fhandle, gmem[UAdd+cbStat]);
                mSL_log(SysLogBox, #gfs_mss);
            );
            // check status, close file if necessary
            ((gmem[UAdd+cbStat] == uSStarting) || (FErrc != 0)) ? (
                ActivePlaying = 0;
                Pmode = mdInactive;
            );
            (Fhandle >= 0) ? (
                file_close(Fhandle);
                Fhandle = -1;
            );
            GState = GSStInactive;
            gmem[UAdd+cbERR] = FErrc;
            fileReading = 0; // stop anyway
        );



        (GState === GSKPlayHold) ? (
            (playHold === 0) ? (
                GState = GSStInactive;
                fileReading = 0;
                ActivePlaying = 1; // really ready to play !
            );
        );


        (GState === GSStInactive) ? (
            fileReading = 0;
        );




        (FErrc != 0) ? (
            gmem[UAdd+cbERR] = FErrc;
            sprintf(#gfs_mss, "* %s * [%d] Error [=> %d", #nowtim, RState, FErrc);
            mSL_log(SysLogBox, #gfs_mss);
            GState = GSStInactive;
            fileReading = 0;
            FErrc = 0;
        );


    );


    AAA_Time += time_precise() - startime ;
    (AAA_Ferr === 0) ? AAA_Ferr = FErrc;


);


actlflg ? (
    evalActions(actlOut);
    switchActions();
    sprintf(#gfs_mss, "* %s * Switch Actions", #nowtim);
    mSL_log(SysLogBox, #gfs_mss);
);



// Unlock all waiting processes after a "load" or a "gc"
while (SchedListNonEmpty(SchedLockdPts) && (atomic_get(mSL_Lock) === 0)) (
    SchX = SchedDetachHead(SchedLockdPts);
    SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
);



XeSched = 1; // set to 1 to make sure we execute at least 1 task during each block execution
/*=======
==== GLOBAL Interpreter ====
*/
while (SchedActive &&
    ((((TLeft = gfxMaxDur + gfxCurrT - (gstrt = time_precise() + timeD)) > 0)) || XeSched) &&
    ((SchX = SchedDetachHead(SchedActivPts)) != SchedNone))
(
    // Get some parameters
    // Execute the action
    XeSched = 0;
    xop = SchedCode[SchX];   // actually, only 1 to 13 are being used
    curr_Proc_PID = SchedPid[SchX]; // current process ident
    curr_Proc_Name = SchedThrName[SchX]; // current process name
    mSL_xop_cnt = (mSL_xop_cnt + 1) % 1000000;


    (xop === 10) ? (
        //++++10++++//
        //====== mSL EXECUTION ======
        // mSL_errX=10;
        mSL_dispatch_entry = SchX;
        atomic_get(mSL_Lock) ? (
            // We are doing some exclusive operation. mSL Threads are not allowed to execute
            SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd); // insert the thread in locked pts
            SchX = -1;
        ) : (
            tstrt = time_precise() + timeD;
            mSL_active_Thread = SchedThrdPt[SchX]; // the thread
            ((SchedStatus[mSL_dispatch_entry] & SchmSLThrUsed) != SchmSLThrUsed) ? (
                (mSL_errX === 0) ? mSL_errX = 3381; // thread not noted active ?
            );
            mSL_load_thread(mSL_active_Thread);
            mSL_max_TOS = mSL_active_Thread[mSL_THR_basePhStack];

            (mSL_errX != 0) ? (
                thread_error(mSL_active_Thread, mSL_errX, SchX);
            ) : (
                mm_xec_mm[mm_xec_ptr] -=  mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] -=  mSL_ICount;
                // Curr_Block_Alloc
                AAAAAAAA_mSL_rpeat = mSL_rpeat = max(8192, min(16384, 0|(mSL_insts_per_s * TLeft * 0.35)));
                mSL_evaluate();
                AAAAAAAA_mSL_evaluate_count += 1;
                mSL_High_Stack = max(mSL_High_Stack, mSL_max_TOS - mSL_active_Thread[mSL_THR_basePhStack]);
                // sprintf(#uuu, "End of evaluation - CR: %d - XC: %d", mSL_CodeStop, AAAAAAAA_mSL_evaluate_count);
                // mSL_log(SysLogBox, #uuu);
                // GMW2("B");
                mSL_save_thread(mSL_active_Thread);
                ((mSL_CodeStop === 0) || (mSL_CodeStop === mSL_RC_Yield)) ? (
                    // reintroduce the thread in the queue
                    SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Wait) ? (
                    (mSL_WaitDuration > 0) ? (
                        // introduce the entry in the wait queue
                        Schedule(SchedRelative, mSL_WaitDuration, 0, SchX, 0, 0, 0);
                    ) : (
                        // reintroduce the thread in the queue
                        SchedInsertTail(SchedActivPts, SchX, SchETypeThrd);
                    );
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_Stop) ? (
                    // finished, free the thread
                    //
                    freeSchedThread(SchX);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    mSL_dispatch_entry = SchX = -1;
                    flagCheckMemory = 1;
                ) :
                (mSL_CodeStop === mSL_RC_WEvent) ? (
                    // introduce the entry in the wait queue
                    SchedInsertTail(SchedEvntPts, SchX, SchETypeThrd);
                    (FlagsTbVals[Flgs_Thrds] & 2) ? ( // trace flags
                        sprintf(#s, "Insert in Evnt : ent: %d thrd: %d siz: %d ", SchX, mSL_active_Thread, SchedListSize(SchedEvntPts));
                        mSL_log(SysLogBox, #s);
                    );
                    AAAAA__Schx = Schx;
                    AAAAA__SchxNum = ent[SchedPid] & SchedNMask;
                    SchX = -1;
                ) :
                (mSL_CodeStop === mSL_RC_WAITGC) ? (
                    // introduce in the wait for GC list
                    SchedInsertTail(SchedLockdPts, SchX, SchETypeThrd);
                    SchX = -1;
                ) :
                (
                    //AAAAAAAA_Errx = mSL_errX;
                    thread_error(mSL_active_Thread, mSL_errX, mSL_CodeStop);
                    // SchedStatus[SchX] &= SchThrNotUsed;
                    // SchedInsertTail(SchedInactPts, SchX, SchETypeThrd);
                    // sprintf(#uuu, "End of evaluation [%d]  CR: %d  Err: %d", SchX, mSL_CodeStop, mSL_errX);
                    (mSL_wbl != 0) ? (
                        sprintf(#uuu, "Block damaged @ %d", mSL_wbl);mSL_log(SysLogBox, #uuu);
                    );
                    mSL_error_analysis(mSL_active_Thread);
                    SchedFree(SchX);
                    SchX = -1;
                    flagCheckMemory = 1;
                    mSL_errC = 0; mSL_errX = 1717; // "error previously detected"
                    mSL_errX = 0; // let other threads progress
                );
                mm_xec_mm[mm_xec_ptr] += mSL_ICount;
                mm_cyc_mm[mm_cyc_ptr] += mSL_ICount;
            );
            mm_dur_mm[mm_cyc_ptr] += time_precise() + timeD - tstrt;
        );
        mSL_active_Thread = -1;

        //++++10++++//
    );



    SchX > 0 ? SchedFree(SchX);
);





// ====== Actual GUI part ======
function
show_Kmd(nb)
(
    (nb === KmdPlay) ? "Play" :
    (nb === KmdLoop) ? "Loop" :
    (nb === KmdNone) ? "None" :
    (nb === KmdStop) ? "Stop" :
    (nb === KmdQStop) ? "STOP!" :
    (sprintf(#Kmd, "Cmd=%d", nb); #Kmd;);
);

function showHPSet(nset, nbh, hpl)
local(z, w, i)
(
    z = #; w = #;
    sprintf(z,"HP%d[%d]", nset, nbh);
    loop(i=0; min(15, nbh),
        sprintf(w, " %d", 1+hpl[i]);
        strcat(z,w);
        i += 1;
    );
    z;
);


function
show_local_block(bn, lnb)
local (siz)
(
    siz = 0;
    (bn === 0) ? (
        siz += 1; ui_show("Track/Player/U.", GMFXTrack, (1+gmem[UAdd+cbPlIdt]) * ((gmem[UAdd+cbInacFlg] > 2) ? -1 : 1), UId, "%d / %d / %d");
        siz += 1; ui_show("Unit Activity", UAdd, CheckNum, gmem[UAdd+cbInacFlg], "%d / %d / %d");
        siz += 1; ui_show("Up time / Status", #nowtim, statNames[gmem[UAdd+cbStat] & statMask], "%s / %s");
        siz += 1; ui_show("Mouse", mouse_x, mouse_y, gfx_ext_retina , "%d  /  %d  /  %d");
        siz += 1; ui_show("Clip Seq.", gmem[UAdd+RCB_GClipSeq], "%d");
        siz += 1; ui_show("Partiel/PlM/SpM",gmem[UAdd+RCB_CPart_nbr], gmem[UAdd+RCB_CPlMd_nbr], gmem[UAdd+RCB_CSpMd_nbr], "%d / %d / %d");
        siz += 1; ui_show("Source file", #finfo, "%s");

        siz += 1; (CFSize > M_avail) ? (
            ui_jshow_color = (XMdP == 1) ? ui_jcolor_active : ui_jcolor_error;
        );
        ui_show("Need", CFSize, M_avail, "%d / %d");

        strcpy(#t1, edTimeMs(gfxPlayT - gfxStrtT, 0x13));
        siz += 1; ui_show("Playtime", #t1, edTimeMs(clDur, 0x13), "%s / %s");
        siz += 1; ui_show("PlayDur", edTimeMs(clAsk, 0x13), edTimeMs(clLng, 0x13), "%s / %s");
    ) :
    (bn === 1) ? (
        (0[0] !== 'MAIN') ? (
            ui_jshow_color = ui_jcolor_error;
            siz += 1;  mSL_edit_value(#s0, 0[0]); sprintf(#s1, "MAIN: %s", #s0); ui_show(#s1);
        );
        siz += 1; ui_show("State", gmem[UAdd+cbType], gmem[UAdd+cbStat], "%d / %d");
        siz += 1; ui_show("Xperiod", xCount, xIncrement, xDecrement, "%0.4f / %0.4f / %0.4f");
        siz += 1; ui_show("GFX", gfx_w, gfx_h, g_remain_h, "%d / %d  (%d)");
        //siz += 1; ui_show("Gstate", GState, gmem[UAdd+cbLocPrime], "%d  |  %d");
        siz += 1; ui_show(#clNameFormat);
        siz += 1; ui_show(#gfx_uc);
        (AAA_Ferr + mSL_StM_Err + ErrorScreen !== 0) ? (ui_jshow_color = ui_jcolor_error;);
        siz += 1; ui_show("Errs", AAA_Ferr, mSL_StM_Err, ErrorScreen, "%04d  |  %04d  |  %04d");
        siz += 1; ui_show("Rd/cnt", gfxcycnt, gfxlpcnt, "%02d  |  %02d");
        siz += 1; ui_show("Trace", GState, RState, Fhandle, FLgHandle, "%d / %d / %d / %d");
    ) :
    (bn === 2) ? (
        siz += 1; ui_show("Kmds", KmdLastDate, KmdLastIn,  KmdKurrent,  "%d : %d | %d");
        siz += 1; ui_show("Gen", playCount,  loopCount,  genCount,  "%d  |  %d  |  %d");
        siz += 1; ui_show("HPCnt", HPCnt1, HPCnt2, CCCC, chOutCnt, "%d : %d : %d -> %d");
        siz += 1; ui_show("ChGen", CCCC, num_ch, hpfold, chGenCnt, "%d : %d : %d -> %d");
        siz += 1; ui_show("ChSrc", chused1, chused1, chGenCnt, "%d : %d / %d");
        ui_show(showHPSet(1, HPCnt1, Chans1));
        ui_show(showHPSet(2, HPCnt2, Chans2));
    ) :
    (bn === 3) ? (
        siz += 1; ui_show("Memory", mm_show_ttu, mm_show_ttf, "%d / %d");
        siz += 1; ui_show("Blocks", mm_show_frbl, mm_show_usbl, mm_show_flr, mm_show_dmg, "%d / %d / %d / %d");
        siz += 1; ui_show("Alloc", AAA_C__1, AAA_M_ptw, AAA_M_bs, AAA_M_tailsize, "%d  %d  %d  %d");
        siz += 1; ui_show("GC", gc_count, mSL_Dyn_LogCnt, mSL_Dyn_fLogCnt, mSL_Dyn_rLogCnt, "%d / %d / %d / %d");
        siz += 1; ui_show("Options", mSL_Dyn_RecycleF, mm_show_limit, (0|(100*mm_show_ratio))/100, "rcy:%d / lim:%.2f:%.2f");
        siz += 1; ui_show("D-Strings", mSL_Str_CFree, mSL_Str_CUsed, "%d / %d");
        siz += 1; ui_show("P-Strings", mSL_Str_PCFree, mSL_Str_PCUsed, "%d / %d");
        siz += 1; ui_show("T-Strings", mSL_Str_TCFree, mSL_Str_TempU, "%d / %d");
        siz += 1; ui_show("Act. Threads", mSL_act, mSL_maxact, "%d / Max:%d");
        siz += 1; ui_show("Inact. Threads", mSL_inactv, mSL_wait, mSL_plck, "F:%d / W:%d / L:%d");
    ) :
    (bn === 4) ? (
        siz += 1; v = gmem[UAdd+cbStat] & statMask; (v> 1) ? ui_jshow_color = ui_jcolor_active;
        ui_show("Clip",clClip, show_Kmd(gmem[UAdd+RCB_cbCKmd]), statNames[v],  "%04d / %s / %s");
        siz += 1; ui_show("Duration", edTimeMs(CFSize / CCCC / FFrRate, 0x13), CFSize, "%s / %d");
        siz += 1; ui_show("Required", edTimeMs(gmem[UAdd+RCB_PlayTime_sec], 0x13), edTimeMs(clDur, 0x13),  "%s / %s");
        siz += 1; ui_show("Reading", edTimeMs(CRSize / CCCC / FFrRate, 0x13), CRSize, XMdP, "%s / %d:%d");
        // siz += 1; ui_show("Cl. range", CLStartPC, CLEndPC, "%.3f%%/ %.3f%%");
        siz += 1; ui_show("Dyn. X-Pan", gmem[UAdd+RCB_Pan], "%.3f");
        siz += 1; ui_show("Position", ClLowArea, ClRIndex, ClHighArea, "%d : %d : %d");
        siz += 1; ui_show("Max Limits", ClLowLimit, ClHighLimit, "[%d   %d]");
        siz += 1; ui_show("C.srate/SpdF", currSrate, SpdFact, "%.2f / %.2f");
    ) :
    (bn === 5) ? (
        siz += 1; ui_show("Grains Dur.", gmem[UAdd+RCB_MinGrains_ms], gmem[UAdd+RCB_MaxGrains_ms], "%.2f ms / %.2f ms");
        siz += 1; ui_show("Init Fades", gmem[UAdd+RCB_GrFdIn_ms], gmem[UAdd+RCB_GrFdOut_ms], "%.2f ms / %.2f ms");
        siz += 1; ui_show("Used Fades", GrFIn/currSrate, GrFOut/currSrate, "%.2f ms / %.2f ms");
        siz += 1; ui_show("GrMLen", GrMLen, GrMLen/currSrate, "%d / %.7f s");
        siz += 1; ui_show("Rpt. Cycle", ti/currSrate, "%.7f s");
        siz += 1; ui_show("Gr.Fad.I.O.", gmem[UAdd+RCB_GrFdIn_ms], gmem[UAdd+RCB_GrFdOut_ms], "%d / %d");
        siz += 1; ui_show("Gr.Depth", gmem[UAdd+RCB_MinNGrains_u], A_Gp_ct, GrXpect, gmem[UAdd+RCB_MaxNGrains_u], "[%d  %d/%.1f  %d]");
        siz += 1; ui_show("Sample Cnt", lpSmplCnt, "%.0f");
        siz += 1; ui_show("Env.Inc.", EnvInc, "%.5f");
    ) :
    (bn === 6) ? (
        siz += 1; ui_show("Pmode", Pmode, "%X");
        siz += 1; ui_show("Volume", gmem [UAdd+RCB_VolumeTarget_dB], FP_GlobVol, "%.4f dB / %.4f");
        siz += 1; ui_show("Vol.Fact", lvol, pvol, pvolEv, "%.4f  %.4f  %.4f");
        siz += 1; ui_show("Src Speed", gmem [UAdd+RCB_PmMdSpd1], gmem [UAdd+RCB_PmMdSpd2], gmem [UAdd+RCB_PmMdSpd3], "%.4f / %.4f / %.4f");
        siz += 1; ui_show("Speed", gmem [UAdd+RCB_SpeedAbs_u], clRSpeed, "%.4f -> %.4f");
        siz += 1; ui_show("Rd. index", ClRIndex, ClRIndInc, "%.5f + %.5f");
        siz += 1; ui_show("Limit index", ClTpl1st, ClTplLast, "%.0f / %.0f");
        siz += 1; ui_show("Src Duration", gmem [UAdd+RCB_PmMdDur1], gmem [UAdd+RCB_PmMdDur2], gmem [UAdd+RCB_PlayTime_sec], "%.2f / %.2f : %.2f");
    ) :
    (bn === 7) ? (
        siz += 1; ui_show("Grains Siz.", gmem[UAdd+RCB_MinGrains_ms], gmem[UAdd+RCB_MaxGrains_ms], "%d / %d");
        siz += 1; ui_show("Grains SVar.", FP_GL_GSiz, "%0.4f");
        siz += 1; ui_show("Extract", GCBL[gClLowLimit], GCBL[gClHighLimit], "%.1f / %.1f");
        siz += 1; ui_show("CFSize/CRSize", CFSize, CRSize, "%.0f / %.0f");
        siz += 1; ui_show("CTSize * CC", CTSize, CCCC, "%.0f * %.0f");
        siz += 1; ui_show("GM / GS / GP", FP_G_PMass, FP_GL_GSiz, FP_G_PPos, "%.4f / %.4f / %.4f");
        siz += 1; ui_show("Smpl Ptr", smplXPtr, smplXPtrMax, "%d / %d");
    ) :
    (bn === 8) ? (
        siz += 1; ui_show("Flags", FP_F, PBFlgs, "%06X / %06X");
        siz += 1; ui_show("Par.Flg",  gmem[UAdd+RCB_PM_Flgs1], gmem[UAdd+RCB_PM_Flgs2], "%06X / %06X");
        siz += 1; ui_show("Dbg.Flg",  gmem[UAdd+RCB_Cl_Flgs], gmem[UAdd+RCB_PlyerFlgs], "%06X / %06X");
        siz += 1; ui_show("Channels", gmem[UAdd+RCB_Channels_cnt_used1], "%d");
        siz += 1; ui_show("SM Algo", gmem[UAdd+RCB_SP_Algo], gmem [UAdd+RCB_SP_Aux], "%04X . %04X");
        siz += 1; ui_show("Gr.Size 0-3", Gr0, Gr1, Gr2, Gr3, "%.0f / %.0f / %.0f / %.0f");
        siz += 1; ui_show("Gr.Size 4-7", Gr4, Gr5, Gr6, Gr7, "%.0f / %.0f / %.0f / %.0f");
        siz += 1; ui_show("Gr.Shapes", FP_G_FI_Shp, FP_G_FO_Shp,  "%.5f / %.5f");
    ) :
    (bn === 9) ? (
        siz += 1; ui_show("Start", gmem [UAdd+RCB_StartIndex], "%.3f");
        siz += 1; ui_show("Play Limits", ClLowArea, ClHighArea, "[%.0f   %.0f]");
        siz += 1; ui_show("Vol max Limits", ClLowLimit, ClHighLimit, "[%.0f   %.0f]");
        siz += 1; ui_show("Sample #", currSmpl, "%.2f");
        siz += 1; ui_show("S.Evnt #", smplEvCnt, "%d");
        siz += 1; ui_show("Conf", nblig, nbcol, glIsiz0, glIsiz1, "%d / %d : %d / %d");
        // siz += 1; ui_show("A. Ops.", xPtr, sactACnt, "%d : %.0f");
        siz += 1; ui_show("Upd.Flg", smUpdateFlag, smUpdateFlagCP, "%06X / %06X");
        siz += 1; ui_show("Play.Pos/V", FP_G_PPos, FP_G_PVar, "%.2f%% / %.2f%%");
        siz += 1; ui_show("Gr Top/SL", FP_GL_GTWd, FP_GL_Slant, "%.2f%% / %.2f%%");
    ) :
    (bn === 10) ? (
        siz += 1; ui_show("Act Stack", sactActs[0], sactActs[1], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[2], sactActs[3], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[4], sactActs[5], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[6], sactActs[7], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[8], sactActs[9], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[10], sactActs[11], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[12], sactActs[13], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[14], sactActs[15], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[16], sactActs[17], "%x / %x");
        siz += 1; ui_show("Act Stack", sactActs[18], sactActs[19], "%x / %x");
    ) :
    (bn === 11) ? (
        EdStr = "%d  %.3f  %.1f";
        Cbg = GCBpts[0];
        siz += 1; ui_show("LPB 0", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[1];
        siz += 1; ui_show("LPB 1", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[2];
        siz += 1; ui_show("LPB 2", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[3];
        siz += 1; ui_show("LPB 3", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[4];
        siz += 1; ui_show("LPB 4", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[5];
        siz += 1; ui_show("LPB 5", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[6];
        siz += 1; ui_show("LPB 6", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[7];
        siz += 1; ui_show("LPB 7", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[8];
        siz += 1; ui_show("LPB 8", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
        Cbg = GCBpts[9];
        siz += 1; ui_show("LPB 9", Cbg[gStatus], Cbg[gCllvol], Cbg[cEvLindx], EdStr);
    ) :
    (
        0;
    );

    //glIsiz = max(glIsiz, siz);
    //(lnb == 0) ? (glIsiz0 = glIsiz) : (glIsiz1 = glIsiz) ;
    siz;
);


function
do_local_Control(u_ch)
(
    // Control part
    (u_ch === 'g') ? gc_run(2)  :
    (u_ch === 'm') ? (mem_walk(0);mem_show();)  :
    (u_ch === 'r') ? (mem_walk(8);mem_show();)  :
    (u_ch === 'L') ? (gui_show_syslog = ! gui_show_syslog ;)  :
    (u_ch === 'M') ? (gui_show_memory = ! gui_show_memory;)  :
    (u_ch === 'c') ? (mSL_Dyn_RecycleF = ! mSL_Dyn_RecycleF;)  :
    (u_ch === 'l') ? (mm_show_limit = ((mm_show_limit * 10 + 1) % 20 )/ 10;)  :
    (u_ch === 'k') ? (mSL_kill_all_thread();)  :
    (u_ch === 'A') ? ( info_config(0, 4, 5, 6, 7, 8, 1, 2, 3, 9, 10, 11); ) :
    (u_ch === 'Z') ? ( info_config(0, 1, 2, 3); ) :
    (u_ch === '+') ? (gfx_col_width = min(560, gfx_col_width + 10) ;)  :
    (u_ch === '-') ? (gfx_col_width = max(260, gfx_col_width - 10) ;)  :
    (u_ch === '=') ? (gfx_col_width = gfx_col_def_width ;)  :
    (u_ch === 'a') ? (nbligMax = min(glIsizCnt, nbligMax+1) ;)  :
    (u_ch === 's') ? (nbligMax = max(1, nbligMax-1); memset(glIsizTab, 0, glIsizCnt);)  :
    (u_ch === 'r') ? ( // run 1st suspended task
        ((ent = SchedDetachHead(SchedSuspPts)) != SchedNone) ? (
            SchedInsertTail(SchedActivPts, ent, SchETypeThrd);
        );
    );
    //
);

function
show_local_Infos(GName)
local (uix_jneed, uix_jmini, h1, k, siz, u_ch)
(
    Eps = 3;
    Ublocks = 0;
    while (info_blocks[Ublocks] >= 0) (Ublocks += 1;);
    split_leftratio = 0.35;
    uix_jneed = ui_jd_ctgr; k = 0; loop (nblig,
        uix_jneed += Eps + uix_jBoxHeight(glIsizTab[k]);
        k += 1;
    );
    //uix_jneed0 = Eps + uix_jBoxHeight(glIsiz0);
    //uix_jneed1 = Eps + uix_jBoxHeight(glIsiz1);
    //uix_jneed = uix_jneed0 + uix_jneed1 + ui_jd_ctgr;
    uix_jmini = uix_jBoxHeight(3) + ui_jd_ctgr;

    sprintf(#s, "min:%d need:%d height:%d width:%d / ubl:%d nbl:%d nbc:%d [%d %d %d %d %d]", uix_jmini, uix_jneed,
    ui_height(), ui_width(),
    Ublocks, nblig, nbcol, glIsizTab[0], glIsizTab[1], glIsizTab[2], glIsizTab[3], glIsizTab[4]);
    ui_split_top(30);
    ui_text(#s);
    ui_pop();

    ((ui_height() >= uix_jmini) && ((gfx_col_width + 16) < ui_width())) ? (

        ui_split_top(uix_jneed);


        zzmi = ui_hover();
        (zzmi) ? (
            ui_push();
                // stack is now 2 levels deep
                ui_color(Col_Frame);
                ui_border(); // draws in purple
            ui_pop();
            u_ch = do_GenericKeyRead();
            (u_ch != 0) ? (
                sprintf(#gfx_uc, "Keyed: '%c' / %02X   [%d]", u_ch, u_ch, kcnt); kcnt+= 1;
                Keyed = KeyedT = 0;  // u_ch has not been used
                do_local_Control(u_ch);
            );
        );
        control_group(GName);
        ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);

        ((k = gmem[UAdd+cbInacFlg]) > 2) ? (
            // Audio thread seems to be unresponsive
            gmem[UAdd+cbStat] = uSUnreachable;
            ActivePlaying = 0; // not really ready to play !
        ) :
        (((gmem[UAdd+cbStat] == uSUnreachable) || (gmem[UAdd+cbStat] == uSUnreachable)) && (k === 0)) ? (
            Pmode = mdInactive; // soon ready to work
        );


        // How many columns can we display ?
        nbcol = floor(gfx_w/gfx_col_width); // need about that
        numb = 0; // number of current block to display

        disbl = Ublocks ; k = 0; ccol = -1; clig = 0; f = 0;
        nblig = min(nbligMax, ceil(Ublocks / max(1, nbcol)));
        while ((disbl > 0) && (clig < nblig)) (
            (ccol <= 0) ? (
                ccol = nbcol;
                f ? ui_pop();
                ui_split_top(Eps + uix_jBoxHeight(glIsizTab[k])); f=1;
                sizlin = 0;
            );
            (ccol === nbcol) ? ui_new_column(1/nbcol) : ui_new_column();
            glIsizTab[k] = sizlin = max(sizlin, show_local_block(info_blocks[numb], clig));
            ccol -= 1; (ccol <= 0) ? (clig += 1; k += 1; ui_pop());
            numb += 1;
            disbl -= 1;
        );
        f ? ui_pop();
        ui_pop();
        ui_pop();
    );


    g_remain_h = ui_height();
    sys_avail = gui_show_memory ? g_remain_h/2 : g_remain_h; // available for syslog
    (gui_show_syslog && gui_show_memory) ? (
        SysLogBox[4] = 20;
        memoryBox1[17] = memoryBox2[17] = 52;
    ) :
    (gui_show_syslog) ? (
        SysLogBox[4] = 80;
    ) :
    (gui_show_memory) ? (
        memoryBox1[17] = memoryBox2[17] = 96;
    );
);


/*
   Display a log/trace
*/
function
show_SysLog(blnb, box)
local (h1, h3, disps, mini, avail, uix_jneed, uix_jmini, ptr, nc, as, fl, flg, zzmi, xx, ii, u_ch, siz, dep, had, thgh)
(
    disps = box[4]; mini = 5;
    h1 = uix_jBoxHeight(mini);
    h3 = uix_jBoxHeight(disps);
    // (box[6] <= 0) ? box[6] = ui_jd_tboxs;
    uix_jneed = h3 + ui_jd_delta2 + ui_jd_ctgr;
    uix_jmini = max(h1 + ui_jd_ctgr, ui_jd_min_block);
    (ui_height() >= uix_jmini) ? (
        ui_split_top(min(sys_avail, uix_jneed));
            //ui_set_rect(ui_left(), ui_top(),max(ui_MinSize1Pane,min(ui_BestSize1Pane, ui_width())), ui_height());
            zzmi = ui_hover();
            keepBlockInfos(blnb);
            (zzmi) ? (
                ui_push();
                    // stack is now 2 levels deep
                    ui_color(Col_Frame);
                    ui_border(); // draws in purple
                ui_pop();
            );
            control_group("File Syslog");
            ui_pad(0,ui_cg_pad_top,0,ui_cg_pad_bottom);
            ui_align(0,0);
            as = box[2]; // array size
            fl = box[1]; // first line
            xx = control_jmenu(menu_uix_jlog);
            (xx > 0) ? (
                (xx === 1) ? (
                    box[5] = 1;
                ) :
                (xx === 2) ? (
                    box[5] = 2;
                ) :
                (xx === 3) ? (
                    box[5] = 3;
                ) :
                (xx === 4) ? (
                    box[5] = 4;
                ) :
                (xx === 5) ? (
                    box[6] = min(20, box[6]+1);
                ) :
                (xx === 6) ? (
                    box[6] = max(0, box[6]-1);
                ) :
                (xx === 7) ? (
                    mSL_log(box, "");
                ) :
                (xx === 8) ? (
                    ii = 0; loop(as,
                        strcpy(fl + ii, ""); ii += 1;
                    );
                );
            );

            (zzmi) ? (
                u_ch = do_GenericKeyRead();
                (u_ch != 0) ? (
                    sprintf(#gfx_uc, "Keyed: '%c' / %02X   [%d]", u_ch, u_ch, kcnt); kcnt+= 1;
                    // mSL_log(SysLogBox, #gfx_uc);
                    (FlagsTbVals[Flgs_Traces] & 1) ? (
                        sprintf(#sq, "***Key  @  %d  %d  %d [%02x+%02x -> '%c']", mouse_x, mouse_y, mouse_cap, mouse_cap, u_ch, u_ch);
                        mSL_log(SysLogBox, #sq);
                    );
                    ui_key_next();
                    Keyed = 0;
                    ((u_ch === ' ') || (u_ch ===  0x0d)) ? (mSL_log(box, " ");) :
                    (u_ch === 'm') ? (box[6] = min(20, box[6]+1);) :
                    (u_ch === 'l') ? (box[6] = max(0, box[6]-1);) :
                    (u_ch === 'z') ? (box[7] = 0;) :
                    (u_ch === 'k') ? (box[7] = max(0, box[7]-1);) :
                    (u_ch === 'j') ? (box[7] = (box[7]+1) % box[2];) :
                    (u_ch === 't') ? (nowTime(); mSL_log(SysLogBox, #nowis);) :
                    //(u_ch === 'v') ? (ShowConfig();) :
                    (u_ch === 'up') ? (box[7] = max(0, box[7]-10);) :
                    (u_ch === 'down') ? (box[7] = (box[7]+10) % box[2];) :
                    ((ui_jmouse_cap === 0) && (u_ch === 'left')) ? (box[7] = 0;) :
                    ((ui_jmouse_cap === 0) && (u_ch === 'rght')) ? (box[7] = (box[7]+100) % box[2];) :
                    (u_ch === '1') ? (box[5] = 1;) :
                    (u_ch === '2') ? (box[5] = 2;) :
                    (u_ch === '3') ? (box[5] = 3;) :
                    (u_ch === '4') ? (box[5] = 4;) :
                    (u_ch === '5') ? (box[5] = 5;) :
                    (u_ch === '6') ? (box[5] = 6;) :
                    (u_ch === '7') ? (box[5] = 7;) :
                    (u_ch === '8') ? (box[5] = 8;) ;
                    //(u_ch === 'p') ? (sysout(SysLogBox);) :
                    Keyed = KeyedT = 0;  // u_ch has not been used
                );
            );
            nc = max(1, min(8, 0|box[5])); // number of columns to show
            nc = min(nc, floor(gfx_w/gfx_colL_width));

            ui_jshow_color = ui_jcolor_text;
            siz = box[2];
            dep = siz - 1; had = box[6];
            ptr = (box[3] + dep + 16*siz - box[7]) % siz; // last inserted line
            loop (nc,
                (nc != 0) ? ui_new_column(1/nc) : ui_new_column();
                nc = 0;
                ui_pad(3,0);ui_align(0, 0.5);
                ui_pcolor(ui_jshow_color);
                flg = 1;
                while (flg) (
                    /*
                    ui_jd_tboxh = had + ui_wraptext_height(#txt);
                    #txt = fl + ptr; // line to print
                    twdt = ui_text_width(#txt);
                    (twdt < wdth) ? (
                        (ui_height() >= ui_jd_tboxh) ? (
                            // put the string
                            uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                ui_pcolor(ui_jshow_color);
                                ui_wraptext(#txt);
                            ui_pop();
                            ptr = (ptr + dep) % siz;
                        ) : (
                            flg = 0;
                        );
                    ) : (
                    */
                    // Mono or Multi-line text
                    #txt = fl + ptr; // line to print
                    (strlen(#txt) === 0) ? #txt = " ";
                    thgh = ui_wraptext_height(#txt) + had;
                    (ui_height() >= thgh) ? (
                        // put the string
                        ui_split_top(thgh);
                            // ui_pcolor(ui_jshow_color);
                            ui_wraptext(#txt);
                        ui_pop();
                        ptr = (ptr + dep) % siz;
                    ) : (
                        flg = 0;
                    );
                    /*
                    lg = strlen(#txt);
                    k = max(1,ceil(lg / maxl));
                    (flg = (av = av - k) >= 0) ? (
                        (k === 1) ? (
                            // put the string
                            uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                ui_pcolor(ui_jshow_color);
                                ui_wraptext(#txt);
                            ui_pop();
                        ) : (
                            off = 0; sz = maxl;
                            while (k > 0) (
                                // cut the string in a few parts
                                strcpy_substr(#txt1,#txt, off, sz);
                                // put the string
                                uix_javail_Bheight -= ui_split_top(ui_jd_tboxh);
                                    // ui_pad(0,1,0,0);
                                    ui_pcolor(ui_jshow_color);
                                    ui_wraptext(#txt1);
                                ui_pop();
                                k -=1; off += maxl; sz = min(maxl, lg); lg -= sz;
                            );
                        );
                        ptr = (ptr + dep) % siz;
                    );
                    */
                );
            );
            ui_pop();


        ui_pop();
    );
);



<? include("GM-Libs/mSL_Dbg_Memory.jsfx-inc"); ?>


(gfxMn !== lastMn) ? (
    gfxMn = lastMn;

    ((gfxMcnt -= 1) <= 0) ? (flagCheckMemory = 1);

    flagCheckMemory ? (
        flagCheckMemory = 0;
        gfxMcnt = 6 + irand(6);
        mSL_StM_Check(); // check static mem
        mem_walk(8); // check dynamic mem
    );

    mSL_Dyn_Recycle(-1);
    mSL_Dyn_TmpProtect(-1);

    (gfxuicnt < 0) ? (
        gfxuicnt = 10 + irand(5);
        flagdogfx = 1;
    );
    // signal any error
    (mSL_StM_Err != 0) ? (
        gmem[UAdd+cbStat] = uSSError;
    );
);





/*
=== USER INTERFACE ===
*/
((((gfxWStat & 0x5) === 5) || flagdogfx) && must_do_gfx())  ? (

    gfx_executed += 1; // just a trace
    flagdogfx = 0;
    // do here the graphic stuff...

    do_gfx_init ? (
        do_gfx_init = 0; // perform only once
        uix_default_fontsize = ui_jdefault_fontsize;
        // uix_default_fontface = "Verdana";
        // uix_default_fontface = "Times";
        // uix_default_fontface = "Futura";
        uix_default_fontface = ui_jdefault_fontface;
    );

    update_theme();

    currScreen = ui_screen();
    (stdScreen === Undef) ? (
        stdScreen = currScreen;
        stdPointer = uix_screenstack + uix_screenstack_step * uix_screenstack_currentlayer;
    ) : (
        (stdScreen != currScreen) ? (
            currScreenWrg = currScreen;
            // Try to correct
            (currScreen === -1) ? (
                SPointer = uix_screenstack + uix_screenstack_step * uix_screenstack_currentlayer;
                SPointer[0] = "Main";
                ErrorScreen = 777;
            );
        );

    );
    ui_Xtime_period = 1; // refresh screen every second


    ui_font();

    my_menu_bar(uix_jG_menuscr);


    //SCREEN
    ui_screen() == "Main" ? (
        // ui_text("Is this ok ? ");
        show_local_Infos("File Player Status");

        gui_show_syslog ? show_SysLog(0, SysLogBox);
        gui_show_memory ? (
            (gfx_w > gfx_colM_width) ? (
                ui_split_leftratio(0.5);
                show_Memory(memoryBox1);
                ui_pop();
            );
            show_Memory(memoryBox2);
        );
    ) :

    //SCREEN--DEFAULT
    (
        control_system();
    );

/*
    ((gfx_Pw != gfx_w) || (gfx_Ph != gfx_h)) ? (
        gfx_PPw = gfx_Pw; gfx_PPh = gfx_Ph;
        gfx_Pw = gfx_w; gfx_Ph = gfx_h;
    );
*/
);


